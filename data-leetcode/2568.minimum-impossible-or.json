[
    {
        "title": "Minimum Impossible OR",
        "question_content": "You are given a 0-indexed&nbsp;integer array nums.\nWe say that an integer x is expressible from nums if there exist some integers 0 <= index1 < index2 < ... < indexk < nums.length for which nums[index1] | nums[index2] | ... | nums[indexk] = x. In other words, an integer is expressible if it can be written as the bitwise OR of some subsequence of nums.\nReturn the minimum positive non-zero integer&nbsp;that is not expressible from nums.\n&nbsp;\nExample 1:\n\nInput: nums = [2,1]\nOutput: 4\nExplanation: 1 and 2 are already present in the array. We know that 3 is expressible, since nums[0] | nums[1] = 2 | 1 = 3. Since 4 is not expressible, we return 4.\n\nExample 2:\n\nInput: nums = [5,3,2]\nOutput: 1\nExplanation: We can show that 1 is the smallest number that is not expressible.\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 105\n\t1 <= nums[i] <= 109",
        "solutions": [
            {
                "id": 3201897,
                "title": "java-c-python-pow-of-2",
                "content": "# **Intuition**\\nIf 1 not in A, we return 1.\\nIf 2 not in A, we return 2.\\n<br>\\n\\n# **Explanation**\\nIf 1 not in `A`,\\nwe return 1,\\notherwise we can have x = 1.\\n\\nIf 2 not in `A`,\\nwe return 2.\\notherwise we can have x = 2.\\n\\nSince we can have x = 1 and x = 2,\\nthen we can have x = 1 | 2 = 3.\\n\\nIf 4 not in `A`,\\nwe return 4,\\notherwise we have x = 4\\n\\nSince we can have x = 1 and x = 4, then we can have x = 1 | 4 = 5.\\nSince we can have x = 2 and x = 4, then we can have x = 2 | 4 = 6.\\nSince we can have x = 1,2,4, then we can have x = 1 | 2 | 4 = 7.\\n\\nSo we can find the rule here,\\nfind out the minimum pow of 2,\\nwhich is not in `A`.\\n\\nThe process of prove is same as above.\\n<br>\\n\\n# **Complexity**\\nTime `O(32n)`\\nSpace `O(32n)`\\n<br>\\n\\n**Java**\\n```java\\n    public int minImpossibleOR(int[] A) {\\n        Set<Integer> s = new HashSet<>();\\n        for (int a : A)\\n            s.add(a);\\n        int a = 1;\\n        while (s.contains(a))\\n            a <<= 1;\\n        return a;\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    int minImpossibleOR(vector<int>& A) {\\n        unordered_set<int> s(A.begin(), A.end());\\n        int a = 1;\\n        while (s.count(a))\\n            a <<= 1;\\n        return a;\\n    }\\n```\\n\\n**Python**\\n```py\\n    def minImpossibleOR(self, A):\\n        A = set(A)\\n        return next(1 << i for i in range(32) if (1 << i) not in A)\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public int minImpossibleOR(int[] A) {\\n        Set<Integer> s = new HashSet<>();\\n        for (int a : A)\\n            s.add(a);\\n        int a = 1;\\n        while (s.contains(a))\\n            a <<= 1;\\n        return a;\\n    }\\n```\n```cpp\\n    int minImpossibleOR(vector<int>& A) {\\n        unordered_set<int> s(A.begin(), A.end());\\n        int a = 1;\\n        while (s.count(a))\\n            a <<= 1;\\n        return a;\\n    }\\n```\n```py\\n    def minImpossibleOR(self, A):\\n        A = set(A)\\n        return next(1 << i for i in range(32) if (1 << i) not in A)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3201924,
                "title": "explained-two-solutions-with-without-extra-space-very-simple-easy-to-understand",
                "content": "Up vote if you like the solution !!!\\n\\n# Approach\\n\\nTrick : We just need to check if the 2\\'s power are present in the array or not. \\n\\nWhy so ? \\n\\nlet\\'s observe few example :\\n5 (101) is only possible if we have  100 + 1, that is 4 & 1 present\\n6 (110) is only possible if we have  100 + 10, that is 4 & 2 present\\nWe can see that, the number is possible if all 2\\'s power lower to it present then its possible. \\n\\n1,2 present then 1- 3 any number possible\\n1,2,4 present then 1 - 7 any number can be possible\\n1,2,4,8 present then 1-15 any number can be possible\\n\\nIn other word only 2\\'s power are not possible to form unless it is present in the array.\\nSo we look for the smallest 2\\'s power that is not present in the array, ans return it as answer.\\n\\nThis can be done in multiple ways. \\nHere I have added two solutions one is space optimized and other one is time optimized.\\n\\n\\n# Solution 1: with sorting & without extra space\\n```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int n = 1;\\n        for(int i = 0; i < nums.size(); ++i){\\n            if(nums[i] > n) return n;\\n            if(nums[i] == n) { n = n*2; }\\n        }\\n        return n;\\n    }\\n};\\n```\\n\\n# Solution 2: with extra space and no sorting\\n```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        unordered_set<int> s(nums.begin(), nums.end());\\n        int ans = 1;\\n        while(s.find(ans) != s.end()){\\n            ans = ans * 2;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n# Solution 3: with out sorting & without any extra space\\n\\nHere basically we keep track of each bit of a number to check if a particular power of 2 is present or not.\\nThis needs a good understanding of bit manupulation concept, if you don\\'t have then try looking for the following :\\n1. (n & (n - 1 )) to check if n is power of 2 or not \\n2. bitwise NOT (one\\'s complement) => ~n\\n3. n &(-n) will give you value of n with  setting only first bit \\'1\\' in binary form of n. For example: n = 144 (0b10010000) => n&(-n) = 0b10000\\n\\n```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        int cummRes = 0;\\n        for (auto &n : nums) {\\n            if ((n & (n-1)) == 0) cummRes |= n;  // check if number is power of 2\\n        }\\n        cummRes = ~cummRes; // identify the bit first lsb which is set to 0\\n        return (cummRes & (-cummRes));  //return 2 power the bit no.\\n    }\\n};\\n```\\n\\nHere is an article of my recent interview experience - A Journey to FAANG Company, I recomand you to go through this to know which all resources I have used & how I cracked interview at Amazon:\\nhttps://leetcode.com/discuss/interview-experience/3171859/Journey-to-a-FAANG-Company-Amazon-or-SDE2-(L5)-or-Bangalore-or-Oct-2022-Accepted\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int n = 1;\\n        for(int i = 0; i < nums.size(); ++i){\\n            if(nums[i] > n) return n;\\n            if(nums[i] == n) { n = n*2; }\\n        }\\n        return n;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        unordered_set<int> s(nums.begin(), nums.end());\\n        int ans = 1;\\n        while(s.find(ans) != s.end()){\\n            ans = ans * 2;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        int cummRes = 0;\\n        for (auto &n : nums) {\\n            if ((n & (n-1)) == 0) cummRes |= n;  // check if number is power of 2\\n        }\\n        cummRes = ~cummRes; // identify the bit first lsb which is set to 0\\n        return (cummRes & (-cummRes));  //return 2 power the bit no.\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3201880,
                "title": "lowest-missing-bit-o-n-o-1",
                "content": "- If `nums` does not contain `1` we return `1`.\\n- If `nums` does not contain `2` we return `2`.\\n\\t- Otherwise, we can form numbers [1, 4).\\n- If `nums` does not contain `4` we return `4`.\\n\\t- Otherwise, we can form numbers [1, 8).\\n- If `nums` does not contain `8` we return `8`.\\n\\t- Otherwise, we can form numbers [1, 16).\\n- ... and so on.\\n\\nWe can see that we need to find the lowest power of 2 that absent from the array.\\n\\n## O(1) Memory\\nWe only store elements that are power of two (30 elements max).\\n**C++**\\n```cpp\\nint minImpossibleOR(vector<int>& nums) {\\n    unordered_set<int> m;\\n    for (int n : nums)\\n        if ((n & (n - 1)) == 0)\\n            m.insert(n);\\n    int res = 1;\\n    while (m.count(res))\\n        res <<= 1;\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint minImpossibleOR(vector<int>& nums) {\\n    unordered_set<int> m;\\n    for (int n : nums)\\n        if ((n & (n - 1)) == 0)\\n            m.insert(n);\\n    int res = 1;\\n    while (m.count(res))\\n        res <<= 1;\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3202062,
                "title": "java-c-python3-sort-and-pow-of-2",
                "content": "# Please UPVOTE\\uD83D\\uDE0A\\n\\n# Python3\\n```\\nclass Solution:\\n    def minImpossibleOR(self, nums: List[int]) -> int:\\n        nums.sort()\\n        x=1\\n        for i in nums:\\n            if x==i:\\n                x*=2\\n        return x\\n        \\n```\\n# C++\\n```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        long long int ans=1;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==ans)\\n            {\\n                ans*=2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# Java\\n```\\nclass Solution {\\n    public int minImpossibleOR(int[] nums) {\\n        Arrays.sort(nums);\\n        int a = 1;\\n        for(int i:nums)\\n        {\\n            if(i==a)\\n            {\\n                a=a*2;\\n            }\\n        }\\n        return a;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "Sort"
                ],
                "code": "```\\nclass Solution:\\n    def minImpossibleOR(self, nums: List[int]) -> int:\\n        nums.sort()\\n        x=1\\n        for i in nums:\\n            if x==i:\\n                x*=2\\n        return x\\n        \\n```\n```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        long long int ans=1;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==ans)\\n            {\\n                ans*=2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int minImpossibleOR(int[] nums) {\\n        Arrays.sort(nums);\\n        int a = 1;\\n        for(int i:nums)\\n        {\\n            if(i==a)\\n            {\\n                a=a*2;\\n            }\\n        }\\n        return a;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3201914,
                "title": "python-explained",
                "content": "# Intuition\\nWe are only concerned about numbers in the form of 2^x.\\nIf the array has [1, 2, 4, 8], then we can form every number between [2^0, (2^4)-1] by forming every possible representation of xxxx in binary.\\n# Approach\\nLet p be the minimum power such that 2^p doesn\\'t exist in the array. Our answer is (2^p) = (2^0 + 2^1 + ... + 2^p-1) + 1\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minImpossibleOR(self, nums: List[int]) -> int:\\n        vals, ans = set(nums), 0\\n        for i in range(31):\\n            val = 2**i\\n            if val in vals:\\n                ans += val\\n                continue\\n            return ans + 1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minImpossibleOR(self, nums: List[int]) -> int:\\n        vals, ans = set(nums), 0\\n        for i in range(31):\\n            val = 2**i\\n            if val in vals:\\n                ans += val\\n                continue\\n            return ans + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3202520,
                "title": "video-solution-pow-of-2-c",
                "content": "# Video Solution\\nhttps://youtu.be/s4AfhorjZzk\\n\\n# Code\\n```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        unordered_map<int, int> mp;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]++;    \\n        }\\n        \\n        ll val = 1;\\n        while(1){\\n            if(mp[val] == 0){\\n                return (int)val;\\n            }\\n            val = val*2;\\n        }\\n        \\n        return val;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        unordered_map<int, int> mp;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]++;    \\n        }\\n        \\n        ll val = 1;\\n        while(1){\\n            if(mp[val] == 0){\\n                return (int)val;\\n            }\\n            val = val*2;\\n        }\\n        \\n        return val;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3202108,
                "title": "code-video-solution-with-concept-c-solution",
                "content": "# Intuition\\n\\n# Approach\\nhttps://www.youtube.com/watch?v=KenyvrJr6B4\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& arr) \\n    {\\n        vector<int>brr(32, 0);\\n        unordered_map<long long int,int>mp;\\n        int n = arr.size();\\n        \\n        for(int i=0; i<n; i++) mp[arr[i]]++;\\n        \\n        for(int i=0; i<32; i++)\\n        {\\n            for(int j=0; j<n; j++)\\n            {\\n                if((arr[j]>>i)&1)\\n                {\\n                    brr[i]++;\\n                }\\n            }\\n        }\\n        \\n        for(int i=0; i<32; i++)\\n        {\\n            long long int curr = pow(2,i);\\n            if(!mp[curr]) return curr;\\n            if(!brr[i]) return curr;\\n        }\\n        \\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& arr) \\n    {\\n        vector<int>brr(32, 0);\\n        unordered_map<long long int,int>mp;\\n        int n = arr.size();\\n        \\n        for(int i=0; i<n; i++) mp[arr[i]]++;\\n        \\n        for(int i=0; i<32; i++)\\n        {\\n            for(int j=0; j<n; j++)\\n            {\\n                if((arr[j]>>i)&1)\\n                {\\n                    brr[i]++;\\n                }\\n            }\\n        }\\n        \\n        for(int i=0; i<32; i++)\\n        {\\n            long long int curr = pow(2,i);\\n            if(!mp[curr]) return curr;\\n            if(!brr[i]) return curr;\\n        }\\n        \\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3202011,
                "title": "lowest-missing-bit-easy-understandable-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>&v) {\\n        int i=0,n=v.size();\\n        unordered_set<int>s;\\n        for(auto x : v)s.insert(x);\\n        while(s.find(1<<i)!=s.end())i++;\\n        return 1<<i;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>&v) {\\n        int i=0,n=v.size();\\n        unordered_set<int>s;\\n        for(auto x : v)s.insert(x);\\n        while(s.find(1<<i)!=s.end())i++;\\n        return 1<<i;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3201929,
                "title": "o-n-solution-smallest-power-of-two",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n* answer: we have to find smallest power of 2 element in the array\\n* reason:\\n1) lets say I have 1,2,4....2^i elements present in the array.\\n2) therefore I can make all the elements upto 2^(i+1)-1  using simple or operation.\\n3) but I cannot make 2^(i+1)th element.\\n4) Therefore we have to find the smallest power of 2 element that is not present in the array.\\n    \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1) Since the only possible solutions can be 1,2,4,8\\n2) put all the elements in an unordered_set \\n3) and check smallest power of two that does not exist\\n# Complexity\\n- Time complexity: O(n) to store all elements in the array\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) \\n    {\\n        unordered_set<long long>s(begin(nums),end(nums));\\n        for(int i=0;i<=32;i++)\\n        {\\n            long long num=(1<<i);\\n            if(s.find(num)==s.end())\\n                return num;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) \\n    {\\n        unordered_set<long long>s(begin(nums),end(nums));\\n        for(int i=0;i<=32;i++)\\n        {\\n            long long num=(1<<i);\\n            if(s.find(num)==s.end())\\n                return num;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3202078,
                "title": "c-all-can-form-except-next-2kipower",
                "content": "# Intuition\\ncrazy\\n\\n# Approach\\njust every 2^x add 1left bit \\nso,\\nall can form except next 2kipower \\neg.. 1 2 4 can form all till 7\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) \\n    {\\n        sort(nums.begin(),nums.end());\\n        unordered_map<int,int> m;\\n        \\n        for(auto e:nums) \\n        {\\n            m[e]++;\\n        }\\n        int twokipower=1;\\n        for(auto e:nums)\\n        {\\n            if(m.find(twokipower)==m.end())\\n            {\\n                return twokipower;\\n            }\\n            twokipower*=2;\\n        }\\n        return twokipower;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) \\n    {\\n        sort(nums.begin(),nums.end());\\n        unordered_map<int,int> m;\\n        \\n        for(auto e:nums) \\n        {\\n            m[e]++;\\n        }\\n        int twokipower=1;\\n        for(auto e:nums)\\n        {\\n            if(m.find(twokipower)==m.end())\\n            {\\n                return twokipower;\\n            }\\n            twokipower*=2;\\n        }\\n        return twokipower;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3207046,
                "title": "python-3-4-lines-w-explanation-t-m-100-69",
                "content": "It\\'s easy to show that`n` is not the answer if and only if every power of two less that is than`n`is in`nums`. A direct result of that fact is the answer is the first power of 2 not in`nums`is the answer.\\n\\nIt follows directly from this fact that the answer is the first power of two not in`nums`.\\n```\\nclass Solution:\\n    def minImpossibleOR(self, nums: List[int]) -> int:\\n\\n        pow2 = 1\\n\\n        for _ in range(30):\\n\\n            if pow2 not in nums: return pow2\\n\\n            pow2*= 2\\n\\n```\\n[https://leetcode.com/problems/minimum-impossible-or/submissions/901095002/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(1).",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minImpossibleOR(self, nums: List[int]) -> int:\\n\\n        pow2 = 1\\n\\n        for _ in range(30):\\n\\n            if pow2 not in nums: return pow2\\n\\n            pow2*= 2\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3202675,
                "title": "easy-c-solution-using-unordered-map-and-bit-manipulation-o-n-time-complexity",
                "content": "# Complexity\\n- Time complexity:\\nO(n), where n is size of nums vector\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        unordered_map<int,int>m;\\n        for(int &i:nums){\\n            m[i]++;\\n        }\\n        for(int i = 0;i<32;i++){\\n            if(!m.count(1<<i)){\\n                return 1<<i;\\n            }\\n        }\\n        return 1<<32;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        unordered_map<int,int>m;\\n        for(int &i:nums){\\n            m[i]++;\\n        }\\n        for(int i = 0;i<32;i++){\\n            if(!m.count(1<<i)){\\n                return 1<<i;\\n            }\\n        }\\n        return 1<<32;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3202053,
                "title": "python-mathematical-induction-explained",
                "content": "Consider if we don\\'t have `1` in `nums`, then the answer is `1` because you cannot use anything larger than `1` to form `1`.\\nConsider if we don\\'t have `2` in `nums`, then the answer is `2` because you cannot use `1` and anything larger than `2` to form `2`.\\nBut if we have [1, 2] in `nums`, we can form `3`.\\nSo, by Mathematical Induction, we know that if we have $1, 2, 2^2, 2^3,...,2^n$ in `nums`, we can form every number in $[1, 2^{n+1}-1]$. If we further have $2^{n+1}$ in `nums`, we can form every number in $[1, 2^{n+2}-1]$. If we don\\'t have $2^{n+1}$ in `nums`, then the minimum unexpressible number is $2^{n+1}$.\\n\\n# Code\\n```python []\\nclass Solution:\\n    def minImpossibleOR(self, nums: List[int]) -> int:\\n        nums = set(nums)\\n        for i in range(33):\\n            if 1 << i not in nums:\\n                return 1 << i\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python []\\nclass Solution:\\n    def minImpossibleOR(self, nums: List[int]) -> int:\\n        nums = set(nums)\\n        for i in range(33):\\n            if 1 << i not in nums:\\n                return 1 << i\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3201925,
                "title": "simple-java-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$ where n is the size of the array\\n\\n- Space complexity: $$O(n)$$ where n is the size of the array\\n\\n# Code\\n```\\nclass Solution {\\n    public int minImpossibleOR(int[] nums) {\\n        Map<Integer,Integer> nm=new HashMap<>();\\n        for(int i:nums)\\n        {\\n            nm.put(i, nm.getOrDefault(i,0)+1);\\n        }\\n        int x=1;\\n        while(nm.containsKey(x))\\n        {\\n            x*=2;\\n        }\\n        return x;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int minImpossibleOR(int[] nums) {\\n        Map<Integer,Integer> nm=new HashMap<>();\\n        for(int i:nums)\\n        {\\n            nm.put(i, nm.getOrDefault(i,0)+1);\\n        }\\n        int x=1;\\n        while(nm.containsKey(x))\\n        {\\n            x*=2;\\n        }\\n        return x;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3555327,
                "title": "c-most-simple-easy",
                "content": "GET MINIMUM 2^i THAT NOT PRESENT IN NUM\\nTHAT MEAN ith BIT NOT SET & WE NEED TO SET IT\\nSO ANS IS 2^i.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int x = 1;\\n        for(auto &i: nums){\\n            if(i==x){\\n                x <<= 1;\\n            }\\n        }\\n        return x;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Bit Manipulation",
                    "Brainteaser",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int x = 1;\\n        for(auto &i: nums){\\n            if(i==x){\\n                x <<= 1;\\n            }\\n        }\\n        return x;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3222766,
                "title": "best-c-solution-ever-bit-manipulation-hash-table-one-stop-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can solve this question using Array + Bit Manipulation + Hash Table.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand the approach by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime Complexity : O(N), where N is the size of the array(nums). Here loop creates the time complexity O(N).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace Complexity: O(N), Hash Table(unordered_set(set)) space.\\n\\n\\n# Code\\n```\\n/*\\n\\n    Time Complexity : O(N), where N is the size of the array(nums). Here loop creates the time complexity O(N).\\n\\n    Space Complexity: O(N), Hash Table(unordered_set(set)) space.\\n\\n    Solved using Array + Bit Manipulation + Hash Table.\\n\\n*/\\n\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        unordered_set set(nums.begin(), nums.end());\\n        int Or = 1;\\n        for(auto num : nums){\\n            if(set.find(Or) != set.end()){\\n                Or <<= 1;\\n            }\\n        }\\n        return Or;\\n    }\\n};\\n\\n```\\n\\n***IF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.***\\n\\n![WhatsApp Image 2023-02-10 at 19.01.02.jpeg](https://assets.leetcode.com/users/images/0a95fea4-64f4-4502-82aa-41db6d77c05c_1676054939.8270252.jpeg)",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Bit Manipulation"
                ],
                "code": "```\\n/*\\n\\n    Time Complexity : O(N), where N is the size of the array(nums). Here loop creates the time complexity O(N).\\n\\n    Space Complexity: O(N), Hash Table(unordered_set(set)) space.\\n\\n    Solved using Array + Bit Manipulation + Hash Table.\\n\\n*/\\n\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        unordered_set set(nums.begin(), nums.end());\\n        int Or = 1;\\n        for(auto num : nums){\\n            if(set.find(Or) != set.end()){\\n                Or <<= 1;\\n            }\\n        }\\n        return Or;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3207641,
                "title": "javascript-and-rust-solution",
                "content": "# Intuition\\nWe need to find first number which is power of 2 and not presented in the array. If we have 1 and 2 we can build 3. If we have 1 2 and 4 we can build 3, 5, 6 and 7 etc. \\n\\n# Approach\\nMove all the numbers from array into set. Iterate powers of 2 unitill first not presented in the array.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n**JavaScript**\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar minImpossibleOR = function(nums) {\\n    let set = new Set()\\n    for(let i = 0; i < nums.length; i++){\\n        set.add(nums[i])\\n    }\\n    \\n    for (let i = 0; i <= 32; i++){\\n        let num = Math.pow(2, i)\\n        if(!set.has(num)){\\n            return num\\n        }\\n    }\\n    \\n};\\n```\\n**Rust**\\n```\\nimpl Solution {\\n    pub fn min_impossible_or(nums: Vec<i32>) -> i32 {\\n        let mut set = std::collections::HashSet::new();\\n        for num in nums.iter() {\\n            set.insert(num);\\n        }\\n        \\n        for n in 0..=32 {\\n            let num:i32 = 2i32.pow(n);\\n            if(!set.contains(&num)){\\n                return num;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "Rust"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar minImpossibleOR = function(nums) {\\n    let set = new Set()\\n    for(let i = 0; i < nums.length; i++){\\n        set.add(nums[i])\\n    }\\n    \\n    for (let i = 0; i <= 32; i++){\\n        let num = Math.pow(2, i)\\n        if(!set.has(num)){\\n            return num\\n        }\\n    }\\n    \\n};\\n```\n```\\nimpl Solution {\\n    pub fn min_impossible_or(nums: Vec<i32>) -> i32 {\\n        let mut set = std::collections::HashSet::new();\\n        for num in nums.iter() {\\n            set.insert(num);\\n        }\\n        \\n        for n in 0..=32 {\\n            let num:i32 = 2i32.pow(n);\\n            if(!set.contains(&num)){\\n                return num;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3202336,
                "title": "c-solution-with-explanation-power-of-2-easy-to-understand",
                "content": "UpVote the Solution if it helps you!!\\n\\n# Intuition\\nWe can create all the elements upto <b> 2^(i+1) - 1</b> using OR operation if we have all 2\\'s power upto <b>2^i</b> element in the array.\\n\\nFor Example:-\\n\\n<ul>\\n<li> If we have Arr = [1, 2], then we can have 1, 2, 3 elements after applying OR operation on Arr. As <b>1 | 2 = 3</b> <br>\\n<li> Similarly, if Arr = [1,2,4], then we can have 1 - 7 elements possible\\n</ul>\\n\\nIn simple words, if we have all the 2\\'s power till 2^3 (i.e. 8) in the array, then we can generate all the elements till 2^4 - 1 i.e. 1-15 using OR operation.\\n\\n<b>We will not able to create 2\\'s power using OR operation</b>\\n\\n# Approach\\nNow we know that, if we have 2\\'s power upto <b>2^i</b>, than we can form all the elements upto <b> 2^(i+1) - 1</b> using OR operation. \\nThe solution will be the smallest 2\\'s power which is not present in array.\\n\\n<b>So we have to find the smallest power of 2 which is not present in Array</b>\\n\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n\\n        // Put all the elements in unordered set\\n        unordered_set<int> st(nums.begin(), nums.end()); \\n\\n        // Initialize with smallest power of 2, i.e. 2^0\\n        int ans = 1;\\n\\n        // Compute the next power of 2 until it is not present in set\\n        while(st.find(ans) != st.end()) {\\n            ans *= 2;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n\\n        // Put all the elements in unordered set\\n        unordered_set<int> st(nums.begin(), nums.end()); \\n\\n        // Initialize with smallest power of 2, i.e. 2^0\\n        int ans = 1;\\n\\n        // Compute the next power of 2 until it is not present in set\\n        while(st.find(ans) != st.end()) {\\n            ans *= 2;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3201900,
                "title": "c-easy-power-of-2",
                "content": "#\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        unordered_map<int, bool> mp;\\n        for(auto ele:nums){\\n            mp[ele]=1;\\n        }\\n        int i=1;\\n        while(1){\\n            if(mp.find(i) == mp.end()){\\n                return i;\\n            }\\n            i<<=1;\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        unordered_map<int, bool> mp;\\n        for(auto ele:nums){\\n            mp[ele]=1;\\n        }\\n        int i=1;\\n        while(1){\\n            if(mp.find(i) == mp.end()){\\n                return i;\\n            }\\n            i<<=1;\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3697262,
                "title": "easy-c-solution-using-only-array-concepts-easily-explained",
                "content": "If array does not contain 1 then our answer is 1 since `a | b > 1 for a, b > 1.`\\nSimlarly, if array does not contain 2 then our answer is 2.\\nIf we still do not have our answer that means our array contains 1 and 2 which certainly gives 3 since` 1 | 2 = 3` However, it does not guarantee 4, so if our array does not contain 4 then 4 is our answer. \\nSimilarly, our answer will be the least power of 2 not present in our array. \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        int curr = 1;\\n        for (int i=0; i<n; ++i) {\\n            if (nums[i] > curr) \\n                return curr;\\n            else if (nums[i] == curr)\\n                curr *= 2;\\n        }\\n        return curr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        int curr = 1;\\n        for (int i=0; i<n; ++i) {\\n            if (nums[i] > curr) \\n                return curr;\\n            else if (nums[i] == curr)\\n                curr *= 2;\\n        }\\n        return curr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3207937,
                "title": "python-simple-solution-of-just-checking-power-of-two-numbers-explained",
                "content": "A number can be expressed by some power of two numbers. Thus, we only need to check the power of two numbers in the list, and find the minimum missing one.\\n\\nTo check the power of two, we can simply do:\\n\\n`num == num & (-num)`\\n\\n\\n\\n```\\nclass Solution:\\n    def minImpossibleOR(self, nums: List[int]) -> int:\\n        bit_set = set()\\n        for num in nums:\\n            if num == num & (-num):\\n                bit_set.add(num)\\n        \\n        i = 1\\n        while i in bit_set:\\n            i = i << 1\\n        return i\\n```",
                "solutionTags": [
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def minImpossibleOR(self, nums: List[int]) -> int:\\n        bit_set = set()\\n        for num in nums:\\n            if num == num & (-num):\\n                bit_set.add(num)\\n        \\n        i = 1\\n        while i in bit_set:\\n            i = i << 1\\n        return i\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3206472,
                "title": "c-easy-to-understand",
                "content": "# Intuition\\nWe can make any number with power of 2 (we need to also insure that we have previous power number as well).\\nLike we can make \\n- 1 (with power 0), \\n- 2,3 (with power 0 and 1), \\n- 4,5,6,7 (with power 0,1 and 2)and so on.\\n\\n# Approach \\nWe mark perfect power of 2 elements like 1,2,4,8,16 in the array then we check which minimum element is not available and return that element.   \\n\\n# Complexity\\n- Time complexity:\\nO(nx30) ~ O(n)\\n\\n- Space complexity:\\nO(31) ~ O(1)\\n\\n# Code\\n```\\nclass Solution \\n{\\n    \\npublic:\\n    bool checkPowerOfTwo(int n) \\n    {\\n        while(n!=1)\\n        {\\n            if(n%2==1) return false;\\n            n /= 2;\\n        }\\n        return true;\\n    }\\n    int minImpossibleOR(vector<int>& nums) \\n    {\\n        vector<int> binary(31, 0);\\n        int cnt;\\n        \\n        for(auto it:nums)\\n        {\\n            if(checkPowerOfTwo(it)) //elements like 1,2,4,8,16\\n            {\\n                cnt=0;\\n                while(it)\\n                {\\n                    it /= 2;\\n                    cnt++;\\n                }\\n                binary[cnt-1]=1; //mark power needed to form the element\\n            }\\n        }\\n        \\n        int num;\\n        for(int i=0; i<31; i++) //find minimum not available element by using power\\n        {\\n            if(binary[i]!=1)\\n            {\\n                num = (int) pow(2, i); //form that element\\n                break;\\n            }\\n        }\\n        return num; \\n    }\\n};\\n```\\n\\n# Please upvote if you like this approach",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution \\n{\\n    \\npublic:\\n    bool checkPowerOfTwo(int n) \\n    {\\n        while(n!=1)\\n        {\\n            if(n%2==1) return false;\\n            n /= 2;\\n        }\\n        return true;\\n    }\\n    int minImpossibleOR(vector<int>& nums) \\n    {\\n        vector<int> binary(31, 0);\\n        int cnt;\\n        \\n        for(auto it:nums)\\n        {\\n            if(checkPowerOfTwo(it)) //elements like 1,2,4,8,16\\n            {\\n                cnt=0;\\n                while(it)\\n                {\\n                    it /= 2;\\n                    cnt++;\\n                }\\n                binary[cnt-1]=1; //mark power needed to form the element\\n            }\\n        }\\n        \\n        int num;\\n        for(int i=0; i<31; i++) //find minimum not available element by using power\\n        {\\n            if(binary[i]!=1)\\n            {\\n                num = (int) pow(2, i); //form that element\\n                break;\\n            }\\n        }\\n        return num; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3204064,
                "title": "find-2-n-c-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        unordered_set<long long int>s;\\n        for(auto &i: nums){\\n            s.insert(i);\\n        }\\n        long long int x = 1;\\n        while(x<=1000000000L&&s.count(x)){\\n            x <<= 1;\\n        }\\n        return x;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Bit Manipulation",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        unordered_set<long long int>s;\\n        for(auto &i: nums){\\n            s.insert(i);\\n        }\\n        long long int x = 1;\\n        while(x<=1000000000L&&s.count(x)){\\n            x <<= 1;\\n        }\\n        return x;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3202046,
                "title": "c-simple-solution",
                "content": "# Code\\n```\\npublic class Solution {\\n    public int MinImpossibleOR(int[] nums) {\\n        int res = 1;\\n        \\n        while (nums.Contains(res))\\n            res <<= 1;\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinImpossibleOR(int[] nums) {\\n        int res = 1;\\n        \\n        while (nums.Contains(res))\\n            res <<= 1;\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3202045,
                "title": "easy-c-solution",
                "content": "# Complexity\\n- Time complexity: $$O(log(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(log(n))$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        int n=nums.size();\\n        unordered_map<int,int> y;\\n        for(int i=0;i<n;i++){\\n            if((nums[i]&(nums[i]-1))==0) y[nums[i]]=1;\\n        }\\n        int i=1;\\n        while(true){\\n            if(y[i]==0) return i;\\n            i*=2;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        int n=nums.size();\\n        unordered_map<int,int> y;\\n        for(int i=0;i<n;i++){\\n            if((nums[i]&(nums[i]-1))==0) y[nums[i]]=1;\\n        }\\n        int i=1;\\n        while(true){\\n            if(y[i]==0) return i;\\n            i*=2;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3201981,
                "title": "easiest-o-n-solution",
                "content": "# Intuition\\nThe first power of 2 will be the answer for sure as it cannot be formed unless we have 1 for the most significant bit position!\\n\\n# Approach\\n1. Add all elements of nums to the set\\n2. Loop over each power of two and check it it exists\\n3. If it does not, it is the answer\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public:\\n        int minImpossibleOR(vector<int>& nums) {\\n            unordered_set<int> set;\\n            for (int num: nums)set.insert(num);\\n\\n            int ans = 1;\\n            while (set.find(ans) != set.end()) ans *= 2;\\n            return ans;\\n        }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    public:\\n        int minImpossibleOR(vector<int>& nums) {\\n            unordered_set<int> set;\\n            for (int num: nums)set.insert(num);\\n\\n            int ans = 1;\\n            while (set.find(ans) != set.end()) ans *= 2;\\n            return ans;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3685180,
                "title": "java-optimized-solution-for-beginners-5-line-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minImpossibleOR(int[] nums) {\\n        HashSet<Integer> set=new HashSet<>();\\n        for(int i=0;i<nums.length;i++)\\n            set.add(nums[i]);\\n        int i=0;\\n        for(i=0;i<32;i++){\\n            if(!set.contains((int)Math.pow(2,i)))\\n                break;\\n        }\\n        return (int)Math.pow(2,i);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minImpossibleOR(int[] nums) {\\n        HashSet<Integer> set=new HashSet<>();\\n        for(int i=0;i<nums.length;i++)\\n            set.add(nums[i]);\\n        int i=0;\\n        for(i=0;i<32;i++){\\n            if(!set.contains((int)Math.pow(2,i)))\\n                break;\\n        }\\n        return (int)Math.pow(2,i);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3272795,
                "title": "python-elegant-short-o-n-powers-of-two",
                "content": "```\\nfrom typing import List\\n\\n\\nclass Solution:\\n    \"\"\"\\n    Time:   O(n)\\n    Memory: O(n)\\n    \"\"\"\\n\\n    def minImpossibleOR(self, nums: List[int]) -> int:\\n        nums = set(nums)\\n        impossible = 1\\n\\n        while impossible in nums:\\n            impossible <<= 1\\n\\n        return impossible\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```\\nfrom typing import List\\n\\n\\nclass Solution:\\n    \"\"\"\\n    Time:   O(n)\\n    Memory: O(n)\\n    \"\"\"\\n\\n    def minImpossibleOR(self, nums: List[int]) -> int:\\n        nums = set(nums)\\n        impossible = 1\\n\\n        while impossible in nums:\\n            impossible <<= 1\\n\\n        return impossible\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3223403,
                "title": "3-4-lines-of-code-easy-and-simple-c-solution",
                "content": "# Approach\\n**Observe**\\n- 1 = 1\\n- 2 = 10\\n- 4 = 100\\n- 8 = 1000\\n- 16 = 10000\\nNotice, 3 can be generated by 1|2, 5 can be generated by 1|4, 6 can be generated by 2|4, 7 can be generated by 3|4.\\nBut, those number can not be generated by OR operation of any number which come in power of 2.\\n\\n**So, our answer is, we have to find first number in power of 2, which is not present in given array.**\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) \\n    {\\n    \\n        unordered_set<int>st(nums.begin(),nums.end());\\n        int x=1;  // starting from 1st bit\\n        while(true)\\n        {\\n            if(!st.count(x))\\n            break;\\n            x <<=1;   // find number with next bit\\n        }\\n        return x;   // x is not present in nums\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) \\n    {\\n    \\n        unordered_set<int>st(nums.begin(),nums.end());\\n        int x=1;  // starting from 1st bit\\n        while(true)\\n        {\\n            if(!st.count(x))\\n            break;\\n            x <<=1;   // find number with next bit\\n        }\\n        return x;   // x is not present in nums\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3219784,
                "title": "javascript-solution-beats-96-30-bit-manipulation-approach",
                "content": "```javascript\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar minImpossibleOR = function(nums) {\\n    let cummRes = 0;\\n    for (const num of nums){\\n        if ((num & (num-1)) == 0)\\n            cummRes |= num;\\n    }\\n    cummRes = ~cummRes;\\n    return (cummRes & (-cummRes));\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Bit Manipulation"
                ],
                "code": "```javascript\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar minImpossibleOR = function(nums) {\\n    let cummRes = 0;\\n    for (const num of nums){\\n        if ((num & (num-1)) == 0)\\n            cummRes |= num;\\n    }\\n    cummRes = ~cummRes;\\n    return (cummRes & (-cummRes));\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3212357,
                "title": "java-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minImpossibleOR(int[] nums) {\\n        Set<Integer> s=new HashSet<>();\\n        for(int i: nums)s.add(i);\\n        int i=0;\\n        for(i=0;i<32;i++)\\n        {\\n            if(!s.contains((int)Math.pow(2,i))){\\n                break;\\n            }\\n        }\\n        return (int)Math.pow(2,i);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minImpossibleOR(int[] nums) {\\n        Set<Integer> s=new HashSet<>();\\n        for(int i: nums)s.add(i);\\n        int i=0;\\n        for(i=0;i<32;i++)\\n        {\\n            if(!s.contains((int)Math.pow(2,i))){\\n                break;\\n            }\\n        }\\n        return (int)Math.pow(2,i);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3209202,
                "title": "c-hash-table-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        map<int, int>s;\\n        int k=1, chk=1;\\n        for(int i=0; i<nums.size(); i++){\\n            //s.insert(nums[i-1]);\\n            s[nums[i]]++;\\n            //s.insert(nums[i-1]|nums[i]);\\n        }\\n        while(1){\\n        //for(auto it: s){\\n            if(s.find(k)==s.end()){\\n                //k++;\\n                return k;\\n            }\\n            k*=2;\\n        //}\\n        }\\n        return k;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        map<int, int>s;\\n        int k=1, chk=1;\\n        for(int i=0; i<nums.size(); i++){\\n            //s.insert(nums[i-1]);\\n            s[nums[i]]++;\\n            //s.insert(nums[i-1]|nums[i]);\\n        }\\n        while(1){\\n        //for(auto it: s){\\n            if(s.find(k)==s.end()){\\n                //k++;\\n                return k;\\n            }\\n            k*=2;\\n        //}\\n        }\\n        return k;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203633,
                "title": "find-lowest-missing-power-of-2",
                "content": "```\\n//  Time Complexity => O(N*32)\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        int n = 1;\\n        int i = 0;\\n        while(i < 32){\\n\\t\\t    // Find each and every power of 2 starting from zero.\\n\\t\\t\\t// If you are unable to find a particular power, then, \\n\\t\\t\\t// it will be an answer. \\n\\t\\t\\t// Since we are starting from zero power, answer will be minimum already.\\n            if(find(nums.begin(), nums.end(), n) == nums.end()) break; \\n            n <<= 1;\\n            i++;\\n        }\\n        return n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n//  Time Complexity => O(N*32)\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        int n = 1;\\n        int i = 0;\\n        while(i < 32){\\n\\t\\t    // Find each and every power of 2 starting from zero.\\n\\t\\t\\t// If you are unable to find a particular power, then, \\n\\t\\t\\t// it will be an answer. \\n\\t\\t\\t// Since we are starting from zero power, answer will be minimum already.\\n            if(find(nums.begin(), nums.end(), n) == nums.end()) break; \\n            n <<= 1;\\n            i++;\\n        }\\n        return n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3202707,
                "title": "c-solution-smallest-2-x-which-is-not-present-in-nums",
                "content": "**return smallest 2^x which is not present in nums**\\n\\n```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        unordered_set<int> s(nums.begin(), nums.end());\\n        \\n        int n=1;\\n        while(s.count(n)) n<<=1;\\n        \\n        return n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        unordered_set<int> s(nums.begin(), nums.end());\\n        \\n        int n=1;\\n        while(s.count(n)) n<<=1;\\n        \\n        return n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3202587,
                "title": "python-easy-to-understand-python3",
                "content": "```\\nclass Solution:\\n    def minImpossibleOR(self, nums: List[int]) -> int:\\n        i = 1\\n        cnt = 1\\n        nums = set(nums)\\n        while True:\\n            if i not in nums:\\n                return i\\n            i = 2**(cnt)\\n            cnt += 1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def minImpossibleOR(self, nums: List[int]) -> int:\\n        i = 1\\n        cnt = 1\\n        nums = set(nums)\\n        while True:\\n            if i not in nums:\\n                return i\\n            i = 2**(cnt)\\n            cnt += 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3202345,
                "title": "python3-check-only-the-powers-of-2-aha-moment-o-n",
                "content": "# Intuition\\nThe thing to notice with this problem is, that if there is any number that is not expressible with OR-ing, it is either a power of two, or there exists a number smaller than it, which is power of 2, and that number is also not expressible.\\nThis is because of the way the \"OR\" works in binary, by \"switching on\" bits.\\n\\n# Approach\\nCheck from smallest to larger the powers of 2 and stop when we find one that cannot be expressed.\\n\\n# Complexity\\n- Time complexity: O(n), and we cannot possibly do better *asymptotically*, as we need to at least look at each of the numbers in `nums`.\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def minImpossibleOR(self, nums: List[int]) -> int:\\n        pows2 = [2**i for i in range(32)]\\n        for pow2 in pows2:\\n            if pow2 not in nums:\\n                return pow2\\n        # NOTE: This shouldn\\'t execute, as per the problem statement\\'s conditions, because nums[i] <= 10^9 < 2**30\\n        return 2**32\\n```\\n\\n# Tag\\nBitwise Arithmetic, Aha-moment \\uD83D\\uDCA1",
                "solutionTags": [
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def minImpossibleOR(self, nums: List[int]) -> int:\\n        pows2 = [2**i for i in range(32)]\\n        for pow2 in pows2:\\n            if pow2 not in nums:\\n                return pow2\\n        # NOTE: This shouldn\\'t execute, as per the problem statement\\'s conditions, because nums[i] <= 10^9 < 2**30\\n        return 2**32\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3202195,
                "title": "100-acceptance-very-easy-approach-beginner-friendly-c",
                "content": "# Intuition : The value is multiplied by two to past equal value.....to make it simple 2 can\\'t be found by OR with lesser numbers...similarly the non 2 powered values like 3,5,6,7 can be found by OR within the minimal values...\\nFor example, if we have 5 it can be found by 1|4 , 4 can\\'t be found by any OR within the lesser numbers....any value that is equivalent to the powers of 2 can\\'t be got by OR ing the minimal values among themselves..... 1,2,3 never produces 4 at anycost.....\\n# Complexity\\n- Time complexity:o(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        int ma=1;\\n        for(auto i:nums){\\n            if(i==ma){\\n                ma*=2;\\n            }\\n        }\\n        return ma;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        int ma=1;\\n        for(auto i:nums){\\n            if(i==ma){\\n                ma*=2;\\n            }\\n        }\\n        return ma;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3202188,
                "title": "c-easy-solution-using-greedy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N)+)O(NlogN)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int val=1;\\n        for(int v:nums)\\n        {\\n            if(v==val)val*=2;\\n        }\\n        return val;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int val=1;\\n        for(int v:nums)\\n        {\\n            if(v==val)val*=2;\\n        }\\n        return val;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3202170,
                "title": "c-hashing-solution-with-explanation",
                "content": "\\n\\n<!-- Describe your approach to solving the problem. -->\\nIf 1 and 2 are present in the array then all the number from 1 to 3 are expressible.\\n\\nIf 1, 2 and 4 are present in the array then all the number from 1 to 7 are expressible.\\n\\nIf 1, 2, 4 and 8 are present in the array then all the numbers from 1 to 15 are expressible.\\n\\nIf 1, 2, 4, 8 and 16 are present in the array then all the numbers from 1 to 31 are expressible.\\n\\nTherefore we need to find the smallest integer which can be expressed as power of 2 and which is not present in the array.\\n\\n# Complexity\\n- Time complexity:\\n  O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n  O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        unordered_set<int> s(nums.begin(),nums.end());\\n        int temp=1;\\n        for(int i=1;i<32;i++){\\n            if(s.find(temp)==s.end()) return temp;\\n            temp=temp*2;\\n        }\\n        return temp; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        unordered_set<int> s(nums.begin(),nums.end());\\n        int temp=1;\\n        for(int i=1;i<32;i++){\\n            if(s.find(temp)==s.end()) return temp;\\n            temp=temp*2;\\n        }\\n        return temp; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3202139,
                "title": "my-java-solution",
                "content": "```\\nclass Solution {\\n    public int minImpossibleOR(int[] nums) {\\n        Arrays.sort(nums);\\n\\t\\tint minXOR = 0;\\n\\t\\tfor (int i = 0; i < nums.length; i++) {\\n\\t\\t\\tif (nums[i] > minXOR + 1) {\\n\\t\\t\\t\\treturn minXOR + 1;\\n\\t\\t\\t}\\n\\t\\t\\tminXOR |= nums[i];\\n\\t\\t}\\n\\t\\treturn minXOR + 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minImpossibleOR(int[] nums) {\\n        Arrays.sort(nums);\\n\\t\\tint minXOR = 0;\\n\\t\\tfor (int i = 0; i < nums.length; i++) {\\n\\t\\t\\tif (nums[i] > minXOR + 1) {\\n\\t\\t\\t\\treturn minXOR + 1;\\n\\t\\t\\t}\\n\\t\\t\\tminXOR |= nums[i];\\n\\t\\t}\\n\\t\\treturn minXOR + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3201985,
                "title": "python-simple-solution",
                "content": "# Code\\n```\\nfrom collections import defaultdict\\nclass Solution:\\n    def minImpossibleOR(self, nums: List[int]) -> int:\\n        nums = set(nums)\\n        for i in range(32):\\n            if (1<<i) not in nums:\\n                return 1<<i\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def minImpossibleOR(self, nums: List[int]) -> int:\\n        nums = set(nums)\\n        for i in range(32):\\n            if (1<<i) not in nums:\\n                return 1<<i\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3201935,
                "title": "simple-python-code-o-n-logn-complexity",
                "content": "```\\nclass Solution:\\n    def minImpossibleOR(self, nums: List[int]) -> int:\\n        minn = min(nums);\\n        if minn != 1:\\n            return 1;\\n        else:\\n            d = {i : 1 for i in nums}\\n            i = 2;\\n            while i in d:\\n                i = i*2;\\n            return i\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minImpossibleOR(self, nums: List[int]) -> int:\\n        minn = min(nums);\\n        if minn != 1:\\n            return 1;\\n        else:\\n            d = {i : 1 for i in nums}\\n            i = 2;\\n            while i in d:\\n                i = i*2;\\n            return i\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3201861,
                "title": "simple-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums,int i= 1) {\\n        unordered_set<int> st{nums.begin(),nums.end()};\\n        for(;;i*=2)if(st.find(i) == st.end())break;\\n        return i;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums,int i= 1) {\\n        unordered_set<int> st{nums.begin(),nums.end()};\\n        for(;;i*=2)if(st.find(i) == st.end())break;\\n        return i;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4089179,
                "title": "o-nlog-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(nlog(n))$$ \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(),nums.end());\\n        int curr=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]>curr+1) return ++curr;\\n            curr|=nums[i];\\n        }\\n        return ++curr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(),nums.end());\\n        int curr=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]>curr+1) return ++curr;\\n            curr|=nums[i];\\n        }\\n        return ++curr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4062558,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) \\n    {\\n       unordered_set<int>st;\\n       for (int i=0;i<nums.size();i++)\\n       {\\n           st.insert(nums[i]);\\n       }\\n       int ans=1;\\n       int pos=0;\\n       while(true)\\n       {\\n           ans=(1<<pos);\\n           if (st.find(ans)==st.end()) return ans;\\n           pos++;\\n       }\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) \\n    {\\n       unordered_set<int>st;\\n       for (int i=0;i<nums.size();i++)\\n       {\\n           st.insert(nums[i]);\\n       }\\n       int ans=1;\\n       int pos=0;\\n       while(true)\\n       {\\n           ans=(1<<pos);\\n           if (st.find(ans)==st.end()) return ans;\\n           pos++;\\n       }\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4032643,
                "title": "simple-c-solution-with-detailed-explanation-for-noobs",
                "content": "```\\nclass Solution {\\npublic:\\n    //we only need to considder power of 2s in increasing order\\n    //we check if input contain 1, 2, 4, 8, 16...\\n    //why don\\'t we need to check numbers in between, like (5,6,7) between 4 and 8?\\n    //because those numbers can be formed by previous power of 2s.\\n    //for exampe, when we already have 1,2 and 4, 5(101) can be formed by 4 | 1, 6(110) = 4 | 2, 7(111) = 4 | 2 | 1.\\n    //thus, we only need to look for the next greater power of 2s as all numbers before it are guaranteed expressible.\\n    int minImpossibleOR(vector<int>& nums) {\\n        //sort input array for faster checking\\n        sort(nums.begin(),nums.end());\\n        //x is power of 2, start with 2^0 = 1;\\n        int x = 1;\\n        for(auto &i: nums){\\n            if(i==x){\\n                x <<= 1;\\n            }\\n        }\\n        return x;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    //we only need to considder power of 2s in increasing order\\n    //we check if input contain 1, 2, 4, 8, 16...\\n    //why don\\'t we need to check numbers in between, like (5,6,7) between 4 and 8?\\n    //because those numbers can be formed by previous power of 2s.\\n    //for exampe, when we already have 1,2 and 4, 5(101) can be formed by 4 | 1, 6(110) = 4 | 2, 7(111) = 4 | 2 | 1.\\n    //thus, we only need to look for the next greater power of 2s as all numbers before it are guaranteed expressible.\\n    int minImpossibleOR(vector<int>& nums) {\\n        //sort input array for faster checking\\n        sort(nums.begin(),nums.end());\\n        //x is power of 2, start with 2^0 = 1;\\n        int x = 1;\\n        for(auto &i: nums){\\n            if(i==x){\\n                x <<= 1;\\n            }\\n        }\\n        return x;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4016992,
                "title": "minimum-impossible-or",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minImpossibleOR(int[] nums) {\\n        HashSet<Integer> hs = new HashSet<Integer>();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            hs.add(nums[i]);\\n        }\\n        int i=0;\\n        int a = (int)Math.pow(2,i);\\n        while(hs.contains(a))\\n        {\\n            i++;\\n            a = (int)Math.pow(2,i);\\n        }\\n        return (int)Math.pow(2,i);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minImpossibleOR(int[] nums) {\\n        HashSet<Integer> hs = new HashSet<Integer>();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            hs.add(nums[i]);\\n        }\\n        int i=0;\\n        int a = (int)Math.pow(2,i);\\n        while(hs.contains(a))\\n        {\\n            i++;\\n            a = (int)Math.pow(2,i);\\n        }\\n        return (int)Math.pow(2,i);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3901203,
                "title": "5-lines-in-ruby",
                "content": "```ruby\\n# @param {Integer[]} nums\\n# @return {Integer}\\ndef min_impossible_or(nums)\\n  uniq_nums, res = nums.to_set, 1\\n  while uniq_nums.include?(res)\\n    res *= 2\\n  end\\n  res\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\n# @param {Integer[]} nums\\n# @return {Integer}\\ndef min_impossible_or(nums)\\n  uniq_nums, res = nums.to_set, 1\\n  while uniq_nums.include?(res)\\n    res *= 2\\n  end\\n  res\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3847039,
                "title": "c-100",
                "content": "```c++\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums, int cand = 0) {\\n        for (int j = 0; j < 31; ++j) if (!canConstruct(cand | (1 << j), nums)) return cand | (1 << j);\\n        return cand;\\n    }\\nprivate:\\n    inline bool canConstruct(int cur, const vector<int>& nums, int tmp = 0) {\\n        for (const auto& num : nums) {\\n            if (((~cur) & num) == 0) tmp |= num;\\n            if (tmp == cur) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums, int cand = 0) {\\n        for (int j = 0; j < 31; ++j) if (!canConstruct(cand | (1 << j), nums)) return cand | (1 << j);\\n        return cand;\\n    }\\nprivate:\\n    inline bool canConstruct(int cur, const vector<int>& nums, int tmp = 0) {\\n        for (const auto& num : nums) {\\n            if (((~cur) & num) == 0) tmp |= num;\\n            if (tmp == cur) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3779086,
                "title": "python-linear-time-solution-with-explaination",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. for every number canbe forming as sum if some powe of 2(also binary):\\neg: 11 --> 1010 --> 1 *pow(2,3)+0 *pow(2,2)+1 *pow(2,1) + 0 *pow(2,0) \\n2.  op a|b means set x bit to 1 if one of a or b set 1 in x bit\\n\\nwith | operattions for any times, a large number its can be forming from small value which are power of 2 if exists: \\n1 2 4 8 16....\\neg. 1|2=3 \\nso the \\'minium impossible or value\\' is the first value of power 2 but not in nums\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\niterator all power of 2 and find the first one not in nums\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution(object):\\n    def minImpossibleOR(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        nums,ans=set(nums),1\\n        while ans in nums:ans=ans<<1\\n        return ans \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def minImpossibleOR(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        nums,ans=set(nums),1\\n        while ans in nums:ans=ans<<1\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3750337,
                "title": "faster-and-easy-to-get-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minImpossibleOR(int[] nums) {\\n        Set<Integer> set=new HashSet<>();\\n         for(int n : nums)\\n          if(n == 1 || (n & 1) == 0) set.add(n); \\n\\n        int powerOfTwo = 1; \\n\\n        while(true){\\n            if(!set.contains(powerOfTwo)) return powerOfTwo;\\n            powerOfTwo *= 2; \\n            }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minImpossibleOR(int[] nums) {\\n        Set<Integer> set=new HashSet<>();\\n         for(int n : nums)\\n          if(n == 1 || (n & 1) == 0) set.add(n); \\n\\n        int powerOfTwo = 1; \\n\\n        while(true){\\n            if(!set.contains(powerOfTwo)) return powerOfTwo;\\n            powerOfTwo *= 2; \\n            }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3693613,
                "title": "python-2-lines-with-intuition-o-n-time-o-1-memory",
                "content": "# Intuition\\nIf an integer is not expressible, then some bit in that integer cannot be set to 1. Since we are looking for the minimum positive non-expressible integer, we just need to know the lowest bit that we can\\'t get from any num in nums. Therefore, we just return the smallest power of 2 that is not found in nums.  \\n\\n\\n# Complexity\\n- Time complexity:\\nO(n) because we check if a number is in nums 32 times, and each lookup is O(n).\\n\\n- Space complexity:\\nO(1) \\n\\n# Code\\n```\\nclass Solution:\\n    def minImpossibleOR(self, nums: List[int]) -> int:\\n        for i in range(32):\\n            if 1 << i not in nums: return 1 << i\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minImpossibleOR(self, nums: List[int]) -> int:\\n        for i in range(32):\\n            if 1 << i not in nums: return 1 << i\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3668001,
                "title": "easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        if(nums[0]!=1)return 1;\\n        set<int>st;\\n        unordered_map<int,bool>mapp;\\n        int x=0;\\n        for(auto i:nums){\\n             x=x|i;\\n             st.insert(x);\\n             mapp[i]=1;\\n            \\n        }\\n        for(auto i:st){\\n            if(mapp.find(i+1)==mapp.end()){\\n                return i+1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        if(nums[0]!=1)return 1;\\n        set<int>st;\\n        unordered_map<int,bool>mapp;\\n        int x=0;\\n        for(auto i:nums){\\n             x=x|i;\\n             st.insert(x);\\n             mapp[i]=1;\\n            \\n        }\\n        for(auto i:st){\\n            if(mapp.find(i+1)==mapp.end()){\\n                return i+1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3646418,
                "title": "rust-o-n-one-liner",
                "content": "# Intuition\\n\\nTake $x$ to be the first power of two that is not included directly in nums. We can create every number less than $x$ by selectively or-ing together the other power of two\\'s. Therefore $x$ must be the smallest number that cannot be created.\\n\\nOur task is now simplified to \"find the smallest power of two that is not contained in nums\"\\n\\n# Approach\\n- filter out non power of two\\'s\\n- or together remaining nums to get a bitmap of which powers of two are contained\\n- count the trailing ones to get the index (exponent) of the first zero bit (the first missing power of 2)\\n- get the value by shifting left\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn min_impossible_or(nums: Vec<i32>) -> i32 {\\n        1 << nums.into_iter()\\n            .filter(|n| n.count_ones() == 1)\\n            .fold(0, |p, c| p | c)\\n            .trailing_ones()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn min_impossible_or(nums: Vec<i32>) -> i32 {\\n        1 << nums.into_iter()\\n            .filter(|n| n.count_ones() == 1)\\n            .fold(0, |p, c| p | c)\\n            .trailing_ones()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3607654,
                "title": "easy-solution-c-quick-to-understand",
                "content": "# Intuition\\nThink about how the numbers are related and how can you check exactly which number will cause no or calculation\\n\\n# Approach\\nThe numbers that have an increase in bit eg: 2-10 4-100 , 2 has 2 and 4 has 3 so the max number that causes break is our result\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        int v=0;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==pow(2,v))v++;\\n        }\\n        return pow(2,v);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation",
                    "Brainteaser"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        int v=0;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==pow(2,v))v++;\\n        }\\n        return pow(2,v);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3492509,
                "title": "ok",
                "content": "```\\nint minImpossibleOR(vector<int>& n)\\n{    \\n\\tint s{};\\n\\tfor(const auto & n : n)\\n\\t\\t s |= (n-1)&n ? 0 : n;\\n\\tint out{1};\\n\\tfor( ; s&out; out<<=1);\\n\\treturn out;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint minImpossibleOR(vector<int>& n)\\n{    \\n\\tint s{};\\n\\tfor(const auto & n : n)\\n\\t\\t s |= (n-1)&n ? 0 : n;\\n\\tint out{1};\\n\\tfor( ; s&out; out<<=1);\\n\\treturn out;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3469560,
                "title": "javascript-2568-minimum-impossible-or",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nif 1 is there\\nif 10 is there\\nthen we can always generate 11\\n\\nsimilarly\\nif 100 is also there\\nthen we can always generate 101, 110 & 111\\n\\nso if 2 power i is missing, that is the our number we cannot generate\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n1 - 32 bit from constraints\\n```\\nvar minImpossibleOR = function (a) {\\n    let set = new Set(a);\\n\\n    for (let i = 0; i < 32; i++)\\n        if (!set.has(1 << i)) {\\n            return 1 << i;\\n        }\\n\\n    return -1;\\n};\\n```\\n\\n2\\n```\\nvar minImpossibleOR = function (a) {\\n    let set = new Set(a);\\n\\n    let two_pow = 1;\\n    while (set.has(two_pow)) {\\n        two_pow *= 2;\\n    }\\n\\n    return two_pow;\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minImpossibleOR = function (a) {\\n    let set = new Set(a);\\n\\n    for (let i = 0; i < 32; i++)\\n        if (!set.has(1 << i)) {\\n            return 1 << i;\\n        }\\n\\n    return -1;\\n};\\n```\n```\\nvar minImpossibleOR = function (a) {\\n    let set = new Set(a);\\n\\n    let two_pow = 1;\\n    while (set.has(two_pow)) {\\n        two_pow *= 2;\\n    }\\n\\n    return two_pow;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3424486,
                "title": "scala-iterate-over-pows-of-2-with-comments",
                "content": "# Intuition\\nThinking in binary, the only numbers that could not be represented by ANY OR operation are the powers of $2$ `(1,2,4,8.. => 0,10,100,1000..)` because they have one and only one bit set to $1$.\\n\\n# Approach\\nSo the solution is to find the first power of $2$ that is not already present in the array.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$ / $$O(n)$$ (depends whether we would like to use `Set` for `contains` optimization)\\n\\n# Code\\n```\\nobject Solution {\\n  def minImpossibleOR(nums: Array[Int]): Int = {\\n    val numSet = nums.toSet // use `Set` for `contains` optimization\\n    var ans = 1\\n    while (numSet.contains(ans)) {\\n      ans *= 2\\n    }\\n    ans\\n  }\\n}\\n```",
                "solutionTags": [
                    "Scala",
                    "Array",
                    "Brainteaser"
                ],
                "code": "```\\nobject Solution {\\n  def minImpossibleOR(nums: Array[Int]): Int = {\\n    val numSet = nums.toSet // use `Set` for `contains` optimization\\n    var ans = 1\\n    while (numSet.contains(ans)) {\\n      ans *= 2\\n    }\\n    ans\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3417894,
                "title": "python-o-n-intuition-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nStep-by-step intuition to understand the solution.\\n1) The minimum X that is not expressible by **nums** is in the set of numbers that are not in **nums**.\\n2) X that is not expressible by **nums**  has 1 (in its bit representation) in the location not covered by other values in **nums**\\n3) The minimum X is a power of 2. \\n# Code\\n```\\nclass Solution:\\n    def minImpossibleOR(self, nums: List[int]) -> int:\\n        res = 1\\n        memo = defaultdict(int,{k:1 for k in nums})\\n        while memo[res] == 1:\\n            res = res << 1\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minImpossibleOR(self, nums: List[int]) -> int:\\n        res = 1\\n        memo = defaultdict(int,{k:1 for k in nums})\\n        while memo[res] == 1:\\n            res = res << 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3393716,
                "title": "c-easy-to-understand-unordered-map-bit-manipulation",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        unordered_map<int,int>mp;\\n        for(int i:nums){\\n            mp[i]++;\\n        }\\n\\n        for(int i=0;i<32;i++){\\n            if(!mp.count(1<<i)){\\n                return 1<<i;\\n            }\\n        }\\n        return 1<<32;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        unordered_map<int,int>mp;\\n        for(int i:nums){\\n            mp[i]++;\\n        }\\n\\n        for(int i=0;i<32;i++){\\n            if(!mp.count(1<<i)){\\n                return 1<<i;\\n            }\\n        }\\n        return 1<<32;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3382251,
                "title": "c-sort-and-search",
                "content": "# Intuition\\nSort the numbers. Look for powers of 2 within the numbers. If a power of 2 is missing, return that.\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(nlog(n))$$\\n\\n- Space complexity:\\n$$O(1)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int n = 1;\\n        if(nums[0]!=1)\\n            return 1;\\n        int i;\\n        int idx=1;\\n        for(i=1;i<nums.size();i++){\\n            if(nums[i]==nums[i-1]){\\n                continue;\\n            }\\n            if(nums[i]!=(1<<idx)){\\n                if((nums[i] & nums[i-1]) != 0)\\n                    continue;\\n                return (1<<idx);\\n            }\\n            if(nums[i]==(1<<idx)){\\n                idx++;\\n            }\\n        }\\n        return (1<<idx);\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int n = 1;\\n        if(nums[0]!=1)\\n            return 1;\\n        int i;\\n        int idx=1;\\n        for(i=1;i<nums.size();i++){\\n            if(nums[i]==nums[i-1]){\\n                continue;\\n            }\\n            if(nums[i]!=(1<<idx)){\\n                if((nums[i] & nums[i-1]) != 0)\\n                    continue;\\n                return (1<<idx);\\n            }\\n            if(nums[i]==(1<<idx)){\\n                idx++;\\n            }\\n        }\\n        return (1<<idx);\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3378634,
                "title": "python-power-of-2-solution-with-explanation",
                "content": "```python\\n\\'\\'\\'\\nif a number is not expressible, we must be missing a bit somewhere.\\ne.g. if 3 is not expressible, 0011, then there must be no 1(0001) or 2(0010) in nums, \\nso the minimum non-expressible number must be power of 2.\\nso find minimum power of 2 number not appear in the nums.\\ntc is O(n), sc is O(1)\\n\\'\\'\\'\\nclass Solution:\\n    def minImpossibleOR(self, nums: List[int]) -> int:\\n        powerOf2 = 0\\n        for n in nums:\\n            if n & (n-1) == 0:\\n                powerOf2 |= n\\n        i = 0\\n        while powerOf2 > 0:\\n            if powerOf2 & 1 == 0:\\n                return 2 ** i\\n            powerOf2 >>= 1\\n            i += 1\\n        return 2 ** i\\n```",
                "solutionTags": [
                    "Python",
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```python\\n\\'\\'\\'\\nif a number is not expressible, we must be missing a bit somewhere.\\ne.g. if 3 is not expressible, 0011, then there must be no 1(0001) or 2(0010) in nums, \\nso the minimum non-expressible number must be power of 2.\\nso find minimum power of 2 number not appear in the nums.\\ntc is O(n), sc is O(1)\\n\\'\\'\\'\\nclass Solution:\\n    def minImpossibleOR(self, nums: List[int]) -> int:\\n        powerOf2 = 0\\n        for n in nums:\\n            if n & (n-1) == 0:\\n                powerOf2 |= n\\n        i = 0\\n        while powerOf2 > 0:\\n            if powerOf2 & 1 == 0:\\n                return 2 ** i\\n            powerOf2 >>= 1\\n            i += 1\\n        return 2 ** i\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3354687,
                "title": "using-onordered-set-esay-and-simple",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        unordered_set<int> s;\\n        for(int i=0;i<nums.size();i++){\\n            s.insert(nums[i]);\\n        }\\n        int i=0; int k=0;\\n        bool cond=true;\\n        while(cond){\\n             k=pow(2,i);\\n            if(s.find(k)==s.end()){\\n                cond=false;\\n            }\\n            else{\\n                i++;\\n            }\\n        }\\n        return k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        unordered_set<int> s;\\n        for(int i=0;i<nums.size();i++){\\n            s.insert(nums[i]);\\n        }\\n        int i=0; int k=0;\\n        bool cond=true;\\n        while(cond){\\n             k=pow(2,i);\\n            if(s.find(k)==s.end()){\\n                cond=false;\\n            }\\n            else{\\n                i++;\\n            }\\n        }\\n        return k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3351565,
                "title": "easy-solution-c-bit-manipulation",
                "content": "\\n# Approach\\nFind lowest missing power of 2 in \\'nums\\'.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        int cnt = 1;\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        if(nums[0] > cnt) {\\n            return cnt;\\n        }\\n        cnt = cnt*2;\\n        for(int i=1; i<n; i++) {\\n            if(nums[i] == nums[i-1]) {\\n                continue;\\n            }\\n            if(nums[i] == cnt) {\\n                cnt = cnt*2;\\n            }\\n            else if(nums[i] > cnt) {\\n                return cnt;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        int cnt = 1;\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        if(nums[0] > cnt) {\\n            return cnt;\\n        }\\n        cnt = cnt*2;\\n        for(int i=1; i<n; i++) {\\n            if(nums[i] == nums[i-1]) {\\n                continue;\\n            }\\n            if(nums[i] == cnt) {\\n                cnt = cnt*2;\\n            }\\n            else if(nums[i] > cnt) {\\n                return cnt;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3341568,
                "title": "simple-c-solution-with-full-explanation-bitwise-operator-and-hashing",
                "content": "# Intuition\\nSIMPLE C++ SOLUTION WITH FULL EXPLANATION (BITWISE OPERATOR AND HASHING)\\n\\n# Approach\\nSimple Bitwise and Hasing is used.\\n\\n# Complexity\\n- Time complexity:\\n     O(log(n))\\n\\n- Space complexity:\\n     O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        map<int,int> mp;\\n        for(auto &it:nums) {\\n            mp[it]++;\\n        }\\n        for(int i = 0; i<32; i++) {\\n            int val = 1<<i;\\n            if(mp[val] == 0) {\\n                return val;\\n            }\\n        }\\n        return 1;\\n    }\\n};\\n\\nExplanation :->\\n\\n/*1. In this question we are using map simply to find weather the given value is present in the map or not , Now forget this point for now.\\n2. Now see why we are using left sift here in the question,see left shift always do the multiplication of a number . Here (1<<i) mean (2^i).\\n3. Now move to a new concept here ...\\n   if(an array consists [2,4,8,16] as its elements then its mean all numbers from 2 to 31 can be formed by doing or operations on these elements of the array)\\n4. so, the number which can\\'nt be formed by using all array elements is (2^i i.e 2^5 i.e next of 2^4 = 16) becouse all numbers before it can be formed becouse (2^4 = 16 is present in the array) \\n5. Now you can easily understand why we have use map in the question*/\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        map<int,int> mp;\\n        for(auto &it:nums) {\\n            mp[it]++;\\n        }\\n        for(int i = 0; i<32; i++) {\\n            int val = 1<<i;\\n            if(mp[val] == 0) {\\n                return val;\\n            }\\n        }\\n        return 1;\\n    }\\n};\\n\\nExplanation :->\\n\\n/*1. In this question we are using map simply to find weather the given value is present in the map or not , Now forget this point for now.\\n2. Now see why we are using left sift here in the question,see left shift always do the multiplication of a number . Here (1<<i) mean (2^i).\\n3. Now move to a new concept here ...\\n   if(an array consists [2,4,8,16] as its elements then its mean all numbers from 2 to 31 can be formed by doing or operations on these elements of the array)\\n4. so, the number which can\\'nt be formed by using all array elements is (2^i i.e 2^5 i.e next of 2^4 = 16) becouse all numbers before it can be formed becouse (2^4 = 16 is present in the array) \\n5. Now you can easily understand why we have use map in the question*/\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3337801,
                "title": "c-bit-manipulation-faster-easy-to-understand",
                "content": "* ***Unordered Set***\\n\\n* ***Time Complexity :- O(N)***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        // declare an unordered set\\n        \\n        unordered_set<int> s;\\n        \\n        // push all the elements of nums into set\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            s.insert(nums[i]);\\n        }\\n        \\n        // start searching power of 2 into set\\n        \\n        int pow = 1;\\n        \\n        while(s.count(pow))\\n        {\\n            pow = pow * 2;\\n        }\\n        \\n        return pow;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Hash Table",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        // declare an unordered set\\n        \\n        unordered_set<int> s;\\n        \\n        // push all the elements of nums into set\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            s.insert(nums[i]);\\n        }\\n        \\n        // start searching power of 2 into set\\n        \\n        int pow = 1;\\n        \\n        while(s.count(pow))\\n        {\\n            pow = pow * 2;\\n        }\\n        \\n        return pow;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3330606,
                "title": "c-solution-unordered-map-bit-manipulation",
                "content": "# Intuition\\nObserver some test cases\\nIn 3 bit if we set the 3rd bit to 1 and taking the mirror of all 2 bit from 1,2 and 3 it will be 5,6,7\\n    0 0 1\\n    0 1 0\\n    0 1 1\\n    -----\\n    1 0 0\\n    -----\\n    1 0 1\\n    1 1 0\\n    1 1 1\\n\\n# Approach\\nWe only have to check 1,2,4,8.....2^k is in array or not.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        unordered_map<int,bool> mp;\\n        for(auto x:nums) mp[x]=true;\\n        int ans = 1;\\n        while(1){\\n            if(!mp[ans]) return ans;\\n            ans*=2;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        unordered_map<int,bool> mp;\\n        for(auto x:nums) mp[x]=true;\\n        int ans = 1;\\n        while(1){\\n            if(!mp[ans]) return ans;\\n            ans*=2;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3325337,
                "title": "93-11-python3-brainteaser",
                "content": "```\\nclass Solution:\\n    def minImpossibleOR(self, nums: List[int]) -> int:\\n        nums = set(nums)\\n        for p in range(1000):\\n            if pow(2, p) not in nums:\\n                return pow(2, p)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minImpossibleOR(self, nums: List[int]) -> int:\\n        nums = set(nums)\\n        for p in range(1000):\\n            if pow(2, p) not in nums:\\n                return pow(2, p)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3319374,
                "title": "accepted-swift",
                "content": "```\\nclass Solution {\\n    func minImpossibleOR(_ nums: [Int]) -> Int {\\n\\n        let ns = nums.sorted()\\n        var res = 1\\n        var i = 0\\n\\n        while true {\\n            while i < ns.count, ns[i] != res { i += 1 }\\n            guard i < ns.count else { break }\\n            res *= 2\\n        }\\n\\n        return res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func minImpossibleOR(_ nums: [Int]) -> Int {\\n\\n        let ns = nums.sorted()\\n        var res = 1\\n        var i = 0\\n\\n        while true {\\n            while i < ns.count, ns[i] != res { i += 1 }\\n            guard i < ns.count else { break }\\n            res *= 2\\n        }\\n\\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3306148,
                "title": "java-solution-using-set",
                "content": "# Intuition\\nPutting all numbers into a set and finding max.\\nThen, starting from 1, checking if this number is in the set.\\nIf yes, then doubling the number.\\nIf no, then return the number.\\n\\n# Code\\n```\\nclass Solution {\\n    public int minImpossibleOR(int[] nums) {\\n        Set<Integer> set = new HashSet<>();\\n        int max = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            set.add(nums[i]);\\n            if (max < nums[i]) max = nums[i];\\n        }\\n        int start = 1;\\n        while (start <= max) {\\n            if (!set.contains(start)) return start;\\n            else start *= 2;\\n        }\\n        return start;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minImpossibleOR(int[] nums) {\\n        Set<Integer> set = new HashSet<>();\\n        int max = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            set.add(nums[i]);\\n            if (max < nums[i]) max = nums[i];\\n        }\\n        int start = 1;\\n        while (start <= max) {\\n            if (!set.contains(start)) return start;\\n            else start *= 2;\\n        }\\n        return start;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3301791,
                "title": "c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        unordered_set<int> st(nums.begin(),nums.end());\\n        int i=0;\\n        while(true)\\n        {\\n            int num=(1<<i);\\n            if(st.find(num)==st.end())\\n            {\\n                return num;\\n            }\\n            i++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        unordered_set<int> st(nums.begin(),nums.end());\\n        int i=0;\\n        while(true)\\n        {\\n            int num=(1<<i);\\n            if(st.find(num)==st.end())\\n            {\\n                return num;\\n            }\\n            i++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3296914,
                "title": "math",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minImpossibleOR(self, nums: List[int]) -> int:\\n\\n        pow2 = [2 ** x for x in range(32)]\\n        seen = {}\\n        for n in nums:\\n            if n in pow2:\\n                seen[n] = True\\n        \\n        keys = list(seen.keys())\\n        for n in range(32):\\n            if 2 ** n not in keys:\\n                return 2 ** n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minImpossibleOR(self, nums: List[int]) -> int:\\n\\n        pow2 = [2 ** x for x in range(32)]\\n        seen = {}\\n        for n in nums:\\n            if n in pow2:\\n                seen[n] = True\\n        \\n        keys = list(seen.keys())\\n        for n in range(32):\\n            if 2 ** n not in keys:\\n                return 2 ** n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3282130,
                "title": "python-video-walkthrough-3-line-solution",
                "content": "[Click Here For Video Walkthrough](    https://youtu.be/emgvthAe2kc)\\n```\\nclass Solution:\\n    def minImpossibleOR(self, nums: List[int]) -> int:\\n        nums, n = set(nums), 1\\n        while n in nums: n *= 2\\n        return n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minImpossibleOR(self, nums: List[int]) -> int:\\n        nums, n = set(nums), 1\\n        while n in nums: n *= 2\\n        return n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3259537,
                "title": "linear-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->sort the array in the ascending order each element combined with its previous one if it can reach to new element then max is updated else we have found our minimum not reachable number   \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minImpossibleOR(int[] nums) {\\n        Arrays.sort(nums);\\n        int max=0;\\n        int n=nums.length;\\n        for (int i=0;i<n;i++){\\n            if(nums[i]<=max+1){\\n                max=max|nums[i];\\n            }\\n            else{\\n                break;\\n            }\\n        }\\n        return max+1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minImpossibleOR(int[] nums) {\\n        Arrays.sort(nums);\\n        int max=0;\\n        int n=nums.length;\\n        for (int i=0;i<n;i++){\\n            if(nums[i]<=max+1){\\n                max=max|nums[i];\\n            }\\n            else{\\n                break;\\n            }\\n        }\\n        return max+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3256840,
                "title": "python3-o-n-time-o-1-memory-using-bit-count",
                "content": "```python\\nclass Solution:\\n    def minImpossibleOR(self, nums: List[int]) -> int:\\n        a = 0\\n        for n in nums:\\n            if n.bit_count() == 1:\\n                a |= n \\n        b = 1\\n        while a & b:\\n            b *= 2\\n        return \\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def minImpossibleOR(self, nums: List[int]) -> int:\\n        a = 0\\n        for n in nums:\\n            if n.bit_count() == 1:\\n                a |= n \\n        b = 1\\n        while a & b:\\n            b *= 2\\n        return \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3245525,
                "title": "java-n-log2max-runtime-18ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n Runtime < 20ms (89% beats) but it could be better by memory\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minImpossibleOR(int[] A) {\\n\\t\\tvar max = 0;\\n\\t\\tSet<Integer> integers = new HashSet<>(A.length);\\n\\t\\tfor (int num : A) {\\n\\t\\t\\tif (max < num) {\\n\\t\\t\\t\\tmax = num;\\n\\t\\t\\t}\\n\\t\\t\\tintegers.add(num);\\n\\t\\t}\\n\\n\\t\\tint possibleVal = (int) Math.pow(2, Math.ceil(Math.log(max) / Math.log(2)));\\n\\t\\tfor (int i = 0; Math.pow(2, i) <= Math.pow(10, 9); i++) {\\n\\t\\t\\tif (!integers.contains((int) Math.pow(2, i))) {\\n\\t\\t\\t\\tpossibleVal = (int) Math.pow(2, i);\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn possibleVal;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minImpossibleOR(int[] A) {\\n\\t\\tvar max = 0;\\n\\t\\tSet<Integer> integers = new HashSet<>(A.length);\\n\\t\\tfor (int num : A) {\\n\\t\\t\\tif (max < num) {\\n\\t\\t\\t\\tmax = num;\\n\\t\\t\\t}\\n\\t\\t\\tintegers.add(num);\\n\\t\\t}\\n\\n\\t\\tint possibleVal = (int) Math.pow(2, Math.ceil(Math.log(max) / Math.log(2)));\\n\\t\\tfor (int i = 0; Math.pow(2, i) <= Math.pow(10, 9); i++) {\\n\\t\\t\\tif (!integers.contains((int) Math.pow(2, i))) {\\n\\t\\t\\t\\tpossibleVal = (int) Math.pow(2, i);\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn possibleVal;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3240332,
                "title": "java-no-set-4lines-fast-small",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public int minImpossibleOR(int[] nums) {\\n    for(int i = 1, is = 0; ; i <<= 1){\\n      for(int n: nums)\\n        if(n == i) {is = 1; break;}\\n      if(is == 1) return i;  \\n    }      \\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public int minImpossibleOR(int[] nums) {\\n    for(int i = 1, is = 0; ; i <<= 1){\\n      for(int n: nums)\\n        if(n == i) {is = 1; break;}\\n      if(is == 1) return i;  \\n    }      \\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3234266,
                "title": "easy-python-solution-with-tc-n-logn",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs simple as it could be\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minImpossibleOR(self, nums: List[int]) -> int:\\n        nums = set(nums)\\n        for i in range(32):\\n            if(2**i not in nums):\\n                return 2**i\\n                \\n            \\n            \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minImpossibleOR(self, nums: List[int]) -> int:\\n        nums = set(nums)\\n        for i in range(32):\\n            if(2**i not in nums):\\n                return 2**i\\n                \\n            \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3233978,
                "title": "c-bitwise",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse bitmap to mark whether each bit is representable\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n  int minImpossibleOR(vector<int> &nums) {\\n    auto bits =\\n        std::accumulate(nums.begin(), nums.end(), 0U, [](auto a, auto b) {\\n          return (__builtin_popcount(b) == 1) ? a | b : a;\\n        });\\n    return 1 << (__builtin_ctz(~bits));\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int minImpossibleOR(vector<int> &nums) {\\n    auto bits =\\n        std::accumulate(nums.begin(), nums.end(), 0U, [](auto a, auto b) {\\n          return (__builtin_popcount(b) == 1) ? a | b : a;\\n        });\\n    return 1 << (__builtin_ctz(~bits));\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3230294,
                "title": "c-solution-simple-and-easy-solution",
                "content": "# Intuition\\nWe are checking only powers of 2. For example if we found 8 and before that 4 also then we can make any number between them. So we start by 1 and check for power of 2 and if we don\\'t find any then we return that only.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n$$O(nlogn)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        int i=1,j=0;\\n        sort(nums.begin(),nums.end());\\n        while(j<nums.size()){\\n            if(nums[j]>i)\\n                return i;\\n            if(nums[j]==i)\\n                i*=2;\\n            j+=1;\\n        }\\n        return i;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        int i=1,j=0;\\n        sort(nums.begin(),nums.end());\\n        while(j<nums.size()){\\n            if(nums[j]>i)\\n                return i;\\n            if(nums[j]==i)\\n                i*=2;\\n            j+=1;\\n        }\\n        return i;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3229064,
                "title": "scala-2-lines-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n    def minImpossibleOR(nums: Array[Int]): Int = {\\n        val set = nums.toSet\\n        (for{i <- 0 to 32} yield 1 << i).dropWhile(set.contains(_)).head\\n  }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def minImpossibleOR(nums: Array[Int]): Int = {\\n        val set = nums.toSet\\n        (for{i <- 0 to 32} yield 1 << i).dropWhile(set.contains(_)).head\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3228858,
                "title": "c-solution-with-intution-code",
                "content": "# intution\\n\\n**Remember the property of OR operation **\\n\\n***observe***\\n\\nif you have nums = [1,2] you can generate numbers  **(1,2,4)**  by OR .\\n\\nif **nums = [1,2,4]** you can generate numbers  **(1,2,3,4,5,6,7)** by OR \\n\\n   **i.e. binary number** = (001,010,100)  by these number you can       generate any number which is <= 7 .\\n\\nsimilarly,\\n **nums = [1,2,4,8]** you can generate numbers  **(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15)**  by OR \\n\\n***conclusion :***\\n\\n if in the array we have **(2^0 , 2^1 , 2^2....2^n)** you can generate all the numbers from  **( 1 to (2^n -1) )**\\n\\n**because 2^x (x >= 0 and int value ) i.e. 2,4,8 can not be generated by any set of numbers by using OR**\\n\\ntherefore check all the **perfect square of 2 starting from (2^0 = 1)** if any square is missing return that perfect square .\\n\\n\\n \\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        vector<bool>arr (50,false) ;\\n        \\n        for(auto a : nums)\\n        {\\n            if((a&(a-1)) == 0) //  if a&(a-1) == 0 than it is a perfect sqaure of 2 \\n            {\\n                int kk = ffs(a)-1 ; //ffs is a inbuilt function use to \\n                                   //get the index of right most set \\n                                         // bit of any number \\n                arr[kk] = true ;\\n            }\\n        }\\n        \\n        for(int i = 0 ; i < 50 ; i++)\\n        {\\n            if(arr[i] == false)\\n            {\\n                return (1<<i) ;\\n            }\\n        }\\n        \\n        return 0 ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        vector<bool>arr (50,false) ;\\n        \\n        for(auto a : nums)\\n        {\\n            if((a&(a-1)) == 0) //  if a&(a-1) == 0 than it is a perfect sqaure of 2 \\n            {\\n                int kk = ffs(a)-1 ; //ffs is a inbuilt function use to \\n                                   //get the index of right most set \\n                                         // bit of any number \\n                arr[kk] = true ;\\n            }\\n        }\\n        \\n        for(int i = 0 ; i < 50 ; i++)\\n        {\\n            if(arr[i] == false)\\n            {\\n                return (1<<i) ;\\n            }\\n        }\\n        \\n        return 0 ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3227623,
                "title": "c-golang-sc-o-n-and-o-1",
                "content": "# Code\\n```\\n// C++\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        unordered_set<int> Set(nums.begin(), nums.end());\\n        for(int i = 0; i < 31; i++) {\\n            if(Set.find(1 << i) == Set.end()) return 1 << i;\\n        }\\n        return 1 << 31;\\n    }\\n};\\n\\nOR\\n\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        for(int i = 0; i < 31; i++) {\\n            if(!binary_search(nums.begin(), nums.end(), 1 << i)) return 1 << i;\\n        }\\n        return 1 << 31;\\n    }\\n};\\n\\n-------------------------------------------------------\\n// Golang\\nfunc minImpossibleOR(nums []int) int {\\n    Set := make(map[int]bool)\\n    for _, num := range nums {\\n        Set[num] = true\\n    }\\n    for i := 0; i < 31; i++ {\\n        if !Set[1 << i] {return 1 << i}\\n    }\\n    return 1 << 31\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Go"
                ],
                "code": "```\\n// C++\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        unordered_set<int> Set(nums.begin(), nums.end());\\n        for(int i = 0; i < 31; i++) {\\n            if(Set.find(1 << i) == Set.end()) return 1 << i;\\n        }\\n        return 1 << 31;\\n    }\\n};\\n\\nOR\\n\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        for(int i = 0; i < 31; i++) {\\n            if(!binary_search(nums.begin(), nums.end(), 1 << i)) return 1 << i;\\n        }\\n        return 1 << 31;\\n    }\\n};\\n\\n-------------------------------------------------------\\n// Golang\\nfunc minImpossibleOR(nums []int) int {\\n    Set := make(map[int]bool)\\n    for _, num := range nums {\\n        Set[num] = true\\n    }\\n    for i := 0; i < 31; i++ {\\n        if !Set[1 << i] {return 1 << i}\\n    }\\n    return 1 << 31\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3227378,
                "title": "python-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def minImpossibleOR(self, nums: List[int]) -> int:\\n        ans=0\\n        for i in range(32):\\n            for item in nums:\\n                if((item>>i)&1!=0):\\n                    for j in range(32):\\n                        if(i==j):continue\\n                        if((item>>j)&1!=0):\\n                            break\\n                    else:\\n                        break\\n            else:\\n                ans=(1<<i)\\n                return ans\\n        \\n                \\n            \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minImpossibleOR(self, nums: List[int]) -> int:\\n        ans=0\\n        for i in range(32):\\n            for item in nums:\\n                if((item>>i)&1!=0):\\n                    for j in range(32):\\n                        if(i==j):continue\\n                        if((item>>j)&1!=0):\\n                            break\\n                    else:\\n                        break\\n            else:\\n                ans=(1<<i)\\n                return ans\\n        \\n                \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3227076,
                "title": "python3-one-line",
                "content": "# Code\\n```\\nclass Solution:\\n    def minImpossibleOR(self, nums: List[int]) -> int:\\n        return min(2**i for i in range(32) if 2**i not in set(nums))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minImpossibleOR(self, nums: List[int]) -> int:\\n        return min(2**i for i in range(32) if 2**i not in set(nums))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3225252,
                "title": "c-bit-manipulation-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) \\n    {\\n        unordered_set<int> s(nums.begin(),nums.end());\\n        int a=1;\\n        while(s.count(a))\\n        {\\n            a<<=1;\\n        }\\n        return a;\\n        \\n    }\\n};\\n```\\nif you like the solution plz upvote.\\n=",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) \\n    {\\n        unordered_set<int> s(nums.begin(),nums.end());\\n        int a=1;\\n        while(s.count(a))\\n        {\\n            a<<=1;\\n        }\\n        return a;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3223273,
                "title": "java-pow-of-2-faster-than-90-without-set-and-complex-bit-manipulation-explained",
                "content": "**Idea:**\\nWe return the 1st `power of 2` that is not present in `nums`. \\n\\n**Method**-**1**: Using `Extra Space`\\nSo, we create a **list** of only the elements that are **powers of 2**. \\nThen we find which is the **1st** `power of 2` that is not present in `list` & return it.\\n\\n**Time Complexity** : O(N)\\n**Space Complexity** : O(N) used for storing powers of 2 in `list`\\n\\n```\\npublic int minImpossibleOR(int[] nums) {\\n      List<Integer> list = new ArrayList<>();\\n      for(int n : nums)\\n          if(n == 1 || (n & 1) == 0) list.add(n); //Adding only the powers of 2 in our list\\n        \\n        int powerOfTwo = 1; //1st power of 2 i.e. 2^0 = 1\\n\\t\\t\\n\\t\\t//Return the 1st power of two that\\'s not found in our list\\n        while(true){\\n            if(!list.contains(powerOfTwo)) return powerOfTwo;\\n            powerOfTwo *= 2; // next power of 2\\n        }\\n    }\\n```\\n\\n**Method**-**2**: `No Extra Space`\\nWe ***sort*** the given array `nums` and check which is the **1st** `power of 2` which is smaller than the **elements** in the sorted order.\\n\\n**Time Complexity** : O(N LogN) for `Sorting`\\n**Space Complexity** : O(1)\\n\\nDo **Upvote**\\uD83D\\uDD3A\\n```\\npublic int minImpossibleOR(int[] nums) {\\n        Arrays.sort(nums);\\n        int powerOfTwo = 1;\\n        \\n        for(int n: nums){\\n            if(n > powerOfTwo) return powerOfTwo;\\n            else if(n == powerOfTwo) powerOfTwo *= 2;\\n        }\\n        return powerOfTwo;\\n    }\\n```\\n\\n\\u2764Do **UPVOTE** or Give ***suggestions*** if you feel so :)",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```\\npublic int minImpossibleOR(int[] nums) {\\n      List<Integer> list = new ArrayList<>();\\n      for(int n : nums)\\n          if(n == 1 || (n & 1) == 0) list.add(n); //Adding only the powers of 2 in our list\\n        \\n        int powerOfTwo = 1; //1st power of 2 i.e. 2^0 = 1\\n\\t\\t\\n\\t\\t//Return the 1st power of two that\\'s not found in our list\\n        while(true){\\n            if(!list.contains(powerOfTwo)) return powerOfTwo;\\n            powerOfTwo *= 2; // next power of 2\\n        }\\n    }\\n```\n```\\npublic int minImpossibleOR(int[] nums) {\\n        Arrays.sort(nums);\\n        int powerOfTwo = 1;\\n        \\n        for(int n: nums){\\n            if(n > powerOfTwo) return powerOfTwo;\\n            else if(n == powerOfTwo) powerOfTwo *= 2;\\n        }\\n        return powerOfTwo;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3219824,
                "title": "implementation-of-hint",
                "content": "Fairly simple idea taken from the hint.  \\n\\n# Code\\n```\\nclass Solution:\\n    def minImpossibleOR(self, nums: List[int]) -> int:\\n        for i in range(50):\\n            if 2**i not in nums:\\n                return 2**i\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minImpossibleOR(self, nums: List[int]) -> int:\\n        for i in range(50):\\n            if 2**i not in nums:\\n                return 2**i\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3218640,
                "title": "java-simple-solution",
                "content": "//\"\"\"\\n\\nimport java.util.*;\\nclass Solution {\\n    public int minImpossibleOR(int[] nums) {\\n        Arrays.sort(nums);\\n        int temp=1;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]<temp)\\n                continue;\\n            if(nums[i]!=temp)\\n                return temp;\\n            temp+=nums[i];\\n        }\\n        return temp;\\n        \\n    }\\n}\\n\\n//\"\"\"",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int minImpossibleOR(int[] nums) {\\n        Arrays.sort(nums);\\n        int temp=1;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]<temp)\\n                continue;\\n            if(nums[i]!=temp)\\n                return temp;\\n            temp+=nums[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3218239,
                "title": "beginner-friendly-easy-cpp-binary-search-bit-manupilation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nWe will find the minimum power of 2 that is not preaent in given array.\\nbeacuse numbers like 1,2,4,8,16... cannot created by using OR beacuse to generate them we will need OR with zero (FOR eg. 8 will only generated if 8 is present and OR with 0 ). minimum power of 2 that is not preaent will be our answer.\\n\\nuse binary search to reduce complexity.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int search(int key,vector<int>& nums,int k){\\n        int s=k;\\n        int e=nums.size()-1;\\n        int m=s+(e-s)/2;\\n        while(s<=e){\\n            if(nums[m]==key){\\n                return m;\\n            }\\n            else if(nums[m]<key){\\n                s=m+1;\\n            }\\n            else{\\n                e=m-1;\\n            }\\n            m=s+(e-s)/2;\\n        }\\n        return -1;\\n    }\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        int i=0;\\n        int prev=0;\\n        while(1){\\n            int k=search(pow(2,i),nums,prev);\\n            if(k==-1){\\n                return pow(2,i);\\n            }\\n            else{\\n                prev=k+1;\\n                i++;\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    int search(int key,vector<int>& nums,int k){\\n        int s=k;\\n        int e=nums.size()-1;\\n        int m=s+(e-s)/2;\\n        while(s<=e){\\n            if(nums[m]==key){\\n                return m;\\n            }\\n            else if(nums[m]<key){\\n                s=m+1;\\n            }\\n            else{\\n                e=m-1;\\n            }\\n            m=s+(e-s)/2;\\n        }\\n        return -1;\\n    }\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        int i=0;\\n        int prev=0;\\n        while(1){\\n            int k=search(pow(2,i),nums,prev);\\n            if(k==-1){\\n                return pow(2,i);\\n            }\\n            else{\\n                prev=k+1;\\n                i++;\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3217151,
                "title": "c-without-set-o-1-space",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        int mask = 0; \\n        \\n        for (int n:nums) {\\n            if (n & (n-1)) \\n                continue;\\n            mask |= n;\\n        }\\n        mask = ~mask;\\n        return (mask & (-mask));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        int mask = 0; \\n        \\n        for (int n:nums) {\\n            if (n & (n-1)) \\n                continue;\\n            mask |= n;\\n        }\\n        mask = ~mask;\\n        return (mask & (-mask));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3216915,
                "title": "first-missing-positive-bit-manipulation-easy-to-understand",
                "content": "# Intuition\\nThis problem seems similar to [First Missing Positive](https://leetcode.com/problems/first-missing-positive/). Here is a solution to that probelm:\\n\\n```\\nint firstMissingPositive(vector<int>& nums) {\\n    unordered_set<int> numSet(nums.begin(),nums.end());\\n    int i = 1;\\n    while (i <= nums.size()){\\n        if (!numSet.count(i)) return i;\\n        i++;\\n    }\\n    return i;\\n}\\n```\\n# Observation\\nOur solution is similar to the above in spirit. The crucial thing to notice is that if we have just powers of 2, we can construct all numbers upto the next power of 2 by their OR.\\n\\nFor example, given the array `[1,2,4,8,16]`, we can do `OR` between various elements to construct all numbers from 1 to 31. So the presence of other numbers in the middle like 3,5,6 etc. does not change the range of possible numbers. Hence these are the only ones that need to be checked.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) \\n    {\\n        unordered_set<int> numSet(nums.begin(),nums.end());\\n        int cur = 1;\\n        while (cur<INT_MAX)\\n        {\\n            if (!numSet.count(cur)) return cur;\\n            cur <<= 1;\\n        }\\n        return INT_MAX;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nint firstMissingPositive(vector<int>& nums) {\\n    unordered_set<int> numSet(nums.begin(),nums.end());\\n    int i = 1;\\n    while (i <= nums.size()){\\n        if (!numSet.count(i)) return i;\\n        i++;\\n    }\\n    return i;\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) \\n    {\\n        unordered_set<int> numSet(nums.begin(),nums.end());\\n        int cur = 1;\\n        while (cur<INT_MAX)\\n        {\\n            if (!numSet.count(cur)) return cur;\\n            cur <<= 1;\\n        }\\n        return INT_MAX;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3216678,
                "title": "easy-to-understand-o-n-not-set-required",
                "content": "```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        int cummRes = 0;\\n        for (auto &n : nums) {\\n            // check if number is power of 2\\n            if ((n & (n-1)) == 0) {\\n                cummRes |= n;\\n            }\\n        }\\n        // identify the bit first lsb which is set to 0\\n        cummRes = ~cummRes;\\n        return (cummRes & (-cummRes));\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        int cummRes = 0;\\n        for (auto &n : nums) {\\n            // check if number is power of 2\\n            if ((n & (n-1)) == 0) {\\n                cummRes |= n;\\n            }\\n        }\\n        // identify the bit first lsb which is set to 0\\n        cummRes = ~cummRes;\\n        return (cummRes & (-cummRes));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3214697,
                "title": "swift-solution-o-n-o-int-bitcount",
                "content": "# Code\\n```\\nclass Solution {\\n    func minImpossibleOR(_ nums: [Int]) -> Int {\\n        let set = Set(nums)\\n        var num = 1\\n\\n        while set.contains(num) {\\n            num <<= 1\\n        }\\n\\n        return num\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func minImpossibleOR(_ nums: [Int]) -> Int {\\n        let set = Set(nums)\\n        var num = 1\\n\\n        while set.contains(num) {\\n            num <<= 1\\n        }\\n\\n        return num\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3214570,
                "title": "smallest-missing-power-of-two",
                "content": "**The smallest power of 2 not present in the array will be the first number that could not be expressed using the given operation.**\\n```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        \\n        int SmallestPowerOfTwo=1;\\n        sort(nums.begin(),nums.end());\\n        \\n        for(auto it:nums)\\n        {\\n            if(it==find)\\n            {\\n                SmallestPowerOfTwo*=2;\\n            }\\n        }\\n        return SmallestPowerOfTwo;\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/804ed631-2b77-4d38-949c-59b10e5aa281_1676984521.1293125.png)\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        \\n        int SmallestPowerOfTwo=1;\\n        sort(nums.begin(),nums.end());\\n        \\n        for(auto it:nums)\\n        {\\n            if(it==find)\\n            {\\n                SmallestPowerOfTwo*=2;\\n            }\\n        }\\n        return SmallestPowerOfTwo;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3213548,
                "title": "contest-answer-simple-approach-java-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int minImpossibleOR(int[] nums) {\\n            Arrays.sort(nums);\\n    int curMax = 0;\\n    for (int num : nums) {\\n        if (num > curMax + 1) {\\n            return curMax + 1;\\n        }\\n        curMax |= num;\\n    }\\n    return curMax + 1;\\n    }\\n}\\n```\\n**This code came in the contest of last weekend and this is how i solved it.**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minImpossibleOR(int[] nums) {\\n            Arrays.sort(nums);\\n    int curMax = 0;\\n    for (int num : nums) {\\n        if (num > curMax + 1) {\\n            return curMax + 1;\\n        }\\n        curMax |= num;\\n    }\\n    return curMax + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3211891,
                "title": "c-bit-logic-explained",
                "content": "# Approach\\nIf you take few examples for this question. You\\'ll observe that if any element is not expressible in the array then at least one element which is power of 2 and less than this element is also not expressible.\\n\\nFor e.g if 3 is not expressible then either 2 is not expressible in array or 1 is not expressible in array.\\n\\nanother example is 11, then either 8 is not expressible or 2 is not expressible or 1.\\n\\nSo, problem reduces to finding minimum power of 2 which is missing in array.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        int ans = 1;\\n        int n = nums.size();\\n        \\n        sort(nums.begin(),nums.end());\\n        int in = lower_bound(nums.begin(),nums.end(),ans) - nums.begin();\\n        while(in < n && nums[in] == ans)\\n        {\\n            ans = ans << 1;\\n            in = lower_bound(nums.begin(),nums.end(),ans) - nums.begin();\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        int ans = 1;\\n        int n = nums.size();\\n        \\n        sort(nums.begin(),nums.end());\\n        int in = lower_bound(nums.begin(),nums.end(),ans) - nums.begin();\\n        while(in < n && nums[in] == ans)\\n        {\\n            ans = ans << 1;\\n            in = lower_bound(nums.begin(),nums.end(),ans) - nums.begin();\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3207654,
                "title": "c-missing-power-of-2",
                "content": "![Approach](https://assets.leetcode.com/users/images/f54ec781-dc6e-4dc2-95d7-c12cbadae6d6_1676845946.6624577.jpeg)\\n\\n\\n![Explaination](https://assets.leetcode.com/users/images/3c45d029-56d7-4658-811b-0b0fd7e4b982_1676845982.0910962.jpeg)\\n\\n\\n[My GitHub](https://github.com/Arnab-Patra006/Code_With_Pie/blob/main/LeetCode/2568.%20Minimum%20Impossible%20OR.md)\\n\\n```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        unordered_map<long long,int>mp;\\n        long long int t=1;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            mp[nums[i]]++;\\n        }\\n        int p=1;\\n        while(mp.find(p)!=mp.end())\\n        {\\n            p*=2;\\n        }\\n        return p;\\n    }\\n};\\n```\\nUpvote iff you like the explaination!",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        unordered_map<long long,int>mp;\\n        long long int t=1;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            mp[nums[i]]++;\\n        }\\n        int p=1;\\n        while(mp.find(p)!=mp.end())\\n        {\\n            p*=2;\\n        }\\n        return p;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3206697,
                "title": "javascript",
                "content": "\\n```\\nvar minImpossibleOR = function (nums) {\\n    let min = 1;\\n    const powerOf2 = new Set();\\n\\n    for (let i = 0; i < nums.length; i++) {\\n        if (!(nums[i] & (nums[i] - 1))) powerOf2.add(nums[i]);\\n    }\\n\\n    // find first power of 2 not in nums\\n    while (powerOf2.has(min)) min *= 2;\\n\\n    return min;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minImpossibleOR = function (nums) {\\n    let min = 1;\\n    const powerOf2 = new Set();\\n\\n    for (let i = 0; i < nums.length; i++) {\\n        if (!(nums[i] & (nums[i] - 1))) powerOf2.add(nums[i]);\\n    }\\n\\n    // find first power of 2 not in nums\\n    while (powerOf2.has(min)) min *= 2;\\n\\n    return min;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3206398,
                "title": "1sentence-c-7-liner-only-2-k-can-be-an-answer-proof-find-the-lowest-2-k-not-in-nums",
                "content": "# Reasoning:\\n\\nLet\\'s suppose a non-$2^k$ is an answer. It has the binary form of `a = 1x1y`, where $x$ and $y$ stand for any sequence of $0$ and $1$. `1x1y` is the lowest non-ORable number. Therefore `1x0y` and `0x1y` are both expressible as an OR of `nums`. But if we take these two solutions and OR them together we will get the original `1x1y`, so `1x1y` is the expressible. We have reached a contradiction.\\n\\nThe only way to have $2^k$ expressible is to have $2^k$ in `nums` from the beginning. Since it is a single bit set on we can efficiently search for such numbers counting bits each number.\\n\\nI chose to store the 1-bit numbers using bit encoding.\\n\\n# Upvote if you like the simplicity of this solution\\n```\\nint minImpossibleOR(vector<int>& nums)\\n{\\n    int mask = 0;\\n    for(int a : nums)\\n        if(__builtin_popcount(a) == 1)\\n            mask |= a;\\n    for(int i=1; true; i <<= 1)\\n        if((mask & i) == 0)\\n            return i;\\n}\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nint minImpossibleOR(vector<int>& nums)\\n{\\n    int mask = 0;\\n    for(int a : nums)\\n        if(__builtin_popcount(a) == 1)\\n            mask |= a;\\n    for(int i=1; true; i <<= 1)\\n        if((mask & i) == 0)\\n            return i;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3206396,
                "title": "explanation-and-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor any number n, we can be written as the bitwise __OR__ of powers of `2`. For eg: `90` whose bits are `1011010` can be written as bitwise __OR__ of (2, 8, 16, 64).\\nThe only numbers wich cannot be written as above are the powers of `2` itself, where we need the number itself in the array.\\nSo, we just need to find the smallest power of `2` not present in the array.\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        int curr = 1;\\n        for (int i=0; i<n; ++i) {\\n            if (nums[i] > curr) return curr;\\n            else if (nums[i] == curr) {\\n                curr *= 2;\\n            }\\n        }\\n        return curr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Sort",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        int curr = 1;\\n        for (int i=0; i<n; ++i) {\\n            if (nums[i] > curr) return curr;\\n            else if (nums[i] == curr) {\\n                curr *= 2;\\n            }\\n        }\\n        return curr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3206062,
                "title": "first-missing-pow-of-2",
                "content": "# Intuition\\n\\n1. You cannot build a pow of 2 with any other numbers using `or` operation because you need only one bit in a particular place. So, to build `4` (``100``) for example you can only use `4 or 4` or `4 or 0`.\\n2. If we consider all numbers consist of only 3 bits: `100, 101, 110, 111`, the smallest one is `100` which is a power of 2.\\n3. If we have `1`, `10`, and `100` numbers we can build any other number lower than `1000`.\\n4. Based on that we can find the smallest missing power of 2 and it will be an answer.\\n\\n# Code\\n```\\nclass Solution:\\n    def minImpossibleOR(self, nums: List[int]) -> int:\\n        s = set(nums)\\n        i = 1\\n        while i in s:\\n            i *= 2\\n        return i\\n```",
                "solutionTags": [
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def minImpossibleOR(self, nums: List[int]) -> int:\\n        s = set(nums)\\n        i = 1\\n        while i in s:\\n            i *= 2\\n        return i\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3205979,
                "title": "builtin-popcount-c-solution",
                "content": "```\\nint minImpossibleOR(int* nums, int numsSize){\\n    int mask = 0, ans = 1;\\n    for(int i = 0; i < numsSize; i++)\\n        if(__builtin_popcount(nums[i]) == 1)\\n            mask |= nums[i];\\n    mask = ~mask;\\n\\t\\n    while(!(mask & ans))\\n        ans <<= 1;\\n    \\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nint minImpossibleOR(int* nums, int numsSize){\\n    int mask = 0, ans = 1;\\n    for(int i = 0; i < numsSize; i++)\\n        if(__builtin_popcount(nums[i]) == 1)\\n            mask |= nums[i];\\n    mask = ~mask;\\n\\t\\n    while(!(mask & ans))\\n        ans <<= 1;\\n    \\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3205256,
                "title": "easy-solution-2-s-power-c-explained-o-n-time-o-1-space",
                "content": "As per OR table even if there is a 1 at a bit position regardless of the other number there will be 1 in the resulting bit position.\\nBut regardless of what the two numbers two 0s can never make a 1.\\n\\nConsidering above facts lets take an example.\\nIf 6 is not there in the vector and all non zero positive numbers are there in the vector or can be formed.\\n6 in bits is 110\\nWhich can be formed by 4 OR 2.\\nSimilarly for 7, 7 in bits is 111\\nWhich can be formed by 4 or 3.\\n\\nNow for 8 which is 1000, this cannot be formed by any number as no number has 1 in its 4th bit position.\\nSo the answer for this problem is the first 2s power which is not available in the given vector.\\n\\n```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        int k = 0;                                                   // To check power of 2\\n        sort(nums.begin(), nums.end());              // To order the numbers, as we need to find the minimum number\\n        \\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            if(nums[i] == pow(2,k))\\n                k++;                                                 // Increasing the power of 2 each time a exponent of 2 is found\\n            else if(nums[i] > pow(2,k))\\n                break;                                              \\n        }\\n        \\n        return pow(2,k);\\n    } \\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        int k = 0;                                                   // To check power of 2\\n        sort(nums.begin(), nums.end());              // To order the numbers, as we need to find the minimum number\\n        \\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            if(nums[i] == pow(2,k))\\n                k++;                                                 // Increasing the power of 2 each time a exponent of 2 is found\\n            else if(nums[i] > pow(2,k))\\n                break;                                              \\n        }\\n        \\n        return pow(2,k);\\n    } \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3205180,
                "title": "minimalist-solution",
                "content": "```\\nfunc minImpossibleOR(nums []int) int {\\n    m := 0\\n    for _, n := range nums {\\n        if n & (n - 1) == 0 {\\n            m |= n\\n        }\\n    }\\n    res := 1\\n    for m & 1 != 0 {\\n        res <<= 1\\n        m >>= 1\\n    }\\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc minImpossibleOR(nums []int) int {\\n    m := 0\\n    for _, n := range nums {\\n        if n & (n - 1) == 0 {\\n            m |= n\\n        }\\n    }\\n    res := 1\\n    for m & 1 != 0 {\\n        res <<= 1\\n        m >>= 1\\n    }\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3205145,
                "title": "c-time-o-n-space-o-1-solution-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe are looking for the minimum positive non-expressible value. So we may check each value among `1` and `2^31 - 1` one-by-one in ascending order.\\n\\nIn the meanwhile, when we are still not found the answer before checking the value `x`, it means we already checked `1` ~ `x-1` before and all of them are expressible. It implies every power of `2` which less than `x` should be checked and expressible.\\n\\nFor example, if we are checking `14` now, then it implies `1` ~ `13` are expressible, so `1`, `2`, `4`, `8` are expressible.\\n\\nEvery power of `2` is expressible only if it is inside `nums` because it only includes a single bit. And every other value is expressible once its each bit component is expressible. For example, `14 = 8 + 4 + 2`, `14` must be expressible when `2`, `4`, and `8` are all expressible. It implies the answer must be power of `2`.\\n\\nSo actually, we are looking for the minimum power of `2` which are not inside `nums`.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSince `1 <= nums[i] <= 10^9`, the answer is not larger than `2^31`.In Leetcode `int` is at least 4-bytes long, so we can just use an `int` as bit flag hash table to record whether each power of `2` is inside `nums`. Then return the lowest missing bit.\\n\\nTo check whether `x` is power of `2`, we can use bit manipulation:\\n```\\n(x & x-1) == 0\\n```\\nif `x` is positive (non-zero), then `x & x-1` removes the lowest bit `1`, and if it becomes zero, then it implies `x` is power of `2`.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        int bit_mask = 0;\\n        for (auto n : nums)\\n            if ((n & n-1) == 0)\\n                bit_mask |= n;\\n        \\n        int highest_bit = 1;\\n        while ((highest_bit & bit_mask) == highest_bit)\\n            highest_bit <<= 1;\\n\\n        return highest_bit;\\n\\n        // another tricky method would be:\\n        // unsigned missing_bit = ~(unsigned)bit_mask;\\n        // return missing_bit - (missing_bit & missing_bit-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\n(x & x-1) == 0\\n```\n```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        int bit_mask = 0;\\n        for (auto n : nums)\\n            if ((n & n-1) == 0)\\n                bit_mask |= n;\\n        \\n        int highest_bit = 1;\\n        while ((highest_bit & bit_mask) == highest_bit)\\n            highest_bit <<= 1;\\n\\n        return highest_bit;\\n\\n        // another tricky method would be:\\n        // unsigned missing_bit = ~(unsigned)bit_mask;\\n        // return missing_bit - (missing_bit & missing_bit-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3205079,
                "title": "2-solutions-with-extra-space-without-space",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        //-solution 1:-simple but ,trick based:)----------\\n        //------------------without space-----------------\\n         int i=1;\\n         while(find(nums.begin(),nums.end(),i)!=nums.end()){\\n           i=i<<1; //i*2\\n         }\\n        return i;\\n        //--------------------------------------\\n\\n        //solution 2:\\n        //---------------with space---------------------------\\n        //set<int> tem;\\n        //for(auto i:nums){\\n        //  tem.insert(i);\\n        //}\\n        //int i=1;\\n        //while(tem.count(i)){\\n        //  i=i<<1; //*2 value\\n        //}\\n        //return i;\\n        //--------------------------------\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        //-solution 1:-simple but ,trick based:)----------\\n        //------------------without space-----------------\\n         int i=1;\\n         while(find(nums.begin(),nums.end(),i)!=nums.end()){\\n           i=i<<1; //i*2\\n         }\\n        return i;\\n        //--------------------------------------\\n\\n        //solution 2:\\n        //---------------with space---------------------------\\n        //set<int> tem;\\n        //for(auto i:nums){\\n        //  tem.insert(i);\\n        //}\\n        //int i=1;\\n        //while(tem.count(i)){\\n        //  i=i<<1; //*2 value\\n        //}\\n        //return i;\\n        //--------------------------------\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3204907,
                "title": "basic-intuitive-explained-fully",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nyou just need to see that numbers who are power of 2 they can\\'t be formed using or of any two numbers , they must be present in array .\\nnow one more thing you can see is that , if you have 1 2 4 that is till second power of 2 then you can form any number less than third power of 2 using these three number hence you just need to find which is the lowest power of 2 that is not present in array.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\njust iterate over all power of 2 till the time you don\\'t find a value that is not present in given array\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(n) i.e length of arrray\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(n) i.e for the map\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        \\n        map<int,int> mp;\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]+=1;\\n        }\\n       \\n        int val=1;\\n        int p=0;\\n        while(mp[val]){\\n            p++;\\n            val=(int)(pow(2,p));\\n        }\\n        return val;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        \\n        map<int,int> mp;\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]+=1;\\n        }\\n       \\n        int val=1;\\n        int p=0;\\n        while(mp[val]){\\n            p++;\\n            val=(int)(pow(2,p));\\n        }\\n        return val;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3204723,
                "title": "just-check-2-s-power-why-2-s-power-explained",
                "content": "\\n// why 2\\'s power -> suppose we have number 4 and 3,2,1 then by 4 we can only get number  5 (4 or 1 ) , 6(4 or 2 ), 7(4 or 3 ) but for 8 there is extra 1 bit added which can be only defined by number itself thats why we are checking power of 2 .\\nupvote if it helps :)\\n\\t\\t   \\n\\t\\t  HashSet<Integer>set = new HashSet<>();\\n        \\n        for(int i:nums){\\n            set.add(i);\\n        }\\n        \\n        \\n        int ans =1;\\n        \\n        while(set.contains(ans)){\\n            ans*=2;\\n        }\\n        \\n       return ans ;",
                "solutionTags": [],
                "code": "\\n// why 2\\'s power -> suppose we have number 4 and 3,2,1 then by 4 we can only get number  5 (4 or 1 ) , 6(4 or 2 ), 7(4 or 3 ) but for 8 there is extra 1 bit added which can be only defined by number itself thats why we are checking power of 2 .\\nupvote if it helps :)\\n\\t\\t   \\n\\t\\t  HashSet<Integer>set = new HashSet<>();\\n        \\n        for(int i:nums){\\n            set.add(i);\\n        }\\n        \\n        \\n        int ans =1;\\n        \\n        while(set.contains(ans)){\\n            ans*=2;\\n        }\\n        \\n       return ans ;",
                "codeTag": "Unknown"
            },
            {
                "id": 3204712,
                "title": "easy-c-soln-o-n",
                "content": "# Intuition\\n=>   If nums does not contain 1 we return 1.\\n=>  If nums does not contain 2 we return 2.\\nOtherwise, we can form numbers [1, 4).\\nbeacuse 3 can be formed by or of 2 and 1\\n\\n.\\n\\n\\n=> If nums does not contain 4 we return 4.\\nOtherwise, we can form numbers [1, 8).\\nbeacuse all the numbers from 5 to 7 can be formed with the OR operation with the combination of 1,2,4\\n\\n\\n.\\n\\n\\n=> If nums does not contain 8 we return 8.\\nOtherwise, we can form numbers [1, 16).\\n... ....and so on.\\n\\n# Approach\\nwe will check the first number in 2^n form (where n is a whole number )which is not present in our given array \\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n \\n    int minImpossibleOR(vector<int>& nums) {\\n        unordered_map<int,int> m;\\n        for(int i=0;i<nums.size();i++)\\n            m[nums[i]]=1;\\n      \\n    if(m[1]==0)\\n        return 1;\\n        int i;\\n        for( i=2;i<=1000000000;i=i*2){\\n          //first number in 2^n form that is not present in given arrat\\n            if(m[i]==0)\\n                return i;\\n        }\\n  \\n  return i;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n \\n    int minImpossibleOR(vector<int>& nums) {\\n        unordered_map<int,int> m;\\n        for(int i=0;i<nums.size();i++)\\n            m[nums[i]]=1;\\n      \\n    if(m[1]==0)\\n        return 1;\\n        int i;\\n        for( i=2;i<=1000000000;i=i*2){\\n          //first number in 2^n form that is not present in given arrat\\n            if(m[i]==0)\\n                return i;\\n        }\\n  \\n  return i;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3204679,
                "title": "c-2-s-power",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWith the fact that every number can be expressed as:\\nnum = a*2^0 + b*2^1 + c*2^2 + ...\\n\\nIn other words, if a number can be exprssed using the number in `nums`, `nums` must inlcude the required 2\\'s power. \\n\\nEg.\\n\\nwith 1, we can get all numbers up to 1 by OR elements in [1]\\nwith 1,2, we can get all numbers up to 3 by OR elements in [1,2]\\nwith 1,2,4, we can get all numbers up to 7 by OR elements in [1,2,4]\\nwith 1,2,4,8, we can get all numbers up to 15 by OR elements in [1,2,4,8]\\n\\netc.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        unordered_set<int> s(nums.begin(), nums.end());\\n        int n = 0;\\n        for(int i=0; i<32; i++) {\\n            n = (1<<i);\\n            if(s.count(n)) continue;\\n            break;\\n        }\\n        return n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        unordered_set<int> s(nums.begin(), nums.end());\\n        int n = 0;\\n        for(int i=0; i<32; i++) {\\n            n = (1<<i);\\n            if(s.count(n)) continue;\\n            break;\\n        }\\n        return n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3204644,
                "title": "python-lowest-missing-bit-100-time-easy-to-understand",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSimply find the lowest power of 2 which isn\\'t there in the array\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```python []\\nclass Solution:\\n    def minImpossibleOR(self, nums: List[int]) -> int:\\n        numsSet, power = set(nums), 0\\n        while 1 << power in numsSet:\\n            power += 1\\n        return 1 << power\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "Bit Manipulation"
                ],
                "code": "```python []\\nclass Solution:\\n    def minImpossibleOR(self, nums: List[int]) -> int:\\n        numsSet, power = set(nums), 0\\n        while 1 << power in numsSet:\\n            power += 1\\n        return 1 << power\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3204432,
                "title": "easy-c-beginner-friendly-bitwise-or",
                "content": "Approach: Suppose you have an array [1,2,5] what is the min positive non zero integer that you cannot form ?\\nAnswer is 4 .But why is that ???   \\n        Because in order to have 4 you must have it in the given array as 4 cannot be form by bitwise OR of any other\\n\\t\\tcombination.\\n\\t\\tWhat if we also had 4 in the given array ?\\n\\t\\tarray would be [1,2,4,5]\\n\\t\\tLet see them in binary(bit) form \\n\\t\\t1   ->1\\n\\t\\t2   ->10\\n\\t\\t4   ->100\\n\\t\\t5   ->101\\n\\t\\t\\n\\t\\tIn this case Let us see if we can form 3 .YES by OR of 1 and 2.Is 6 also possible yes by OR of 4 and 2 .\\n\\t\\t7 -> 5|2.\\n\\t\\tanswer would be 8 as it cannot be formed by any other combination.\\n\\t\\t\\n\\t\\tIf set does not contain (2^0) we return 1.\\n       If set does not contain (2^1) we return 2.\\n        Otherwise, we can form numbers {1,2,3}\\n       If set does not contain 4 we return 4.\\n     Otherwise, we can form numbers {1,2,3,4,5,6,7}\\n     If set does not contain 8 we return 8.\\n     Otherwise, we can form numbers [1, 15].\\n\\t\\t\\n\\t\\tSo we can conclude that the if the ith power of 2   (2^i) is not present individually then it is our answer.\\n\\t\\tBecause any number smaller than it can be form by combination of other numbers .\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums)\\n    {\\n        unordered_set<int>s;                         // set  to store the numbers\\n        for(auto it:nums)\\n            s.insert(it);\\n        int ans=-1;\\n        for(int i=0;i<32;i++)\\n        {\\n            int check=1<<i;                           // value to be checked\\n            if(s.count(check)==0)                 // not present then it is our answer\\n            {\\n                ans=check;\\n                break;\\n            }\\n        }\\n        return ans;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums)\\n    {\\n        unordered_set<int>s;                         // set  to store the numbers\\n        for(auto it:nums)\\n            s.insert(it);\\n        int ans=-1;\\n        for(int i=0;i<32;i++)\\n        {\\n            int check=1<<i;                           // value to be checked\\n            if(s.count(check)==0)                 // not present then it is our answer\\n            {\\n                ans=check;\\n                break;\\n            }\\n        }\\n        return ans;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3204401,
                "title": "antarnab-100-easy-faster-coding-life-cpp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int n = 1;\\n        for(int i = 0; i < nums.size(); ++i){\\n            if(nums[i] > n) return n;\\n            if(nums[i] == n) { n = n*2; }\\n        }\\n        return n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int n = 1;\\n        for(int i = 0; i < nums.size(); ++i){\\n            if(nums[i] > n) return n;\\n            if(nums[i] == n) { n = n*2; }\\n        }\\n        return n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3204235,
                "title": "fundamental-approach-c-bit-manip",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        unordered_map<int, int> umap;\\n        for(auto val: nums) {\\n            umap[val]++;\\n        }\\n        int n = 1;\\n        while(n < 1e10) {\\n            if(umap.find(n) == umap.end()) {\\n                return n;\\n            }\\n            n <<= 1;\\n        }\\n        return 1e10;\\n    }\\n};\\n// Please consider upvoting if the solution helped! Thank you :)\\n// Credits: DeepCodes (YouTube)\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        unordered_map<int, int> umap;\\n        for(auto val: nums) {\\n            umap[val]++;\\n        }\\n        int n = 1;\\n        while(n < 1e10) {\\n            if(umap.find(n) == umap.end()) {\\n                return n;\\n            }\\n            n <<= 1;\\n        }\\n        return 1e10;\\n    }\\n};\\n// Please consider upvoting if the solution helped! Thank you :)\\n// Credits: DeepCodes (YouTube)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3204111,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn min_impossible_or(nums: Vec<i32>) -> i32 {\\n        let s = nums.into_iter().collect::<std::collections::HashSet<i32>>();\\n        let mut a = 1;\\n        while s.contains(&a) {\\n            a <<= 1;\\n        }\\n        a\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn min_impossible_or(nums: Vec<i32>) -> i32 {\\n        let s = nums.into_iter().collect::<std::collections::HashSet<i32>>();\\n        let mut a = 1;\\n        while s.contains(&a) {\\n            a <<= 1;\\n        }\\n        a\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3203910,
                "title": "my-solution",
                "content": "```\\n/**\\n * Time Complexity: O(n)\\n * Space Complexity: O(n)\\n * where `n` is the length of the vector `nums`\\n */\\nclass Solution {\\n public:\\n  int minImpossibleOR(const vector<int> &nums) {\\n    constexpr int max_offset = 31;\\n    unordered_set<int> all_nums(nums.begin(), nums.end());\\n    int ret = -1;\\n    for (int offset = 0; offset < max_offset; ++offset) {\\n      const int missing = 1 << offset;\\n      if (all_nums.find(missing) == all_nums.end()) {\\n        ret = missing;\\n        break;\\n      }\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Time Complexity: O(n)\\n * Space Complexity: O(n)\\n * where `n` is the length of the vector `nums`\\n */\\nclass Solution {\\n public:\\n  int minImpossibleOR(const vector<int> &nums) {\\n    constexpr int max_offset = 31;\\n    unordered_set<int> all_nums(nums.begin(), nums.end());\\n    int ret = -1;\\n    for (int offset = 0; offset < max_offset; ++offset) {\\n      const int missing = 1 << offset;\\n      if (all_nums.find(missing) == all_nums.end()) {\\n        ret = missing;\\n        break;\\n      }\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203562,
                "title": "python3-power-of-two-greedy-with-explanation",
                "content": "Loop through the **sorted(nums)**, checking if the current number can be represented as a power of two, starting from zero in binary representation. If so, we update pows to the next power of two (pows *= 2), since we need to move on to the next level of bits in the binary representation, otherwise, we continue with the next number in the array. \\nOnce we have iterated over all the nums, we return pows as the answer, because no number in an array can be expressed as a combination of previous powers of two, making it the smallest non-zero positive integer that cannot be expressed from nums, as we were asked in the task description.\\n\\n```\\nclass Solution:\\n    def minImpossibleOR(self, nums: List[int]) -> int:\\n        pows = 2 ** 0\\n        \\n        for num in sorted(nums):\\n            if num == pows:\\n                pows *= 2\\n                \\n        return pows\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minImpossibleOR(self, nums: List[int]) -> int:\\n        pows = 2 ** 0\\n        \\n        for num in sorted(nums):\\n            if num == pows:\\n                pows *= 2\\n                \\n        return pows\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203408,
                "title": "python3-answer-is-pow-of-2-explained",
                "content": "# Explanation\\n\\nEach number `n` can be created from powers of `2`.\\nExample:\\n`n=15` is binary: `bin(15)=\\'0b1111\\'`\\nWe can create it as: `1+2+4+8 = 15`\\nOr we can use binary operation `OR`: `1|2|4|8 = 15`\\nbecause `OR` is preserving ones.\\n\\nIf we have available numbers `1, 2, 4, ..., 2**n`, we can create all numbers `k <= 2**(n+1)`. But we can\\'t create `2**(n+1)`.\\n\\nWe can\\'t create digit `1` if only zeros are available.\\nWe can get digit zero only if all used numbers have zero on that possition, whete we need to have zero.\\nFor example:\\nIf we have numbers: `1, 2, 4, 8, 17`, we are still not able to create number `16`, since `bin(16)=\\'0b10000\\'` and we are not able to \"delete\" the digit `1` from `17`, `bin(17)=\\'0b10001\\'`\\n\\nWe are looking for the smallest power of 2.\\n\\n# Code\\n```\\nclass Solution:\\n    def minImpossibleOR(self, nums: List[int]) -> int:\\n        s=set(nums)\\n        x=1\\n        while x in s:\\n            x*=2\\n        return x    \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minImpossibleOR(self, nums: List[int]) -> int:\\n        s=set(nums)\\n        x=1\\n        while x in s:\\n            x*=2\\n        return x    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203396,
                "title": "java",
                "content": "we can use a set for better time complexity, or sort the input like below\\n```\\nclass Solution {\\n    public int minImpossibleOR(int[] nums) {\\n        Arrays.sort(nums);\\n        int base = 1, n = nums.length, i = 0;\\n        while(i<n){\\n            if(nums[i]>base)\\n                return base;          \\n            if(base==nums[i])\\n                base*=2;\\n            i++;\\n        }\\n        return base;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minImpossibleOR(int[] nums) {\\n        Arrays.sort(nums);\\n        int base = 1, n = nums.length, i = 0;\\n        while(i<n){\\n            if(nums[i]>base)\\n                return base;          \\n            if(base==nums[i])\\n                base*=2;\\n            i++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3203366,
                "title": "javascript-o-n-time-o-1-space",
                "content": "How to figure out that we only want powers of 2\\n- The only way to make a power of 2 is if it exists in nums\\n- We can make any other number with all the powers of 2 below it.\\n\\nI didn\\'t realize that logic at first, but if it doesn\\'t come immediately, the easy thing to do is try the first several numbers.\\n- you can only make 1 if you have it in nums\\n- same with 2\\n- we need 1 and 2 to make 3, so if we can\\'t make 3 we already couldn\\'t make 1 or 2\\n- need 4 exactly\\n- 5 needs 4 and 1\\n- etc.. if we can\\'t form a number, how did we form the powers of 2 below it?\\n\\nJust use a bitmask to store all the powers of 2 from nums, then run through it to find the first missing number.\\n\\nThe max bits we\\'ll use is 29 since 10 ** 9 is < 1 << 30\\n```javascript\\nvar minImpossibleOR = function(nums) {\\n  const mask = nums.reduce((mask, num) => num & (num - 1) ? mask : mask | 1 << Math.log2(num), 0);\\n  for (let bit = 0; bit < 32; bit += 1) {\\n    if (mask & 1 << bit) continue;\\n    return 1 << bit;\\n  }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Bit Manipulation"
                ],
                "code": "```javascript\\nvar minImpossibleOR = function(nums) {\\n  const mask = nums.reduce((mask, num) => num & (num - 1) ? mask : mask | 1 << Math.log2(num), 0);\\n  for (let bit = 0; bit < 32; bit += 1) {\\n    if (mask & 1 << bit) continue;\\n    return 1 << bit;\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3203340,
                "title": "python3-bit-operation",
                "content": "\\n```\\nclass Solution:\\n    def minImpossibleOR(self, nums: List[int]) -> int:\\n        mask = 0\\n        for x in nums: \\n            if x & x-1 == 0: mask |= x \\n        for i in range(32): \\n            if not mask & 1<<i: return 1 << i \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minImpossibleOR(self, nums: List[int]) -> int:\\n        mask = 0\\n        for x in nums: \\n            if x & x-1 == 0: mask |= x \\n        for i in range(32): \\n            if not mask & 1<<i: return 1 << i \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203283,
                "title": "c-lowest-missing-power-of-2-62ms-46-6mb",
                "content": "This problem is apparently daunting, given the specs, since we cannot tests via BF if every number if obtanaible or not.\\n\\nBut we can play smart and figure out something:\\n* any element in the form `1` followed by any amount (including no one) of `0`s can\\'t be obtained mixing numbers, so it has to be present there on its own;\\n* if `1` followed by `x` `0`s can be obtained and so were the othere combinations for smaller values of `x` (ie: if for example `1000` was obtainable and we verified before that so were `10`, `100` and `100`), then also every other number in that range can be obtained and thus we need to go and search for the next higher bit followed by `x + 1` `0`s;\\n* in other words, since `1` followed by any amount of `0`s are our \"primes\" here (number we cannot obtain otherwise with smaller numbers) and we know that each number in such a format is a power of `2`, we might jut wish to end up looking for the smallest power of `2` which was not initially provided.\\n\\nThe last sub-problem to solve is how to do so efficiently, but that is easily done, if we use the hashset `s` to quickly check if a given number `i` multiple of `2` was provided or not.\\n\\nGiven the range offered to us, we will always get at least a valid answer, but in order to placate the compiler, we will put a `return -1` at the end of the loop that we will never terminate without finding a valid solution before.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```cpp\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        // support variables\\n        unordered_set<int> s(begin(nums), end(nums));\\n        // finding the first power of 2 not covered\\n        for (int i = 1; i < INT_MAX; i *= 2) if (s.find(i) == end(s)) return i;\\n        return -1;\\n    }\\n};\\n```\\n\\nBut, wait a moment! Why would be bother putting each single value of `n` in `s`, when all that we care about (and check) are just powers of `2`?\\n\\nAnd since there is a super-cheap way of testing if a given number `n` is a power of `2` ([logic explaind here](https://leetcode.com/problems/power-of-two/solutions/3203226/)), we can limit our more constly insertions, presize the hashset to be at most `29` elemments (but we will never have all of them anyway) and insert only the power of `2` actually present in `nums`.\\n\\nThe updated code runs much faster (62 vs. 140ms of best time) and used way less memory (46.6 vs. 67MB).\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(log(n))$$\\n\\n# Code\\n```cpp\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        // support variables\\n        unordered_set<int> s;\\n        s.reserve(29);\\n        for (int n: nums) if (!(n & (n - 1))) s.insert(n);\\n        // finding the first power of 2 not covered\\n        for (int i = 1; i < INT_MAX; i *= 2) if (s.find(i) == end(s)) return i;\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        // support variables\\n        unordered_set<int> s(begin(nums), end(nums));\\n        // finding the first power of 2 not covered\\n        for (int i = 1; i < INT_MAX; i *= 2) if (s.find(i) == end(s)) return i;\\n        return -1;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        // support variables\\n        unordered_set<int> s;\\n        s.reserve(29);\\n        for (int n: nums) if (!(n & (n - 1))) s.insert(n);\\n        // finding the first power of 2 not covered\\n        for (int i = 1; i < INT_MAX; i *= 2) if (s.find(i) == end(s)) return i;\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203267,
                "title": "c-direct-check",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe answer is the lowest binary of `1b, 10b, 100b, 1000b, ...` which is *not* in `nums`\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDirect check\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MinImpossibleOR(int[] nums) {\\n        for (int i = 0; i < 32; ++i) {\\n            int value = 1 << i;\\n\\n            if (!nums.Contains(value))\\n                return value;    \\n        }\\n\\n        return -1;    \\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinImpossibleOR(int[] nums) {\\n        for (int i = 0; i < 32; ++i) {\\n            int value = 1 << i;\\n\\n            if (!nums.Contains(value))\\n                return value;    \\n        }\\n\\n        return -1;    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203133,
                "title": "o-n-time-o-1-space",
                "content": "```ruby\\ndef min_impossible_or a\\n    s = Set.new\\n    a.each { | x | s << x if (x & (x - 1)) == 0 }\\n    (0..30).each do\\n        x = 1 << _1\\n        return x if !(s === x)\\n    end\\nend\\n```\\n```ruby\\ndef min_impossible_or a\\n    m = a.reduce 0 do | m, x |\\n        (x & (x - 1)) == 0 ? m | x : m\\n    end\\n    (0..30).each do\\n        x = 1 << _1\\n        return x if (m & x) == 0\\n    end\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\ndef min_impossible_or a\\n    s = Set.new\\n    a.each { | x | s << x if (x & (x - 1)) == 0 }\\n    (0..30).each do\\n        x = 1 << _1\\n        return x if !(s === x)\\n    end\\nend\\n```\n```ruby\\ndef min_impossible_or a\\n    m = a.reduce 0 do | m, x |\\n        (x & (x - 1)) == 0 ? m | x : m\\n    end\\n    (0..30).each do\\n        x = 1 << _1\\n        return x if (m & x) == 0\\n    end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3203123,
                "title": "simple-c-solution",
                "content": "# Complexity\\n- Time complexity: O(n*32)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        vector<int> v(32, 0);\\n        unordered_set<int>s;\\n        for(auto x: nums){\\n            s.insert(x);\\n            for(int i=0;i<32;i++){\\n                if(v[i]) continue;\\n                else if(x&(1<<i)) v[i]=1;\\n            }\\n        }\\n        int ans=-1, index;\\n        for(int i=0;i<32;i++){\\n            if(v[i]==0){\\n                index=i;\\n                break;\\n            }\\n        }\\n        for(int i=0;i<=index;i++){\\n            if(s.find(pow(2, i))==s.end()){\\n                ans=pow(2, i);\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n#if You Like My Answer Please Do Upvote This!\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        vector<int> v(32, 0);\\n        unordered_set<int>s;\\n        for(auto x: nums){\\n            s.insert(x);\\n            for(int i=0;i<32;i++){\\n                if(v[i]) continue;\\n                else if(x&(1<<i)) v[i]=1;\\n            }\\n        }\\n        int ans=-1, index;\\n        for(int i=0;i<32;i++){\\n            if(v[i]==0){\\n                index=i;\\n                break;\\n            }\\n        }\\n        for(int i=0;i<=index;i++){\\n            if(s.find(pow(2, i))==s.end()){\\n                ans=pow(2, i);\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n#if You Like My Answer Please Do Upvote This!\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203116,
                "title": "kotlin-lambda-solution-100-with-easy-proof",
                "content": "We want to find the first pow of `2` that do not exist in the array.\\n\\nThe proof is this:\\n1. assume you have `1,2,4,...` \\n2. with them, you can make any of `1-7`.\\n3. but to make `8`, you need precisely `8`, and with the previous `1-7` and `8`, you can make any number `1-15`\\n\\n\\n```\\nclass Solution {\\n  fun minImpossibleOR(nums: IntArray): Int {\\n    val pow2s = nums.filter {\\n      it and (it - 1) == 0\\n    }.toSet()\\n    return 1 shl (0..31).first {\\n      (1 shl it) !in pow2s\\n    }\\n  }\\n}\\n```\\n\\nCan you write shorter lambda?\\n",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n  fun minImpossibleOR(nums: IntArray): Int {\\n    val pow2s = nums.filter {\\n      it and (it - 1) == 0\\n    }.toSet()\\n    return 1 shl (0..31).first {\\n      (1 shl it) !in pow2s\\n    }\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203032,
                "title": "python-short-solution",
                "content": "```\\ndef minImpossibleOR(self, nums: List[int]) -> int:\\n\\tx, nums = 1, set(nums)\\n\\twhile(x in nums):\\n\\t\\tx <<= 1\\n\\treturn x\\n```",
                "solutionTags": [],
                "code": "```\\ndef minImpossibleOR(self, nums: List[int]) -> int:\\n\\tx, nums = 1, set(nums)\\n\\twhile(x in nums):\\n\\t\\tx <<= 1\\n\\treturn x\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3203026,
                "title": "easy-faster-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        int n=nums.size();\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<n;i++){\\n            mp[nums[i]]++;\\n        }\\n        for(int i=1;i<INT_MAX;i=i*2){\\n            if(mp.find(i)==mp.end()){\\n                return i;\\n                \\n            }\\n        }\\n        return 0;\\n       \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        int n=nums.size();\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<n;i++){\\n            mp[nums[i]]++;\\n        }\\n        for(int i=1;i<INT_MAX;i=i*2){\\n            if(mp.find(i)==mp.end()){\\n                return i;\\n                \\n            }\\n        }\\n        return 0;\\n       \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203019,
                "title": "one-liner-with-accumulate-and-ctz",
                "content": "Minimum non-expressible value cannot be composed of multiple bits, because that would mean its constituents are expressible, so they could be or-ed to the composite value, which leads to contradiction. Hence, we are looking for the smallest non-expressible power of two.\\n\\n```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        return 1 << __builtin_ctz(~accumulate(begin(nums), end(nums), 0, [](int a, int b) { return a | ((b&(b-1)) == 0 ? b : 0); }));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        return 1 << __builtin_ctz(~accumulate(begin(nums), end(nums), 0, [](int a, int b) { return a | ((b&(b-1)) == 0 ? b : 0); }));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203012,
                "title": "c-2-line",
                "content": "# Code\\n```\\nint minImpossibleOR(vector<int>& v) {\\n    unordered_set<int> st(begin(v), end(v));\\n    for(int i=1;;i*=2) if(!st.count(i)) return i;\\n}\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nint minImpossibleOR(vector<int>& v) {\\n    unordered_set<int> st(begin(v), end(v));\\n    for(int i=1;;i*=2) if(!st.count(i)) return i;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3202973,
                "title": "swift-one-liner",
                "content": "**One-Liner, terse (accepted answer)**\\n```\\nclass Solution {\\n    func minImpossibleOR(_ nums: [Int]) -> Int {\\n        Set((1..<31).reduce(into: [1]) {$0 += [1<<$1]}).subtracting(nums).min()!\\n    }\\n}\\n```\\n\\n---\\n\\n**One-Liner, expanded and annotated (accepted answer)**\\n```\\nclass Solution {\\n    func minImpossibleOR(_ nums: [Int]) -> Int {\\n        Set( // <-- set of 31 integers each with only one bit set, representing all 31 lowest bits.  \\n\\t\\t\\t(0 ..< 31).reduce(into: [Int]()) { bitArray, bitPosition in\\n\\t\\t\\t\\tbitArray.append(1 << bitPosition)\\n\\t\\t\\t}\\n\\t\\t)  \\n\\t\\t.subtracting(nums)  // remove all `num` elements with one bit set from `bitSet`\\n\\t\\t.min()! // return the lowest remaining element in `bitSet`\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func minImpossibleOR(_ nums: [Int]) -> Int {\\n        Set((1..<31).reduce(into: [1]) {$0 += [1<<$1]}).subtracting(nums).min()!\\n    }\\n}\\n```\n```\\nclass Solution {\\n    func minImpossibleOR(_ nums: [Int]) -> Int {\\n        Set( // <-- set of 31 integers each with only one bit set, representing all 31 lowest bits.  \\n\\t\\t\\t(0 ..< 31).reduce(into: [Int]()) { bitArray, bitPosition in\\n\\t\\t\\t\\tbitArray.append(1 << bitPosition)\\n\\t\\t\\t}\\n\\t\\t)  \\n\\t\\t.subtracting(nums)  // remove all `num` elements with one bit set from `bitSet`\\n\\t\\t.min()! // return the lowest remaining element in `bitSet`\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3202949,
                "title": "intuition-explained-smallest-power-of-2-not-present",
                "content": "# Intuition\\n- We have to return the smallest power of 2 which is not present in nums\\n- For ex- If we have  elements 1, 2, 4, 8, ....... 2^n as present and 2^(n+1) as absent\\n- Then we can easily form numbers 1,2,3,4,5,6.........,2^(n+1)-1 by adding present numbers\\n- So we return 2^(n+1) as answer\\n\\n---\\n\\n# Complexity\\n- Time complexity: $$O(logn)$$ \\n\\n- Space complexity: $$O(n)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        unordered_map<int,int> present;\\n        \\n        for(auto it : nums)\\n        {\\n            present[it]++;\\n        }\\n        int n = 1;\\n        while(true)\\n        {\\n            if(!present[n]) //if element is not present, simply return it\\n              return n;\\n            else\\n             n *= 2; //otherwise, search for next power of 2 which is absent\\n        }\\n//we will never reach here, so return any integer (It does\\'nt matter)\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        unordered_map<int,int> present;\\n        \\n        for(auto it : nums)\\n        {\\n            present[it]++;\\n        }\\n        int n = 1;\\n        while(true)\\n        {\\n            if(!present[n]) //if element is not present, simply return it\\n              return n;\\n            else\\n             n *= 2; //otherwise, search for next power of 2 which is absent\\n        }\\n//we will never reach here, so return any integer (It does\\'nt matter)\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3202947,
                "title": "easiest-short-best-solution-in-c",
                "content": "# Code\\n### **Please Upvote if u liked my Solution**\\uD83E\\uDD17\\n```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        unordered_set<int> st(nums.begin(),nums.end());\\n        int x=1;\\n        while(1){\\n            if(st.find(x)==st.end())\\n                return x;\\n            x*=2;\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        unordered_set<int> st(nums.begin(),nums.end());\\n        int x=1;\\n        while(1){\\n            if(st.find(x)==st.end())\\n                return x;\\n            x*=2;\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3202942,
                "title": "c-solution-bit-hashmap",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        int ans=0;\\n        map<int,int>m;\\n        for(auto it:nums) m[it]++;\\n        for(int i=0; i<32; i++){\\n            if(m[(1<<i)]){\\n                continue;\\n            }\\n            else return (1<<i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        int ans=0;\\n        map<int,int>m;\\n        for(auto it:nums) m[it]++;\\n        for(int i=0; i<32; i++){\\n            if(m[(1<<i)]){\\n                continue;\\n            }\\n            else return (1<<i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3202880,
                "title": "lowest-power-of-2-w-explanation-runtime",
                "content": "## **Please upvote/favourite/comment if you like this solution!**\\n\\n# Intuition\\n<!-- Describe your approach to solving the problem. -->\\nThis problem has two key observations:\\n1. Given a list of powers of two from $$2^0$$, $$2^1$$, $$\\\\dots$$, $$2^{(a-1)}$$, every number from 1 to $$2^a-1$$ can be expressed\\n2. No power of two can be expressed from the bitwise OR of two other numbers \\n\\nThere are no two numbers that can bitwise OR to produce an power of two (other than 0 and the power of two itself). Every power of two when expressed in base-2 has a single 1 in a particular bit. Every non-power of two will have more 1\\'s in its base-2 representation which will be included in a bitwise OR. Therefore, we know that the smallest power of two not in `nums` will be impossible to create. \\n\\nSuppose `x` is the smallest power of two not in `nums`. Is there a number smaller than `x` that is impossible to be produced? **NO!** By our assumption that `x` is the smallest power of two not in `nums`, this means we have every other power of two smaller than `x` which means we can produce every number from `1` to `x-1`.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThis problem reduces to finding the smallest power of two that is not in `nums`.\\n\\n# Code\\n```\\nclass Solution:\\n    def minImpossibleOR(self, nums: List[int]) -> int:\\n        nums_set = set(nums)\\n        power_of_two = 1\\n        while power_of_two in nums_set:\\n            power_of_two *= 2\\n        return power_of_two\\n```\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def minImpossibleOR(self, nums: List[int]) -> int:\\n        nums_set = set(nums)\\n        power_of_two = 1\\n        while power_of_two in nums_set:\\n            power_of_two *= 2\\n        return power_of_two\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3202794,
                "title": "a-different-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        set<int> s(nums.begin(), nums.end());\\n        vector<int> v;\\n        v.assign(s.begin(), s.end());\\n        int n = v.size(), OR = v[0];\\n        if(OR != 1){\\n            return 1;\\n        }\\n        v.push_back(INT_MAX);\\n        for (int i = 0; i + 1 < n; i++)\\n        {\\n            OR |= v[i];\\n            if(v[i + 1] - OR > 1){\\n                return OR + 1;\\n            }\\n        }\\n        return (OR | v[n - 1]) + 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        set<int> s(nums.begin(), nums.end());\\n        vector<int> v;\\n        v.assign(s.begin(), s.end());\\n        int n = v.size(), OR = v[0];\\n        if(OR != 1){\\n            return 1;\\n        }\\n        v.push_back(INT_MAX);\\n        for (int i = 0; i + 1 < n; i++)\\n        {\\n            OR |= v[i];\\n            if(v[i + 1] - OR > 1){\\n                return OR + 1;\\n            }\\n        }\\n        return (OR | v[n - 1]) + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3202779,
                "title": "java-set-solution",
                "content": "```\\nclass Solution {\\n    public int minImpossibleOR(int[] nums) {\\n        Set<Integer> set = new HashSet<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            set.add(nums[i]);\\n        }\\n        for (int i = 0; i < 32; i++) {\\n            int value = (int) Math.pow(2, i);\\n            if (!set.contains(value)) {\\n                return value;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minImpossibleOR(int[] nums) {\\n        Set<Integer> set = new HashSet<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            set.add(nums[i]);\\n        }\\n        for (int i = 0; i < 32; i++) {\\n            int value = (int) Math.pow(2, i);\\n            if (!set.contains(value)) {\\n                return value;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3202731,
                "title": "python-simple-maths",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minImpossibleOR(self, nums):\\n        for i in range(32):\\n            if 1<<i not in nums:\\n                return 1<<i\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minImpossibleOR(self, nums):\\n        for i in range(32):\\n            if 1<<i not in nums:\\n                return 1<<i\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3202701,
                "title": "c-observation-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int power=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==pow(2,power)){\\n                power++;\\n            }\\n        }\\n        return pow(2,power);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int power=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==pow(2,power)){\\n                power++;\\n            }\\n        }\\n        return pow(2,power);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3202679,
                "title": "easy-to-understand-conscise-and-efficient",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        map<int,int> mp;int i=2;\\n        for(auto i:nums) mp[i]++;\\n        if(mp.find(1)==mp.end()) return 1;\\n        while(1){\\n            if(mp.find(i)==mp.end()) return i;\\n            i*=2;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        map<int,int> mp;int i=2;\\n        for(auto i:nums) mp[i]++;\\n        if(mp.find(1)==mp.end()) return 1;\\n        while(1){\\n            if(mp.find(i)==mp.end()) return i;\\n            i*=2;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3202677,
                "title": "c-solution-without-using-extra-space-simple-easy-to-understand-and-self-explanatory-solution",
                "content": "# Intuition\\nCatch: All we need to do is check if 2\\'s power is present in the array or not.\\n\\n# Approach\\nLogic behind the catch:\\nFor example,\\n5 (101) is only possible if we have 100 + 1, that is 4 & 1 present\\n6 (110) is only possible if we have 100 + 10, that is 4 & 2 present\\nWe can see that, the number is possible if all 2\\'s power lower to it present then its possible.\\n\\nIn other word only 2\\'s power are not possible to form unless it is present in the array.\\nSo we look for the smallest 2\\'s power that is not present in the array, ans return it as answer.\\n\\n# Complexity\\n- Time complexity:\\nO(NlogN)\\n\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int n = 1;\\n        for(int i = 0; i < nums.size(); ++i){\\n            if(nums[i] > n) return n;\\n            if(nums[i] == n) { \\n                n = n*2; \\n            }\\n        }\\n        return n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int n = 1;\\n        for(int i = 0; i < nums.size(); ++i){\\n            if(nums[i] > n) return n;\\n            if(nums[i] == n) { \\n                n = n*2; \\n            }\\n        }\\n        return n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3202665,
                "title": "java-bit-manipulation-without-map-or-set",
                "content": "```\\n    public int minImpossibleOR(int[] nums) {\\n        int found = 0, num = 1;\\n\\n        for(int n : nums){\\n            if((n & (n-1)) == 0) {\\n                found |= n;\\n            }\\n        }\\n\\n        for(int i = 0; i < 30; i++){\\n            if((found & 1) == 0) break;\\n\\n            found >>= 1;\\n            num <<= 1;\\n        }\\n        \\n        return num;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\n    public int minImpossibleOR(int[] nums) {\\n        int found = 0, num = 1;\\n\\n        for(int n : nums){\\n            if((n & (n-1)) == 0) {\\n                found |= n;\\n            }\\n        }\\n\\n        for(int i = 0; i < 30; i++){\\n            if((found & 1) == 0) break;\\n\\n            found >>= 1;\\n            num <<= 1;\\n        }\\n        \\n        return num;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3202635,
                "title": "constant-time-power-of-2-solution-beats-100",
                "content": "![image.png](https://assets.leetcode.com/users/images/c0cc86e8-df43-4ec0-9e1b-3f6511a2285d_1676743949.5034077.png)\\n\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minImpossibleOR(self, nums: List[int]) -> int:\\n        st = set(nums)\\n        i = 1\\n        while i in st:\\n            i = i<<1\\n        return i\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minImpossibleOR(self, nums: List[int]) -> int:\\n        st = set(nums)\\n        i = 1\\n        while i in st:\\n            i = i<<1\\n        return i\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3202632,
                "title": "best-and-easier-c-easy",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        int k=0;\\n        map<int,int> mp;\\n        for(auto i: nums)\\n            mp[i]++;\\n        \\n        for(;k<32;k++)\\n        {\\n            if(mp.find(pow(2,k))==mp.end())\\n            {\\n                return pow(2,k);\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        int k=0;\\n        map<int,int> mp;\\n        for(auto i: nums)\\n            mp[i]++;\\n        \\n        for(;k<32;k++)\\n        {\\n            if(mp.find(pow(2,k))==mp.end())\\n            {\\n                return pow(2,k);\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3202596,
                "title": "easy-c-solution",
                "content": "# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        unordered_set<int> m(nums.begin(),nums.end());\\n        for(int i=0; i<=32; i++){\\n            long long int a = (1<<i);\\n            if(m.find(a) == m.end()){\\n                return a;\\n            }\\n        }\\n    return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        unordered_set<int> m(nums.begin(),nums.end());\\n        for(int i=0; i<=32; i++){\\n            long long int a = (1<<i);\\n            if(m.find(a) == m.end()){\\n                return a;\\n            }\\n        }\\n    return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3202509,
                "title": "simple-c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        unordered_map <int,int> ump;\\n        for(auto &it:nums)\\n            ump[it]++;\\n        int i = 1;\\n        while(ump[i]>0)\\n            i *= 2;\\n        return i;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Math",
                    "Bit Manipulation",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        unordered_map <int,int> ump;\\n        for(auto &it:nums)\\n            ump[it]++;\\n        int i = 1;\\n        while(ump[i]>0)\\n            i *= 2;\\n        return i;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3202498,
                "title": "easy-understanding-code-c-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nif power of 2 will be present then numbers get formed from them.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nchecking power of 2 only.\\nfirst which is not present in it will be the answer.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n     map<int,bool> mp;\\n     int Mx=1e9+1;\\n     \\n    int minImpossibleOR(vector<int>& nums) {\\n        int n=nums.size();\\n        \\n        for(int i=0;i<n;i++){\\n            mp[nums[i]]=true;\\n        }\\n        int k=1;\\n        while(mp[k] && k<Mx){\\n            k*=2;\\n        }\\n        \\n        if(!mp[k]) return k;\\n        \\n        return Mx-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     map<int,bool> mp;\\n     int Mx=1e9+1;\\n     \\n    int minImpossibleOR(vector<int>& nums) {\\n        int n=nums.size();\\n        \\n        for(int i=0;i<n;i++){\\n            mp[nums[i]]=true;\\n        }\\n        int k=1;\\n        while(mp[k] && k<Mx){\\n            k*=2;\\n        }\\n        \\n        if(!mp[k]) return k;\\n        \\n        return Mx-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3202480,
                "title": "4-lines-easiest-cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        long long m=1;\\n        set<long long>st;\\n        for(auto &it:nums){\\n            st.insert(it);\\n        }\\n        while(st.find(m)!=st.end()){\\n            m=m*2;\\n        }\\n        return m;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        long long m=1;\\n        set<long long>st;\\n        for(auto &it:nums){\\n            st.insert(it);\\n        }\\n        while(st.find(m)!=st.end()){\\n            m=m*2;\\n        }\\n        return m;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3202394,
                "title": "easy-to-understand-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwhat can be the possible answer?????\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIf we closely look at the pattern then we can find out that the answers can only be of power of 2 i.e\\nanswer = {1, 2, 4, 8, 16, 32, 64, .......}\\n\\nWe can store the values of nums in a set.\\nAfter that we can iterate over the answer and check whether the answer is present in the set or not. \\n\\nIf answer is not present in the set, then simply return the answer\\nelse increment the answer by multiplication of 2.\\n\\nSee the code for easy implementation.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        set<int>s;\\n        for(int i=0; i<nums.size(); i++){\\n            s.insert(nums[i]);\\n        }\\n        \\n        int ans=1;\\n        while(ans<INT_MAX){\\n            if(s.find(ans)==s.end()) return ans;\\n            else ans=ans*2;\\n        }\\n        return INT_MAX;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        set<int>s;\\n        for(int i=0; i<nums.size(); i++){\\n            s.insert(nums[i]);\\n        }\\n        \\n        int ans=1;\\n        while(ans<INT_MAX){\\n            if(s.find(ans)==s.end()) return ans;\\n            else ans=ans*2;\\n        }\\n        return INT_MAX;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1807128,
                "content": [
                    {
                        "username": "dmitryartux",
                        "content": "Some numbers are impossible to build using the other numbers with `or` operator. Think about them"
                    },
                    {
                        "username": "LordAlgorithms",
                        "content": "Thank you so much! This is a valuable hint!"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "my dumbass was reading subsequence as subarray \\uD83D\\uDE2D\\uD83D\\uDE2D, changed the whole perspective."
                    },
                    {
                        "username": "batsy01",
                        "content": "mee tooo bro"
                    },
                    {
                        "username": "missionG",
                        "content": "My observations:\n1.   x1 | x2 | x3 .... >= min(x1, x2, x3 ....)\n2.   x1 | x2 | x3 .... <= x1 + x2 + x3 + ....\n\nNot able to understand further, can someone give a tip?"
                    },
                    {
                        "username": "samyak1409",
                        "content": "The way you thought is right, and is the 1 way everyone else must have thought, but it doesn't help here, the other way to think is binary.\nRepresent the numbers in binary (but why would this come in mind? because the op we're talking about here is bitwise) and try to make 1 to n (where n is the ans, i.e., min num that can't be made) from any nums, and you'll notice something."
                    }
                ]
            },
            {
                "id": 1805646,
                "content": [
                    {
                        "username": "dmitryartux",
                        "content": "Some numbers are impossible to build using the other numbers with `or` operator. Think about them"
                    },
                    {
                        "username": "LordAlgorithms",
                        "content": "Thank you so much! This is a valuable hint!"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "my dumbass was reading subsequence as subarray \\uD83D\\uDE2D\\uD83D\\uDE2D, changed the whole perspective."
                    },
                    {
                        "username": "batsy01",
                        "content": "mee tooo bro"
                    },
                    {
                        "username": "missionG",
                        "content": "My observations:\n1.   x1 | x2 | x3 .... >= min(x1, x2, x3 ....)\n2.   x1 | x2 | x3 .... <= x1 + x2 + x3 + ....\n\nNot able to understand further, can someone give a tip?"
                    },
                    {
                        "username": "samyak1409",
                        "content": "The way you thought is right, and is the 1 way everyone else must have thought, but it doesn't help here, the other way to think is binary.\nRepresent the numbers in binary (but why would this come in mind? because the op we're talking about here is bitwise) and try to make 1 to n (where n is the ans, i.e., min num that can't be made) from any nums, and you'll notice something."
                    }
                ]
            },
            {
                "id": 1806675,
                "content": [
                    {
                        "username": "dmitryartux",
                        "content": "Some numbers are impossible to build using the other numbers with `or` operator. Think about them"
                    },
                    {
                        "username": "LordAlgorithms",
                        "content": "Thank you so much! This is a valuable hint!"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "my dumbass was reading subsequence as subarray \\uD83D\\uDE2D\\uD83D\\uDE2D, changed the whole perspective."
                    },
                    {
                        "username": "batsy01",
                        "content": "mee tooo bro"
                    },
                    {
                        "username": "missionG",
                        "content": "My observations:\n1.   x1 | x2 | x3 .... >= min(x1, x2, x3 ....)\n2.   x1 | x2 | x3 .... <= x1 + x2 + x3 + ....\n\nNot able to understand further, can someone give a tip?"
                    },
                    {
                        "username": "samyak1409",
                        "content": "The way you thought is right, and is the 1 way everyone else must have thought, but it doesn't help here, the other way to think is binary.\nRepresent the numbers in binary (but why would this come in mind? because the op we're talking about here is bitwise) and try to make 1 to n (where n is the ans, i.e., min num that can't be made) from any nums, and you'll notice something."
                    }
                ]
            }
        ]
    }
]