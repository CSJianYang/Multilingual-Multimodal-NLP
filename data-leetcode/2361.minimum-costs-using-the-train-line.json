[
    {
        "title": "Root Equals Sum of Children",
        "question_content": "You are given the root of a binary tree that consists of exactly 3 nodes: the root, its left child, and its right child.\nReturn true if the value of the root is equal to the sum of the values of its two children, or false otherwise.\n&nbsp;\nExample 1:\n\nInput: root = [10,4,6]\nOutput: true\nExplanation: The values of the root, its left child, and its right child are 10, 4, and 6, respectively.\n10 is equal to 4 + 6, so we return true.\n\nExample 2:\n\nInput: root = [5,3,1]\nOutput: false\nExplanation: The values of the root, its left child, and its right child are 5, 3, and 1, respectively.\n5 is not equal to 3 + 1, so we return false.\n\n&nbsp;\nConstraints:\n\n\tThe tree consists only of the root, its left child, and its right child.\n\t-100 <= Node.val <= 100",
        "solutions": [
            {
                "id": 2775146,
                "title": "java-easy-1-liner-o-1-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n       return root.val == root.right.val + root.left.val; \\n    }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n       return root.val == root.right.val + root.left.val; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1977620,
                "title": "java-c-python-1line-o-n-time-beats-99-97-memory-speed-0ms-april-2022",
                "content": "**As a professional with a passion for problem-solving and collaboration, I am always looking to expand my network of like-minded individuals on LinkedIn. By connecting with me, we can work together to tackle complex challenges, share ideas, and grow both professionally and personally.**\\n\\n**Whether you\\'re an expert in your field or just starting out, I welcome connections from all backgrounds and experiences. By building a diverse and collaborative network, we can leverage our unique perspectives and skill sets to push the boundaries of what\\'s possible.**\\n\\n**So, if you\\'re interested in connecting and exploring the potential for future collaborations, please don\\'t hesitate to reach out. Let\\'s start a conversation and see where it takes us!**\\n\\n---\\n\\nhttps://www.linkedin.com/in/cucerdariancatalin/\\nhttps://www.linkedin.com/in/cucerdariancatalin/\\nhttps://www.linkedin.com/in/cucerdariancatalin/\\n\\n---\\n***Java***\\n```\\nclass Solution\\n{\\n    public boolean checkTree(TreeNode root)\\n\\t{\\n        return root.val == root.left.val + root.right.val;  // O(1)\\n    }\\n}\\n```\\n\\n***C++***\\n```\\nclass Solution\\n{\\npublic:\\n    bool checkTree(TreeNode* root)\\n\\t{\\n       if((root->left->val)+(root->right->val)==root->val) return true;\\n        return false;\\n    }\\n};\\n```\\n\\n***Python***\\n```\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val == (root.left.val + root.right.val)\\n```\\n\\n***Consider upvote if useful!***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution\\n{\\n    public boolean checkTree(TreeNode root)\\n\\t{\\n        return root.val == root.left.val + root.right.val;  // O(1)\\n    }\\n}\\n```\n```\\nclass Solution\\n{\\npublic:\\n    bool checkTree(TreeNode* root)\\n\\t{\\n       if((root->left->val)+(root->right->val)==root->val) return true;\\n        return false;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val == (root.left.val + root.right.val)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1934995,
                "title": "python-one-liner",
                "content": "```\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val == (root.left.val + root.right.val)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val == (root.left.val + root.right.val)",
                "codeTag": "Java"
            },
            {
                "id": 2180137,
                "title": "python-easy-solution-with-explanation",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        # As per the def of binary tree node, we can compare the root value \\\\\\n        # with the TreeNode function, the root.left.val retrieves value of left node \\\\\\n        # the root.right.val retrieves value of right node. \\'==\\' compares two values\\n        if root.val == root.left.val + root.right.val:  \\n            return True\\n        else:\\n            return False\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        # As per the def of binary tree node, we can compare the root value \\\\\\n        # with the TreeNode function, the root.left.val retrieves value of left node \\\\\\n        # the root.right.val retrieves value of right node. \\'==\\' compares two values\\n        if root.val == root.left.val + root.right.val:  \\n            return True\\n        else:\\n            return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3053858,
                "title": "javascript-solution-o-1-one-liner-81ms-basic-comparison-maths-examples",
                "content": "***Happy Coding..!* Feel free to ask Q\\'s...**\\n\\n```\\n/**\\n * @param {TreeNode} root\\n * @return {boolean}\\n */\\n\\nconst checkTree = root => root.val === (root.left.val + root.right.val);\\n\\n```\\n\\n// Tree Node\\nfunction TreeNode(val, left, right) {\\n    this.val = (val === undefined ? 0 : val)\\n    this.left = (left === undefined ? null : left)\\n    this.right = (right === undefined ? null : right)\\n}\\n\\n// Test Case 1\\n// root = [10, 4, 6]\\nlet tNode1 = new TreeNode(10);\\nlet tNode2 = new TreeNode(4);\\nlet tNode3 = new TreeNode(6);\\n\\ntNode1.left = tNode2;\\ntNode1.right = tNode3;\\n\\nlet root = tNode1;\\nconsole.log(checkTree(root)); // true\\n\\n\\n***#happytohelpu***\\n\\n# ***Do upvote if you find this solution useful..***\\n",
                "solutionTags": [
                    "JavaScript",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * @param {TreeNode} root\\n * @return {boolean}\\n */\\n\\nconst checkTree = root => root.val === (root.left.val + root.right.val);\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3130162,
                "title": "easy-to-understand-for-beginners-python-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nDirect Tree approach ATTACKKKKKKKKK\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val==root.left.val + root.right.val\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val==root.left.val + root.right.val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2058305,
                "title": "c-easy-sol",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        if(root->left->val+root->right->val==root->val){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        if(root->left->val+root->right->val==root->val){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1961431,
                "title": "hardest-binary-tree-problem-hard",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return root->val == (root->left->val+root->right->val);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return root->val == (root->left->val+root->right->val);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1937186,
                "title": "javascript-one-liner",
                "content": "Let me know if you have any doubts. I try to answer/help.\\n\\nPlease upvote if you liked the solution.\\n\\n```\\nvar checkTree = function(root) {\\n    return root.val === root.left.val + root.right.val;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar checkTree = function(root) {\\n    return root.val === root.left.val + root.right.val;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1939586,
                "title": "cpp-one-liner-beats-100",
                "content": "Since we are guaranteed by the contstraints that ```root``` has a right and a left child all that we need to do is just check if the sum of the children values is equal to the value of the root.\\n```cpp\\nbool checkTree(TreeNode* root) {\\n   return root->val == root->left->val + root->right->val;    \\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```root```\n```cpp\\nbool checkTree(TreeNode* root) {\\n   return root->val == root->left->val + root->right->val;    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3519510,
                "title": "my-checktree",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity\\n- Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {boolean}\\n */\\nvar checkTree = function(root) {\\n    return root.val === root.left.val + root.right.val;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {boolean}\\n */\\nvar checkTree = function(root) {\\n    return root.val === root.left.val + root.right.val;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3524372,
                "title": "python-one-line-solution-easy",
                "content": "```\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val==root.left.val+root.right.val\\n```\\n**An upvote will be encouraging**\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val==root.left.val+root.right.val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2795902,
                "title": "python-one-liner-easy-to-understand",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val == root.left.val + root.right.val\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val == root.left.val + root.right.val\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2546066,
                "title": "javascript-easy-to-understand-one-line-solution",
                "content": "```/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {boolean}\\n */\\nvar checkTree = function(root) {\\n    return root.val == root.left.val + root.right.val;\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {boolean}\\n */\\nvar checkTree = function(root) {\\n    return root.val == root.left.val + root.right.val;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 3731720,
                "title": "i-ask-why-u-are-seeing-this",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nLOL U Still opened this ......\\n# Code\\n```\\nNOTHING HERE BRO - SORRY !\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "Tree"
                ],
                "code": "```\\nNOTHING HERE BRO - SORRY !\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3011338,
                "title": "using-single-line-expression-body",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public bool CheckTree(TreeNode root) => root.val == root.left.val + root.right.val;\\n    \\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public bool CheckTree(TreeNode root) => root.val == root.left.val + root.right.val;\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2695970,
                "title": "python-simple-solution-in-4-lines",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        if root.val == (root.left.val + root.right.val):\\n            return True\\n        else:\\n            return False\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        if root.val == (root.left.val + root.right.val):\\n            return True\\n        else:\\n            return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2602756,
                "title": "c-generic-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n      queue<TreeNode*>q;\\n      q.push(root);\\n      while(!q.empty()){\\n          int size = q.size();\\n          for(int i=0;i<size;i++){\\n          TreeNode* curr = q.front();\\n          q.pop();\\n          int parentValue = curr->val;\\n          int childValue = 0;\\n          int child = 0;\\n          if(curr->left){\\n              q.push(curr->left);\\n              childValue+=curr->left->val;\\n          }else{\\n              child++;\\n          }\\n          if(curr->right){\\n          q.push(curr->right);\\n          childValue+=curr->right->val;\\n          }else{\\n              child++;\\n          }\\n          if(child==2) continue;\\n          if(parentValue != childValue) return false;\\n          }\\n      }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n      queue<TreeNode*>q;\\n      q.push(root);\\n      while(!q.empty()){\\n          int size = q.size();\\n          for(int i=0;i<size;i++){\\n          TreeNode* curr = q.front();\\n          q.pop();\\n          int parentValue = curr->val;\\n          int childValue = 0;\\n          int child = 0;\\n          if(curr->left){\\n              q.push(curr->left);\\n              childValue+=curr->left->val;\\n          }else{\\n              child++;\\n          }\\n          if(curr->right){\\n          q.push(curr->right);\\n          childValue+=curr->right->val;\\n          }else{\\n              child++;\\n          }\\n          if(child==2) continue;\\n          if(parentValue != childValue) return false;\\n          }\\n      }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2178260,
                "title": "python-oneliner",
                "content": "```\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.left.val+root.right.val == root.val\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.left.val+root.right.val == root.val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1935634,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    pub fn check_tree(root: Option<Rc<RefCell<TreeNode>>>) -> bool {\\n        let root_node = root.as_ref().unwrap().borrow();\\n        let left_node = root_node.left.as_ref().unwrap().borrow();\\n        let right_node = root_node.right.as_ref().unwrap().borrow();\\n\\n        root_node.val == left_node.val + right_node.val\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn check_tree(root: Option<Rc<RefCell<TreeNode>>>) -> bool {\\n        let root_node = root.as_ref().unwrap().borrow();\\n        let left_node = root_node.left.as_ref().unwrap().borrow();\\n        let right_node = root_node.right.as_ref().unwrap().borrow();\\n\\n        root_node.val == left_node.val + right_node.val\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2973035,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     struct TreeNode *left;\\n *     struct TreeNode *right;\\n * };\\n */\\nbool checkTree(struct TreeNode* root){\\n    if(root->val == ((root->left->val) + (root->right->val))){\\n        return true;\\n    }else {\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     struct TreeNode *left;\\n *     struct TreeNode *right;\\n * };\\n */\\nbool checkTree(struct TreeNode* root){\\n    if(root->val == ((root->left->val) + (root->right->val))){\\n        return true;\\n    }else {\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2945899,
                "title": "c-one-line-code-super-easy",
                "content": "![image](https://assets.leetcode.com/users/images/be24e3a1-f1ff-4926-b2f1-9e892f9e7992_1671888672.6683366.png)\\n\\n**TC->O(1) && SC->O(1)**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool checkTree(TreeNode* root) {\\n\\t\\t\\treturn root->val==root->left->val+root->right->val;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tbool checkTree(TreeNode* root) {\\n\\t\\t\\treturn root->val==root->left->val+root->right->val;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2683146,
                "title": "python-one-liner-easy-to-understand",
                "content": "\\tclass Solution:\\n\\t\\tdef checkTree(self, root: Optional[TreeNode]) -> bool:\\n\\t\\t\\treturn root.val == (root.left.val + root.right.val)",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef checkTree(self, root: Optional[TreeNode]) -> bool:\\n\\t\\t\\treturn root.val == (root.left.val + root.right.val)",
                "codeTag": "Java"
            },
            {
                "id": 2603021,
                "title": "rust-0-ms-simple-solution-with-detailed-comments",
                "content": "This [**solution**](https://leetcode.com/submissions/detail/804824674/) employs simple operations with smart pointers. It demonstrated **0 ms runtime (100.00%)** and used **2.1 MB memory (67.14%)**. Detailed comments are provided.\\n\\n**IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n```\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution \\n{\\n    pub fn check_tree(root: Option<Rc<RefCell<TreeNode>>>) -> bool \\n    {\\n        // unfortunately, in Rust the use of smart pointers\\n        // is challenging due to security issues;\\n        // also, an Option requires unwrapping...\\n        \\n        // [1] unpack smart pointer and borrow TreeNode\\n        let root_node = root.as_ref().unwrap().borrow();\\n\\n        // [2] unpack left & right smart pointers and borrow their TreeNodes\\n        let left_node = root_node.left.as_ref().unwrap().borrow();\\n        let right_node = root_node.right.as_ref().unwrap().borrow();\\n\\n        root_node.val == left_node.val + right_node.val\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution \\n{\\n    pub fn check_tree(root: Option<Rc<RefCell<TreeNode>>>) -> bool \\n    {\\n        // unfortunately, in Rust the use of smart pointers\\n        // is challenging due to security issues;\\n        // also, an Option requires unwrapping...\\n        \\n        // [1] unpack smart pointer and borrow TreeNode\\n        let root_node = root.as_ref().unwrap().borrow();\\n\\n        // [2] unpack left & right smart pointers and borrow their TreeNodes\\n        let left_node = root_node.left.as_ref().unwrap().borrow();\\n        let right_node = root_node.right.as_ref().unwrap().borrow();\\n\\n        root_node.val == left_node.val + right_node.val\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2581688,
                "title": "rust-solution-with-pattern-matching",
                "content": "```rust\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn check_tree(root: Option<Rc<RefCell<TreeNode>>>) -> bool {\\n        // type(root): Option<...>, use pattern matching to handle this\\n        match root {\\n            Some(root) =>  {\\n                // what happend when we use root.borrow() ?\\n                //    1. In rust, all smart pointers(like Rc<T> here) implement Deref trait.\\n                //    2. Deref coersion, a feature provided by rust. It will convert automatically\\n                //       for us:\\n                //           a reference to a type that implements Deref \\n                //       ->  a reference to a type that Deref can convert the original type into. \\n                //    3. The borrow() method accepts a &self paramater. However, the type of root is Rc<RefCell<TreeNode>>>.\\n                //    4. We can imagine the conversion here:\\n                //           Rc<RefCell<TreeNode>> -> &RefCell<TreeNode> -> &TreeNode\\n                //                               get reference         borrows the wrapped value.\\n                let root_node = root.borrow();\\n                // type(root_node.left/right) = Option<Rc<RefCell<TreeNode>>>\\n                // , which means we need to call .unwrap() method\\n                // why use .as_ref() here ?\\n                //     because we need to take care of the ownship\\'s problem :)\\n                let left_child = root_node.left.as_ref().unwrap().borrow();\\n                let right_child = root_node.right.as_ref().unwrap().borrow();\\n                root_node.val == left_child.val + right_child.val\\n            }\\n            // a empty root is ok\\n            None => true,\\n        }\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn check_tree(root: Option<Rc<RefCell<TreeNode>>>) -> bool {\\n        // type(root): Option<...>, use pattern matching to handle this\\n        match root {\\n            Some(root) =>  {\\n                // what happend when we use root.borrow() ?\\n                //    1. In rust, all smart pointers(like Rc<T> here) implement Deref trait.\\n                //    2. Deref coersion, a feature provided by rust. It will convert automatically\\n                //       for us:\\n                //           a reference to a type that implements Deref \\n                //       ->  a reference to a type that Deref can convert the original type into. \\n                //    3. The borrow() method accepts a &self paramater. However, the type of root is Rc<RefCell<TreeNode>>>.\\n                //    4. We can imagine the conversion here:\\n                //           Rc<RefCell<TreeNode>> -> &RefCell<TreeNode> -> &TreeNode\\n                //                               get reference         borrows the wrapped value.\\n                let root_node = root.borrow();\\n                // type(root_node.left/right) = Option<Rc<RefCell<TreeNode>>>\\n                // , which means we need to call .unwrap() method\\n                // why use .as_ref() here ?\\n                //     because we need to take care of the ownship\\'s problem :)\\n                let left_child = root_node.left.as_ref().unwrap().borrow();\\n                let right_child = root_node.right.as_ref().unwrap().borrow();\\n                root_node.val == left_child.val + right_child.val\\n            }\\n            // a empty root is ok\\n            None => true,\\n        }\\n\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2426866,
                "title": "with-explanation-comments-time-0-ms-100-space-12-6-mb-66-2",
                "content": "**Like it? ->Upvote please!**\\n\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        \\n        //check if the left & the right values equals the main root value\\n        return root->val == root->left->val + root->right->val;\\n    }\\n};\\n\\'\\'\\'\\n\\n**Like it? ->Upvote please!**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        \\n        //check if the left & the right values equals the main root value\\n        return root->val == root->left->val + root->right->val;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2239768,
                "title": "swift-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public var val: Int\\n *     public var left: TreeNode?\\n *     public var right: TreeNode?\\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n *         self.val = val\\n *         self.left = left\\n *         self.right = right\\n *     }\\n * }\\n */\\nclass Solution {\\n    func checkTree(_ root: TreeNode?) -> Bool {\\n                guard let root = root, let leftVal = root.left?.val, let rightVal = root.right?.val else { return false }\\n        return root.val == leftVal + rightVal\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public var val: Int\\n *     public var left: TreeNode?\\n *     public var right: TreeNode?\\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n *         self.val = val\\n *         self.left = left\\n *         self.right = right\\n *     }\\n * }\\n */\\nclass Solution {\\n    func checkTree(_ root: TreeNode?) -> Bool {\\n                guard let root = root, let leftVal = root.left?.val, let rightVal = root.right?.val else { return false }\\n        return root.val == leftVal + rightVal\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2096471,
                "title": "beginner-friendly-solutoin-one-line-solution",
                "content": "**Time Complexity : O(1)**\\njava\\n```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.val == root.left.val + root.right.val;\\n    }\\n}\\n```\\njavascript\\n```\\nvar checkTree = function(root) {\\n    return root.val == root.left.val + root.right.val\\n};\\n```\\npython\\n```\\nclass Solution(object):\\n    def checkTree(self, root):\\n        return root.val == root.left.val + root.right.val\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.val == root.left.val + root.right.val;\\n    }\\n}\\n```\n```\\nvar checkTree = function(root) {\\n    return root.val == root.left.val + root.right.val\\n};\\n```\n```\\nclass Solution(object):\\n    def checkTree(self, root):\\n        return root.val == root.left.val + root.right.val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2054085,
                "title": "c-one-liner",
                "content": "```\\npublic class Solution \\n{\\n    public bool CheckTree(TreeNode root) => root.val == root.left.val+root.right.val;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "C#"
                ],
                "code": "```\\npublic class Solution \\n{\\n    public bool CheckTree(TreeNode root) => root.val == root.left.val+root.right.val;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1953001,
                "title": "java-o-1-one-line-solution",
                "content": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.val == root.left.val + root.right.val;  // O(1)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.val == root.left.val + root.right.val;  // O(1)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1937707,
                "title": "one-liner-javascript-solution",
                "content": "Found this solution helpful? Consider showing support by upvoting this post.\\nHave a question? Kindly leave a comment below.\\nThank you and happy hacking!\\n```\\nconst checkTree = root => {\\n    return root.val === root.left.val + root.right.val \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst checkTree = root => {\\n    return root.val === root.left.val + root.right.val \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3448027,
                "title": "easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        if(root.val==root.right.val+root.left.val):\\n            return(True)\\n        return(False)\\n```",
                "solutionTags": [
                    "Python3",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        if(root.val==root.right.val+root.left.val):\\n            return(True)\\n        return(False)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3360082,
                "title": "easy-to-understand-c-solution-beats-100-of-other-solutions",
                "content": "Please upvote if you like it.\\n```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        if (root -> val == (root -> left -> val + root -> right -> val)){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        if (root -> val == (root -> left -> val + root -> right -> val)){\\n            return true;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3215805,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        if(root==NULL)\\n        return false;\\n        if(root->left->val+root->right->val==root->val)\\n        return true;\\n        else\\n        return false;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val == (root.left.val + root.right.val)\\n```\\n\\n```Java []\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.left.val + root.right.val == root.val ? true : false; \\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        if(root==NULL)\\n        return false;\\n        if(root->left->val+root->right->val==root->val)\\n        return true;\\n        else\\n        return false;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val == (root.left.val + root.right.val)\\n```\n```Java []\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.left.val + root.right.val == root.val ? true : false; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2761196,
                "title": "python-easy-solution",
                "content": "**Please upvote if you like my solution. Let me know in the comments if you have any suggestions to increase performance or readability.**\\n```\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        if root.val == root.left.val + root.right.val:\\n            return True\\n        else:\\n            return False\\n```\\n\\n**Happy coding!**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        if root.val == root.left.val + root.right.val:\\n            return True\\n        else:\\n            return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2671683,
                "title": "c-java-python-one-line-code-faster-than-100",
                "content": "C++ : \\n-------------------------------------------------------------------\\n```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        if(root->left->val + root->right->val == root->val){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```\\n\\n\\nJAVA : \\n--------------------------------------------------------------------\\n```\\nclass Solution\\n{\\n    public boolean checkTree(TreeNode root)\\n\\t{\\n        return root.val == root.left.val + root.right.val;  // O(1)\\n    }\\n}\\n```\\n\\n\\nPYTHON :\\n--------------------------------------------------------------------\\n```\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val == (root.left.val + root.right.val)\\n```\\n\\n\\nplz upvote; happy coding :)",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        if(root->left->val + root->right->val == root->val){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```\n```\\nclass Solution\\n{\\n    public boolean checkTree(TreeNode root)\\n\\t{\\n        return root.val == root.left.val + root.right.val;  // O(1)\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val == (root.left.val + root.right.val)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2663173,
                "title": "java-solution-one-line-code",
                "content": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) { \\n        return (root.val == root.left.val + root.right.val);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) { \\n        return (root.val == root.left.val + root.right.val);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2254854,
                "title": "one-line-js",
                "content": "```\\nconst checkTree =  (root) => root.val === root.right.val + root.left.val\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst checkTree =  (root) => root.val === root.right.val + root.left.val\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2246142,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val ==(root.left.val +root.right.val)\\n```",
                "solutionTags": [
                    "Python",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val ==(root.left.val +root.right.val)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2219867,
                "title": "kotlin-resolve-o-1-space",
                "content": "It is known from the condition that the binary tree consists of exactly 3 nodes. Therefore, there is no need to specify Nullable in the root: TreeNode argument. The final solution without using secure calls will take the following form:\\n```\\nclass Solution {\\n        fun checkTree(root: TreeNode) = root.`val` == root.left.`val` + root.right.`val`\\n    }\\n\\t",
                "solutionTags": [],
                "code": "class Solution {\\n        fun checkTree(root: TreeNode) = root.`val` == root.left.`val` + root.right.`val`\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3196201,
                "title": "java-easy-sol-0ms-beats-100-one-liner",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.left.val + root.right.val == root.val ? true : false; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.left.val + root.right.val == root.val ? true : false; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3196200,
                "title": "beats-100-easy",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return root->left->val+root->right->val==root->val ? true : false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return root->left->val+root->right->val==root->val ? true : false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3074170,
                "title": "java-applicable-to-all-trees-for-beginners-o-1",
                "content": "Can be used for all Trees\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\n\\n// Applicable to all Trees\\nclass Solution \\n{\\n    int num = 0;\\n\\n    public boolean checkTree(TreeNode root) \\n    {\\n        inorder(root);\\n\\n        //subtract the root val and cmp them\\n        if((num - root.val) == root.val)\\n            return true;\\n\\n        return false;\\n    }\\n\\n    //recursive function\\n    public void inorder(TreeNode node)\\n    {\\n        //if reach the end\\n        if (node == null)\\n            return;\\n \\n        //recuring on the left child\\n        inorder(node.left);\\n \\n        //add all the values\\n        num += node.val;\\n \\n        //then recuring on the right child\\n        inorder(node.right);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\n\\n// Applicable to all Trees\\nclass Solution \\n{\\n    int num = 0;\\n\\n    public boolean checkTree(TreeNode root) \\n    {\\n        inorder(root);\\n\\n        //subtract the root val and cmp them\\n        if((num - root.val) == root.val)\\n            return true;\\n\\n        return false;\\n    }\\n\\n    //recursive function\\n    public void inorder(TreeNode node)\\n    {\\n        //if reach the end\\n        if (node == null)\\n            return;\\n \\n        //recuring on the left child\\n        inorder(node.left);\\n \\n        //add all the values\\n        num += node.val;\\n \\n        //then recuring on the right child\\n        inorder(node.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2925093,
                "title": "98-faster-solution-easy-to-understand",
                "content": "![Screenshot 2022-12-18 at 16.02.43.png](https://assets.leetcode.com/users/images/f4d30438-82c5-495e-9d39-e54807f78a6b_1671361444.7605064.png)\\n\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val==root.left.val+root.right.val\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val==root.left.val+root.right.val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2895960,
                "title": "c-easiest-way-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        \\n        TreeNode* l = root->left;\\n        TreeNode* r = root->right;\\n\\n        return root->val == l->val + r->val;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        \\n        TreeNode* l = root->left;\\n        TreeNode* r = root->right;\\n\\n        return root->val == l->val + r->val;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2827085,
                "title": "java-one-line-code",
                "content": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.val==root.left.val+root.right.val;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.val==root.left.val+root.right.val;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2792297,
                "title": "c-one-line-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n     return (root->val==(root->left->val + root->right->val));  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n     return (root->val==(root->left->val + root->right->val));  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2766329,
                "title": "one-line-solution",
                "content": "```\\ndef checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val==(root.left.val+root.right.val)\\n```",
                "solutionTags": [
                    "Python",
                    "Tree"
                ],
                "code": "```\\ndef checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val==(root.left.val+root.right.val)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2761009,
                "title": "c-1-line-approach-o-1-time-complexity",
                "content": "bool checkTree(TreeNode* root) {\\n       \\n        if(root->val == (root->left->val + root->right->val))return true;\\n        else return false;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "bool checkTree(TreeNode* root) {\\n       \\n        if(root->val == (root->left->val + root->right->val))return true;\\n        else return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2755142,
                "title": "python-simple-python-solution",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 58 ms, faster than 50.14% of Python3 online submissions for Root Equals Sum of Children.\\n# Memory Usage: 13.8 MB, less than 94.99% of Python3 online submissions for Root Equals Sum of Children.\\n\\n\\tclass Solution:\\n\\t\\tdef checkTree(self, root: Optional[TreeNode]) -> bool:\\n\\n\\t\\t\\tif root != None:\\n\\n\\t\\t\\t\\tif root.val == root.left.val + root.right.val:\\n\\t\\t\\t\\t\\treturn True\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\treturn False\\n\\t\\t\\telse:\\n\\t\\t\\t\\treturn False\\n\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 58 ms, faster than 50.14% of Python3 online submissions for Root Equals Sum of Children.\\n# Memory Usage: 13.8 MB, less than 94.99% of Python3 online submissions for Root Equals Sum of Children.\\n\\n\\tclass Solution:\\n\\t\\tdef checkTree(self, root: Optional[TreeNode]) -> bool:\\n\\n\\t\\t\\tif root != None:\\n\\n\\t\\t\\t\\tif root.val == root.left.val + root.right.val:\\n\\t\\t\\t\\t\\treturn True\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\treturn False\\n\\t\\t\\telse:\\n\\t\\t\\t\\treturn False\\n\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "codeTag": "Java"
            },
            {
                "id": 2744279,
                "title": "c-easy-short",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        if(root->left->val + root->right->val == root->val){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        if(root->left->val + root->right->val == root->val){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2509473,
                "title": "three-different-solutions-for-beginner-s",
                "content": "##### **Solution : 1**\\n```\\n    def checkTree(self, root):\\n        if root.val == root.left.val + root.right.val:\\n            return True\\n        return False\\n```\\n\\n##### **Solution : 2**\\n```\\n    def checkTree(self, root):\\n        return (root.val == root.left.val + root.right.val)\\n```\\n\\n##### **Solution : 3**\\n```\\n    def checkTree(self, root):\\n        total = root.left.val + root.right.val\\n        return total == root.val\\n```\\n\\nLiked it? Please **UpVote**",
                "solutionTags": [],
                "code": "```\\n    def checkTree(self, root):\\n        if root.val == root.left.val + root.right.val:\\n            return True\\n        return False\\n```\n```\\n    def checkTree(self, root):\\n        return (root.val == root.left.val + root.right.val)\\n```\n```\\n    def checkTree(self, root):\\n        total = root.left.val + root.right.val\\n        return total == root.val\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2506582,
                "title": "python-one-line-code-tree",
                "content": "```\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val == root.left.val + root.right.val\\n```",
                "solutionTags": [
                    "Python",
                    "Tree"
                ],
                "code": "```\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val == root.left.val + root.right.val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2499960,
                "title": "java-solution-one-line-of-code-1ms-runtime-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return (root.left.val + root.right.val) == root.val;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return (root.left.val + root.right.val) == root.val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2403440,
                "title": "java-one-liner",
                "content": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.val == root.left.val + root.right.val;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.val == root.left.val + root.right.val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2393335,
                "title": "safest-1-line-kotlin-solution-all-edge-cases-covered",
                "content": "```class Solution {\\n    fun checkTree(root: TreeNode?): Boolean {\\n        return if((root?.`val` ?: 0) == (root?.right?.`val` ?: 0) + (root?.left?.`val` ?: 0)) true else false\\n    }\\n}",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "class Solution {\\n    fun checkTree(root: TreeNode?): Boolean {\\n        return if((root?.`val` ?: 0) == (root?.right?.`val` ?: 0) + (root?.left?.`val` ?: 0)) true else false\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2262869,
                "title": "c-simple-oneline-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return (root->val == root->left->val + root->right->val);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return (root->val == root->left->val + root->right->val);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2098710,
                "title": "c-one-line-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return root->val==root->right->val+root->left->val?1:0;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return root->val==root->right->val+root->left->val?1:0;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2005563,
                "title": "python-solution",
                "content": "**Upvote** if you like solution and feel **free to ask** If you have any question.\\n```\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        if root.val == (root.left.val + root.right.val):\\n            return True\\n        else:\\n            return False\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        if root.val == (root.left.val + root.right.val):\\n            return True\\n        else:\\n            return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1978941,
                "title": "haven-t-seen-this-much-simple-question",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        if(root->left->val+root->right->val==root->val) \\n            return true; \\n        return false;\\n    }\\n}; // please upvote if it helps you!\\n```",
                "solutionTags": [
                    "C++",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        if(root->left->val+root->right->val==root->val) \\n            return true; \\n        return false;\\n    }\\n}; // please upvote if it helps you!\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4004701,
                "title": "0ms-beats-100-00-of-users-with-c-1-line-code",
                "content": "# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return root->left->val+root->right->val==root->val;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return root->left->val+root->right->val==root->val;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3985693,
                "title": "c-1-line-code-tc-o-n",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nAs they have informed tree has only 3 nodes , so its easy to access them . left + right == root ?\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        if(root->left->val + root->right->val == root->val) return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        if(root->left->val + root->right->val == root->val) return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3984030,
                "title": "easy-one-liner-solution-in-c",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return (root->left->val + root->right->val == root->val);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return (root->left->val + root->right->val == root->val);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3783934,
                "title": "fix-documentation-before",
                "content": "# Fix documentation\\nProperties of TreeNode were not type hinted, after fixing this, solution is easy!\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * class TreeNode {\\n *     public $val = null;\\n *     public TreeNode $left = null;\\n *     public TreeNode $right = null;\\n *     function __construct($val = 0, TreeNode $left = null, TreeNode $right = null) {\\n *         $this->val = $val;\\n *         $this->left = $left;\\n *         $this->right = $right;\\n *     }\\n * }\\n */\\nclass Solution {\\n\\n    /**\\n     * @param TreeNode $root\\n     * @return Boolean\\n     */\\n    function checkTree(TreeNode $root) {\\n        return $root->val === ($root->left->val + $root->right->val);\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * class TreeNode {\\n *     public $val = null;\\n *     public TreeNode $left = null;\\n *     public TreeNode $right = null;\\n *     function __construct($val = 0, TreeNode $left = null, TreeNode $right = null) {\\n *         $this->val = $val;\\n *         $this->left = $left;\\n *         $this->right = $right;\\n *     }\\n * }\\n */\\nclass Solution {\\n\\n    /**\\n     * @param TreeNode $root\\n     * @return Boolean\\n     */\\n    function checkTree(TreeNode $root) {\\n        return $root->val === ($root->left->val + $root->right->val);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3735396,
                "title": "easy-3-line-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        if(root->left->val+root->right->val==root->val)\\n        return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        if(root->left->val+root->right->val==root->val)\\n        return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3665571,
                "title": "check-this-out",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public bool CheckTree(TreeNode root) {\\n        bool checkRootValue = root.val == (root.left.val + root.right.val) ? true : false;\\n        return checkRootValue;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public bool CheckTree(TreeNode root) {\\n        bool checkRootValue = root.val == (root.left.val + root.right.val) ? true : false;\\n        return checkRootValue;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3410421,
                "title": "what-if-the-height-of-the-tree-was-more-than-two",
                "content": "\\n\\n**This code will work for the tree with  any number of height.**\\n# Code\\n```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        if(root==null) return true;\\n        if(root.left==null&&root.right==null)\\n        return true;\\n        int sum=0;\\n        if(root.left!=null)\\n         sum+=root.left.val;\\n        \\n        if(root.right!=null) \\n        sum+=root.right.val;\\n       \\n        return (sum==root.val&&checkTree(root.left)&&checkTree(root.right));\\n    }\\n}\\n```\\nplease upvote if you find it helpful.\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        if(root==null) return true;\\n        if(root.left==null&&root.right==null)\\n        return true;\\n        int sum=0;\\n        if(root.left!=null)\\n         sum+=root.left.val;\\n        \\n        if(root.right!=null) \\n        sum+=root.right.val;\\n       \\n        return (sum==root.val&&checkTree(root.left)&&checkTree(root.right));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3364957,
                "title": "c-1-liner",
                "content": "# Complexity\\n- Time complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return (root->val == (root->left->val +root->right->val));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return (root->val == (root->left->val +root->right->val));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3253905,
                "title": "c-super-ez-tree-prob",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public bool CheckTree(TreeNode root) {\\n        if(root == null)\\n            return true;\\n        if(root.left == null && root.right != null)\\n            return (root.val == root.right.val);\\n        else if(root.right == null && root.left != null)\\n            return (root.val == root.left.val);\\n        else\\n            return (root.val == (root.right.val + root.left.val));\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public bool CheckTree(TreeNode root) {\\n        if(root == null)\\n            return true;\\n        if(root.left == null && root.right != null)\\n            return (root.val == root.right.val);\\n        else if(root.right == null && root.left != null)\\n            return (root.val == root.left.val);\\n        else\\n            return (root.val == (root.right.val + root.left.val));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3206666,
                "title": "java-100-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.right.val + root.left.val == root.val;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.right.val + root.left.val == root.val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3200221,
                "title": "java-1-liner-approach-beats-100",
                "content": "# Code\\n```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.left.val + root.right.val == root.val ? true : false;   \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.left.val + root.right.val == root.val ? true : false;   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3169261,
                "title": "js",
                "content": "# Intuition\\nCheck if the sume of the left and right children is equal to the value of the node.\\n\\n# Complexity\\n- Time complexity: O(1): performs a constant amount of work\\n\\n- Space complexity: O(1): does not use any additional variables / data structures\\n\\n# Code\\n```\\nconst checkTree = (root) => {\\n    return root.val === (root.left.val) + (root.right.val)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst checkTree = (root) => {\\n    return root.val === (root.left.val) + (root.right.val)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2939455,
                "title": "c-2-liner-easy-solution-beat-98",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        if(root==NULL)\\n        return 0;\\n        if(root->val==(root->right->val + root->left->val))\\n        return true;\\n        return false;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        if(root==NULL)\\n        return 0;\\n        if(root->val==(root->right->val + root->left->val))\\n        return true;\\n        return false;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2854093,
                "title": "pattern-matching",
                "content": "# Intuition\\nBeing passed in a struct was a little weird compared to the example passing in a list. \\n\\n# Approach\\nPattern match the different inputs to return false with the last pattern doing the summation. Might not be the most efficient but it does work.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n#\\n# defmodule TreeNode do\\n#   @type t :: %__MODULE__{\\n#           val: integer,\\n#           left: TreeNode.t() | nil,\\n#           right: TreeNode.t() | nil\\n#         }\\n#   defstruct val: 0, left: nil, right: nil\\n# end\\n\\ndefmodule Solution do\\n  @spec check_tree(root :: TreeNode.t | nil) :: boolean\\n  def check_tree(nil), do: false\\n  def check_tree(%TreeNode{left: nil}), do: false\\n  def check_tree(%TreeNode{right: nil}), do: false\\n  def check_tree(%TreeNode{val: total, left: left, right: right}) do\\n    left.val + right.val == total\\n  end\\nend\\n```",
                "solutionTags": [
                    "Elixir"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n#\\n# defmodule TreeNode do\\n#   @type t :: %__MODULE__{\\n#           val: integer,\\n#           left: TreeNode.t() | nil,\\n#           right: TreeNode.t() | nil\\n#         }\\n#   defstruct val: 0, left: nil, right: nil\\n# end\\n\\ndefmodule Solution do\\n  @spec check_tree(root :: TreeNode.t | nil) :: boolean\\n  def check_tree(nil), do: false\\n  def check_tree(%TreeNode{left: nil}), do: false\\n  def check_tree(%TreeNode{right: nil}), do: false\\n  def check_tree(%TreeNode{val: total, left: left, right: right}) do\\n    left.val + right.val == total\\n  end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2821687,
                "title": "java-detailed-explanation-o-1-time-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nJava Solution to Root Equals Sum Of Children.\\n\\nDetailed explanation included in code comments.\\n\\n# Complexity\\n- Time complexity: $$O(1)$$ constant time.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$ no additional space is used, only constant needed for the boolean returned by the function.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n\\n    /**\\n     * Checks A Binary Tree Root Node Consisting Of 3 Nodes (Root, Left Child, Right Child)\\n     * To See If Sum Of Children Node Values Equals Root Node Value.\\n     * @param TreeNode - Root node of a binary tree consisting of 3 nodes: root, left, and right children nodes.\\n     * @return boolean - True if sum of children node values equals root node value, false otherwise.\\n     */\\n    public boolean checkTree(TreeNode root) {\\n        // Sum of left and right children nodes of the root node equal root value\\n        if (root.left.val + root.right.val == root.val)\\n        {\\n            return true;\\n        }\\n\\n        // Return false when sum of right and left children nodes values not equal root node value\\n        return false;\\n\\n        // NOTE: Could also solve using one line shown below\\n        // return root.val == root.right.val + root.left.val; \\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n\\n    /**\\n     * Checks A Binary Tree Root Node Consisting Of 3 Nodes (Root, Left Child, Right Child)\\n     * To See If Sum Of Children Node Values Equals Root Node Value.\\n     * @param TreeNode - Root node of a binary tree consisting of 3 nodes: root, left, and right children nodes.\\n     * @return boolean - True if sum of children node values equals root node value, false otherwise.\\n     */\\n    public boolean checkTree(TreeNode root) {\\n        // Sum of left and right children nodes of the root node equal root value\\n        if (root.left.val + root.right.val == root.val)\\n        {\\n            return true;\\n        }\\n\\n        // Return false when sum of right and left children nodes values not equal root node value\\n        return false;\\n\\n        // NOTE: Could also solve using one line shown below\\n        // return root.val == root.right.val + root.left.val; \\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2744869,
                "title": "c-recursive-approach",
                "content": "Here is my c++ code for this problem.\\n\\'\\'\\'\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n \\nclass Solution {\\npublic:\\n\\n    bool checkTree(TreeNode* root) {\\n        if(root==NULL || (root->left==NULL && root->right==NULL)){return true;}\\n        int l, r;\\n        if(root->left!=NULL){l=root->left->val;}else{l=0;}\\n        if(root->right!=NULL){r=root->right->val;}else{r=0;}\\n        if(root->val!=(l+r)){return false;}\\n        return checkTree(root->left) && checkTree(root->right);\\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n\\n    bool checkTree(TreeNode* root) {\\n        if(root==NULL || (root->left==NULL && root->right==NULL)){return true;}",
                "codeTag": "Java"
            },
            {
                "id": 2661568,
                "title": "java-solution-recursive-0ms",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->Auxillary stack space.\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        if(root==null) return true;\\n        if(root.left!=null && root.right!=null)\\n        {\\n        if(root.val==root.left.val+root.right.val)return true;}\\n        checkTree(root.left);\\n        checkTree(root.right);\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        if(root==null) return true;\\n        if(root.left!=null && root.right!=null)\\n        {\\n        if(root.val==root.left.val+root.right.val)return true;}\\n        checkTree(root.left);\\n        checkTree(root.right);\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2641237,
                "title": "c-one-liner",
                "content": "```\\nbool checkTree(TreeNode* root) {\\n        return (root->val == (root->left->val + root->right->val));\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool checkTree(TreeNode* root) {\\n        return (root->val == (root->left->val + root->right->val));\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2637705,
                "title": "java-easy-to-understand-not-one-liner",
                "content": "Runtime - 1ms\\nUsing a \\'temp\\' TreeNode to store \\'root\\'.\\n\\n```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        TreeNode temp = root; //Creating temp TreeNode\\n        int sum=0;\\n        root = root.left; //Traversing to left node\\n        sum = sum + root.val; //Adding left node value\\n        root = temp; //Returning to Root Node\\n        root = root.right;  //Traversing to right node\\n        sum = sum + root.val; //Adding right node value\\n        if(sum == temp.val) return true; //Final condition\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        TreeNode temp = root; //Creating temp TreeNode\\n        int sum=0;\\n        root = root.left; //Traversing to left node\\n        sum = sum + root.val; //Adding left node value\\n        root = temp; //Returning to Root Node\\n        root = root.right;  //Traversing to right node\\n        sum = sum + root.val; //Adding right node value\\n        if(sum == temp.val) return true; //Final condition\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2589206,
                "title": "single-line-code-javascript",
                "content": "```\\nvar checkTree = function(root) {    \\n    return root.val === root.left.val + root.right.val ? true : false;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar checkTree = function(root) {    \\n    return root.val === root.left.val + root.right.val ? true : false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2579229,
                "title": "easy-one-liner-c",
                "content": "# One Line\\n\\n```\\nbool checkTree(TreeNode* root) {\\n        return (root->val) == (root->left)->val + (root->right)->val ? true : false;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool checkTree(TreeNode* root) {\\n        return (root->val) == (root->left)->val + (root->right)->val ? true : false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2552128,
                "title": "1-liner-java-c-very-easy",
                "content": "```\\n// Java Solution\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.val == root.left.val + root.right.val;\\n    }\\n}\\n\\n\\n\\n// C++ Solution\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return root->val == root->left->val + root->right->val;\\n    }\\n};\\n\\n\\n\\n/*\\n\\tif(you like)\\n\\t\\tplease upvote;\\n*/\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\n// Java Solution\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.val == root.left.val + root.right.val;\\n    }\\n}\\n\\n\\n\\n// C++ Solution\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return root->val == root->left->val + root->right->val;\\n    }\\n};\\n\\n\\n\\n/*\\n\\tif(you like)\\n\\t\\tplease upvote;\\n*/\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2506775,
                "title": "simplest-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return (root->val == (root->left->val + root->right->val));    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return (root->val == (root->left->val + root->right->val));    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2492642,
                "title": "java-5-lines-code-100-faster-easy-solution",
                "content": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        int sum = 0;\\n        sum = root.left.val + root.right.val;\\n        if(root.val == sum){\\n            return true;\\n        }\\n        return false;\\n        \\n    }\\n}\\n```\\n**Thanks for visiting :)**",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        int sum = 0;\\n        sum = root.left.val + root.right.val;\\n        if(root.val == sum){\\n            return true;\\n        }\\n        return false;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2462159,
                "title": "python-simple-and-faster-solution",
                "content": "```\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        d=root.val\\n        self.res=0\\n        def dsf(root):\\n            if(root==None):\\n                return \\n            if(root.left==None and root.right==None):\\n                self.res+=root.val\\n            else:\\n                dsf(root.left)\\n                dsf(root.right)\\n        dsf(root)\\n        return self.res==d\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        d=root.val\\n        self.res=0\\n        def dsf(root):\\n            if(root==None):\\n                return \\n            if(root.left==None and root.right==None):\\n                self.res+=root.val\\n            else:\\n                dsf(root.left)\\n                dsf(root.right)\\n        dsf(root)\\n        return self.res==d\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2433136,
                "title": "root-equals-sum-of-children-solution-java",
                "content": "class Solution {\\n  public boolean checkTree(TreeNode root) {\\n    return root.val == root.left.val + root.right.val;\\n  }\\n}\\n",
                "solutionTags": [
                    "Tree",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n  public boolean checkTree(TreeNode root) {\\n    return root.val == root.left.val + root.right.val;\\n  }",
                "codeTag": "Java"
            },
            {
                "id": 2342925,
                "title": "root-equals-sum-of-children",
                "content": "```\\nvar checkTree = function(root) {\\n    // let binary = (root[0] === root[1]+root[2])? true: false\\n    return root.val === root.left.val+root.right.val\\n    //return binary;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar checkTree = function(root) {\\n    // let binary = (root[0] === root[1]+root[2])? true: false\\n    return root.val === root.left.val+root.right.val\\n    //return binary;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2329524,
                "title": "python-100-faster-one-line",
                "content": "return (root.left.val + root.right.val) == root.val",
                "solutionTags": [
                    "Python"
                ],
                "code": "return (root.left.val + root.right.val) == root.val",
                "codeTag": "Unknown"
            },
            {
                "id": 2312637,
                "title": "why-why-why-why-why-why",
                "content": "return (root->val == root->left->val + root->right->val);",
                "solutionTags": [],
                "code": "return (root->val == root->left->val + root->right->val);",
                "codeTag": "Unknown"
            },
            {
                "id": 2276459,
                "title": "c-easiest-solution-10-ms-runtime-very-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        \\n        if(root->left->val + root->right->val==root->val) return true ;\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        \\n        if(root->left->val + root->right->val==root->val) return true ;\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2256250,
                "title": "java",
                "content": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.val == root.left.val+root.right.val;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.val == root.left.val+root.right.val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2227427,
                "title": "simple-c-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public bool CheckTree(TreeNode root) {\\n        return root.left.val + root.right.val == root.val;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public bool CheckTree(TreeNode root) {\\n        return root.left.val + root.right.val == root.val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2196708,
                "title": "easy-one-liner-python-solution",
                "content": "Code: \\n```return root.val == (root.left.val + root.right.val)```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```return root.val == (root.left.val + root.right.val)```",
                "codeTag": "Unknown"
            },
            {
                "id": 2178290,
                "title": "one-line-killer-typescript-javascript",
                "content": "```\\nfunction checkTree(root: TreeNode | null): boolean {\\n    return root.val === root.left.val + root.right.val\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction checkTree(root: TreeNode | null): boolean {\\n    return root.val === root.left.val + root.right.val\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2156990,
                "title": "javascript-easy-solution",
                "content": "```\\nvar checkTree = function(root) {\\n    let value = root.left.val + root.right.val;\\n    value = value === root.val ? true : false;\\n    return value;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar checkTree = function(root) {\\n    let value = root.left.val + root.right.val;\\n    value = value === root.val ? true : false;\\n    return value;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2109950,
                "title": "easy-python-1-liner",
                "content": "```\\ndef checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val == (root.left.val + root.right.val)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val == (root.left.val + root.right.val)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2076045,
                "title": "php",
                "content": "```\\nfunction checkTree($root) {\\n        return $root->val === $root->left->val+$root->right->val;\\n        \\n    }\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nfunction checkTree($root) {\\n        return $root->val === $root->left->val+$root->right->val;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2028580,
                "title": "java-1-liner-short-simple-and-easy-using-shorthand-if-notation",
                "content": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return ((root.left.val)+(root.right.val)==root.val)?true:false; // just used shorthand if notation in java - google it !\\n\\t\\t//root.right - > will get the right node & .val will get its value, similarly for others !\\n    }\\n}\\n```\\n\\n**Perform a dry run for better understanding !\\nHappy Coding !\\nDo upvote if it helped !**",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return ((root.left.val)+(root.right.val)==root.val)?true:false; // just used shorthand if notation in java - google it !\\n\\t\\t//root.right - > will get the right node & .val will get its value, similarly for others !\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2010130,
                "title": "sharing-my-solution-in-11-languages",
                "content": "I cannot comprehend which company would ask this question and for which role ?\\nMaybe as an interviewer myself, if I ask a tree based question to a candidate, and the candidate is completely clueless - I would usually level-down the problem, but never ever to this type of level.\\n\\n@Leetcode please do not post such trivial problems on a site which is supposedly used by people preparing for coding contests/interviews.\\n\\nThis problem is good for Exercise in a textbook which has introductory chapter on Trees.\\n\\nEnough of ranting, let us discuss the solutions .....\\n\\n**C**\\n```\\nbool checkTree(struct TreeNode* root){\\n    return root->val == root->left->val + root->right->val;\\n}\\n```\\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return root->val == root->left->val + root->right->val;\\n    }\\n};\\n```\\n\\n\\n**C#**\\n```\\npublic class Solution {\\n    public bool CheckTree(TreeNode root) {\\n        return root.val == root.left.val + root.right.val;\\n    }\\n}\\n```\\n\\n**Go**\\n```\\nfunc checkTree(root *TreeNode) bool {\\n    return root.Val == root.Left.Val + root.Right.Val;\\n}\\n```\\n\\n\\n**Java**\\n```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.val == root.left.val + root.right.val;\\n    }\\n}\\n```\\n\\n**Javascript**\\n```\\nvar checkTree = function(root) {\\n    return root.val === root.left.val + root.right.val;\\n};\\n```\\n\\n**PHP**\\n```\\nclass Solution {\\n\\n    /**\\n     * @param TreeNode $root\\n     * @return Boolean\\n     */\\n    function checkTree($root) {\\n        return $root->val == $root->left->val + $root->right->val;\\n    }\\n}\\n```\\n\\n**Python**\\n```\\nclass Solution(object):\\n    def checkTree(self, root):\\n        \"\"\"\\n        :type root: Optional[TreeNode]\\n        :rtype: bool\\n        \"\"\"\\n        return root.val == root.left.val + root.right.val\\n```\\n\\n**Python3**\\n```\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val == root.left.val + root.right.val\\n \\n```\\n\\n**Ruby**\\n```\\ndef check_tree(root)\\n    return root.val == root.left.val + root.right.val\\nend\\n```\\n\\n**TypeScript**\\n```\\nfunction checkTree(root: TreeNode | null): boolean {\\n    return root.val == root.left.val + root.right.val;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nbool checkTree(struct TreeNode* root){\\n    return root->val == root->left->val + root->right->val;\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return root->val == root->left->val + root->right->val;\\n    }\\n};\\n```\n```\\npublic class Solution {\\n    public bool CheckTree(TreeNode root) {\\n        return root.val == root.left.val + root.right.val;\\n    }\\n}\\n```\n```\\nfunc checkTree(root *TreeNode) bool {\\n    return root.Val == root.Left.Val + root.Right.Val;\\n}\\n```\n```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.val == root.left.val + root.right.val;\\n    }\\n}\\n```\n```\\nvar checkTree = function(root) {\\n    return root.val === root.left.val + root.right.val;\\n};\\n```\n```\\nclass Solution {\\n\\n    /**\\n     * @param TreeNode $root\\n     * @return Boolean\\n     */\\n    function checkTree($root) {\\n        return $root->val == $root->left->val + $root->right->val;\\n    }\\n}\\n```\n```\\nclass Solution(object):\\n    def checkTree(self, root):\\n        \"\"\"\\n        :type root: Optional[TreeNode]\\n        :rtype: bool\\n        \"\"\"\\n        return root.val == root.left.val + root.right.val\\n```\n```\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val == root.left.val + root.right.val\\n \\n```\n```\\ndef check_tree(root)\\n    return root.val == root.left.val + root.right.val\\nend\\n```\n```\\nfunction checkTree(root: TreeNode | null): boolean {\\n    return root.val == root.left.val + root.right.val;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1952848,
                "title": "hardest-question-needs-sophisticated-solution",
                "content": "```java\\n    public boolean checkTree(TreeNode root) {\\n        return root.val == root.left.val + root.right.val;\\n    }\\n```\\t",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\n    public boolean checkTree(TreeNode root) {\\n        return root.val == root.left.val + root.right.val;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1947025,
                "title": "every-programming-language-c-java-python-c-c-javascript-ruby-swift-go-scala-and-more",
                "content": "If you think this question is too easy, complete it in every programming language offered by LeetCode.\\n\\n**C++**:\\n```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return root->val == root->left->val + root->right->val;\\n    }\\n};\\n```\\n\\n**Java**:\\n```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.val == root.right.val + root.left.val;\\n    }\\n}\\n```\\n\\n**Python**:\\n```\\nclass Solution(object):\\n    def checkTree(self, root):\\n        return root.val == root.right.val + root.left.val\\n```\\n\\n**Python 3**:\\n```\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val == root.right.val + root.left.val\\n```\\n\\n**C**:\\n```\\nbool checkTree(struct TreeNode* root){\\n    return root->val == root->left->val + root->right->val;\\n}\\n```\\n\\n**C#**:\\n```\\npublic class Solution {\\n    public bool CheckTree(TreeNode root) {\\n        return root.val == root.left.val + root.right.val;\\n    }\\n}\\n```\\n\\n**JavaScript**:\\n```\\nvar checkTree = function(root) {\\n    return root.val == root.left.val + root.right.val;\\n};\\n```\\n\\n**Ruby**:\\n```\\ndef check_tree(root)\\n    return root.val == root.left.val + root.right.val\\nend\\n```\\n\\n**Swift**:\\n```\\nclass Solution {\\n    func checkTree(_ root: TreeNode?) -> Bool {\\n        return root!.val == root!.left!.val + root!.right!.val\\n    }\\n}\\n```\\n\\n**Go**:\\n```\\nfunc checkTree(root *TreeNode) bool {\\n    return root.Val == root.Left.Val + root.Right.Val;\\n}\\n```\\n\\n**Scala**:\\n```\\nobject Solution {\\n    def checkTree(root: TreeNode): Boolean = {\\n        return root.value == root.left.value + root.right.value\\n    }\\n}\\n```\\n\\n**Kotlin**:\\n```\\nclass Solution {\\n    fun checkTree(root: TreeNode?): Boolean {\\n        return root!!.`val` == root!!.left!!.`val` + root!!.right!!.`val`\\n    }\\n}\\n```\\n\\n**Rust**:\\n```\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn check_tree(root: Option<Rc<RefCell<TreeNode>>>) -> bool {\\n        let root = root.as_ref().unwrap().borrow();    \\n        return root.val == root.left.as_ref().unwrap().borrow().val + root.right.as_ref().unwrap().borrow().val;\\n    }\\n}\\n```\\n\\n**PHP**:\\n```\\nclass Solution {\\n    function checkTree($root) {\\n        return $root->val == $root->left->val + $root->right->val;\\n    }\\n}\\n```\\n\\n**TypeScript**:\\n```\\nfunction checkTree(root: TreeNode | null): boolean {\\n    return root.val == root.left.val + root.right.val;\\n};\\n```\\n\\n**Racket**:\\n```\\n(define/contract (check-tree root)\\n  (-> (or/c tree-node? #f) boolean?)\\n    (eq? (tree-node-val root) (+ (tree-node-val (tree-node-left root)) (tree-node-val (tree-node-right root))))\\n  )\\n```\\n\\n**Erlang**:\\n```\\n-spec check_tree(Root :: #tree_node{} | null) -> boolean().\\ncheck_tree(Root) ->\\n  Root#tree_node.val == Root#tree_node.left#tree_node.val + Root#tree_node.right#tree_node.val.\\n```\\n\\n**Elixir**:\\n```\\ndefmodule Solution do\\n  @spec check_tree(root :: TreeNode.t | nil) :: boolean\\n  def check_tree(root) do\\n    root.val == root.left.val + root.right.val\\n  end\\nend\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "JavaScript",
                    "Ruby",
                    "Swift",
                    "Scala",
                    "Rust"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return root->val == root->left->val + root->right->val;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.val == root.right.val + root.left.val;\\n    }\\n}\\n```\n```\\nclass Solution(object):\\n    def checkTree(self, root):\\n        return root.val == root.right.val + root.left.val\\n```\n```\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val == root.right.val + root.left.val\\n```\n```\\nbool checkTree(struct TreeNode* root){\\n    return root->val == root->left->val + root->right->val;\\n}\\n```\n```\\npublic class Solution {\\n    public bool CheckTree(TreeNode root) {\\n        return root.val == root.left.val + root.right.val;\\n    }\\n}\\n```\n```\\nvar checkTree = function(root) {\\n    return root.val == root.left.val + root.right.val;\\n};\\n```\n```\\ndef check_tree(root)\\n    return root.val == root.left.val + root.right.val\\nend\\n```\n```\\nclass Solution {\\n    func checkTree(_ root: TreeNode?) -> Bool {\\n        return root!.val == root!.left!.val + root!.right!.val\\n    }\\n}\\n```\n```\\nfunc checkTree(root *TreeNode) bool {\\n    return root.Val == root.Left.Val + root.Right.Val;\\n}\\n```\n```\\nobject Solution {\\n    def checkTree(root: TreeNode): Boolean = {\\n        return root.value == root.left.value + root.right.value\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun checkTree(root: TreeNode?): Boolean {\\n        return root!!.`val` == root!!.left!!.`val` + root!!.right!!.`val`\\n    }\\n}\\n```\n```\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn check_tree(root: Option<Rc<RefCell<TreeNode>>>) -> bool {\\n        let root = root.as_ref().unwrap().borrow();    \\n        return root.val == root.left.as_ref().unwrap().borrow().val + root.right.as_ref().unwrap().borrow().val;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    function checkTree($root) {\\n        return $root->val == $root->left->val + $root->right->val;\\n    }\\n}\\n```\n```\\nfunction checkTree(root: TreeNode | null): boolean {\\n    return root.val == root.left.val + root.right.val;\\n};\\n```\n```\\n(define/contract (check-tree root)\\n  (-> (or/c tree-node? #f) boolean?)\\n    (eq? (tree-node-val root) (+ (tree-node-val (tree-node-left root)) (tree-node-val (tree-node-right root))))\\n  )\\n```\n```\\n-spec check_tree(Root :: #tree_node{} | null) -> boolean().\\ncheck_tree(Root) ->\\n  Root#tree_node.val == Root#tree_node.left#tree_node.val + Root#tree_node.right#tree_node.val.\\n```\n```\\ndefmodule Solution do\\n  @spec check_tree(root :: TreeNode.t | nil) :: boolean\\n  def check_tree(root) do\\n    root.val == root.left.val + root.right.val\\n  end\\nend\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1945881,
                "title": "c-solution",
                "content": "My little solution in C#\\n\\n\\n```\\npublic class Solution {\\n    public bool CheckTree(TreeNode root) {\\n        \\n        int left = root.left.val;\\n        int right= root.right.val;\\n        \\n        return(left+right==root.val);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public bool CheckTree(TreeNode root) {\\n        \\n        int left = root.left.val;\\n        int right= root.right.val;\\n        \\n        return(left+right==root.val);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1944211,
                "title": "javascript-js",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {boolean}\\n */\\nvar checkTree = function (root) {\\n  return root.val === root.left.val + root.right.val;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {boolean}\\n */\\nvar checkTree = function (root) {\\n  return root.val === root.left.val + root.right.val;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1940061,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        if(root->val == root->left->val + root->right->val)\\n            return true; \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        if(root->val == root->left->val + root->right->val)\\n            return true; \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1938760,
                "title": "rust-0ms-pattern-matching",
                "content": "```rust\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\n\\nimpl Solution {\\n    pub fn check_tree(root: Option<Rc<RefCell<TreeNode>>>) -> bool {\\n        match root {\\n            Some(node) => match (node.borrow().left.as_ref(), node.borrow().right.as_ref()) {\\n                (Some(left), Some(right)) => {\\n                    left.borrow().val + right.borrow().val == node.borrow().val\\n                }\\n                _ => true,\\n            },\\n            None => true,\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\n\\nimpl Solution {\\n    pub fn check_tree(root: Option<Rc<RefCell<TreeNode>>>) -> bool {\\n        match root {\\n            Some(node) => match (node.borrow().left.as_ref(), node.borrow().right.as_ref()) {\\n                (Some(left), Some(right)) => {\\n                    left.borrow().val + right.borrow().val == node.borrow().val\\n                }\\n                _ => true,\\n            },\\n            None => true,\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1938094,
                "title": "python-simple-solution",
                "content": "```\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val == root.left.val + root.right.val\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val == root.left.val + root.right.val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1935170,
                "title": "java-recursive-solution",
                "content": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode node) {\\n        if(node.left == null){\\n            return true;\\n        }\\n        if(node.right==null){\\n            return true;\\n        }\\n        checkTree(node.left);\\n        checkTree(node.right);\\n        if(node.val == node.left.val + node.right.val){\\n            return true;\\n            \\n        }\\n        else{\\n            return false;\\n        }\\n        \\n      \\n        \\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode node) {\\n        if(node.left == null){\\n            return true;\\n        }\\n        if(node.right==null){\\n            return true;\\n        }\\n        checkTree(node.left);\\n        checkTree(node.right);\\n        if(node.val == node.left.val + node.right.val){\\n            return true;\\n            \\n        }\\n        else{\\n            return false;\\n        }\\n        \\n      \\n        \\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1934711,
                "title": "don-t-see-the-point-of-this-problem",
                "content": "```\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val == root.left.val+root.right.val\\n```",
                "solutionTags": [],
                "code": "```\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val == root.left.val+root.right.val\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4063581,
                "title": "best-java-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        if(root.val==root.left.val+root.right.val) return true;\\n        else return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        if(root.val==root.left.val+root.right.val) return true;\\n        else return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3964841,
                "title": "100-faster-solution",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        int sum = root->left->val + root->right->val;\\n\\n        return root->val == sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        int sum = root->left->val + root->right->val;\\n\\n        return root->val == sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3877448,
                "title": "2-lines-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n\\n       if(root.val==root.left.val+root.right.val)return true;\\n       return false;\\n        \\n\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n\\n       if(root.val==root.left.val+root.right.val)return true;\\n       return false;\\n        \\n\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3793957,
                "title": "root-equals-sum-of-children",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n![image.png](https://assets.leetcode.com/users/images/d16f0b89-7c41-4ab2-8a87-436262395422_1689877762.281462.png)\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        if root.val==root.left.val+root.right.val:\\n            return True\\n        else:\\n            return False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        if root.val==root.left.val+root.right.val:\\n            return True\\n        else:\\n            return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3757098,
                "title": "clean-and-easy-with-type-hinting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * class TreeNode {\\n *     public $val = null;\\n *     public $left = null;\\n *     public $right = null;\\n *     function __construct($val = 0, $left = null, $right = null) {\\n *         $this->val = $val;\\n *         $this->left = $left;\\n *         $this->right = $right;\\n *     }\\n * }\\n */\\nclass Solution\\n{\\n    function checkTree(TreeNode $root): bool\\n    {\\n        return $root->left->val + $root->right->val === $root->val;\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * class TreeNode {\\n *     public $val = null;\\n *     public $left = null;\\n *     public $right = null;\\n *     function __construct($val = 0, $left = null, $right = null) {\\n *         $this->val = $val;\\n *         $this->left = $left;\\n *         $this->right = $right;\\n *     }\\n * }\\n */\\nclass Solution\\n{\\n    function checkTree(TreeNode $root): bool\\n    {\\n        return $root->left->val + $root->right->val === $root->val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3698924,
                "title": "2-line-sol-beats-100-c",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        if(root->val==(root->left->val+root->right->val)) return true;\\n        else return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        if(root->val==(root->left->val+root->right->val)) return true;\\n        else return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3555807,
                "title": "easy-java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        if(root==null) return true;\\n        if(root.left==null && root.right==null) return true;\\n        int s=0;\\n        if(root.left!=null) s+=root.left.val;\\n        if(root.right!=null) s+=root.right.val;\\n        \\n        return (root.val==s && checkTree(root.left) && checkTree(root.right)) ;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        if(root==null) return true;\\n        if(root.left==null && root.right==null) return true;\\n        int s=0;\\n        if(root.left!=null) s+=root.left.val;\\n        if(root.right!=null) s+=root.right.val;\\n        \\n        return (root.val==s && checkTree(root.left) && checkTree(root.right)) ;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3532202,
                "title": "swift-recursive-solution",
                "content": "Recursive solution:\\n```\\nclass Solution {\\n\\n    func sum(_ root: TreeNode?) -> Int {\\n        guard let root = root else {\\n            return 0\\n        }\\n\\n        return root.val + sum(root.left) + sum(root.right)\\n    }\\n\\n    func checkTree(_ root: TreeNode?) -> Bool {\\n        guard let root = root else {\\n            return false\\n        }\\n\\n        return root.val == sum(root.left) + sum(root.right)\\n    }\\n}\\n```\\n\\nOne liner:\\n\\n```\\nclass Solution {\\n    func checkTree(_ root: TreeNode?) -> Bool {\\n        return (root?.val ?? -1) - (root?.left?.val ?? 0) - (root?.right?.val ?? 0) == 0\\n    }\\n}\\n\\n```\\n\\n",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n\\n    func sum(_ root: TreeNode?) -> Int {\\n        guard let root = root else {\\n            return 0\\n        }\\n\\n        return root.val + sum(root.left) + sum(root.right)\\n    }\\n\\n    func checkTree(_ root: TreeNode?) -> Bool {\\n        guard let root = root else {\\n            return false\\n        }\\n\\n        return root.val == sum(root.left) + sum(root.right)\\n    }\\n}\\n```\n```\\nclass Solution {\\n    func checkTree(_ root: TreeNode?) -> Bool {\\n        return (root?.val ?? -1) - (root?.left?.val ?? 0) - (root?.right?.val ?? 0) == 0\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3505689,
                "title": "easiest-solution-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n\\n        TreeNode node1 =root.left;\\n        TreeNode node2 = root.right;\\n        if(root.val == (node1.val+node2.val)) return true;\\n        return false;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n\\n        TreeNode node1 =root.left;\\n        TreeNode node2 = root.right;\\n        if(root.val == (node1.val+node2.val)) return true;\\n        return false;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3456779,
                "title": "0-ms-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        if(root.val==root.left.val+root.right.val)\\n        {\\n            return true;\\n        }\\n        return false;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        if(root.val==root.left.val+root.right.val)\\n        {\\n            return true;\\n        }\\n        return false;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3355187,
                "title": "java-sol-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        if((root.left.val+root.right.val) == root.val){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        if((root.left.val+root.right.val) == root.val){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3160860,
                "title": "c-and-c-one-line-solution",
                "content": "\\n# C++\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return root->right->val + root->left->val == root->val;\\n        \\n    }\\n    \\n};\\n```\\n\\n# C Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     struct TreeNode *left;\\n *     struct TreeNode *right;\\n * };\\n */\\nbool checkTree(struct TreeNode* root){\\n    return root->right->val + root->left->val == root->val;\\n\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return root->right->val + root->left->val == root->val;\\n        \\n    }\\n    \\n};\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     struct TreeNode *left;\\n *     struct TreeNode *right;\\n * };\\n */\\nbool checkTree(struct TreeNode* root){\\n    return root->right->val + root->left->val == root->val;\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3103175,
                "title": "root-equals-sum-of-children-using-kotlin-best-complexity-o-1",
                "content": "# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n//Author: Mohamed Shaban Ahmed\\n\\n/**\\n * Example:\\n * var ti = TreeNode(5)\\n * var v = ti.`val`\\n * Definition for a binary tree node.\\n * class TreeNode(var `val`: Int) {\\n *     var left: TreeNode? = null\\n *     var right: TreeNode? = null\\n * }\\n */\\nclass Solution {\\n    fun checkTree(root: TreeNode?): Boolean {\\n        return root!!.`val` == (root!!.left!!.`val` + root!!.right!!.`val`)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Binary Tree"
                ],
                "code": "```\\n//Author: Mohamed Shaban Ahmed\\n\\n/**\\n * Example:\\n * var ti = TreeNode(5)\\n * var v = ti.`val`\\n * Definition for a binary tree node.\\n * class TreeNode(var `val`: Int) {\\n *     var left: TreeNode? = null\\n *     var right: TreeNode? = null\\n * }\\n */\\nclass Solution {\\n    fun checkTree(root: TreeNode?): Boolean {\\n        return root!!.`val` == (root!!.left!!.`val` + root!!.right!!.`val`)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3101716,
                "title": "2236-java",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Runtime : 0 ms\\n- Beats : 100%\\n- Memory : 39.6 MB\\n- Beats : 97.64%\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean checkTree(TreeNode r) {\\n        return r.val == r.left.val + r.right.val;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode r) {\\n        return r.val == r.left.val + r.right.val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3075269,
                "title": "dart-null-safety-solution",
                "content": "# Code\\n```\\nclass Solution {\\n  bool checkTree(TreeNode? root) {\\n      if (root == null) return false;\\n\\n      final leftValue = root.left?.val ?? 0;\\n      final rightValue = root.right?.val ?? 0;\\n\\n      return root.val == leftValue + rightValue;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  bool checkTree(TreeNode? root) {\\n      if (root == null) return false;\\n\\n      final leftValue = root.left?.val ?? 0;\\n      final rightValue = root.right?.val ?? 0;\\n\\n      return root.val == leftValue + rightValue;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3063740,
                "title": "recursive",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\nfunc checkTree(root *TreeNode) bool {\\n\\n     if root==nil {\\n         return true\\n     }\\n     sum:=0\\n     if root.Left!= nil {\\n         sum+=root.Left.Val\\n     }\\n      if root.Right!=nil {\\n          sum+=root.Right.Val\\n      }\\n      if sum==root.Val {\\n          return true\\n      } else {\\n          return false\\n      }\\n      sum=0\\n    return checkTree(root.Left) && checkTree(root.Right)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\nfunc checkTree(root *TreeNode) bool {\\n\\n     if root==nil {\\n         return true\\n     }\\n     sum:=0\\n     if root.Left!= nil {\\n         sum+=root.Left.Val\\n     }\\n      if root.Right!=nil {\\n          sum+=root.Right.Val\\n      }\\n      if sum==root.Val {\\n          return true\\n      } else {\\n          return false\\n      }\\n      sum=0\\n    return checkTree(root.Left) && checkTree(root.Right)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3031466,
                "title": "c-easy-2-lines-code-beats-100",
                "content": "# C++ Easy solution\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        if(root->val == root->left->val + root->right->val) return true;\\n        else return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        if(root->val == root->left->val + root->right->val) return true;\\n        else return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2853865,
                "title": "go-one-line-solution",
                "content": "```\\nfunc checkTree(root *TreeNode) bool {\\n    return root.Val == root.Left.Val + root.Right.Val\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\nfunc checkTree(root *TreeNode) bool {\\n    return root.Val == root.Left.Val + root.Right.Val\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2839553,
                "title": "c-one-liner-beats-100-submissions",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return (root->left->val+ root->right->val== root->val) ? true : false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return (root->left->val+ root->right->val== root->val) ? true : false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2784979,
                "title": "for-all-depths",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    \\n    void help(TreeNode* r, int &sum)\\n    {\\n        if(!r)\\n            return ;\\n        if(!r->left && !r->right)\\n            sum+=r->val;\\n        help(r->left,sum);\\n        help(r->right,sum);\\n        \\n        \\n    }\\n    bool checkTree(TreeNode* r) {\\n        \\n        if(!r)\\n            return true;\\n        \\n        int sum = 0;\\n        help(r,sum);\\n        return r->val == sum;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    \\n    void help(TreeNode* r, int &sum)\\n    {\\n        if(!r)\\n            return ;\\n        if(!r->left && !r->right)\\n            sum+=r->val;\\n        help(r->left,sum);\\n        help(r->right,sum);\\n        \\n        \\n    }\\n    bool checkTree(TreeNode* r) {\\n        \\n        if(!r)\\n            return true;\\n        \\n        int sum = 0;\\n        help(r,sum);\\n        return r->val == sum;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2751619,
                "title": "one-line-solution-c",
                "content": "Assuming that in the constraints of the problem it is specified that each input has only 3 nodes including the root, and its two right and left nodes. We can simply return an equality check between the sum of the two nodes and the root.\\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    public:\\n        bool checkTree(TreeNode* root) {\\n            return (root->val == (root->left->val + root->right->val));\\n        }\\n};\\n```\\n\\n**If that helped, an upvote would be welcome.**",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    public:\\n        bool checkTree(TreeNode* root) {\\n            return (root->val == (root->left->val + root->right->val));\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2744252,
                "title": "ruby-five-different-ways",
                "content": "# Intuition\\nWe are given the root node that has access its left and right children. Simply call its left and right right children values and see if the add up to the root\\'s value. Keep in mind that each node in the tree has a val, left, and right attribute. \\n\\n##### Root:\\nroot => root\\n\\nroot value => root.val\\n\\n##### Root\\'s Left:\\nleft child => root.left\\n\\nleft child value => root.left.val\\n\\n\\n##### Root\\'s Right:\\nright child => root.right\\n\\nright child value => root.right.val\\n\\n# Complexity\\n- Time complexity: O(1)\\nGenerally speaking operations take O(1) time and accessing the immediate children of the root node is constant as well.   \\n\\n- Space complexity: O(1)\\nSince no additional data structures are created to perform the calculations. \\n\\n# Code\\n\\n### ternary operator\\n```\\n# ternary operator\\n# time: O(1) \\n# space: O(1)\\ndef check_tree(root)\\n    root.left.val + root.right.val == root.val ? true : false\\nend\\n```\\n\\n### implicit boolean return \\n```\\n# implicit boolean return \\n# time: O(1)\\n# space: O(1)\\ndef check_tree(root)\\n    root.val == root.left.val + root.right.val\\nend\\n```\\n\\n### complement\\n```\\n# complement\\n# time: O(1)\\n# space: O(1)\\ndef check_tree(root)\\n    root.left.val == root.val - root.right.val \\nend\\n```\\n\\n### conditional part 1\\n```\\n# conditional part 1\\n# time: O(1)\\n# space: O(1)\\ndef check_tree(root)\\n    if root.val == root.left.val + root.right.val\\n        return true\\n    else\\n        return false\\n    end\\nend\\n```\\nOne can omit the return statement\\n\\n### conditional part 2  \\n```\\n# conditional part 2 \\n# time: O(1)\\n# space: O(1)\\ndef check_tree(root)\\n    return true if root.val == root.left.val + root.right.val\\n    return false\\nend\\n```\\n\\n",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# ternary operator\\n# time: O(1) \\n# space: O(1)\\ndef check_tree(root)\\n    root.left.val + root.right.val == root.val ? true : false\\nend\\n```\n```\\n# implicit boolean return \\n# time: O(1)\\n# space: O(1)\\ndef check_tree(root)\\n    root.val == root.left.val + root.right.val\\nend\\n```\n```\\n# complement\\n# time: O(1)\\n# space: O(1)\\ndef check_tree(root)\\n    root.left.val == root.val - root.right.val \\nend\\n```\n```\\n# conditional part 1\\n# time: O(1)\\n# space: O(1)\\ndef check_tree(root)\\n    if root.val == root.left.val + root.right.val\\n        return true\\n    else\\n        return false\\n    end\\nend\\n```\n```\\n# conditional part 2 \\n# time: O(1)\\n# space: O(1)\\ndef check_tree(root)\\n    return true if root.val == root.left.val + root.right.val\\n    return false\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2739176,
                "title": "python3-single-liner-code",
                "content": "python3 solution in just one line\\n\\n```\\nreturn root.val == (root.right.val + root.left.val);\\n```",
                "solutionTags": [],
                "code": "```\\nreturn root.val == (root.right.val + root.left.val);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2693206,
                "title": "cpp-easy-to-understand",
                "content": "```\\nbool checkTree(TreeNode* root) {\\n        if(root==NULL)\\n            return false;\\n        else if(root->val==(root->left->val+root->right->val))\\n            return true;\\n        return false;\\n    }",
                "solutionTags": [],
                "code": "```\\nbool checkTree(TreeNode* root) {\\n        if(root==NULL)\\n            return false;\\n        else if(root->val==(root->left->val+root->right->val))\\n            return true;\\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2655474,
                "title": "c-simple-recursive-solution",
                "content": "```\\n// Please, UpVote if you like it :)\\n// Runtime: 8 ms, faster than 25.96% of C++ online submissions for Root Equals Sum of Children.\\n// Memory Usage: 12.6 MB, less than 14.35% of C++ online submissions for Root Equals Sum of Children.\\nbool checkTree(TreeNode* root) {\\n\\tif (!root || !root->left && !root->right)\\n\\t\\treturn true;\\n\\treturn (root->val == ((root->left) ? root->left->val : 0) + ((root->right) ? root->right->val : 0)) &&\\n\\t\\tcheckTree(root->left) &&\\n\\t\\tcheckTree(root->right);\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\n// Please, UpVote if you like it :)\\n// Runtime: 8 ms, faster than 25.96% of C++ online submissions for Root Equals Sum of Children.\\n// Memory Usage: 12.6 MB, less than 14.35% of C++ online submissions for Root Equals Sum of Children.\\nbool checkTree(TreeNode* root) {\\n\\tif (!root || !root->left && !root->right)\\n\\t\\treturn true;\\n\\treturn (root->val == ((root->left) ? root->left->val : 0) + ((root->right) ? root->right->val : 0)) &&\\n\\t\\tcheckTree(root->left) &&\\n\\t\\tcheckTree(root->right);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2639773,
                "title": "go-simple-solution-in-go-golang",
                "content": "Hello Gophers!\\n\\n# Problem: Root Equals Sum of Children (Easy)\\n\\n## Solution 1: One Line Solution\\n\\n```go\\nfunc checkTree(root *TreeNode) bool {\\n    return root.Val == root.Left.Val + root.Right.Val\\n}\\n```\\n\\n## Solution 2: Best Practice\\n\\nLet\\'s say we are not sure if `root` is not nil or if it has children:\\n\\n```go\\nfunc checkTree(root *TreeNode) bool {\\n    if root == nil {\\n        return false\\n    }\\n    var sum int = 0\\n    if root.Left != nil {\\n        sum += root.Left.Val\\n    }\\n    if root.Right != nil {\\n        sum += root.Right.Val\\n    }\\n    return root.Val == sum\\n}\\n```\\n\\nI hope it helped! =)",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc checkTree(root *TreeNode) bool {\\n    return root.Val == root.Left.Val + root.Right.Val\\n}\\n```\n```go\\nfunc checkTree(root *TreeNode) bool {\\n    if root == nil {\\n        return false\\n    }\\n    var sum int = 0\\n    if root.Left != nil {\\n        sum += root.Left.Val\\n    }\\n    if root.Right != nil {\\n        sum += root.Right.Val\\n    }\\n    return root.Val == sum\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2602398,
                "title": "c-starightforward",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return root->val == root->left->val + root->right->val ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return root->val == root->left->val + root->right->val ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2593043,
                "title": "one-liner-pythonic-way",
                "content": "\\'\\'\\'\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val == root.left.val + root.right.val\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "\\'\\'\\'\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val == root.left.val + root.right.val\\n\\'\\'\\'",
                "codeTag": "Java"
            },
            {
                "id": 2569744,
                "title": "java-one-liner",
                "content": "Please Upvote if Helpful\\n\\n***\\n\\n```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.val == root.left.val + root.right.val;\\n    }\\n}\\n```\\n\\n***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.val == root.left.val + root.right.val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2567885,
                "title": "python3-one-line-solution",
                "content": "```\\nreturn root.val == root.left.val + root.right.val\\n```",
                "solutionTags": [],
                "code": "```\\nreturn root.val == root.left.val + root.right.val\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2530043,
                "title": "c-solution-one-line-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return root->val == (root->left->val + root->right->val);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return root->val == (root->left->val + root->right->val);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2529742,
                "title": "python-easy-solution",
                "content": "```python\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        def subtreeSum(node: Optional[TreeNode], value) -> int:\\n            if not node:\\n                return 0\\n\\n            return value + subtreeSum(node.left, node.val) + subtreeSum(node.right, node.val)\\n\\n        return root.val == (subtreeSum(root.left, root.left.val) + subtreeSum(root.right, root.right.val))\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```python\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        def subtreeSum(node: Optional[TreeNode], value) -> int:\\n            if not node:\\n                return 0\\n\\n            return value + subtreeSum(node.left, node.val) + subtreeSum(node.right, node.val)\\n\\n        return root.val == (subtreeSum(root.left, root.left.val) + subtreeSum(root.right, root.right.val))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2526561,
                "title": "java-simple-one-line-solution-the-most-minimalistic-solution",
                "content": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n\\t\\treturn root.val == root.left.val + root.right.val;\\n\\t}\\n}\\n```\\nIf you really found my solution helpful please upvote it, as it motivates me to post such kind of codes and help the coding community, if you have some queries or some improvements please feel free to comment and share your views.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n\\t\\treturn root.val == root.left.val + root.right.val;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2507139,
                "title": "java-solution-faster-than-100-00-of-submissions",
                "content": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        if (root == null) \\n            return false;\\n        else \\n            return (root.val == root.left.val + root.right.val); \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        if (root == null) \\n            return false;\\n        else \\n            return (root.val == root.left.val + root.right.val); \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2503005,
                "title": "javascript-sol",
                "content": "```\\nvar checkTree = function (root) {\\n    let node = root.val;\\n    let left = root.left.val;\\n    let right = root.right.val;\\n\\n    if (node == (left + right)) { return true }\\n    return false\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar checkTree = function (root) {\\n    let node = root.val;\\n    let left = root.left.val;\\n    let right = root.right.val;\\n\\n    if (node == (left + right)) { return true }\\n    return false\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2495069,
                "title": "javascript",
                "content": "```\\nconst checkTree = (root) => root.val === (root.right.val + root.left.val)\\n```\\n\\nRuntime: 62 ms, faster than 96.61% of JavaScript online submissions for Root Equals Sum of Children.\\nMemory Usage: 42.2 MB, less than 98.62% of JavaScript online submissions for Root Equals Sum of Children.",
                "solutionTags": [],
                "code": "```\\nconst checkTree = (root) => root.val === (root.right.val + root.left.val)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2480656,
                "title": "c-solution-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        if(root->val==root->left->val+root->right->val)\\n            return true;\\n        return false;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        if(root->val==root->left->val+root->right->val)\\n            return true;\\n        return false;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2475103,
                "title": "2236-root-equals-sum-of-children",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        if(root==NULL)\\n        {\\n            return true;\\n        }\\n        if(root->left->val + root->right->val == root->val)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Tree"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        if(root==NULL)\\n        {\\n            return true;\\n        }\\n        if(root->left->val + root->right->val == root->val)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2465225,
                "title": "java-1-line-easy",
                "content": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.left.val + root.right.val == root.val;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.left.val + root.right.val == root.val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2448051,
                "title": "single-line-solution-clean-c-code",
                "content": "# If you liked this solution then do upvote.\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return root->val == root->left->val + root->right->val;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return root->val == root->left->val + root->right->val;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2440740,
                "title": "java-1-liner-1ms",
                "content": "# Please Upvote\\n\\n```\\nreturn root.val == (root.right.val + root.left.val);\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\nreturn root.val == (root.right.val + root.left.val);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2420305,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.val==(root.left).val+(root.right).val;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.val==(root.left).val+(root.right).val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1693829,
                "content": [
                    {
                        "username": "charlessrze",
                        "content": " Why its not working...\\n`if(root[1] + root[2] == root[0]) return true;\\n    else return false;`"
                    },
                    {
                        "username": "At-sushi",
                        "content": "I think it is because the code lacks \".val\" after object statements. Reading them as an array is actually work for the result of C pointer trick (though I recommend to avoid this because the result is undefined)."
                    },
                    {
                        "username": "willima09",
                        "content": "[@jerryy147](/jerryy147) are you sure\\njs is declarative\\n"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "[@jerryy147](/jerryy147)  are you suggesting this solution for JS?"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "Because it\\'s not an array, root is a pointer"
                    },
                    {
                        "username": "jerryy147",
                        "content": "try root.val, root.left, and root.right"
                    },
                    {
                        "username": "rymoon",
                        "content": "It is not a list. Access properties via pointer."
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "Your code is meant to access the values of a list, but when I used console.log(typeof root), I saw that it is an object. Think of how you access the properties and values of an object."
                    },
                    {
                        "username": "EivindDelFierro",
                        "content": "On java script, when i console.log\\'d the input of function, it appeared like an array, but when i tried to convert it to string, it had an interesting output: the data structure that I was working with. From that output I was able to figure out the problem.."
                    },
                    {
                        "username": "Vladomira",
                        "content": "because it's not an array. In my case (TypeScript) every left side and every right side has own data: left side has own [value]- (its like independent node ) and also it has [left side] and [right side]. the same for right side. Every side can has own children.\nTry to console every element and type of it  and you will see"
                    },
                    {
                        "username": "niloufer_anjum",
                        "content": "It\\'s a TreeNode not a list. Try print(root) and solve from there."
                    },
                    {
                        "username": "rowe1227",
                        "content": "This question is much simpler than what one would expect to see in any interview setting.  \\n\\nThis is by design.  This problem and its [counterpart](https://leetcode.com/problems/add-two-integers/) will be used to help new LeetCode users become familiar with the platform and learn how to submit solutions.  \\n\\nAs many new LeetCode users will start at this problem, please feel free to share any advice you have for them below!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I feel as if this shouldn\\'t be an official problem; and if it is, that it be more findable to a new user. Just a suggestion. :) "
                    },
                    {
                        "username": "Universe_ldy",
                        "content": "Seriously? This is a real interview question?"
                    },
                    {
                        "username": "rparks52",
                        "content": "No, it\\'s not. It\\'s for learning how to use LeetCode for users that are not familiar with coding."
                    },
                    {
                        "username": "venka_",
                        "content": "For other noobs like me: pay attention to how to access structures using pointers, note that there are multiple pointers"
                    },
                    {
                        "username": "CoffeeCode247",
                        "content": "Why so many dislikes?? We all start from somewhere. Don\\'t forget that some of us WERE beginners at one point."
                    },
                    {
                        "username": "boo-m",
                        "content": "I do not understand the purpose of few of these problems\\n\\n[2235. Add Two Integers](https://leetcode.com/problems/add-two-integers/)\\n[2236. Root Equals Sum of Children](https://leetcode.com/problems/root-equals-sum-of-children/)\\n[1480. Running Sum of 1d Array](https://leetcode.com/problems/running-sum-of-1d-array/)\\n[1920. Build Array from Permutation](https://leetcode.com/problems/build-array-from-permutation/)\\n[1929. Concatenation of Array](https://leetcode.com/problems/concatenation-of-array/)\\n\\nPlease add to the list if you find any more easy problems.\\n"
                    },
                    {
                        "username": "hectorstestlab",
                        "content": "Its good for catching up on the programming logic again. I have been a Software QA Lead for almost 4 years now and I lost that, this is helping me."
                    },
                    {
                        "username": "mqberry",
                        "content": "It lowers the coding barrier to entry for new coders who may be coming to LC as a primary source of learning.  It is also hard to see what can be learned from simple problems like these when your experience and understanding far surpasses what these problems are testing you for.  :)"
                    },
                    {
                        "username": "denz1994",
                        "content": "It is good if you are teaching someone how to use the LC platform. Not really for interviews."
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of tree is more than two ?\nThen this will become a medium level problem;\n\nHere is the code for this question if height of tree was more than two!!\n\n```\nclass Solution {\npublic boolean checkTree(TreeNode root) {\nif(root==null) return true;\nif(root.left==null&&root.right==null)\n     return true;\n    int sum=0;\n     if(root.left!=null)\n      sum+=root.left.val;\n        \n      if(root.right!=null) \n      sum+=root.right.val;\n       \n        return\n(sum==root.val&&checkTree(root.left)&&checkTree(root.right));\n    }\n}\n```\n\nplease upvote if you like this ![leetcode] "
                    },
                    {
                        "username": "deredskoy",
                        "content": "Everyone is wondering why there is this question at all, but for one year of dev I never even encountered a problem with nodes. Usually it's baskets or smiley faces, this one is a bit more mature. I guess it's what is educated in the uni "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "True, I am a computer science major, and I have not been taught nodes/trees/graphs during my first year of college, Leetcode helped me learn what nodes and such are beforehand."
                    },
                    {
                        "username": "dilanekamga777",
                        "content": "The easiest problem on Tree"
                    },
                    {
                        "username": "Finesse",
                        "content": "Is there an easier problem on the whole LeetCode?\n\nUpdate: yes, it's 2235. Add Two Integers"
                    },
                    {
                        "username": "tomereli",
                        "content": "But no tree knowledge required to solve it.."
                    },
                    {
                        "username": "nadabao",
                        "content": "\\u7B80\\u5355\\u5230\\u8BA9\\u4EBA\\u6D41\\u6CEA\\uFF0C\\u597D\\u611F\\u4EBA\\u3002\\u3002\\u3002"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "\\u592A\\u96E3\\u4E86\\uFF0C\\u6211\\u4E0D\\u6703 : ("
                    }
                ]
            },
            {
                "id": 1564888,
                "content": [
                    {
                        "username": "charlessrze",
                        "content": " Why its not working...\\n`if(root[1] + root[2] == root[0]) return true;\\n    else return false;`"
                    },
                    {
                        "username": "At-sushi",
                        "content": "I think it is because the code lacks \".val\" after object statements. Reading them as an array is actually work for the result of C pointer trick (though I recommend to avoid this because the result is undefined)."
                    },
                    {
                        "username": "willima09",
                        "content": "[@jerryy147](/jerryy147) are you sure\\njs is declarative\\n"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "[@jerryy147](/jerryy147)  are you suggesting this solution for JS?"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "Because it\\'s not an array, root is a pointer"
                    },
                    {
                        "username": "jerryy147",
                        "content": "try root.val, root.left, and root.right"
                    },
                    {
                        "username": "rymoon",
                        "content": "It is not a list. Access properties via pointer."
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "Your code is meant to access the values of a list, but when I used console.log(typeof root), I saw that it is an object. Think of how you access the properties and values of an object."
                    },
                    {
                        "username": "EivindDelFierro",
                        "content": "On java script, when i console.log\\'d the input of function, it appeared like an array, but when i tried to convert it to string, it had an interesting output: the data structure that I was working with. From that output I was able to figure out the problem.."
                    },
                    {
                        "username": "Vladomira",
                        "content": "because it's not an array. In my case (TypeScript) every left side and every right side has own data: left side has own [value]- (its like independent node ) and also it has [left side] and [right side]. the same for right side. Every side can has own children.\nTry to console every element and type of it  and you will see"
                    },
                    {
                        "username": "niloufer_anjum",
                        "content": "It\\'s a TreeNode not a list. Try print(root) and solve from there."
                    },
                    {
                        "username": "rowe1227",
                        "content": "This question is much simpler than what one would expect to see in any interview setting.  \\n\\nThis is by design.  This problem and its [counterpart](https://leetcode.com/problems/add-two-integers/) will be used to help new LeetCode users become familiar with the platform and learn how to submit solutions.  \\n\\nAs many new LeetCode users will start at this problem, please feel free to share any advice you have for them below!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I feel as if this shouldn\\'t be an official problem; and if it is, that it be more findable to a new user. Just a suggestion. :) "
                    },
                    {
                        "username": "Universe_ldy",
                        "content": "Seriously? This is a real interview question?"
                    },
                    {
                        "username": "rparks52",
                        "content": "No, it\\'s not. It\\'s for learning how to use LeetCode for users that are not familiar with coding."
                    },
                    {
                        "username": "venka_",
                        "content": "For other noobs like me: pay attention to how to access structures using pointers, note that there are multiple pointers"
                    },
                    {
                        "username": "CoffeeCode247",
                        "content": "Why so many dislikes?? We all start from somewhere. Don\\'t forget that some of us WERE beginners at one point."
                    },
                    {
                        "username": "boo-m",
                        "content": "I do not understand the purpose of few of these problems\\n\\n[2235. Add Two Integers](https://leetcode.com/problems/add-two-integers/)\\n[2236. Root Equals Sum of Children](https://leetcode.com/problems/root-equals-sum-of-children/)\\n[1480. Running Sum of 1d Array](https://leetcode.com/problems/running-sum-of-1d-array/)\\n[1920. Build Array from Permutation](https://leetcode.com/problems/build-array-from-permutation/)\\n[1929. Concatenation of Array](https://leetcode.com/problems/concatenation-of-array/)\\n\\nPlease add to the list if you find any more easy problems.\\n"
                    },
                    {
                        "username": "hectorstestlab",
                        "content": "Its good for catching up on the programming logic again. I have been a Software QA Lead for almost 4 years now and I lost that, this is helping me."
                    },
                    {
                        "username": "mqberry",
                        "content": "It lowers the coding barrier to entry for new coders who may be coming to LC as a primary source of learning.  It is also hard to see what can be learned from simple problems like these when your experience and understanding far surpasses what these problems are testing you for.  :)"
                    },
                    {
                        "username": "denz1994",
                        "content": "It is good if you are teaching someone how to use the LC platform. Not really for interviews."
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of tree is more than two ?\nThen this will become a medium level problem;\n\nHere is the code for this question if height of tree was more than two!!\n\n```\nclass Solution {\npublic boolean checkTree(TreeNode root) {\nif(root==null) return true;\nif(root.left==null&&root.right==null)\n     return true;\n    int sum=0;\n     if(root.left!=null)\n      sum+=root.left.val;\n        \n      if(root.right!=null) \n      sum+=root.right.val;\n       \n        return\n(sum==root.val&&checkTree(root.left)&&checkTree(root.right));\n    }\n}\n```\n\nplease upvote if you like this ![leetcode] "
                    },
                    {
                        "username": "deredskoy",
                        "content": "Everyone is wondering why there is this question at all, but for one year of dev I never even encountered a problem with nodes. Usually it's baskets or smiley faces, this one is a bit more mature. I guess it's what is educated in the uni "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "True, I am a computer science major, and I have not been taught nodes/trees/graphs during my first year of college, Leetcode helped me learn what nodes and such are beforehand."
                    },
                    {
                        "username": "dilanekamga777",
                        "content": "The easiest problem on Tree"
                    },
                    {
                        "username": "Finesse",
                        "content": "Is there an easier problem on the whole LeetCode?\n\nUpdate: yes, it's 2235. Add Two Integers"
                    },
                    {
                        "username": "tomereli",
                        "content": "But no tree knowledge required to solve it.."
                    },
                    {
                        "username": "nadabao",
                        "content": "\\u7B80\\u5355\\u5230\\u8BA9\\u4EBA\\u6D41\\u6CEA\\uFF0C\\u597D\\u611F\\u4EBA\\u3002\\u3002\\u3002"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "\\u592A\\u96E3\\u4E86\\uFF0C\\u6211\\u4E0D\\u6703 : ("
                    }
                ]
            },
            {
                "id": 1565649,
                "content": [
                    {
                        "username": "charlessrze",
                        "content": " Why its not working...\\n`if(root[1] + root[2] == root[0]) return true;\\n    else return false;`"
                    },
                    {
                        "username": "At-sushi",
                        "content": "I think it is because the code lacks \".val\" after object statements. Reading them as an array is actually work for the result of C pointer trick (though I recommend to avoid this because the result is undefined)."
                    },
                    {
                        "username": "willima09",
                        "content": "[@jerryy147](/jerryy147) are you sure\\njs is declarative\\n"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "[@jerryy147](/jerryy147)  are you suggesting this solution for JS?"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "Because it\\'s not an array, root is a pointer"
                    },
                    {
                        "username": "jerryy147",
                        "content": "try root.val, root.left, and root.right"
                    },
                    {
                        "username": "rymoon",
                        "content": "It is not a list. Access properties via pointer."
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "Your code is meant to access the values of a list, but when I used console.log(typeof root), I saw that it is an object. Think of how you access the properties and values of an object."
                    },
                    {
                        "username": "EivindDelFierro",
                        "content": "On java script, when i console.log\\'d the input of function, it appeared like an array, but when i tried to convert it to string, it had an interesting output: the data structure that I was working with. From that output I was able to figure out the problem.."
                    },
                    {
                        "username": "Vladomira",
                        "content": "because it's not an array. In my case (TypeScript) every left side and every right side has own data: left side has own [value]- (its like independent node ) and also it has [left side] and [right side]. the same for right side. Every side can has own children.\nTry to console every element and type of it  and you will see"
                    },
                    {
                        "username": "niloufer_anjum",
                        "content": "It\\'s a TreeNode not a list. Try print(root) and solve from there."
                    },
                    {
                        "username": "rowe1227",
                        "content": "This question is much simpler than what one would expect to see in any interview setting.  \\n\\nThis is by design.  This problem and its [counterpart](https://leetcode.com/problems/add-two-integers/) will be used to help new LeetCode users become familiar with the platform and learn how to submit solutions.  \\n\\nAs many new LeetCode users will start at this problem, please feel free to share any advice you have for them below!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I feel as if this shouldn\\'t be an official problem; and if it is, that it be more findable to a new user. Just a suggestion. :) "
                    },
                    {
                        "username": "Universe_ldy",
                        "content": "Seriously? This is a real interview question?"
                    },
                    {
                        "username": "rparks52",
                        "content": "No, it\\'s not. It\\'s for learning how to use LeetCode for users that are not familiar with coding."
                    },
                    {
                        "username": "venka_",
                        "content": "For other noobs like me: pay attention to how to access structures using pointers, note that there are multiple pointers"
                    },
                    {
                        "username": "CoffeeCode247",
                        "content": "Why so many dislikes?? We all start from somewhere. Don\\'t forget that some of us WERE beginners at one point."
                    },
                    {
                        "username": "boo-m",
                        "content": "I do not understand the purpose of few of these problems\\n\\n[2235. Add Two Integers](https://leetcode.com/problems/add-two-integers/)\\n[2236. Root Equals Sum of Children](https://leetcode.com/problems/root-equals-sum-of-children/)\\n[1480. Running Sum of 1d Array](https://leetcode.com/problems/running-sum-of-1d-array/)\\n[1920. Build Array from Permutation](https://leetcode.com/problems/build-array-from-permutation/)\\n[1929. Concatenation of Array](https://leetcode.com/problems/concatenation-of-array/)\\n\\nPlease add to the list if you find any more easy problems.\\n"
                    },
                    {
                        "username": "hectorstestlab",
                        "content": "Its good for catching up on the programming logic again. I have been a Software QA Lead for almost 4 years now and I lost that, this is helping me."
                    },
                    {
                        "username": "mqberry",
                        "content": "It lowers the coding barrier to entry for new coders who may be coming to LC as a primary source of learning.  It is also hard to see what can be learned from simple problems like these when your experience and understanding far surpasses what these problems are testing you for.  :)"
                    },
                    {
                        "username": "denz1994",
                        "content": "It is good if you are teaching someone how to use the LC platform. Not really for interviews."
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of tree is more than two ?\nThen this will become a medium level problem;\n\nHere is the code for this question if height of tree was more than two!!\n\n```\nclass Solution {\npublic boolean checkTree(TreeNode root) {\nif(root==null) return true;\nif(root.left==null&&root.right==null)\n     return true;\n    int sum=0;\n     if(root.left!=null)\n      sum+=root.left.val;\n        \n      if(root.right!=null) \n      sum+=root.right.val;\n       \n        return\n(sum==root.val&&checkTree(root.left)&&checkTree(root.right));\n    }\n}\n```\n\nplease upvote if you like this ![leetcode] "
                    },
                    {
                        "username": "deredskoy",
                        "content": "Everyone is wondering why there is this question at all, but for one year of dev I never even encountered a problem with nodes. Usually it's baskets or smiley faces, this one is a bit more mature. I guess it's what is educated in the uni "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "True, I am a computer science major, and I have not been taught nodes/trees/graphs during my first year of college, Leetcode helped me learn what nodes and such are beforehand."
                    },
                    {
                        "username": "dilanekamga777",
                        "content": "The easiest problem on Tree"
                    },
                    {
                        "username": "Finesse",
                        "content": "Is there an easier problem on the whole LeetCode?\n\nUpdate: yes, it's 2235. Add Two Integers"
                    },
                    {
                        "username": "tomereli",
                        "content": "But no tree knowledge required to solve it.."
                    },
                    {
                        "username": "nadabao",
                        "content": "\\u7B80\\u5355\\u5230\\u8BA9\\u4EBA\\u6D41\\u6CEA\\uFF0C\\u597D\\u611F\\u4EBA\\u3002\\u3002\\u3002"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "\\u592A\\u96E3\\u4E86\\uFF0C\\u6211\\u4E0D\\u6703 : ("
                    }
                ]
            },
            {
                "id": 1735919,
                "content": [
                    {
                        "username": "charlessrze",
                        "content": " Why its not working...\\n`if(root[1] + root[2] == root[0]) return true;\\n    else return false;`"
                    },
                    {
                        "username": "At-sushi",
                        "content": "I think it is because the code lacks \".val\" after object statements. Reading them as an array is actually work for the result of C pointer trick (though I recommend to avoid this because the result is undefined)."
                    },
                    {
                        "username": "willima09",
                        "content": "[@jerryy147](/jerryy147) are you sure\\njs is declarative\\n"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "[@jerryy147](/jerryy147)  are you suggesting this solution for JS?"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "Because it\\'s not an array, root is a pointer"
                    },
                    {
                        "username": "jerryy147",
                        "content": "try root.val, root.left, and root.right"
                    },
                    {
                        "username": "rymoon",
                        "content": "It is not a list. Access properties via pointer."
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "Your code is meant to access the values of a list, but when I used console.log(typeof root), I saw that it is an object. Think of how you access the properties and values of an object."
                    },
                    {
                        "username": "EivindDelFierro",
                        "content": "On java script, when i console.log\\'d the input of function, it appeared like an array, but when i tried to convert it to string, it had an interesting output: the data structure that I was working with. From that output I was able to figure out the problem.."
                    },
                    {
                        "username": "Vladomira",
                        "content": "because it's not an array. In my case (TypeScript) every left side and every right side has own data: left side has own [value]- (its like independent node ) and also it has [left side] and [right side]. the same for right side. Every side can has own children.\nTry to console every element and type of it  and you will see"
                    },
                    {
                        "username": "niloufer_anjum",
                        "content": "It\\'s a TreeNode not a list. Try print(root) and solve from there."
                    },
                    {
                        "username": "rowe1227",
                        "content": "This question is much simpler than what one would expect to see in any interview setting.  \\n\\nThis is by design.  This problem and its [counterpart](https://leetcode.com/problems/add-two-integers/) will be used to help new LeetCode users become familiar with the platform and learn how to submit solutions.  \\n\\nAs many new LeetCode users will start at this problem, please feel free to share any advice you have for them below!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I feel as if this shouldn\\'t be an official problem; and if it is, that it be more findable to a new user. Just a suggestion. :) "
                    },
                    {
                        "username": "Universe_ldy",
                        "content": "Seriously? This is a real interview question?"
                    },
                    {
                        "username": "rparks52",
                        "content": "No, it\\'s not. It\\'s for learning how to use LeetCode for users that are not familiar with coding."
                    },
                    {
                        "username": "venka_",
                        "content": "For other noobs like me: pay attention to how to access structures using pointers, note that there are multiple pointers"
                    },
                    {
                        "username": "CoffeeCode247",
                        "content": "Why so many dislikes?? We all start from somewhere. Don\\'t forget that some of us WERE beginners at one point."
                    },
                    {
                        "username": "boo-m",
                        "content": "I do not understand the purpose of few of these problems\\n\\n[2235. Add Two Integers](https://leetcode.com/problems/add-two-integers/)\\n[2236. Root Equals Sum of Children](https://leetcode.com/problems/root-equals-sum-of-children/)\\n[1480. Running Sum of 1d Array](https://leetcode.com/problems/running-sum-of-1d-array/)\\n[1920. Build Array from Permutation](https://leetcode.com/problems/build-array-from-permutation/)\\n[1929. Concatenation of Array](https://leetcode.com/problems/concatenation-of-array/)\\n\\nPlease add to the list if you find any more easy problems.\\n"
                    },
                    {
                        "username": "hectorstestlab",
                        "content": "Its good for catching up on the programming logic again. I have been a Software QA Lead for almost 4 years now and I lost that, this is helping me."
                    },
                    {
                        "username": "mqberry",
                        "content": "It lowers the coding barrier to entry for new coders who may be coming to LC as a primary source of learning.  It is also hard to see what can be learned from simple problems like these when your experience and understanding far surpasses what these problems are testing you for.  :)"
                    },
                    {
                        "username": "denz1994",
                        "content": "It is good if you are teaching someone how to use the LC platform. Not really for interviews."
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of tree is more than two ?\nThen this will become a medium level problem;\n\nHere is the code for this question if height of tree was more than two!!\n\n```\nclass Solution {\npublic boolean checkTree(TreeNode root) {\nif(root==null) return true;\nif(root.left==null&&root.right==null)\n     return true;\n    int sum=0;\n     if(root.left!=null)\n      sum+=root.left.val;\n        \n      if(root.right!=null) \n      sum+=root.right.val;\n       \n        return\n(sum==root.val&&checkTree(root.left)&&checkTree(root.right));\n    }\n}\n```\n\nplease upvote if you like this ![leetcode] "
                    },
                    {
                        "username": "deredskoy",
                        "content": "Everyone is wondering why there is this question at all, but for one year of dev I never even encountered a problem with nodes. Usually it's baskets or smiley faces, this one is a bit more mature. I guess it's what is educated in the uni "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "True, I am a computer science major, and I have not been taught nodes/trees/graphs during my first year of college, Leetcode helped me learn what nodes and such are beforehand."
                    },
                    {
                        "username": "dilanekamga777",
                        "content": "The easiest problem on Tree"
                    },
                    {
                        "username": "Finesse",
                        "content": "Is there an easier problem on the whole LeetCode?\n\nUpdate: yes, it's 2235. Add Two Integers"
                    },
                    {
                        "username": "tomereli",
                        "content": "But no tree knowledge required to solve it.."
                    },
                    {
                        "username": "nadabao",
                        "content": "\\u7B80\\u5355\\u5230\\u8BA9\\u4EBA\\u6D41\\u6CEA\\uFF0C\\u597D\\u611F\\u4EBA\\u3002\\u3002\\u3002"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "\\u592A\\u96E3\\u4E86\\uFF0C\\u6211\\u4E0D\\u6703 : ("
                    }
                ]
            },
            {
                "id": 1925445,
                "content": [
                    {
                        "username": "charlessrze",
                        "content": " Why its not working...\\n`if(root[1] + root[2] == root[0]) return true;\\n    else return false;`"
                    },
                    {
                        "username": "At-sushi",
                        "content": "I think it is because the code lacks \".val\" after object statements. Reading them as an array is actually work for the result of C pointer trick (though I recommend to avoid this because the result is undefined)."
                    },
                    {
                        "username": "willima09",
                        "content": "[@jerryy147](/jerryy147) are you sure\\njs is declarative\\n"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "[@jerryy147](/jerryy147)  are you suggesting this solution for JS?"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "Because it\\'s not an array, root is a pointer"
                    },
                    {
                        "username": "jerryy147",
                        "content": "try root.val, root.left, and root.right"
                    },
                    {
                        "username": "rymoon",
                        "content": "It is not a list. Access properties via pointer."
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "Your code is meant to access the values of a list, but when I used console.log(typeof root), I saw that it is an object. Think of how you access the properties and values of an object."
                    },
                    {
                        "username": "EivindDelFierro",
                        "content": "On java script, when i console.log\\'d the input of function, it appeared like an array, but when i tried to convert it to string, it had an interesting output: the data structure that I was working with. From that output I was able to figure out the problem.."
                    },
                    {
                        "username": "Vladomira",
                        "content": "because it's not an array. In my case (TypeScript) every left side and every right side has own data: left side has own [value]- (its like independent node ) and also it has [left side] and [right side]. the same for right side. Every side can has own children.\nTry to console every element and type of it  and you will see"
                    },
                    {
                        "username": "niloufer_anjum",
                        "content": "It\\'s a TreeNode not a list. Try print(root) and solve from there."
                    },
                    {
                        "username": "rowe1227",
                        "content": "This question is much simpler than what one would expect to see in any interview setting.  \\n\\nThis is by design.  This problem and its [counterpart](https://leetcode.com/problems/add-two-integers/) will be used to help new LeetCode users become familiar with the platform and learn how to submit solutions.  \\n\\nAs many new LeetCode users will start at this problem, please feel free to share any advice you have for them below!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I feel as if this shouldn\\'t be an official problem; and if it is, that it be more findable to a new user. Just a suggestion. :) "
                    },
                    {
                        "username": "Universe_ldy",
                        "content": "Seriously? This is a real interview question?"
                    },
                    {
                        "username": "rparks52",
                        "content": "No, it\\'s not. It\\'s for learning how to use LeetCode for users that are not familiar with coding."
                    },
                    {
                        "username": "venka_",
                        "content": "For other noobs like me: pay attention to how to access structures using pointers, note that there are multiple pointers"
                    },
                    {
                        "username": "CoffeeCode247",
                        "content": "Why so many dislikes?? We all start from somewhere. Don\\'t forget that some of us WERE beginners at one point."
                    },
                    {
                        "username": "boo-m",
                        "content": "I do not understand the purpose of few of these problems\\n\\n[2235. Add Two Integers](https://leetcode.com/problems/add-two-integers/)\\n[2236. Root Equals Sum of Children](https://leetcode.com/problems/root-equals-sum-of-children/)\\n[1480. Running Sum of 1d Array](https://leetcode.com/problems/running-sum-of-1d-array/)\\n[1920. Build Array from Permutation](https://leetcode.com/problems/build-array-from-permutation/)\\n[1929. Concatenation of Array](https://leetcode.com/problems/concatenation-of-array/)\\n\\nPlease add to the list if you find any more easy problems.\\n"
                    },
                    {
                        "username": "hectorstestlab",
                        "content": "Its good for catching up on the programming logic again. I have been a Software QA Lead for almost 4 years now and I lost that, this is helping me."
                    },
                    {
                        "username": "mqberry",
                        "content": "It lowers the coding barrier to entry for new coders who may be coming to LC as a primary source of learning.  It is also hard to see what can be learned from simple problems like these when your experience and understanding far surpasses what these problems are testing you for.  :)"
                    },
                    {
                        "username": "denz1994",
                        "content": "It is good if you are teaching someone how to use the LC platform. Not really for interviews."
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of tree is more than two ?\nThen this will become a medium level problem;\n\nHere is the code for this question if height of tree was more than two!!\n\n```\nclass Solution {\npublic boolean checkTree(TreeNode root) {\nif(root==null) return true;\nif(root.left==null&&root.right==null)\n     return true;\n    int sum=0;\n     if(root.left!=null)\n      sum+=root.left.val;\n        \n      if(root.right!=null) \n      sum+=root.right.val;\n       \n        return\n(sum==root.val&&checkTree(root.left)&&checkTree(root.right));\n    }\n}\n```\n\nplease upvote if you like this ![leetcode] "
                    },
                    {
                        "username": "deredskoy",
                        "content": "Everyone is wondering why there is this question at all, but for one year of dev I never even encountered a problem with nodes. Usually it's baskets or smiley faces, this one is a bit more mature. I guess it's what is educated in the uni "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "True, I am a computer science major, and I have not been taught nodes/trees/graphs during my first year of college, Leetcode helped me learn what nodes and such are beforehand."
                    },
                    {
                        "username": "dilanekamga777",
                        "content": "The easiest problem on Tree"
                    },
                    {
                        "username": "Finesse",
                        "content": "Is there an easier problem on the whole LeetCode?\n\nUpdate: yes, it's 2235. Add Two Integers"
                    },
                    {
                        "username": "tomereli",
                        "content": "But no tree knowledge required to solve it.."
                    },
                    {
                        "username": "nadabao",
                        "content": "\\u7B80\\u5355\\u5230\\u8BA9\\u4EBA\\u6D41\\u6CEA\\uFF0C\\u597D\\u611F\\u4EBA\\u3002\\u3002\\u3002"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "\\u592A\\u96E3\\u4E86\\uFF0C\\u6211\\u4E0D\\u6703 : ("
                    }
                ]
            },
            {
                "id": 1570895,
                "content": [
                    {
                        "username": "charlessrze",
                        "content": " Why its not working...\\n`if(root[1] + root[2] == root[0]) return true;\\n    else return false;`"
                    },
                    {
                        "username": "At-sushi",
                        "content": "I think it is because the code lacks \".val\" after object statements. Reading them as an array is actually work for the result of C pointer trick (though I recommend to avoid this because the result is undefined)."
                    },
                    {
                        "username": "willima09",
                        "content": "[@jerryy147](/jerryy147) are you sure\\njs is declarative\\n"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "[@jerryy147](/jerryy147)  are you suggesting this solution for JS?"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "Because it\\'s not an array, root is a pointer"
                    },
                    {
                        "username": "jerryy147",
                        "content": "try root.val, root.left, and root.right"
                    },
                    {
                        "username": "rymoon",
                        "content": "It is not a list. Access properties via pointer."
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "Your code is meant to access the values of a list, but when I used console.log(typeof root), I saw that it is an object. Think of how you access the properties and values of an object."
                    },
                    {
                        "username": "EivindDelFierro",
                        "content": "On java script, when i console.log\\'d the input of function, it appeared like an array, but when i tried to convert it to string, it had an interesting output: the data structure that I was working with. From that output I was able to figure out the problem.."
                    },
                    {
                        "username": "Vladomira",
                        "content": "because it's not an array. In my case (TypeScript) every left side and every right side has own data: left side has own [value]- (its like independent node ) and also it has [left side] and [right side]. the same for right side. Every side can has own children.\nTry to console every element and type of it  and you will see"
                    },
                    {
                        "username": "niloufer_anjum",
                        "content": "It\\'s a TreeNode not a list. Try print(root) and solve from there."
                    },
                    {
                        "username": "rowe1227",
                        "content": "This question is much simpler than what one would expect to see in any interview setting.  \\n\\nThis is by design.  This problem and its [counterpart](https://leetcode.com/problems/add-two-integers/) will be used to help new LeetCode users become familiar with the platform and learn how to submit solutions.  \\n\\nAs many new LeetCode users will start at this problem, please feel free to share any advice you have for them below!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I feel as if this shouldn\\'t be an official problem; and if it is, that it be more findable to a new user. Just a suggestion. :) "
                    },
                    {
                        "username": "Universe_ldy",
                        "content": "Seriously? This is a real interview question?"
                    },
                    {
                        "username": "rparks52",
                        "content": "No, it\\'s not. It\\'s for learning how to use LeetCode for users that are not familiar with coding."
                    },
                    {
                        "username": "venka_",
                        "content": "For other noobs like me: pay attention to how to access structures using pointers, note that there are multiple pointers"
                    },
                    {
                        "username": "CoffeeCode247",
                        "content": "Why so many dislikes?? We all start from somewhere. Don\\'t forget that some of us WERE beginners at one point."
                    },
                    {
                        "username": "boo-m",
                        "content": "I do not understand the purpose of few of these problems\\n\\n[2235. Add Two Integers](https://leetcode.com/problems/add-two-integers/)\\n[2236. Root Equals Sum of Children](https://leetcode.com/problems/root-equals-sum-of-children/)\\n[1480. Running Sum of 1d Array](https://leetcode.com/problems/running-sum-of-1d-array/)\\n[1920. Build Array from Permutation](https://leetcode.com/problems/build-array-from-permutation/)\\n[1929. Concatenation of Array](https://leetcode.com/problems/concatenation-of-array/)\\n\\nPlease add to the list if you find any more easy problems.\\n"
                    },
                    {
                        "username": "hectorstestlab",
                        "content": "Its good for catching up on the programming logic again. I have been a Software QA Lead for almost 4 years now and I lost that, this is helping me."
                    },
                    {
                        "username": "mqberry",
                        "content": "It lowers the coding barrier to entry for new coders who may be coming to LC as a primary source of learning.  It is also hard to see what can be learned from simple problems like these when your experience and understanding far surpasses what these problems are testing you for.  :)"
                    },
                    {
                        "username": "denz1994",
                        "content": "It is good if you are teaching someone how to use the LC platform. Not really for interviews."
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of tree is more than two ?\nThen this will become a medium level problem;\n\nHere is the code for this question if height of tree was more than two!!\n\n```\nclass Solution {\npublic boolean checkTree(TreeNode root) {\nif(root==null) return true;\nif(root.left==null&&root.right==null)\n     return true;\n    int sum=0;\n     if(root.left!=null)\n      sum+=root.left.val;\n        \n      if(root.right!=null) \n      sum+=root.right.val;\n       \n        return\n(sum==root.val&&checkTree(root.left)&&checkTree(root.right));\n    }\n}\n```\n\nplease upvote if you like this ![leetcode] "
                    },
                    {
                        "username": "deredskoy",
                        "content": "Everyone is wondering why there is this question at all, but for one year of dev I never even encountered a problem with nodes. Usually it's baskets or smiley faces, this one is a bit more mature. I guess it's what is educated in the uni "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "True, I am a computer science major, and I have not been taught nodes/trees/graphs during my first year of college, Leetcode helped me learn what nodes and such are beforehand."
                    },
                    {
                        "username": "dilanekamga777",
                        "content": "The easiest problem on Tree"
                    },
                    {
                        "username": "Finesse",
                        "content": "Is there an easier problem on the whole LeetCode?\n\nUpdate: yes, it's 2235. Add Two Integers"
                    },
                    {
                        "username": "tomereli",
                        "content": "But no tree knowledge required to solve it.."
                    },
                    {
                        "username": "nadabao",
                        "content": "\\u7B80\\u5355\\u5230\\u8BA9\\u4EBA\\u6D41\\u6CEA\\uFF0C\\u597D\\u611F\\u4EBA\\u3002\\u3002\\u3002"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "\\u592A\\u96E3\\u4E86\\uFF0C\\u6211\\u4E0D\\u6703 : ("
                    }
                ]
            },
            {
                "id": 1861691,
                "content": [
                    {
                        "username": "charlessrze",
                        "content": " Why its not working...\\n`if(root[1] + root[2] == root[0]) return true;\\n    else return false;`"
                    },
                    {
                        "username": "At-sushi",
                        "content": "I think it is because the code lacks \".val\" after object statements. Reading them as an array is actually work for the result of C pointer trick (though I recommend to avoid this because the result is undefined)."
                    },
                    {
                        "username": "willima09",
                        "content": "[@jerryy147](/jerryy147) are you sure\\njs is declarative\\n"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "[@jerryy147](/jerryy147)  are you suggesting this solution for JS?"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "Because it\\'s not an array, root is a pointer"
                    },
                    {
                        "username": "jerryy147",
                        "content": "try root.val, root.left, and root.right"
                    },
                    {
                        "username": "rymoon",
                        "content": "It is not a list. Access properties via pointer."
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "Your code is meant to access the values of a list, but when I used console.log(typeof root), I saw that it is an object. Think of how you access the properties and values of an object."
                    },
                    {
                        "username": "EivindDelFierro",
                        "content": "On java script, when i console.log\\'d the input of function, it appeared like an array, but when i tried to convert it to string, it had an interesting output: the data structure that I was working with. From that output I was able to figure out the problem.."
                    },
                    {
                        "username": "Vladomira",
                        "content": "because it's not an array. In my case (TypeScript) every left side and every right side has own data: left side has own [value]- (its like independent node ) and also it has [left side] and [right side]. the same for right side. Every side can has own children.\nTry to console every element and type of it  and you will see"
                    },
                    {
                        "username": "niloufer_anjum",
                        "content": "It\\'s a TreeNode not a list. Try print(root) and solve from there."
                    },
                    {
                        "username": "rowe1227",
                        "content": "This question is much simpler than what one would expect to see in any interview setting.  \\n\\nThis is by design.  This problem and its [counterpart](https://leetcode.com/problems/add-two-integers/) will be used to help new LeetCode users become familiar with the platform and learn how to submit solutions.  \\n\\nAs many new LeetCode users will start at this problem, please feel free to share any advice you have for them below!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I feel as if this shouldn\\'t be an official problem; and if it is, that it be more findable to a new user. Just a suggestion. :) "
                    },
                    {
                        "username": "Universe_ldy",
                        "content": "Seriously? This is a real interview question?"
                    },
                    {
                        "username": "rparks52",
                        "content": "No, it\\'s not. It\\'s for learning how to use LeetCode for users that are not familiar with coding."
                    },
                    {
                        "username": "venka_",
                        "content": "For other noobs like me: pay attention to how to access structures using pointers, note that there are multiple pointers"
                    },
                    {
                        "username": "CoffeeCode247",
                        "content": "Why so many dislikes?? We all start from somewhere. Don\\'t forget that some of us WERE beginners at one point."
                    },
                    {
                        "username": "boo-m",
                        "content": "I do not understand the purpose of few of these problems\\n\\n[2235. Add Two Integers](https://leetcode.com/problems/add-two-integers/)\\n[2236. Root Equals Sum of Children](https://leetcode.com/problems/root-equals-sum-of-children/)\\n[1480. Running Sum of 1d Array](https://leetcode.com/problems/running-sum-of-1d-array/)\\n[1920. Build Array from Permutation](https://leetcode.com/problems/build-array-from-permutation/)\\n[1929. Concatenation of Array](https://leetcode.com/problems/concatenation-of-array/)\\n\\nPlease add to the list if you find any more easy problems.\\n"
                    },
                    {
                        "username": "hectorstestlab",
                        "content": "Its good for catching up on the programming logic again. I have been a Software QA Lead for almost 4 years now and I lost that, this is helping me."
                    },
                    {
                        "username": "mqberry",
                        "content": "It lowers the coding barrier to entry for new coders who may be coming to LC as a primary source of learning.  It is also hard to see what can be learned from simple problems like these when your experience and understanding far surpasses what these problems are testing you for.  :)"
                    },
                    {
                        "username": "denz1994",
                        "content": "It is good if you are teaching someone how to use the LC platform. Not really for interviews."
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of tree is more than two ?\nThen this will become a medium level problem;\n\nHere is the code for this question if height of tree was more than two!!\n\n```\nclass Solution {\npublic boolean checkTree(TreeNode root) {\nif(root==null) return true;\nif(root.left==null&&root.right==null)\n     return true;\n    int sum=0;\n     if(root.left!=null)\n      sum+=root.left.val;\n        \n      if(root.right!=null) \n      sum+=root.right.val;\n       \n        return\n(sum==root.val&&checkTree(root.left)&&checkTree(root.right));\n    }\n}\n```\n\nplease upvote if you like this ![leetcode] "
                    },
                    {
                        "username": "deredskoy",
                        "content": "Everyone is wondering why there is this question at all, but for one year of dev I never even encountered a problem with nodes. Usually it's baskets or smiley faces, this one is a bit more mature. I guess it's what is educated in the uni "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "True, I am a computer science major, and I have not been taught nodes/trees/graphs during my first year of college, Leetcode helped me learn what nodes and such are beforehand."
                    },
                    {
                        "username": "dilanekamga777",
                        "content": "The easiest problem on Tree"
                    },
                    {
                        "username": "Finesse",
                        "content": "Is there an easier problem on the whole LeetCode?\n\nUpdate: yes, it's 2235. Add Two Integers"
                    },
                    {
                        "username": "tomereli",
                        "content": "But no tree knowledge required to solve it.."
                    },
                    {
                        "username": "nadabao",
                        "content": "\\u7B80\\u5355\\u5230\\u8BA9\\u4EBA\\u6D41\\u6CEA\\uFF0C\\u597D\\u611F\\u4EBA\\u3002\\u3002\\u3002"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "\\u592A\\u96E3\\u4E86\\uFF0C\\u6211\\u4E0D\\u6703 : ("
                    }
                ]
            },
            {
                "id": 1726629,
                "content": [
                    {
                        "username": "charlessrze",
                        "content": " Why its not working...\\n`if(root[1] + root[2] == root[0]) return true;\\n    else return false;`"
                    },
                    {
                        "username": "At-sushi",
                        "content": "I think it is because the code lacks \".val\" after object statements. Reading them as an array is actually work for the result of C pointer trick (though I recommend to avoid this because the result is undefined)."
                    },
                    {
                        "username": "willima09",
                        "content": "[@jerryy147](/jerryy147) are you sure\\njs is declarative\\n"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "[@jerryy147](/jerryy147)  are you suggesting this solution for JS?"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "Because it\\'s not an array, root is a pointer"
                    },
                    {
                        "username": "jerryy147",
                        "content": "try root.val, root.left, and root.right"
                    },
                    {
                        "username": "rymoon",
                        "content": "It is not a list. Access properties via pointer."
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "Your code is meant to access the values of a list, but when I used console.log(typeof root), I saw that it is an object. Think of how you access the properties and values of an object."
                    },
                    {
                        "username": "EivindDelFierro",
                        "content": "On java script, when i console.log\\'d the input of function, it appeared like an array, but when i tried to convert it to string, it had an interesting output: the data structure that I was working with. From that output I was able to figure out the problem.."
                    },
                    {
                        "username": "Vladomira",
                        "content": "because it's not an array. In my case (TypeScript) every left side and every right side has own data: left side has own [value]- (its like independent node ) and also it has [left side] and [right side]. the same for right side. Every side can has own children.\nTry to console every element and type of it  and you will see"
                    },
                    {
                        "username": "niloufer_anjum",
                        "content": "It\\'s a TreeNode not a list. Try print(root) and solve from there."
                    },
                    {
                        "username": "rowe1227",
                        "content": "This question is much simpler than what one would expect to see in any interview setting.  \\n\\nThis is by design.  This problem and its [counterpart](https://leetcode.com/problems/add-two-integers/) will be used to help new LeetCode users become familiar with the platform and learn how to submit solutions.  \\n\\nAs many new LeetCode users will start at this problem, please feel free to share any advice you have for them below!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I feel as if this shouldn\\'t be an official problem; and if it is, that it be more findable to a new user. Just a suggestion. :) "
                    },
                    {
                        "username": "Universe_ldy",
                        "content": "Seriously? This is a real interview question?"
                    },
                    {
                        "username": "rparks52",
                        "content": "No, it\\'s not. It\\'s for learning how to use LeetCode for users that are not familiar with coding."
                    },
                    {
                        "username": "venka_",
                        "content": "For other noobs like me: pay attention to how to access structures using pointers, note that there are multiple pointers"
                    },
                    {
                        "username": "CoffeeCode247",
                        "content": "Why so many dislikes?? We all start from somewhere. Don\\'t forget that some of us WERE beginners at one point."
                    },
                    {
                        "username": "boo-m",
                        "content": "I do not understand the purpose of few of these problems\\n\\n[2235. Add Two Integers](https://leetcode.com/problems/add-two-integers/)\\n[2236. Root Equals Sum of Children](https://leetcode.com/problems/root-equals-sum-of-children/)\\n[1480. Running Sum of 1d Array](https://leetcode.com/problems/running-sum-of-1d-array/)\\n[1920. Build Array from Permutation](https://leetcode.com/problems/build-array-from-permutation/)\\n[1929. Concatenation of Array](https://leetcode.com/problems/concatenation-of-array/)\\n\\nPlease add to the list if you find any more easy problems.\\n"
                    },
                    {
                        "username": "hectorstestlab",
                        "content": "Its good for catching up on the programming logic again. I have been a Software QA Lead for almost 4 years now and I lost that, this is helping me."
                    },
                    {
                        "username": "mqberry",
                        "content": "It lowers the coding barrier to entry for new coders who may be coming to LC as a primary source of learning.  It is also hard to see what can be learned from simple problems like these when your experience and understanding far surpasses what these problems are testing you for.  :)"
                    },
                    {
                        "username": "denz1994",
                        "content": "It is good if you are teaching someone how to use the LC platform. Not really for interviews."
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of tree is more than two ?\nThen this will become a medium level problem;\n\nHere is the code for this question if height of tree was more than two!!\n\n```\nclass Solution {\npublic boolean checkTree(TreeNode root) {\nif(root==null) return true;\nif(root.left==null&&root.right==null)\n     return true;\n    int sum=0;\n     if(root.left!=null)\n      sum+=root.left.val;\n        \n      if(root.right!=null) \n      sum+=root.right.val;\n       \n        return\n(sum==root.val&&checkTree(root.left)&&checkTree(root.right));\n    }\n}\n```\n\nplease upvote if you like this ![leetcode] "
                    },
                    {
                        "username": "deredskoy",
                        "content": "Everyone is wondering why there is this question at all, but for one year of dev I never even encountered a problem with nodes. Usually it's baskets or smiley faces, this one is a bit more mature. I guess it's what is educated in the uni "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "True, I am a computer science major, and I have not been taught nodes/trees/graphs during my first year of college, Leetcode helped me learn what nodes and such are beforehand."
                    },
                    {
                        "username": "dilanekamga777",
                        "content": "The easiest problem on Tree"
                    },
                    {
                        "username": "Finesse",
                        "content": "Is there an easier problem on the whole LeetCode?\n\nUpdate: yes, it's 2235. Add Two Integers"
                    },
                    {
                        "username": "tomereli",
                        "content": "But no tree knowledge required to solve it.."
                    },
                    {
                        "username": "nadabao",
                        "content": "\\u7B80\\u5355\\u5230\\u8BA9\\u4EBA\\u6D41\\u6CEA\\uFF0C\\u597D\\u611F\\u4EBA\\u3002\\u3002\\u3002"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "\\u592A\\u96E3\\u4E86\\uFF0C\\u6211\\u4E0D\\u6703 : ("
                    }
                ]
            },
            {
                "id": 1698119,
                "content": [
                    {
                        "username": "charlessrze",
                        "content": " Why its not working...\\n`if(root[1] + root[2] == root[0]) return true;\\n    else return false;`"
                    },
                    {
                        "username": "At-sushi",
                        "content": "I think it is because the code lacks \".val\" after object statements. Reading them as an array is actually work for the result of C pointer trick (though I recommend to avoid this because the result is undefined)."
                    },
                    {
                        "username": "willima09",
                        "content": "[@jerryy147](/jerryy147) are you sure\\njs is declarative\\n"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "[@jerryy147](/jerryy147)  are you suggesting this solution for JS?"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "Because it\\'s not an array, root is a pointer"
                    },
                    {
                        "username": "jerryy147",
                        "content": "try root.val, root.left, and root.right"
                    },
                    {
                        "username": "rymoon",
                        "content": "It is not a list. Access properties via pointer."
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "Your code is meant to access the values of a list, but when I used console.log(typeof root), I saw that it is an object. Think of how you access the properties and values of an object."
                    },
                    {
                        "username": "EivindDelFierro",
                        "content": "On java script, when i console.log\\'d the input of function, it appeared like an array, but when i tried to convert it to string, it had an interesting output: the data structure that I was working with. From that output I was able to figure out the problem.."
                    },
                    {
                        "username": "Vladomira",
                        "content": "because it's not an array. In my case (TypeScript) every left side and every right side has own data: left side has own [value]- (its like independent node ) and also it has [left side] and [right side]. the same for right side. Every side can has own children.\nTry to console every element and type of it  and you will see"
                    },
                    {
                        "username": "niloufer_anjum",
                        "content": "It\\'s a TreeNode not a list. Try print(root) and solve from there."
                    },
                    {
                        "username": "rowe1227",
                        "content": "This question is much simpler than what one would expect to see in any interview setting.  \\n\\nThis is by design.  This problem and its [counterpart](https://leetcode.com/problems/add-two-integers/) will be used to help new LeetCode users become familiar with the platform and learn how to submit solutions.  \\n\\nAs many new LeetCode users will start at this problem, please feel free to share any advice you have for them below!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I feel as if this shouldn\\'t be an official problem; and if it is, that it be more findable to a new user. Just a suggestion. :) "
                    },
                    {
                        "username": "Universe_ldy",
                        "content": "Seriously? This is a real interview question?"
                    },
                    {
                        "username": "rparks52",
                        "content": "No, it\\'s not. It\\'s for learning how to use LeetCode for users that are not familiar with coding."
                    },
                    {
                        "username": "venka_",
                        "content": "For other noobs like me: pay attention to how to access structures using pointers, note that there are multiple pointers"
                    },
                    {
                        "username": "CoffeeCode247",
                        "content": "Why so many dislikes?? We all start from somewhere. Don\\'t forget that some of us WERE beginners at one point."
                    },
                    {
                        "username": "boo-m",
                        "content": "I do not understand the purpose of few of these problems\\n\\n[2235. Add Two Integers](https://leetcode.com/problems/add-two-integers/)\\n[2236. Root Equals Sum of Children](https://leetcode.com/problems/root-equals-sum-of-children/)\\n[1480. Running Sum of 1d Array](https://leetcode.com/problems/running-sum-of-1d-array/)\\n[1920. Build Array from Permutation](https://leetcode.com/problems/build-array-from-permutation/)\\n[1929. Concatenation of Array](https://leetcode.com/problems/concatenation-of-array/)\\n\\nPlease add to the list if you find any more easy problems.\\n"
                    },
                    {
                        "username": "hectorstestlab",
                        "content": "Its good for catching up on the programming logic again. I have been a Software QA Lead for almost 4 years now and I lost that, this is helping me."
                    },
                    {
                        "username": "mqberry",
                        "content": "It lowers the coding barrier to entry for new coders who may be coming to LC as a primary source of learning.  It is also hard to see what can be learned from simple problems like these when your experience and understanding far surpasses what these problems are testing you for.  :)"
                    },
                    {
                        "username": "denz1994",
                        "content": "It is good if you are teaching someone how to use the LC platform. Not really for interviews."
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of tree is more than two ?\nThen this will become a medium level problem;\n\nHere is the code for this question if height of tree was more than two!!\n\n```\nclass Solution {\npublic boolean checkTree(TreeNode root) {\nif(root==null) return true;\nif(root.left==null&&root.right==null)\n     return true;\n    int sum=0;\n     if(root.left!=null)\n      sum+=root.left.val;\n        \n      if(root.right!=null) \n      sum+=root.right.val;\n       \n        return\n(sum==root.val&&checkTree(root.left)&&checkTree(root.right));\n    }\n}\n```\n\nplease upvote if you like this ![leetcode] "
                    },
                    {
                        "username": "deredskoy",
                        "content": "Everyone is wondering why there is this question at all, but for one year of dev I never even encountered a problem with nodes. Usually it's baskets or smiley faces, this one is a bit more mature. I guess it's what is educated in the uni "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "True, I am a computer science major, and I have not been taught nodes/trees/graphs during my first year of college, Leetcode helped me learn what nodes and such are beforehand."
                    },
                    {
                        "username": "dilanekamga777",
                        "content": "The easiest problem on Tree"
                    },
                    {
                        "username": "Finesse",
                        "content": "Is there an easier problem on the whole LeetCode?\n\nUpdate: yes, it's 2235. Add Two Integers"
                    },
                    {
                        "username": "tomereli",
                        "content": "But no tree knowledge required to solve it.."
                    },
                    {
                        "username": "nadabao",
                        "content": "\\u7B80\\u5355\\u5230\\u8BA9\\u4EBA\\u6D41\\u6CEA\\uFF0C\\u597D\\u611F\\u4EBA\\u3002\\u3002\\u3002"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "\\u592A\\u96E3\\u4E86\\uFF0C\\u6211\\u4E0D\\u6703 : ("
                    }
                ]
            },
            {
                "id": 1576632,
                "content": [
                    {
                        "username": "charlessrze",
                        "content": " Why its not working...\\n`if(root[1] + root[2] == root[0]) return true;\\n    else return false;`"
                    },
                    {
                        "username": "At-sushi",
                        "content": "I think it is because the code lacks \".val\" after object statements. Reading them as an array is actually work for the result of C pointer trick (though I recommend to avoid this because the result is undefined)."
                    },
                    {
                        "username": "willima09",
                        "content": "[@jerryy147](/jerryy147) are you sure\\njs is declarative\\n"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "[@jerryy147](/jerryy147)  are you suggesting this solution for JS?"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "Because it\\'s not an array, root is a pointer"
                    },
                    {
                        "username": "jerryy147",
                        "content": "try root.val, root.left, and root.right"
                    },
                    {
                        "username": "rymoon",
                        "content": "It is not a list. Access properties via pointer."
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "Your code is meant to access the values of a list, but when I used console.log(typeof root), I saw that it is an object. Think of how you access the properties and values of an object."
                    },
                    {
                        "username": "EivindDelFierro",
                        "content": "On java script, when i console.log\\'d the input of function, it appeared like an array, but when i tried to convert it to string, it had an interesting output: the data structure that I was working with. From that output I was able to figure out the problem.."
                    },
                    {
                        "username": "Vladomira",
                        "content": "because it's not an array. In my case (TypeScript) every left side and every right side has own data: left side has own [value]- (its like independent node ) and also it has [left side] and [right side]. the same for right side. Every side can has own children.\nTry to console every element and type of it  and you will see"
                    },
                    {
                        "username": "niloufer_anjum",
                        "content": "It\\'s a TreeNode not a list. Try print(root) and solve from there."
                    },
                    {
                        "username": "rowe1227",
                        "content": "This question is much simpler than what one would expect to see in any interview setting.  \\n\\nThis is by design.  This problem and its [counterpart](https://leetcode.com/problems/add-two-integers/) will be used to help new LeetCode users become familiar with the platform and learn how to submit solutions.  \\n\\nAs many new LeetCode users will start at this problem, please feel free to share any advice you have for them below!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I feel as if this shouldn\\'t be an official problem; and if it is, that it be more findable to a new user. Just a suggestion. :) "
                    },
                    {
                        "username": "Universe_ldy",
                        "content": "Seriously? This is a real interview question?"
                    },
                    {
                        "username": "rparks52",
                        "content": "No, it\\'s not. It\\'s for learning how to use LeetCode for users that are not familiar with coding."
                    },
                    {
                        "username": "venka_",
                        "content": "For other noobs like me: pay attention to how to access structures using pointers, note that there are multiple pointers"
                    },
                    {
                        "username": "CoffeeCode247",
                        "content": "Why so many dislikes?? We all start from somewhere. Don\\'t forget that some of us WERE beginners at one point."
                    },
                    {
                        "username": "boo-m",
                        "content": "I do not understand the purpose of few of these problems\\n\\n[2235. Add Two Integers](https://leetcode.com/problems/add-two-integers/)\\n[2236. Root Equals Sum of Children](https://leetcode.com/problems/root-equals-sum-of-children/)\\n[1480. Running Sum of 1d Array](https://leetcode.com/problems/running-sum-of-1d-array/)\\n[1920. Build Array from Permutation](https://leetcode.com/problems/build-array-from-permutation/)\\n[1929. Concatenation of Array](https://leetcode.com/problems/concatenation-of-array/)\\n\\nPlease add to the list if you find any more easy problems.\\n"
                    },
                    {
                        "username": "hectorstestlab",
                        "content": "Its good for catching up on the programming logic again. I have been a Software QA Lead for almost 4 years now and I lost that, this is helping me."
                    },
                    {
                        "username": "mqberry",
                        "content": "It lowers the coding barrier to entry for new coders who may be coming to LC as a primary source of learning.  It is also hard to see what can be learned from simple problems like these when your experience and understanding far surpasses what these problems are testing you for.  :)"
                    },
                    {
                        "username": "denz1994",
                        "content": "It is good if you are teaching someone how to use the LC platform. Not really for interviews."
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of tree is more than two ?\nThen this will become a medium level problem;\n\nHere is the code for this question if height of tree was more than two!!\n\n```\nclass Solution {\npublic boolean checkTree(TreeNode root) {\nif(root==null) return true;\nif(root.left==null&&root.right==null)\n     return true;\n    int sum=0;\n     if(root.left!=null)\n      sum+=root.left.val;\n        \n      if(root.right!=null) \n      sum+=root.right.val;\n       \n        return\n(sum==root.val&&checkTree(root.left)&&checkTree(root.right));\n    }\n}\n```\n\nplease upvote if you like this ![leetcode] "
                    },
                    {
                        "username": "deredskoy",
                        "content": "Everyone is wondering why there is this question at all, but for one year of dev I never even encountered a problem with nodes. Usually it's baskets or smiley faces, this one is a bit more mature. I guess it's what is educated in the uni "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "True, I am a computer science major, and I have not been taught nodes/trees/graphs during my first year of college, Leetcode helped me learn what nodes and such are beforehand."
                    },
                    {
                        "username": "dilanekamga777",
                        "content": "The easiest problem on Tree"
                    },
                    {
                        "username": "Finesse",
                        "content": "Is there an easier problem on the whole LeetCode?\n\nUpdate: yes, it's 2235. Add Two Integers"
                    },
                    {
                        "username": "tomereli",
                        "content": "But no tree knowledge required to solve it.."
                    },
                    {
                        "username": "nadabao",
                        "content": "\\u7B80\\u5355\\u5230\\u8BA9\\u4EBA\\u6D41\\u6CEA\\uFF0C\\u597D\\u611F\\u4EBA\\u3002\\u3002\\u3002"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "\\u592A\\u96E3\\u4E86\\uFF0C\\u6211\\u4E0D\\u6703 : ("
                    }
                ]
            },
            {
                "id": 1693829,
                "content": [
                    {
                        "username": "charlessrze",
                        "content": " Why its not working...\\n`if(root[1] + root[2] == root[0]) return true;\\n    else return false;`"
                    },
                    {
                        "username": "At-sushi",
                        "content": "I think it is because the code lacks \".val\" after object statements. Reading them as an array is actually work for the result of C pointer trick (though I recommend to avoid this because the result is undefined)."
                    },
                    {
                        "username": "willima09",
                        "content": "[@jerryy147](/jerryy147) are you sure\\njs is declarative\\n"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "[@jerryy147](/jerryy147)  are you suggesting this solution for JS?"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "Because it\\'s not an array, root is a pointer"
                    },
                    {
                        "username": "jerryy147",
                        "content": "try root.val, root.left, and root.right"
                    },
                    {
                        "username": "rymoon",
                        "content": "It is not a list. Access properties via pointer."
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "Your code is meant to access the values of a list, but when I used console.log(typeof root), I saw that it is an object. Think of how you access the properties and values of an object."
                    },
                    {
                        "username": "EivindDelFierro",
                        "content": "On java script, when i console.log\\'d the input of function, it appeared like an array, but when i tried to convert it to string, it had an interesting output: the data structure that I was working with. From that output I was able to figure out the problem.."
                    },
                    {
                        "username": "Vladomira",
                        "content": "because it's not an array. In my case (TypeScript) every left side and every right side has own data: left side has own [value]- (its like independent node ) and also it has [left side] and [right side]. the same for right side. Every side can has own children.\nTry to console every element and type of it  and you will see"
                    },
                    {
                        "username": "niloufer_anjum",
                        "content": "It\\'s a TreeNode not a list. Try print(root) and solve from there."
                    },
                    {
                        "username": "rowe1227",
                        "content": "This question is much simpler than what one would expect to see in any interview setting.  \\n\\nThis is by design.  This problem and its [counterpart](https://leetcode.com/problems/add-two-integers/) will be used to help new LeetCode users become familiar with the platform and learn how to submit solutions.  \\n\\nAs many new LeetCode users will start at this problem, please feel free to share any advice you have for them below!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I feel as if this shouldn\\'t be an official problem; and if it is, that it be more findable to a new user. Just a suggestion. :) "
                    },
                    {
                        "username": "Universe_ldy",
                        "content": "Seriously? This is a real interview question?"
                    },
                    {
                        "username": "rparks52",
                        "content": "No, it\\'s not. It\\'s for learning how to use LeetCode for users that are not familiar with coding."
                    },
                    {
                        "username": "venka_",
                        "content": "For other noobs like me: pay attention to how to access structures using pointers, note that there are multiple pointers"
                    },
                    {
                        "username": "CoffeeCode247",
                        "content": "Why so many dislikes?? We all start from somewhere. Don\\'t forget that some of us WERE beginners at one point."
                    },
                    {
                        "username": "boo-m",
                        "content": "I do not understand the purpose of few of these problems\\n\\n[2235. Add Two Integers](https://leetcode.com/problems/add-two-integers/)\\n[2236. Root Equals Sum of Children](https://leetcode.com/problems/root-equals-sum-of-children/)\\n[1480. Running Sum of 1d Array](https://leetcode.com/problems/running-sum-of-1d-array/)\\n[1920. Build Array from Permutation](https://leetcode.com/problems/build-array-from-permutation/)\\n[1929. Concatenation of Array](https://leetcode.com/problems/concatenation-of-array/)\\n\\nPlease add to the list if you find any more easy problems.\\n"
                    },
                    {
                        "username": "hectorstestlab",
                        "content": "Its good for catching up on the programming logic again. I have been a Software QA Lead for almost 4 years now and I lost that, this is helping me."
                    },
                    {
                        "username": "mqberry",
                        "content": "It lowers the coding barrier to entry for new coders who may be coming to LC as a primary source of learning.  It is also hard to see what can be learned from simple problems like these when your experience and understanding far surpasses what these problems are testing you for.  :)"
                    },
                    {
                        "username": "denz1994",
                        "content": "It is good if you are teaching someone how to use the LC platform. Not really for interviews."
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of tree is more than two ?\nThen this will become a medium level problem;\n\nHere is the code for this question if height of tree was more than two!!\n\n```\nclass Solution {\npublic boolean checkTree(TreeNode root) {\nif(root==null) return true;\nif(root.left==null&&root.right==null)\n     return true;\n    int sum=0;\n     if(root.left!=null)\n      sum+=root.left.val;\n        \n      if(root.right!=null) \n      sum+=root.right.val;\n       \n        return\n(sum==root.val&&checkTree(root.left)&&checkTree(root.right));\n    }\n}\n```\n\nplease upvote if you like this ![leetcode] "
                    },
                    {
                        "username": "deredskoy",
                        "content": "Everyone is wondering why there is this question at all, but for one year of dev I never even encountered a problem with nodes. Usually it's baskets or smiley faces, this one is a bit more mature. I guess it's what is educated in the uni "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "True, I am a computer science major, and I have not been taught nodes/trees/graphs during my first year of college, Leetcode helped me learn what nodes and such are beforehand."
                    },
                    {
                        "username": "dilanekamga777",
                        "content": "The easiest problem on Tree"
                    },
                    {
                        "username": "Finesse",
                        "content": "Is there an easier problem on the whole LeetCode?\n\nUpdate: yes, it's 2235. Add Two Integers"
                    },
                    {
                        "username": "tomereli",
                        "content": "But no tree knowledge required to solve it.."
                    },
                    {
                        "username": "nadabao",
                        "content": "\\u7B80\\u5355\\u5230\\u8BA9\\u4EBA\\u6D41\\u6CEA\\uFF0C\\u597D\\u611F\\u4EBA\\u3002\\u3002\\u3002"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "\\u592A\\u96E3\\u4E86\\uFF0C\\u6211\\u4E0D\\u6703 : ("
                    }
                ]
            },
            {
                "id": 1564888,
                "content": [
                    {
                        "username": "charlessrze",
                        "content": " Why its not working...\\n`if(root[1] + root[2] == root[0]) return true;\\n    else return false;`"
                    },
                    {
                        "username": "At-sushi",
                        "content": "I think it is because the code lacks \".val\" after object statements. Reading them as an array is actually work for the result of C pointer trick (though I recommend to avoid this because the result is undefined)."
                    },
                    {
                        "username": "willima09",
                        "content": "[@jerryy147](/jerryy147) are you sure\\njs is declarative\\n"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "[@jerryy147](/jerryy147)  are you suggesting this solution for JS?"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "Because it\\'s not an array, root is a pointer"
                    },
                    {
                        "username": "jerryy147",
                        "content": "try root.val, root.left, and root.right"
                    },
                    {
                        "username": "rymoon",
                        "content": "It is not a list. Access properties via pointer."
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "Your code is meant to access the values of a list, but when I used console.log(typeof root), I saw that it is an object. Think of how you access the properties and values of an object."
                    },
                    {
                        "username": "EivindDelFierro",
                        "content": "On java script, when i console.log\\'d the input of function, it appeared like an array, but when i tried to convert it to string, it had an interesting output: the data structure that I was working with. From that output I was able to figure out the problem.."
                    },
                    {
                        "username": "Vladomira",
                        "content": "because it's not an array. In my case (TypeScript) every left side and every right side has own data: left side has own [value]- (its like independent node ) and also it has [left side] and [right side]. the same for right side. Every side can has own children.\nTry to console every element and type of it  and you will see"
                    },
                    {
                        "username": "niloufer_anjum",
                        "content": "It\\'s a TreeNode not a list. Try print(root) and solve from there."
                    },
                    {
                        "username": "rowe1227",
                        "content": "This question is much simpler than what one would expect to see in any interview setting.  \\n\\nThis is by design.  This problem and its [counterpart](https://leetcode.com/problems/add-two-integers/) will be used to help new LeetCode users become familiar with the platform and learn how to submit solutions.  \\n\\nAs many new LeetCode users will start at this problem, please feel free to share any advice you have for them below!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I feel as if this shouldn\\'t be an official problem; and if it is, that it be more findable to a new user. Just a suggestion. :) "
                    },
                    {
                        "username": "Universe_ldy",
                        "content": "Seriously? This is a real interview question?"
                    },
                    {
                        "username": "rparks52",
                        "content": "No, it\\'s not. It\\'s for learning how to use LeetCode for users that are not familiar with coding."
                    },
                    {
                        "username": "venka_",
                        "content": "For other noobs like me: pay attention to how to access structures using pointers, note that there are multiple pointers"
                    },
                    {
                        "username": "CoffeeCode247",
                        "content": "Why so many dislikes?? We all start from somewhere. Don\\'t forget that some of us WERE beginners at one point."
                    },
                    {
                        "username": "boo-m",
                        "content": "I do not understand the purpose of few of these problems\\n\\n[2235. Add Two Integers](https://leetcode.com/problems/add-two-integers/)\\n[2236. Root Equals Sum of Children](https://leetcode.com/problems/root-equals-sum-of-children/)\\n[1480. Running Sum of 1d Array](https://leetcode.com/problems/running-sum-of-1d-array/)\\n[1920. Build Array from Permutation](https://leetcode.com/problems/build-array-from-permutation/)\\n[1929. Concatenation of Array](https://leetcode.com/problems/concatenation-of-array/)\\n\\nPlease add to the list if you find any more easy problems.\\n"
                    },
                    {
                        "username": "hectorstestlab",
                        "content": "Its good for catching up on the programming logic again. I have been a Software QA Lead for almost 4 years now and I lost that, this is helping me."
                    },
                    {
                        "username": "mqberry",
                        "content": "It lowers the coding barrier to entry for new coders who may be coming to LC as a primary source of learning.  It is also hard to see what can be learned from simple problems like these when your experience and understanding far surpasses what these problems are testing you for.  :)"
                    },
                    {
                        "username": "denz1994",
                        "content": "It is good if you are teaching someone how to use the LC platform. Not really for interviews."
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of tree is more than two ?\nThen this will become a medium level problem;\n\nHere is the code for this question if height of tree was more than two!!\n\n```\nclass Solution {\npublic boolean checkTree(TreeNode root) {\nif(root==null) return true;\nif(root.left==null&&root.right==null)\n     return true;\n    int sum=0;\n     if(root.left!=null)\n      sum+=root.left.val;\n        \n      if(root.right!=null) \n      sum+=root.right.val;\n       \n        return\n(sum==root.val&&checkTree(root.left)&&checkTree(root.right));\n    }\n}\n```\n\nplease upvote if you like this ![leetcode] "
                    },
                    {
                        "username": "deredskoy",
                        "content": "Everyone is wondering why there is this question at all, but for one year of dev I never even encountered a problem with nodes. Usually it's baskets or smiley faces, this one is a bit more mature. I guess it's what is educated in the uni "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "True, I am a computer science major, and I have not been taught nodes/trees/graphs during my first year of college, Leetcode helped me learn what nodes and such are beforehand."
                    },
                    {
                        "username": "dilanekamga777",
                        "content": "The easiest problem on Tree"
                    },
                    {
                        "username": "Finesse",
                        "content": "Is there an easier problem on the whole LeetCode?\n\nUpdate: yes, it's 2235. Add Two Integers"
                    },
                    {
                        "username": "tomereli",
                        "content": "But no tree knowledge required to solve it.."
                    },
                    {
                        "username": "nadabao",
                        "content": "\\u7B80\\u5355\\u5230\\u8BA9\\u4EBA\\u6D41\\u6CEA\\uFF0C\\u597D\\u611F\\u4EBA\\u3002\\u3002\\u3002"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "\\u592A\\u96E3\\u4E86\\uFF0C\\u6211\\u4E0D\\u6703 : ("
                    }
                ]
            },
            {
                "id": 1565649,
                "content": [
                    {
                        "username": "charlessrze",
                        "content": " Why its not working...\\n`if(root[1] + root[2] == root[0]) return true;\\n    else return false;`"
                    },
                    {
                        "username": "At-sushi",
                        "content": "I think it is because the code lacks \".val\" after object statements. Reading them as an array is actually work for the result of C pointer trick (though I recommend to avoid this because the result is undefined)."
                    },
                    {
                        "username": "willima09",
                        "content": "[@jerryy147](/jerryy147) are you sure\\njs is declarative\\n"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "[@jerryy147](/jerryy147)  are you suggesting this solution for JS?"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "Because it\\'s not an array, root is a pointer"
                    },
                    {
                        "username": "jerryy147",
                        "content": "try root.val, root.left, and root.right"
                    },
                    {
                        "username": "rymoon",
                        "content": "It is not a list. Access properties via pointer."
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "Your code is meant to access the values of a list, but when I used console.log(typeof root), I saw that it is an object. Think of how you access the properties and values of an object."
                    },
                    {
                        "username": "EivindDelFierro",
                        "content": "On java script, when i console.log\\'d the input of function, it appeared like an array, but when i tried to convert it to string, it had an interesting output: the data structure that I was working with. From that output I was able to figure out the problem.."
                    },
                    {
                        "username": "Vladomira",
                        "content": "because it's not an array. In my case (TypeScript) every left side and every right side has own data: left side has own [value]- (its like independent node ) and also it has [left side] and [right side]. the same for right side. Every side can has own children.\nTry to console every element and type of it  and you will see"
                    },
                    {
                        "username": "niloufer_anjum",
                        "content": "It\\'s a TreeNode not a list. Try print(root) and solve from there."
                    },
                    {
                        "username": "rowe1227",
                        "content": "This question is much simpler than what one would expect to see in any interview setting.  \\n\\nThis is by design.  This problem and its [counterpart](https://leetcode.com/problems/add-two-integers/) will be used to help new LeetCode users become familiar with the platform and learn how to submit solutions.  \\n\\nAs many new LeetCode users will start at this problem, please feel free to share any advice you have for them below!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I feel as if this shouldn\\'t be an official problem; and if it is, that it be more findable to a new user. Just a suggestion. :) "
                    },
                    {
                        "username": "Universe_ldy",
                        "content": "Seriously? This is a real interview question?"
                    },
                    {
                        "username": "rparks52",
                        "content": "No, it\\'s not. It\\'s for learning how to use LeetCode for users that are not familiar with coding."
                    },
                    {
                        "username": "venka_",
                        "content": "For other noobs like me: pay attention to how to access structures using pointers, note that there are multiple pointers"
                    },
                    {
                        "username": "CoffeeCode247",
                        "content": "Why so many dislikes?? We all start from somewhere. Don\\'t forget that some of us WERE beginners at one point."
                    },
                    {
                        "username": "boo-m",
                        "content": "I do not understand the purpose of few of these problems\\n\\n[2235. Add Two Integers](https://leetcode.com/problems/add-two-integers/)\\n[2236. Root Equals Sum of Children](https://leetcode.com/problems/root-equals-sum-of-children/)\\n[1480. Running Sum of 1d Array](https://leetcode.com/problems/running-sum-of-1d-array/)\\n[1920. Build Array from Permutation](https://leetcode.com/problems/build-array-from-permutation/)\\n[1929. Concatenation of Array](https://leetcode.com/problems/concatenation-of-array/)\\n\\nPlease add to the list if you find any more easy problems.\\n"
                    },
                    {
                        "username": "hectorstestlab",
                        "content": "Its good for catching up on the programming logic again. I have been a Software QA Lead for almost 4 years now and I lost that, this is helping me."
                    },
                    {
                        "username": "mqberry",
                        "content": "It lowers the coding barrier to entry for new coders who may be coming to LC as a primary source of learning.  It is also hard to see what can be learned from simple problems like these when your experience and understanding far surpasses what these problems are testing you for.  :)"
                    },
                    {
                        "username": "denz1994",
                        "content": "It is good if you are teaching someone how to use the LC platform. Not really for interviews."
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of tree is more than two ?\nThen this will become a medium level problem;\n\nHere is the code for this question if height of tree was more than two!!\n\n```\nclass Solution {\npublic boolean checkTree(TreeNode root) {\nif(root==null) return true;\nif(root.left==null&&root.right==null)\n     return true;\n    int sum=0;\n     if(root.left!=null)\n      sum+=root.left.val;\n        \n      if(root.right!=null) \n      sum+=root.right.val;\n       \n        return\n(sum==root.val&&checkTree(root.left)&&checkTree(root.right));\n    }\n}\n```\n\nplease upvote if you like this ![leetcode] "
                    },
                    {
                        "username": "deredskoy",
                        "content": "Everyone is wondering why there is this question at all, but for one year of dev I never even encountered a problem with nodes. Usually it's baskets or smiley faces, this one is a bit more mature. I guess it's what is educated in the uni "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "True, I am a computer science major, and I have not been taught nodes/trees/graphs during my first year of college, Leetcode helped me learn what nodes and such are beforehand."
                    },
                    {
                        "username": "dilanekamga777",
                        "content": "The easiest problem on Tree"
                    },
                    {
                        "username": "Finesse",
                        "content": "Is there an easier problem on the whole LeetCode?\n\nUpdate: yes, it's 2235. Add Two Integers"
                    },
                    {
                        "username": "tomereli",
                        "content": "But no tree knowledge required to solve it.."
                    },
                    {
                        "username": "nadabao",
                        "content": "\\u7B80\\u5355\\u5230\\u8BA9\\u4EBA\\u6D41\\u6CEA\\uFF0C\\u597D\\u611F\\u4EBA\\u3002\\u3002\\u3002"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "\\u592A\\u96E3\\u4E86\\uFF0C\\u6211\\u4E0D\\u6703 : ("
                    }
                ]
            },
            {
                "id": 1735919,
                "content": [
                    {
                        "username": "charlessrze",
                        "content": " Why its not working...\\n`if(root[1] + root[2] == root[0]) return true;\\n    else return false;`"
                    },
                    {
                        "username": "At-sushi",
                        "content": "I think it is because the code lacks \".val\" after object statements. Reading them as an array is actually work for the result of C pointer trick (though I recommend to avoid this because the result is undefined)."
                    },
                    {
                        "username": "willima09",
                        "content": "[@jerryy147](/jerryy147) are you sure\\njs is declarative\\n"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "[@jerryy147](/jerryy147)  are you suggesting this solution for JS?"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "Because it\\'s not an array, root is a pointer"
                    },
                    {
                        "username": "jerryy147",
                        "content": "try root.val, root.left, and root.right"
                    },
                    {
                        "username": "rymoon",
                        "content": "It is not a list. Access properties via pointer."
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "Your code is meant to access the values of a list, but when I used console.log(typeof root), I saw that it is an object. Think of how you access the properties and values of an object."
                    },
                    {
                        "username": "EivindDelFierro",
                        "content": "On java script, when i console.log\\'d the input of function, it appeared like an array, but when i tried to convert it to string, it had an interesting output: the data structure that I was working with. From that output I was able to figure out the problem.."
                    },
                    {
                        "username": "Vladomira",
                        "content": "because it's not an array. In my case (TypeScript) every left side and every right side has own data: left side has own [value]- (its like independent node ) and also it has [left side] and [right side]. the same for right side. Every side can has own children.\nTry to console every element and type of it  and you will see"
                    },
                    {
                        "username": "niloufer_anjum",
                        "content": "It\\'s a TreeNode not a list. Try print(root) and solve from there."
                    },
                    {
                        "username": "rowe1227",
                        "content": "This question is much simpler than what one would expect to see in any interview setting.  \\n\\nThis is by design.  This problem and its [counterpart](https://leetcode.com/problems/add-two-integers/) will be used to help new LeetCode users become familiar with the platform and learn how to submit solutions.  \\n\\nAs many new LeetCode users will start at this problem, please feel free to share any advice you have for them below!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I feel as if this shouldn\\'t be an official problem; and if it is, that it be more findable to a new user. Just a suggestion. :) "
                    },
                    {
                        "username": "Universe_ldy",
                        "content": "Seriously? This is a real interview question?"
                    },
                    {
                        "username": "rparks52",
                        "content": "No, it\\'s not. It\\'s for learning how to use LeetCode for users that are not familiar with coding."
                    },
                    {
                        "username": "venka_",
                        "content": "For other noobs like me: pay attention to how to access structures using pointers, note that there are multiple pointers"
                    },
                    {
                        "username": "CoffeeCode247",
                        "content": "Why so many dislikes?? We all start from somewhere. Don\\'t forget that some of us WERE beginners at one point."
                    },
                    {
                        "username": "boo-m",
                        "content": "I do not understand the purpose of few of these problems\\n\\n[2235. Add Two Integers](https://leetcode.com/problems/add-two-integers/)\\n[2236. Root Equals Sum of Children](https://leetcode.com/problems/root-equals-sum-of-children/)\\n[1480. Running Sum of 1d Array](https://leetcode.com/problems/running-sum-of-1d-array/)\\n[1920. Build Array from Permutation](https://leetcode.com/problems/build-array-from-permutation/)\\n[1929. Concatenation of Array](https://leetcode.com/problems/concatenation-of-array/)\\n\\nPlease add to the list if you find any more easy problems.\\n"
                    },
                    {
                        "username": "hectorstestlab",
                        "content": "Its good for catching up on the programming logic again. I have been a Software QA Lead for almost 4 years now and I lost that, this is helping me."
                    },
                    {
                        "username": "mqberry",
                        "content": "It lowers the coding barrier to entry for new coders who may be coming to LC as a primary source of learning.  It is also hard to see what can be learned from simple problems like these when your experience and understanding far surpasses what these problems are testing you for.  :)"
                    },
                    {
                        "username": "denz1994",
                        "content": "It is good if you are teaching someone how to use the LC platform. Not really for interviews."
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of tree is more than two ?\nThen this will become a medium level problem;\n\nHere is the code for this question if height of tree was more than two!!\n\n```\nclass Solution {\npublic boolean checkTree(TreeNode root) {\nif(root==null) return true;\nif(root.left==null&&root.right==null)\n     return true;\n    int sum=0;\n     if(root.left!=null)\n      sum+=root.left.val;\n        \n      if(root.right!=null) \n      sum+=root.right.val;\n       \n        return\n(sum==root.val&&checkTree(root.left)&&checkTree(root.right));\n    }\n}\n```\n\nplease upvote if you like this ![leetcode] "
                    },
                    {
                        "username": "deredskoy",
                        "content": "Everyone is wondering why there is this question at all, but for one year of dev I never even encountered a problem with nodes. Usually it's baskets or smiley faces, this one is a bit more mature. I guess it's what is educated in the uni "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "True, I am a computer science major, and I have not been taught nodes/trees/graphs during my first year of college, Leetcode helped me learn what nodes and such are beforehand."
                    },
                    {
                        "username": "dilanekamga777",
                        "content": "The easiest problem on Tree"
                    },
                    {
                        "username": "Finesse",
                        "content": "Is there an easier problem on the whole LeetCode?\n\nUpdate: yes, it's 2235. Add Two Integers"
                    },
                    {
                        "username": "tomereli",
                        "content": "But no tree knowledge required to solve it.."
                    },
                    {
                        "username": "nadabao",
                        "content": "\\u7B80\\u5355\\u5230\\u8BA9\\u4EBA\\u6D41\\u6CEA\\uFF0C\\u597D\\u611F\\u4EBA\\u3002\\u3002\\u3002"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "\\u592A\\u96E3\\u4E86\\uFF0C\\u6211\\u4E0D\\u6703 : ("
                    }
                ]
            },
            {
                "id": 1925445,
                "content": [
                    {
                        "username": "charlessrze",
                        "content": " Why its not working...\\n`if(root[1] + root[2] == root[0]) return true;\\n    else return false;`"
                    },
                    {
                        "username": "At-sushi",
                        "content": "I think it is because the code lacks \".val\" after object statements. Reading them as an array is actually work for the result of C pointer trick (though I recommend to avoid this because the result is undefined)."
                    },
                    {
                        "username": "willima09",
                        "content": "[@jerryy147](/jerryy147) are you sure\\njs is declarative\\n"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "[@jerryy147](/jerryy147)  are you suggesting this solution for JS?"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "Because it\\'s not an array, root is a pointer"
                    },
                    {
                        "username": "jerryy147",
                        "content": "try root.val, root.left, and root.right"
                    },
                    {
                        "username": "rymoon",
                        "content": "It is not a list. Access properties via pointer."
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "Your code is meant to access the values of a list, but when I used console.log(typeof root), I saw that it is an object. Think of how you access the properties and values of an object."
                    },
                    {
                        "username": "EivindDelFierro",
                        "content": "On java script, when i console.log\\'d the input of function, it appeared like an array, but when i tried to convert it to string, it had an interesting output: the data structure that I was working with. From that output I was able to figure out the problem.."
                    },
                    {
                        "username": "Vladomira",
                        "content": "because it's not an array. In my case (TypeScript) every left side and every right side has own data: left side has own [value]- (its like independent node ) and also it has [left side] and [right side]. the same for right side. Every side can has own children.\nTry to console every element and type of it  and you will see"
                    },
                    {
                        "username": "niloufer_anjum",
                        "content": "It\\'s a TreeNode not a list. Try print(root) and solve from there."
                    },
                    {
                        "username": "rowe1227",
                        "content": "This question is much simpler than what one would expect to see in any interview setting.  \\n\\nThis is by design.  This problem and its [counterpart](https://leetcode.com/problems/add-two-integers/) will be used to help new LeetCode users become familiar with the platform and learn how to submit solutions.  \\n\\nAs many new LeetCode users will start at this problem, please feel free to share any advice you have for them below!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I feel as if this shouldn\\'t be an official problem; and if it is, that it be more findable to a new user. Just a suggestion. :) "
                    },
                    {
                        "username": "Universe_ldy",
                        "content": "Seriously? This is a real interview question?"
                    },
                    {
                        "username": "rparks52",
                        "content": "No, it\\'s not. It\\'s for learning how to use LeetCode for users that are not familiar with coding."
                    },
                    {
                        "username": "venka_",
                        "content": "For other noobs like me: pay attention to how to access structures using pointers, note that there are multiple pointers"
                    },
                    {
                        "username": "CoffeeCode247",
                        "content": "Why so many dislikes?? We all start from somewhere. Don\\'t forget that some of us WERE beginners at one point."
                    },
                    {
                        "username": "boo-m",
                        "content": "I do not understand the purpose of few of these problems\\n\\n[2235. Add Two Integers](https://leetcode.com/problems/add-two-integers/)\\n[2236. Root Equals Sum of Children](https://leetcode.com/problems/root-equals-sum-of-children/)\\n[1480. Running Sum of 1d Array](https://leetcode.com/problems/running-sum-of-1d-array/)\\n[1920. Build Array from Permutation](https://leetcode.com/problems/build-array-from-permutation/)\\n[1929. Concatenation of Array](https://leetcode.com/problems/concatenation-of-array/)\\n\\nPlease add to the list if you find any more easy problems.\\n"
                    },
                    {
                        "username": "hectorstestlab",
                        "content": "Its good for catching up on the programming logic again. I have been a Software QA Lead for almost 4 years now and I lost that, this is helping me."
                    },
                    {
                        "username": "mqberry",
                        "content": "It lowers the coding barrier to entry for new coders who may be coming to LC as a primary source of learning.  It is also hard to see what can be learned from simple problems like these when your experience and understanding far surpasses what these problems are testing you for.  :)"
                    },
                    {
                        "username": "denz1994",
                        "content": "It is good if you are teaching someone how to use the LC platform. Not really for interviews."
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of tree is more than two ?\nThen this will become a medium level problem;\n\nHere is the code for this question if height of tree was more than two!!\n\n```\nclass Solution {\npublic boolean checkTree(TreeNode root) {\nif(root==null) return true;\nif(root.left==null&&root.right==null)\n     return true;\n    int sum=0;\n     if(root.left!=null)\n      sum+=root.left.val;\n        \n      if(root.right!=null) \n      sum+=root.right.val;\n       \n        return\n(sum==root.val&&checkTree(root.left)&&checkTree(root.right));\n    }\n}\n```\n\nplease upvote if you like this ![leetcode] "
                    },
                    {
                        "username": "deredskoy",
                        "content": "Everyone is wondering why there is this question at all, but for one year of dev I never even encountered a problem with nodes. Usually it's baskets or smiley faces, this one is a bit more mature. I guess it's what is educated in the uni "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "True, I am a computer science major, and I have not been taught nodes/trees/graphs during my first year of college, Leetcode helped me learn what nodes and such are beforehand."
                    },
                    {
                        "username": "dilanekamga777",
                        "content": "The easiest problem on Tree"
                    },
                    {
                        "username": "Finesse",
                        "content": "Is there an easier problem on the whole LeetCode?\n\nUpdate: yes, it's 2235. Add Two Integers"
                    },
                    {
                        "username": "tomereli",
                        "content": "But no tree knowledge required to solve it.."
                    },
                    {
                        "username": "nadabao",
                        "content": "\\u7B80\\u5355\\u5230\\u8BA9\\u4EBA\\u6D41\\u6CEA\\uFF0C\\u597D\\u611F\\u4EBA\\u3002\\u3002\\u3002"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "\\u592A\\u96E3\\u4E86\\uFF0C\\u6211\\u4E0D\\u6703 : ("
                    }
                ]
            },
            {
                "id": 1570895,
                "content": [
                    {
                        "username": "charlessrze",
                        "content": " Why its not working...\\n`if(root[1] + root[2] == root[0]) return true;\\n    else return false;`"
                    },
                    {
                        "username": "At-sushi",
                        "content": "I think it is because the code lacks \".val\" after object statements. Reading them as an array is actually work for the result of C pointer trick (though I recommend to avoid this because the result is undefined)."
                    },
                    {
                        "username": "willima09",
                        "content": "[@jerryy147](/jerryy147) are you sure\\njs is declarative\\n"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "[@jerryy147](/jerryy147)  are you suggesting this solution for JS?"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "Because it\\'s not an array, root is a pointer"
                    },
                    {
                        "username": "jerryy147",
                        "content": "try root.val, root.left, and root.right"
                    },
                    {
                        "username": "rymoon",
                        "content": "It is not a list. Access properties via pointer."
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "Your code is meant to access the values of a list, but when I used console.log(typeof root), I saw that it is an object. Think of how you access the properties and values of an object."
                    },
                    {
                        "username": "EivindDelFierro",
                        "content": "On java script, when i console.log\\'d the input of function, it appeared like an array, but when i tried to convert it to string, it had an interesting output: the data structure that I was working with. From that output I was able to figure out the problem.."
                    },
                    {
                        "username": "Vladomira",
                        "content": "because it's not an array. In my case (TypeScript) every left side and every right side has own data: left side has own [value]- (its like independent node ) and also it has [left side] and [right side]. the same for right side. Every side can has own children.\nTry to console every element and type of it  and you will see"
                    },
                    {
                        "username": "niloufer_anjum",
                        "content": "It\\'s a TreeNode not a list. Try print(root) and solve from there."
                    },
                    {
                        "username": "rowe1227",
                        "content": "This question is much simpler than what one would expect to see in any interview setting.  \\n\\nThis is by design.  This problem and its [counterpart](https://leetcode.com/problems/add-two-integers/) will be used to help new LeetCode users become familiar with the platform and learn how to submit solutions.  \\n\\nAs many new LeetCode users will start at this problem, please feel free to share any advice you have for them below!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I feel as if this shouldn\\'t be an official problem; and if it is, that it be more findable to a new user. Just a suggestion. :) "
                    },
                    {
                        "username": "Universe_ldy",
                        "content": "Seriously? This is a real interview question?"
                    },
                    {
                        "username": "rparks52",
                        "content": "No, it\\'s not. It\\'s for learning how to use LeetCode for users that are not familiar with coding."
                    },
                    {
                        "username": "venka_",
                        "content": "For other noobs like me: pay attention to how to access structures using pointers, note that there are multiple pointers"
                    },
                    {
                        "username": "CoffeeCode247",
                        "content": "Why so many dislikes?? We all start from somewhere. Don\\'t forget that some of us WERE beginners at one point."
                    },
                    {
                        "username": "boo-m",
                        "content": "I do not understand the purpose of few of these problems\\n\\n[2235. Add Two Integers](https://leetcode.com/problems/add-two-integers/)\\n[2236. Root Equals Sum of Children](https://leetcode.com/problems/root-equals-sum-of-children/)\\n[1480. Running Sum of 1d Array](https://leetcode.com/problems/running-sum-of-1d-array/)\\n[1920. Build Array from Permutation](https://leetcode.com/problems/build-array-from-permutation/)\\n[1929. Concatenation of Array](https://leetcode.com/problems/concatenation-of-array/)\\n\\nPlease add to the list if you find any more easy problems.\\n"
                    },
                    {
                        "username": "hectorstestlab",
                        "content": "Its good for catching up on the programming logic again. I have been a Software QA Lead for almost 4 years now and I lost that, this is helping me."
                    },
                    {
                        "username": "mqberry",
                        "content": "It lowers the coding barrier to entry for new coders who may be coming to LC as a primary source of learning.  It is also hard to see what can be learned from simple problems like these when your experience and understanding far surpasses what these problems are testing you for.  :)"
                    },
                    {
                        "username": "denz1994",
                        "content": "It is good if you are teaching someone how to use the LC platform. Not really for interviews."
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of tree is more than two ?\nThen this will become a medium level problem;\n\nHere is the code for this question if height of tree was more than two!!\n\n```\nclass Solution {\npublic boolean checkTree(TreeNode root) {\nif(root==null) return true;\nif(root.left==null&&root.right==null)\n     return true;\n    int sum=0;\n     if(root.left!=null)\n      sum+=root.left.val;\n        \n      if(root.right!=null) \n      sum+=root.right.val;\n       \n        return\n(sum==root.val&&checkTree(root.left)&&checkTree(root.right));\n    }\n}\n```\n\nplease upvote if you like this ![leetcode] "
                    },
                    {
                        "username": "deredskoy",
                        "content": "Everyone is wondering why there is this question at all, but for one year of dev I never even encountered a problem with nodes. Usually it's baskets or smiley faces, this one is a bit more mature. I guess it's what is educated in the uni "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "True, I am a computer science major, and I have not been taught nodes/trees/graphs during my first year of college, Leetcode helped me learn what nodes and such are beforehand."
                    },
                    {
                        "username": "dilanekamga777",
                        "content": "The easiest problem on Tree"
                    },
                    {
                        "username": "Finesse",
                        "content": "Is there an easier problem on the whole LeetCode?\n\nUpdate: yes, it's 2235. Add Two Integers"
                    },
                    {
                        "username": "tomereli",
                        "content": "But no tree knowledge required to solve it.."
                    },
                    {
                        "username": "nadabao",
                        "content": "\\u7B80\\u5355\\u5230\\u8BA9\\u4EBA\\u6D41\\u6CEA\\uFF0C\\u597D\\u611F\\u4EBA\\u3002\\u3002\\u3002"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "\\u592A\\u96E3\\u4E86\\uFF0C\\u6211\\u4E0D\\u6703 : ("
                    }
                ]
            },
            {
                "id": 1861691,
                "content": [
                    {
                        "username": "charlessrze",
                        "content": " Why its not working...\\n`if(root[1] + root[2] == root[0]) return true;\\n    else return false;`"
                    },
                    {
                        "username": "At-sushi",
                        "content": "I think it is because the code lacks \".val\" after object statements. Reading them as an array is actually work for the result of C pointer trick (though I recommend to avoid this because the result is undefined)."
                    },
                    {
                        "username": "willima09",
                        "content": "[@jerryy147](/jerryy147) are you sure\\njs is declarative\\n"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "[@jerryy147](/jerryy147)  are you suggesting this solution for JS?"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "Because it\\'s not an array, root is a pointer"
                    },
                    {
                        "username": "jerryy147",
                        "content": "try root.val, root.left, and root.right"
                    },
                    {
                        "username": "rymoon",
                        "content": "It is not a list. Access properties via pointer."
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "Your code is meant to access the values of a list, but when I used console.log(typeof root), I saw that it is an object. Think of how you access the properties and values of an object."
                    },
                    {
                        "username": "EivindDelFierro",
                        "content": "On java script, when i console.log\\'d the input of function, it appeared like an array, but when i tried to convert it to string, it had an interesting output: the data structure that I was working with. From that output I was able to figure out the problem.."
                    },
                    {
                        "username": "Vladomira",
                        "content": "because it's not an array. In my case (TypeScript) every left side and every right side has own data: left side has own [value]- (its like independent node ) and also it has [left side] and [right side]. the same for right side. Every side can has own children.\nTry to console every element and type of it  and you will see"
                    },
                    {
                        "username": "niloufer_anjum",
                        "content": "It\\'s a TreeNode not a list. Try print(root) and solve from there."
                    },
                    {
                        "username": "rowe1227",
                        "content": "This question is much simpler than what one would expect to see in any interview setting.  \\n\\nThis is by design.  This problem and its [counterpart](https://leetcode.com/problems/add-two-integers/) will be used to help new LeetCode users become familiar with the platform and learn how to submit solutions.  \\n\\nAs many new LeetCode users will start at this problem, please feel free to share any advice you have for them below!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I feel as if this shouldn\\'t be an official problem; and if it is, that it be more findable to a new user. Just a suggestion. :) "
                    },
                    {
                        "username": "Universe_ldy",
                        "content": "Seriously? This is a real interview question?"
                    },
                    {
                        "username": "rparks52",
                        "content": "No, it\\'s not. It\\'s for learning how to use LeetCode for users that are not familiar with coding."
                    },
                    {
                        "username": "venka_",
                        "content": "For other noobs like me: pay attention to how to access structures using pointers, note that there are multiple pointers"
                    },
                    {
                        "username": "CoffeeCode247",
                        "content": "Why so many dislikes?? We all start from somewhere. Don\\'t forget that some of us WERE beginners at one point."
                    },
                    {
                        "username": "boo-m",
                        "content": "I do not understand the purpose of few of these problems\\n\\n[2235. Add Two Integers](https://leetcode.com/problems/add-two-integers/)\\n[2236. Root Equals Sum of Children](https://leetcode.com/problems/root-equals-sum-of-children/)\\n[1480. Running Sum of 1d Array](https://leetcode.com/problems/running-sum-of-1d-array/)\\n[1920. Build Array from Permutation](https://leetcode.com/problems/build-array-from-permutation/)\\n[1929. Concatenation of Array](https://leetcode.com/problems/concatenation-of-array/)\\n\\nPlease add to the list if you find any more easy problems.\\n"
                    },
                    {
                        "username": "hectorstestlab",
                        "content": "Its good for catching up on the programming logic again. I have been a Software QA Lead for almost 4 years now and I lost that, this is helping me."
                    },
                    {
                        "username": "mqberry",
                        "content": "It lowers the coding barrier to entry for new coders who may be coming to LC as a primary source of learning.  It is also hard to see what can be learned from simple problems like these when your experience and understanding far surpasses what these problems are testing you for.  :)"
                    },
                    {
                        "username": "denz1994",
                        "content": "It is good if you are teaching someone how to use the LC platform. Not really for interviews."
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of tree is more than two ?\nThen this will become a medium level problem;\n\nHere is the code for this question if height of tree was more than two!!\n\n```\nclass Solution {\npublic boolean checkTree(TreeNode root) {\nif(root==null) return true;\nif(root.left==null&&root.right==null)\n     return true;\n    int sum=0;\n     if(root.left!=null)\n      sum+=root.left.val;\n        \n      if(root.right!=null) \n      sum+=root.right.val;\n       \n        return\n(sum==root.val&&checkTree(root.left)&&checkTree(root.right));\n    }\n}\n```\n\nplease upvote if you like this ![leetcode] "
                    },
                    {
                        "username": "deredskoy",
                        "content": "Everyone is wondering why there is this question at all, but for one year of dev I never even encountered a problem with nodes. Usually it's baskets or smiley faces, this one is a bit more mature. I guess it's what is educated in the uni "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "True, I am a computer science major, and I have not been taught nodes/trees/graphs during my first year of college, Leetcode helped me learn what nodes and such are beforehand."
                    },
                    {
                        "username": "dilanekamga777",
                        "content": "The easiest problem on Tree"
                    },
                    {
                        "username": "Finesse",
                        "content": "Is there an easier problem on the whole LeetCode?\n\nUpdate: yes, it's 2235. Add Two Integers"
                    },
                    {
                        "username": "tomereli",
                        "content": "But no tree knowledge required to solve it.."
                    },
                    {
                        "username": "nadabao",
                        "content": "\\u7B80\\u5355\\u5230\\u8BA9\\u4EBA\\u6D41\\u6CEA\\uFF0C\\u597D\\u611F\\u4EBA\\u3002\\u3002\\u3002"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "\\u592A\\u96E3\\u4E86\\uFF0C\\u6211\\u4E0D\\u6703 : ("
                    }
                ]
            },
            {
                "id": 1726629,
                "content": [
                    {
                        "username": "charlessrze",
                        "content": " Why its not working...\\n`if(root[1] + root[2] == root[0]) return true;\\n    else return false;`"
                    },
                    {
                        "username": "At-sushi",
                        "content": "I think it is because the code lacks \".val\" after object statements. Reading them as an array is actually work for the result of C pointer trick (though I recommend to avoid this because the result is undefined)."
                    },
                    {
                        "username": "willima09",
                        "content": "[@jerryy147](/jerryy147) are you sure\\njs is declarative\\n"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "[@jerryy147](/jerryy147)  are you suggesting this solution for JS?"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "Because it\\'s not an array, root is a pointer"
                    },
                    {
                        "username": "jerryy147",
                        "content": "try root.val, root.left, and root.right"
                    },
                    {
                        "username": "rymoon",
                        "content": "It is not a list. Access properties via pointer."
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "Your code is meant to access the values of a list, but when I used console.log(typeof root), I saw that it is an object. Think of how you access the properties and values of an object."
                    },
                    {
                        "username": "EivindDelFierro",
                        "content": "On java script, when i console.log\\'d the input of function, it appeared like an array, but when i tried to convert it to string, it had an interesting output: the data structure that I was working with. From that output I was able to figure out the problem.."
                    },
                    {
                        "username": "Vladomira",
                        "content": "because it's not an array. In my case (TypeScript) every left side and every right side has own data: left side has own [value]- (its like independent node ) and also it has [left side] and [right side]. the same for right side. Every side can has own children.\nTry to console every element and type of it  and you will see"
                    },
                    {
                        "username": "niloufer_anjum",
                        "content": "It\\'s a TreeNode not a list. Try print(root) and solve from there."
                    },
                    {
                        "username": "rowe1227",
                        "content": "This question is much simpler than what one would expect to see in any interview setting.  \\n\\nThis is by design.  This problem and its [counterpart](https://leetcode.com/problems/add-two-integers/) will be used to help new LeetCode users become familiar with the platform and learn how to submit solutions.  \\n\\nAs many new LeetCode users will start at this problem, please feel free to share any advice you have for them below!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I feel as if this shouldn\\'t be an official problem; and if it is, that it be more findable to a new user. Just a suggestion. :) "
                    },
                    {
                        "username": "Universe_ldy",
                        "content": "Seriously? This is a real interview question?"
                    },
                    {
                        "username": "rparks52",
                        "content": "No, it\\'s not. It\\'s for learning how to use LeetCode for users that are not familiar with coding."
                    },
                    {
                        "username": "venka_",
                        "content": "For other noobs like me: pay attention to how to access structures using pointers, note that there are multiple pointers"
                    },
                    {
                        "username": "CoffeeCode247",
                        "content": "Why so many dislikes?? We all start from somewhere. Don\\'t forget that some of us WERE beginners at one point."
                    },
                    {
                        "username": "boo-m",
                        "content": "I do not understand the purpose of few of these problems\\n\\n[2235. Add Two Integers](https://leetcode.com/problems/add-two-integers/)\\n[2236. Root Equals Sum of Children](https://leetcode.com/problems/root-equals-sum-of-children/)\\n[1480. Running Sum of 1d Array](https://leetcode.com/problems/running-sum-of-1d-array/)\\n[1920. Build Array from Permutation](https://leetcode.com/problems/build-array-from-permutation/)\\n[1929. Concatenation of Array](https://leetcode.com/problems/concatenation-of-array/)\\n\\nPlease add to the list if you find any more easy problems.\\n"
                    },
                    {
                        "username": "hectorstestlab",
                        "content": "Its good for catching up on the programming logic again. I have been a Software QA Lead for almost 4 years now and I lost that, this is helping me."
                    },
                    {
                        "username": "mqberry",
                        "content": "It lowers the coding barrier to entry for new coders who may be coming to LC as a primary source of learning.  It is also hard to see what can be learned from simple problems like these when your experience and understanding far surpasses what these problems are testing you for.  :)"
                    },
                    {
                        "username": "denz1994",
                        "content": "It is good if you are teaching someone how to use the LC platform. Not really for interviews."
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of tree is more than two ?\nThen this will become a medium level problem;\n\nHere is the code for this question if height of tree was more than two!!\n\n```\nclass Solution {\npublic boolean checkTree(TreeNode root) {\nif(root==null) return true;\nif(root.left==null&&root.right==null)\n     return true;\n    int sum=0;\n     if(root.left!=null)\n      sum+=root.left.val;\n        \n      if(root.right!=null) \n      sum+=root.right.val;\n       \n        return\n(sum==root.val&&checkTree(root.left)&&checkTree(root.right));\n    }\n}\n```\n\nplease upvote if you like this ![leetcode] "
                    },
                    {
                        "username": "deredskoy",
                        "content": "Everyone is wondering why there is this question at all, but for one year of dev I never even encountered a problem with nodes. Usually it's baskets or smiley faces, this one is a bit more mature. I guess it's what is educated in the uni "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "True, I am a computer science major, and I have not been taught nodes/trees/graphs during my first year of college, Leetcode helped me learn what nodes and such are beforehand."
                    },
                    {
                        "username": "dilanekamga777",
                        "content": "The easiest problem on Tree"
                    },
                    {
                        "username": "Finesse",
                        "content": "Is there an easier problem on the whole LeetCode?\n\nUpdate: yes, it's 2235. Add Two Integers"
                    },
                    {
                        "username": "tomereli",
                        "content": "But no tree knowledge required to solve it.."
                    },
                    {
                        "username": "nadabao",
                        "content": "\\u7B80\\u5355\\u5230\\u8BA9\\u4EBA\\u6D41\\u6CEA\\uFF0C\\u597D\\u611F\\u4EBA\\u3002\\u3002\\u3002"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "\\u592A\\u96E3\\u4E86\\uFF0C\\u6211\\u4E0D\\u6703 : ("
                    }
                ]
            },
            {
                "id": 1698119,
                "content": [
                    {
                        "username": "charlessrze",
                        "content": " Why its not working...\\n`if(root[1] + root[2] == root[0]) return true;\\n    else return false;`"
                    },
                    {
                        "username": "At-sushi",
                        "content": "I think it is because the code lacks \".val\" after object statements. Reading them as an array is actually work for the result of C pointer trick (though I recommend to avoid this because the result is undefined)."
                    },
                    {
                        "username": "willima09",
                        "content": "[@jerryy147](/jerryy147) are you sure\\njs is declarative\\n"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "[@jerryy147](/jerryy147)  are you suggesting this solution for JS?"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "Because it\\'s not an array, root is a pointer"
                    },
                    {
                        "username": "jerryy147",
                        "content": "try root.val, root.left, and root.right"
                    },
                    {
                        "username": "rymoon",
                        "content": "It is not a list. Access properties via pointer."
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "Your code is meant to access the values of a list, but when I used console.log(typeof root), I saw that it is an object. Think of how you access the properties and values of an object."
                    },
                    {
                        "username": "EivindDelFierro",
                        "content": "On java script, when i console.log\\'d the input of function, it appeared like an array, but when i tried to convert it to string, it had an interesting output: the data structure that I was working with. From that output I was able to figure out the problem.."
                    },
                    {
                        "username": "Vladomira",
                        "content": "because it's not an array. In my case (TypeScript) every left side and every right side has own data: left side has own [value]- (its like independent node ) and also it has [left side] and [right side]. the same for right side. Every side can has own children.\nTry to console every element and type of it  and you will see"
                    },
                    {
                        "username": "niloufer_anjum",
                        "content": "It\\'s a TreeNode not a list. Try print(root) and solve from there."
                    },
                    {
                        "username": "rowe1227",
                        "content": "This question is much simpler than what one would expect to see in any interview setting.  \\n\\nThis is by design.  This problem and its [counterpart](https://leetcode.com/problems/add-two-integers/) will be used to help new LeetCode users become familiar with the platform and learn how to submit solutions.  \\n\\nAs many new LeetCode users will start at this problem, please feel free to share any advice you have for them below!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I feel as if this shouldn\\'t be an official problem; and if it is, that it be more findable to a new user. Just a suggestion. :) "
                    },
                    {
                        "username": "Universe_ldy",
                        "content": "Seriously? This is a real interview question?"
                    },
                    {
                        "username": "rparks52",
                        "content": "No, it\\'s not. It\\'s for learning how to use LeetCode for users that are not familiar with coding."
                    },
                    {
                        "username": "venka_",
                        "content": "For other noobs like me: pay attention to how to access structures using pointers, note that there are multiple pointers"
                    },
                    {
                        "username": "CoffeeCode247",
                        "content": "Why so many dislikes?? We all start from somewhere. Don\\'t forget that some of us WERE beginners at one point."
                    },
                    {
                        "username": "boo-m",
                        "content": "I do not understand the purpose of few of these problems\\n\\n[2235. Add Two Integers](https://leetcode.com/problems/add-two-integers/)\\n[2236. Root Equals Sum of Children](https://leetcode.com/problems/root-equals-sum-of-children/)\\n[1480. Running Sum of 1d Array](https://leetcode.com/problems/running-sum-of-1d-array/)\\n[1920. Build Array from Permutation](https://leetcode.com/problems/build-array-from-permutation/)\\n[1929. Concatenation of Array](https://leetcode.com/problems/concatenation-of-array/)\\n\\nPlease add to the list if you find any more easy problems.\\n"
                    },
                    {
                        "username": "hectorstestlab",
                        "content": "Its good for catching up on the programming logic again. I have been a Software QA Lead for almost 4 years now and I lost that, this is helping me."
                    },
                    {
                        "username": "mqberry",
                        "content": "It lowers the coding barrier to entry for new coders who may be coming to LC as a primary source of learning.  It is also hard to see what can be learned from simple problems like these when your experience and understanding far surpasses what these problems are testing you for.  :)"
                    },
                    {
                        "username": "denz1994",
                        "content": "It is good if you are teaching someone how to use the LC platform. Not really for interviews."
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of tree is more than two ?\nThen this will become a medium level problem;\n\nHere is the code for this question if height of tree was more than two!!\n\n```\nclass Solution {\npublic boolean checkTree(TreeNode root) {\nif(root==null) return true;\nif(root.left==null&&root.right==null)\n     return true;\n    int sum=0;\n     if(root.left!=null)\n      sum+=root.left.val;\n        \n      if(root.right!=null) \n      sum+=root.right.val;\n       \n        return\n(sum==root.val&&checkTree(root.left)&&checkTree(root.right));\n    }\n}\n```\n\nplease upvote if you like this ![leetcode] "
                    },
                    {
                        "username": "deredskoy",
                        "content": "Everyone is wondering why there is this question at all, but for one year of dev I never even encountered a problem with nodes. Usually it's baskets or smiley faces, this one is a bit more mature. I guess it's what is educated in the uni "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "True, I am a computer science major, and I have not been taught nodes/trees/graphs during my first year of college, Leetcode helped me learn what nodes and such are beforehand."
                    },
                    {
                        "username": "dilanekamga777",
                        "content": "The easiest problem on Tree"
                    },
                    {
                        "username": "Finesse",
                        "content": "Is there an easier problem on the whole LeetCode?\n\nUpdate: yes, it's 2235. Add Two Integers"
                    },
                    {
                        "username": "tomereli",
                        "content": "But no tree knowledge required to solve it.."
                    },
                    {
                        "username": "nadabao",
                        "content": "\\u7B80\\u5355\\u5230\\u8BA9\\u4EBA\\u6D41\\u6CEA\\uFF0C\\u597D\\u611F\\u4EBA\\u3002\\u3002\\u3002"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "\\u592A\\u96E3\\u4E86\\uFF0C\\u6211\\u4E0D\\u6703 : ("
                    }
                ]
            },
            {
                "id": 1576632,
                "content": [
                    {
                        "username": "charlessrze",
                        "content": " Why its not working...\\n`if(root[1] + root[2] == root[0]) return true;\\n    else return false;`"
                    },
                    {
                        "username": "At-sushi",
                        "content": "I think it is because the code lacks \".val\" after object statements. Reading them as an array is actually work for the result of C pointer trick (though I recommend to avoid this because the result is undefined)."
                    },
                    {
                        "username": "willima09",
                        "content": "[@jerryy147](/jerryy147) are you sure\\njs is declarative\\n"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "[@jerryy147](/jerryy147)  are you suggesting this solution for JS?"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "Because it\\'s not an array, root is a pointer"
                    },
                    {
                        "username": "jerryy147",
                        "content": "try root.val, root.left, and root.right"
                    },
                    {
                        "username": "rymoon",
                        "content": "It is not a list. Access properties via pointer."
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "Your code is meant to access the values of a list, but when I used console.log(typeof root), I saw that it is an object. Think of how you access the properties and values of an object."
                    },
                    {
                        "username": "EivindDelFierro",
                        "content": "On java script, when i console.log\\'d the input of function, it appeared like an array, but when i tried to convert it to string, it had an interesting output: the data structure that I was working with. From that output I was able to figure out the problem.."
                    },
                    {
                        "username": "Vladomira",
                        "content": "because it's not an array. In my case (TypeScript) every left side and every right side has own data: left side has own [value]- (its like independent node ) and also it has [left side] and [right side]. the same for right side. Every side can has own children.\nTry to console every element and type of it  and you will see"
                    },
                    {
                        "username": "niloufer_anjum",
                        "content": "It\\'s a TreeNode not a list. Try print(root) and solve from there."
                    },
                    {
                        "username": "rowe1227",
                        "content": "This question is much simpler than what one would expect to see in any interview setting.  \\n\\nThis is by design.  This problem and its [counterpart](https://leetcode.com/problems/add-two-integers/) will be used to help new LeetCode users become familiar with the platform and learn how to submit solutions.  \\n\\nAs many new LeetCode users will start at this problem, please feel free to share any advice you have for them below!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I feel as if this shouldn\\'t be an official problem; and if it is, that it be more findable to a new user. Just a suggestion. :) "
                    },
                    {
                        "username": "Universe_ldy",
                        "content": "Seriously? This is a real interview question?"
                    },
                    {
                        "username": "rparks52",
                        "content": "No, it\\'s not. It\\'s for learning how to use LeetCode for users that are not familiar with coding."
                    },
                    {
                        "username": "venka_",
                        "content": "For other noobs like me: pay attention to how to access structures using pointers, note that there are multiple pointers"
                    },
                    {
                        "username": "CoffeeCode247",
                        "content": "Why so many dislikes?? We all start from somewhere. Don\\'t forget that some of us WERE beginners at one point."
                    },
                    {
                        "username": "boo-m",
                        "content": "I do not understand the purpose of few of these problems\\n\\n[2235. Add Two Integers](https://leetcode.com/problems/add-two-integers/)\\n[2236. Root Equals Sum of Children](https://leetcode.com/problems/root-equals-sum-of-children/)\\n[1480. Running Sum of 1d Array](https://leetcode.com/problems/running-sum-of-1d-array/)\\n[1920. Build Array from Permutation](https://leetcode.com/problems/build-array-from-permutation/)\\n[1929. Concatenation of Array](https://leetcode.com/problems/concatenation-of-array/)\\n\\nPlease add to the list if you find any more easy problems.\\n"
                    },
                    {
                        "username": "hectorstestlab",
                        "content": "Its good for catching up on the programming logic again. I have been a Software QA Lead for almost 4 years now and I lost that, this is helping me."
                    },
                    {
                        "username": "mqberry",
                        "content": "It lowers the coding barrier to entry for new coders who may be coming to LC as a primary source of learning.  It is also hard to see what can be learned from simple problems like these when your experience and understanding far surpasses what these problems are testing you for.  :)"
                    },
                    {
                        "username": "denz1994",
                        "content": "It is good if you are teaching someone how to use the LC platform. Not really for interviews."
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of tree is more than two ?\nThen this will become a medium level problem;\n\nHere is the code for this question if height of tree was more than two!!\n\n```\nclass Solution {\npublic boolean checkTree(TreeNode root) {\nif(root==null) return true;\nif(root.left==null&&root.right==null)\n     return true;\n    int sum=0;\n     if(root.left!=null)\n      sum+=root.left.val;\n        \n      if(root.right!=null) \n      sum+=root.right.val;\n       \n        return\n(sum==root.val&&checkTree(root.left)&&checkTree(root.right));\n    }\n}\n```\n\nplease upvote if you like this ![leetcode] "
                    },
                    {
                        "username": "deredskoy",
                        "content": "Everyone is wondering why there is this question at all, but for one year of dev I never even encountered a problem with nodes. Usually it's baskets or smiley faces, this one is a bit more mature. I guess it's what is educated in the uni "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "True, I am a computer science major, and I have not been taught nodes/trees/graphs during my first year of college, Leetcode helped me learn what nodes and such are beforehand."
                    },
                    {
                        "username": "dilanekamga777",
                        "content": "The easiest problem on Tree"
                    },
                    {
                        "username": "Finesse",
                        "content": "Is there an easier problem on the whole LeetCode?\n\nUpdate: yes, it's 2235. Add Two Integers"
                    },
                    {
                        "username": "tomereli",
                        "content": "But no tree knowledge required to solve it.."
                    },
                    {
                        "username": "nadabao",
                        "content": "\\u7B80\\u5355\\u5230\\u8BA9\\u4EBA\\u6D41\\u6CEA\\uFF0C\\u597D\\u611F\\u4EBA\\u3002\\u3002\\u3002"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "\\u592A\\u96E3\\u4E86\\uFF0C\\u6211\\u4E0D\\u6703 : ("
                    }
                ]
            },
            {
                "id": 2047005,
                "content": [
                    {
                        "username": "load-a",
                        "content": "Important Information:\\nI\\'m using Ruby but hopefully this helps others too.\\n- The `root` input is not an array, it is an instance of the `TreeNode` class. Likewise, the other values in the array are also nodes. It should actually look something like this, in my opinion:\\n`TreeNode.new(X, TreeNode.new(Y, nil, nil), TreeNode.new(Z, nil, nil))`\\n- Because of the above hint, `val` can (and must) be called on the root node\\'s `left` and `right` values.\\n\\nThis feels like a pretty mean trick for a beginner question."
                    },
                    {
                        "username": "Mudi26",
                        "content": "Wow thanks, i just added .val to the right and left as you said, and then it worked lol"
                    },
                    {
                        "username": "cheuyin",
                        "content": "This question is too hard."
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "exactly"
                    },
                    {
                        "username": "HelloWorldfromMine",
                        "content": "what I told myself : \\n-the struc has2 pointers for children\\n-root points to struc TreeNode which starts at the beg of the 3 numbers given. [root, left child, right child]\\n\\nas a total beg, it helped me connect the dots so I hope it helps someone looking for help."
                    },
                    {
                        "username": "EzequielGil",
                        "content": "\"the struc has2 pointers for children\", this totally helped me to understand how to refer to the values of the childs. Thank you so much for sharing! :)"
                    },
                    {
                        "username": "cs_can",
                        "content": "idk if it is just me? \\nit should be tagged hard.. spent 2 days solving it after looking so many solutions still didnt get it completely"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "2 days ? I spent 200 light years finally I passed."
                    },
                    {
                        "username": "mazharkafi",
                        "content": "If you are scared of solving  `Tree` problems, you should start with this."
                    },
                    {
                        "username": "khemendra123b",
                        "content": "Too easy to get disliked"
                    },
                    {
                        "username": "heriwahyudianto",
                        "content": "how to console.log?"
                    },
                    {
                        "username": "eagerLearner21",
                        "content": "I think the definition for binary tree is incorrect which may cause a confusion I tried accessing value at left and right node by using root.left and root.right but I was unaware that those are of type TreeNode in python they should have explicitly told about this ( I think so I\\'m a noob if there is some naive mistake please explain me of my mistake instead of replying by harsh comments)\\n"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "This is the easiest tree problem on this website."
                    },
                    {
                        "username": "smamir",
                        "content": "Can someone please explain the struct TreeNode part that is commented out?   "
                    },
                    {
                        "username": "load-a",
                        "content": "don\\'t know what language you\\'re using but I just posted a tip that might help"
                    }
                ]
            },
            {
                "id": 1945995,
                "content": [
                    {
                        "username": "load-a",
                        "content": "Important Information:\\nI\\'m using Ruby but hopefully this helps others too.\\n- The `root` input is not an array, it is an instance of the `TreeNode` class. Likewise, the other values in the array are also nodes. It should actually look something like this, in my opinion:\\n`TreeNode.new(X, TreeNode.new(Y, nil, nil), TreeNode.new(Z, nil, nil))`\\n- Because of the above hint, `val` can (and must) be called on the root node\\'s `left` and `right` values.\\n\\nThis feels like a pretty mean trick for a beginner question."
                    },
                    {
                        "username": "Mudi26",
                        "content": "Wow thanks, i just added .val to the right and left as you said, and then it worked lol"
                    },
                    {
                        "username": "cheuyin",
                        "content": "This question is too hard."
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "exactly"
                    },
                    {
                        "username": "HelloWorldfromMine",
                        "content": "what I told myself : \\n-the struc has2 pointers for children\\n-root points to struc TreeNode which starts at the beg of the 3 numbers given. [root, left child, right child]\\n\\nas a total beg, it helped me connect the dots so I hope it helps someone looking for help."
                    },
                    {
                        "username": "EzequielGil",
                        "content": "\"the struc has2 pointers for children\", this totally helped me to understand how to refer to the values of the childs. Thank you so much for sharing! :)"
                    },
                    {
                        "username": "cs_can",
                        "content": "idk if it is just me? \\nit should be tagged hard.. spent 2 days solving it after looking so many solutions still didnt get it completely"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "2 days ? I spent 200 light years finally I passed."
                    },
                    {
                        "username": "mazharkafi",
                        "content": "If you are scared of solving  `Tree` problems, you should start with this."
                    },
                    {
                        "username": "khemendra123b",
                        "content": "Too easy to get disliked"
                    },
                    {
                        "username": "heriwahyudianto",
                        "content": "how to console.log?"
                    },
                    {
                        "username": "eagerLearner21",
                        "content": "I think the definition for binary tree is incorrect which may cause a confusion I tried accessing value at left and right node by using root.left and root.right but I was unaware that those are of type TreeNode in python they should have explicitly told about this ( I think so I\\'m a noob if there is some naive mistake please explain me of my mistake instead of replying by harsh comments)\\n"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "This is the easiest tree problem on this website."
                    },
                    {
                        "username": "smamir",
                        "content": "Can someone please explain the struct TreeNode part that is commented out?   "
                    },
                    {
                        "username": "load-a",
                        "content": "don\\'t know what language you\\'re using but I just posted a tip that might help"
                    }
                ]
            },
            {
                "id": 1737102,
                "content": [
                    {
                        "username": "load-a",
                        "content": "Important Information:\\nI\\'m using Ruby but hopefully this helps others too.\\n- The `root` input is not an array, it is an instance of the `TreeNode` class. Likewise, the other values in the array are also nodes. It should actually look something like this, in my opinion:\\n`TreeNode.new(X, TreeNode.new(Y, nil, nil), TreeNode.new(Z, nil, nil))`\\n- Because of the above hint, `val` can (and must) be called on the root node\\'s `left` and `right` values.\\n\\nThis feels like a pretty mean trick for a beginner question."
                    },
                    {
                        "username": "Mudi26",
                        "content": "Wow thanks, i just added .val to the right and left as you said, and then it worked lol"
                    },
                    {
                        "username": "cheuyin",
                        "content": "This question is too hard."
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "exactly"
                    },
                    {
                        "username": "HelloWorldfromMine",
                        "content": "what I told myself : \\n-the struc has2 pointers for children\\n-root points to struc TreeNode which starts at the beg of the 3 numbers given. [root, left child, right child]\\n\\nas a total beg, it helped me connect the dots so I hope it helps someone looking for help."
                    },
                    {
                        "username": "EzequielGil",
                        "content": "\"the struc has2 pointers for children\", this totally helped me to understand how to refer to the values of the childs. Thank you so much for sharing! :)"
                    },
                    {
                        "username": "cs_can",
                        "content": "idk if it is just me? \\nit should be tagged hard.. spent 2 days solving it after looking so many solutions still didnt get it completely"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "2 days ? I spent 200 light years finally I passed."
                    },
                    {
                        "username": "mazharkafi",
                        "content": "If you are scared of solving  `Tree` problems, you should start with this."
                    },
                    {
                        "username": "khemendra123b",
                        "content": "Too easy to get disliked"
                    },
                    {
                        "username": "heriwahyudianto",
                        "content": "how to console.log?"
                    },
                    {
                        "username": "eagerLearner21",
                        "content": "I think the definition for binary tree is incorrect which may cause a confusion I tried accessing value at left and right node by using root.left and root.right but I was unaware that those are of type TreeNode in python they should have explicitly told about this ( I think so I\\'m a noob if there is some naive mistake please explain me of my mistake instead of replying by harsh comments)\\n"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "This is the easiest tree problem on this website."
                    },
                    {
                        "username": "smamir",
                        "content": "Can someone please explain the struct TreeNode part that is commented out?   "
                    },
                    {
                        "username": "load-a",
                        "content": "don\\'t know what language you\\'re using but I just posted a tip that might help"
                    }
                ]
            },
            {
                "id": 2047791,
                "content": [
                    {
                        "username": "load-a",
                        "content": "Important Information:\\nI\\'m using Ruby but hopefully this helps others too.\\n- The `root` input is not an array, it is an instance of the `TreeNode` class. Likewise, the other values in the array are also nodes. It should actually look something like this, in my opinion:\\n`TreeNode.new(X, TreeNode.new(Y, nil, nil), TreeNode.new(Z, nil, nil))`\\n- Because of the above hint, `val` can (and must) be called on the root node\\'s `left` and `right` values.\\n\\nThis feels like a pretty mean trick for a beginner question."
                    },
                    {
                        "username": "Mudi26",
                        "content": "Wow thanks, i just added .val to the right and left as you said, and then it worked lol"
                    },
                    {
                        "username": "cheuyin",
                        "content": "This question is too hard."
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "exactly"
                    },
                    {
                        "username": "HelloWorldfromMine",
                        "content": "what I told myself : \\n-the struc has2 pointers for children\\n-root points to struc TreeNode which starts at the beg of the 3 numbers given. [root, left child, right child]\\n\\nas a total beg, it helped me connect the dots so I hope it helps someone looking for help."
                    },
                    {
                        "username": "EzequielGil",
                        "content": "\"the struc has2 pointers for children\", this totally helped me to understand how to refer to the values of the childs. Thank you so much for sharing! :)"
                    },
                    {
                        "username": "cs_can",
                        "content": "idk if it is just me? \\nit should be tagged hard.. spent 2 days solving it after looking so many solutions still didnt get it completely"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "2 days ? I spent 200 light years finally I passed."
                    },
                    {
                        "username": "mazharkafi",
                        "content": "If you are scared of solving  `Tree` problems, you should start with this."
                    },
                    {
                        "username": "khemendra123b",
                        "content": "Too easy to get disliked"
                    },
                    {
                        "username": "heriwahyudianto",
                        "content": "how to console.log?"
                    },
                    {
                        "username": "eagerLearner21",
                        "content": "I think the definition for binary tree is incorrect which may cause a confusion I tried accessing value at left and right node by using root.left and root.right but I was unaware that those are of type TreeNode in python they should have explicitly told about this ( I think so I\\'m a noob if there is some naive mistake please explain me of my mistake instead of replying by harsh comments)\\n"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "This is the easiest tree problem on this website."
                    },
                    {
                        "username": "smamir",
                        "content": "Can someone please explain the struct TreeNode part that is commented out?   "
                    },
                    {
                        "username": "load-a",
                        "content": "don\\'t know what language you\\'re using but I just posted a tip that might help"
                    }
                ]
            },
            {
                "id": 2001533,
                "content": [
                    {
                        "username": "load-a",
                        "content": "Important Information:\\nI\\'m using Ruby but hopefully this helps others too.\\n- The `root` input is not an array, it is an instance of the `TreeNode` class. Likewise, the other values in the array are also nodes. It should actually look something like this, in my opinion:\\n`TreeNode.new(X, TreeNode.new(Y, nil, nil), TreeNode.new(Z, nil, nil))`\\n- Because of the above hint, `val` can (and must) be called on the root node\\'s `left` and `right` values.\\n\\nThis feels like a pretty mean trick for a beginner question."
                    },
                    {
                        "username": "Mudi26",
                        "content": "Wow thanks, i just added .val to the right and left as you said, and then it worked lol"
                    },
                    {
                        "username": "cheuyin",
                        "content": "This question is too hard."
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "exactly"
                    },
                    {
                        "username": "HelloWorldfromMine",
                        "content": "what I told myself : \\n-the struc has2 pointers for children\\n-root points to struc TreeNode which starts at the beg of the 3 numbers given. [root, left child, right child]\\n\\nas a total beg, it helped me connect the dots so I hope it helps someone looking for help."
                    },
                    {
                        "username": "EzequielGil",
                        "content": "\"the struc has2 pointers for children\", this totally helped me to understand how to refer to the values of the childs. Thank you so much for sharing! :)"
                    },
                    {
                        "username": "cs_can",
                        "content": "idk if it is just me? \\nit should be tagged hard.. spent 2 days solving it after looking so many solutions still didnt get it completely"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "2 days ? I spent 200 light years finally I passed."
                    },
                    {
                        "username": "mazharkafi",
                        "content": "If you are scared of solving  `Tree` problems, you should start with this."
                    },
                    {
                        "username": "khemendra123b",
                        "content": "Too easy to get disliked"
                    },
                    {
                        "username": "heriwahyudianto",
                        "content": "how to console.log?"
                    },
                    {
                        "username": "eagerLearner21",
                        "content": "I think the definition for binary tree is incorrect which may cause a confusion I tried accessing value at left and right node by using root.left and root.right but I was unaware that those are of type TreeNode in python they should have explicitly told about this ( I think so I\\'m a noob if there is some naive mistake please explain me of my mistake instead of replying by harsh comments)\\n"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "This is the easiest tree problem on this website."
                    },
                    {
                        "username": "smamir",
                        "content": "Can someone please explain the struct TreeNode part that is commented out?   "
                    },
                    {
                        "username": "load-a",
                        "content": "don\\'t know what language you\\'re using but I just posted a tip that might help"
                    }
                ]
            },
            {
                "id": 1998810,
                "content": [
                    {
                        "username": "load-a",
                        "content": "Important Information:\\nI\\'m using Ruby but hopefully this helps others too.\\n- The `root` input is not an array, it is an instance of the `TreeNode` class. Likewise, the other values in the array are also nodes. It should actually look something like this, in my opinion:\\n`TreeNode.new(X, TreeNode.new(Y, nil, nil), TreeNode.new(Z, nil, nil))`\\n- Because of the above hint, `val` can (and must) be called on the root node\\'s `left` and `right` values.\\n\\nThis feels like a pretty mean trick for a beginner question."
                    },
                    {
                        "username": "Mudi26",
                        "content": "Wow thanks, i just added .val to the right and left as you said, and then it worked lol"
                    },
                    {
                        "username": "cheuyin",
                        "content": "This question is too hard."
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "exactly"
                    },
                    {
                        "username": "HelloWorldfromMine",
                        "content": "what I told myself : \\n-the struc has2 pointers for children\\n-root points to struc TreeNode which starts at the beg of the 3 numbers given. [root, left child, right child]\\n\\nas a total beg, it helped me connect the dots so I hope it helps someone looking for help."
                    },
                    {
                        "username": "EzequielGil",
                        "content": "\"the struc has2 pointers for children\", this totally helped me to understand how to refer to the values of the childs. Thank you so much for sharing! :)"
                    },
                    {
                        "username": "cs_can",
                        "content": "idk if it is just me? \\nit should be tagged hard.. spent 2 days solving it after looking so many solutions still didnt get it completely"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "2 days ? I spent 200 light years finally I passed."
                    },
                    {
                        "username": "mazharkafi",
                        "content": "If you are scared of solving  `Tree` problems, you should start with this."
                    },
                    {
                        "username": "khemendra123b",
                        "content": "Too easy to get disliked"
                    },
                    {
                        "username": "heriwahyudianto",
                        "content": "how to console.log?"
                    },
                    {
                        "username": "eagerLearner21",
                        "content": "I think the definition for binary tree is incorrect which may cause a confusion I tried accessing value at left and right node by using root.left and root.right but I was unaware that those are of type TreeNode in python they should have explicitly told about this ( I think so I\\'m a noob if there is some naive mistake please explain me of my mistake instead of replying by harsh comments)\\n"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "This is the easiest tree problem on this website."
                    },
                    {
                        "username": "smamir",
                        "content": "Can someone please explain the struct TreeNode part that is commented out?   "
                    },
                    {
                        "username": "load-a",
                        "content": "don\\'t know what language you\\'re using but I just posted a tip that might help"
                    }
                ]
            },
            {
                "id": 2058053,
                "content": [
                    {
                        "username": "load-a",
                        "content": "Important Information:\\nI\\'m using Ruby but hopefully this helps others too.\\n- The `root` input is not an array, it is an instance of the `TreeNode` class. Likewise, the other values in the array are also nodes. It should actually look something like this, in my opinion:\\n`TreeNode.new(X, TreeNode.new(Y, nil, nil), TreeNode.new(Z, nil, nil))`\\n- Because of the above hint, `val` can (and must) be called on the root node\\'s `left` and `right` values.\\n\\nThis feels like a pretty mean trick for a beginner question."
                    },
                    {
                        "username": "Mudi26",
                        "content": "Wow thanks, i just added .val to the right and left as you said, and then it worked lol"
                    },
                    {
                        "username": "cheuyin",
                        "content": "This question is too hard."
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "exactly"
                    },
                    {
                        "username": "HelloWorldfromMine",
                        "content": "what I told myself : \\n-the struc has2 pointers for children\\n-root points to struc TreeNode which starts at the beg of the 3 numbers given. [root, left child, right child]\\n\\nas a total beg, it helped me connect the dots so I hope it helps someone looking for help."
                    },
                    {
                        "username": "EzequielGil",
                        "content": "\"the struc has2 pointers for children\", this totally helped me to understand how to refer to the values of the childs. Thank you so much for sharing! :)"
                    },
                    {
                        "username": "cs_can",
                        "content": "idk if it is just me? \\nit should be tagged hard.. spent 2 days solving it after looking so many solutions still didnt get it completely"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "2 days ? I spent 200 light years finally I passed."
                    },
                    {
                        "username": "mazharkafi",
                        "content": "If you are scared of solving  `Tree` problems, you should start with this."
                    },
                    {
                        "username": "khemendra123b",
                        "content": "Too easy to get disliked"
                    },
                    {
                        "username": "heriwahyudianto",
                        "content": "how to console.log?"
                    },
                    {
                        "username": "eagerLearner21",
                        "content": "I think the definition for binary tree is incorrect which may cause a confusion I tried accessing value at left and right node by using root.left and root.right but I was unaware that those are of type TreeNode in python they should have explicitly told about this ( I think so I\\'m a noob if there is some naive mistake please explain me of my mistake instead of replying by harsh comments)\\n"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "This is the easiest tree problem on this website."
                    },
                    {
                        "username": "smamir",
                        "content": "Can someone please explain the struct TreeNode part that is commented out?   "
                    },
                    {
                        "username": "load-a",
                        "content": "don\\'t know what language you\\'re using but I just posted a tip that might help"
                    }
                ]
            },
            {
                "id": 2051470,
                "content": [
                    {
                        "username": "load-a",
                        "content": "Important Information:\\nI\\'m using Ruby but hopefully this helps others too.\\n- The `root` input is not an array, it is an instance of the `TreeNode` class. Likewise, the other values in the array are also nodes. It should actually look something like this, in my opinion:\\n`TreeNode.new(X, TreeNode.new(Y, nil, nil), TreeNode.new(Z, nil, nil))`\\n- Because of the above hint, `val` can (and must) be called on the root node\\'s `left` and `right` values.\\n\\nThis feels like a pretty mean trick for a beginner question."
                    },
                    {
                        "username": "Mudi26",
                        "content": "Wow thanks, i just added .val to the right and left as you said, and then it worked lol"
                    },
                    {
                        "username": "cheuyin",
                        "content": "This question is too hard."
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "exactly"
                    },
                    {
                        "username": "HelloWorldfromMine",
                        "content": "what I told myself : \\n-the struc has2 pointers for children\\n-root points to struc TreeNode which starts at the beg of the 3 numbers given. [root, left child, right child]\\n\\nas a total beg, it helped me connect the dots so I hope it helps someone looking for help."
                    },
                    {
                        "username": "EzequielGil",
                        "content": "\"the struc has2 pointers for children\", this totally helped me to understand how to refer to the values of the childs. Thank you so much for sharing! :)"
                    },
                    {
                        "username": "cs_can",
                        "content": "idk if it is just me? \\nit should be tagged hard.. spent 2 days solving it after looking so many solutions still didnt get it completely"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "2 days ? I spent 200 light years finally I passed."
                    },
                    {
                        "username": "mazharkafi",
                        "content": "If you are scared of solving  `Tree` problems, you should start with this."
                    },
                    {
                        "username": "khemendra123b",
                        "content": "Too easy to get disliked"
                    },
                    {
                        "username": "heriwahyudianto",
                        "content": "how to console.log?"
                    },
                    {
                        "username": "eagerLearner21",
                        "content": "I think the definition for binary tree is incorrect which may cause a confusion I tried accessing value at left and right node by using root.left and root.right but I was unaware that those are of type TreeNode in python they should have explicitly told about this ( I think so I\\'m a noob if there is some naive mistake please explain me of my mistake instead of replying by harsh comments)\\n"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "This is the easiest tree problem on this website."
                    },
                    {
                        "username": "smamir",
                        "content": "Can someone please explain the struct TreeNode part that is commented out?   "
                    },
                    {
                        "username": "load-a",
                        "content": "don\\'t know what language you\\'re using but I just posted a tip that might help"
                    }
                ]
            },
            {
                "id": 2046940,
                "content": [
                    {
                        "username": "load-a",
                        "content": "Important Information:\\nI\\'m using Ruby but hopefully this helps others too.\\n- The `root` input is not an array, it is an instance of the `TreeNode` class. Likewise, the other values in the array are also nodes. It should actually look something like this, in my opinion:\\n`TreeNode.new(X, TreeNode.new(Y, nil, nil), TreeNode.new(Z, nil, nil))`\\n- Because of the above hint, `val` can (and must) be called on the root node\\'s `left` and `right` values.\\n\\nThis feels like a pretty mean trick for a beginner question."
                    },
                    {
                        "username": "Mudi26",
                        "content": "Wow thanks, i just added .val to the right and left as you said, and then it worked lol"
                    },
                    {
                        "username": "cheuyin",
                        "content": "This question is too hard."
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "exactly"
                    },
                    {
                        "username": "HelloWorldfromMine",
                        "content": "what I told myself : \\n-the struc has2 pointers for children\\n-root points to struc TreeNode which starts at the beg of the 3 numbers given. [root, left child, right child]\\n\\nas a total beg, it helped me connect the dots so I hope it helps someone looking for help."
                    },
                    {
                        "username": "EzequielGil",
                        "content": "\"the struc has2 pointers for children\", this totally helped me to understand how to refer to the values of the childs. Thank you so much for sharing! :)"
                    },
                    {
                        "username": "cs_can",
                        "content": "idk if it is just me? \\nit should be tagged hard.. spent 2 days solving it after looking so many solutions still didnt get it completely"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "2 days ? I spent 200 light years finally I passed."
                    },
                    {
                        "username": "mazharkafi",
                        "content": "If you are scared of solving  `Tree` problems, you should start with this."
                    },
                    {
                        "username": "khemendra123b",
                        "content": "Too easy to get disliked"
                    },
                    {
                        "username": "heriwahyudianto",
                        "content": "how to console.log?"
                    },
                    {
                        "username": "eagerLearner21",
                        "content": "I think the definition for binary tree is incorrect which may cause a confusion I tried accessing value at left and right node by using root.left and root.right but I was unaware that those are of type TreeNode in python they should have explicitly told about this ( I think so I\\'m a noob if there is some naive mistake please explain me of my mistake instead of replying by harsh comments)\\n"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "This is the easiest tree problem on this website."
                    },
                    {
                        "username": "smamir",
                        "content": "Can someone please explain the struct TreeNode part that is commented out?   "
                    },
                    {
                        "username": "load-a",
                        "content": "don\\'t know what language you\\'re using but I just posted a tip that might help"
                    }
                ]
            },
            {
                "id": 2046108,
                "content": [
                    {
                        "username": "load-a",
                        "content": "Important Information:\\nI\\'m using Ruby but hopefully this helps others too.\\n- The `root` input is not an array, it is an instance of the `TreeNode` class. Likewise, the other values in the array are also nodes. It should actually look something like this, in my opinion:\\n`TreeNode.new(X, TreeNode.new(Y, nil, nil), TreeNode.new(Z, nil, nil))`\\n- Because of the above hint, `val` can (and must) be called on the root node\\'s `left` and `right` values.\\n\\nThis feels like a pretty mean trick for a beginner question."
                    },
                    {
                        "username": "Mudi26",
                        "content": "Wow thanks, i just added .val to the right and left as you said, and then it worked lol"
                    },
                    {
                        "username": "cheuyin",
                        "content": "This question is too hard."
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "exactly"
                    },
                    {
                        "username": "HelloWorldfromMine",
                        "content": "what I told myself : \\n-the struc has2 pointers for children\\n-root points to struc TreeNode which starts at the beg of the 3 numbers given. [root, left child, right child]\\n\\nas a total beg, it helped me connect the dots so I hope it helps someone looking for help."
                    },
                    {
                        "username": "EzequielGil",
                        "content": "\"the struc has2 pointers for children\", this totally helped me to understand how to refer to the values of the childs. Thank you so much for sharing! :)"
                    },
                    {
                        "username": "cs_can",
                        "content": "idk if it is just me? \\nit should be tagged hard.. spent 2 days solving it after looking so many solutions still didnt get it completely"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "2 days ? I spent 200 light years finally I passed."
                    },
                    {
                        "username": "mazharkafi",
                        "content": "If you are scared of solving  `Tree` problems, you should start with this."
                    },
                    {
                        "username": "khemendra123b",
                        "content": "Too easy to get disliked"
                    },
                    {
                        "username": "heriwahyudianto",
                        "content": "how to console.log?"
                    },
                    {
                        "username": "eagerLearner21",
                        "content": "I think the definition for binary tree is incorrect which may cause a confusion I tried accessing value at left and right node by using root.left and root.right but I was unaware that those are of type TreeNode in python they should have explicitly told about this ( I think so I\\'m a noob if there is some naive mistake please explain me of my mistake instead of replying by harsh comments)\\n"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "This is the easiest tree problem on this website."
                    },
                    {
                        "username": "smamir",
                        "content": "Can someone please explain the struct TreeNode part that is commented out?   "
                    },
                    {
                        "username": "load-a",
                        "content": "don\\'t know what language you\\'re using but I just posted a tip that might help"
                    }
                ]
            },
            {
                "id": 1997803,
                "content": [
                    {
                        "username": "lazlo2024",
                        "content": "I got a long way to go, this was rocket science to me."
                    },
                    {
                        "username": "MJ12_Believer",
                        "content": "IMO this is a really good intro binary trees. In my data structures class we focused a lot on theory and barely on implementation so this was a really good jumping off point for me."
                    },
                    {
                        "username": "JohnGiorgi",
                        "content": "Is there a reason the `root` argument to `checkTree` is type hinted as `Optional` in `Python3`?"
                    },
                    {
                        "username": "daddyunluck",
                        "content": "bro i searched children sum property leetcode and i got this, i\\'m not complaining tho."
                    },
                    {
                        "username": "kleinodergross",
                        "content": "Hello! Why this solution doesn't work?\n\n`bool checkTree(struct TreeNode* root){\n    if ((root->left + root->right) == root->val)}\n        return true;\n    } else {\n        return false;\n    }\n}` "
                    },
                    {
                        "username": "anonode",
                        "content": "Here is the corrected version of your code:\n```clang\nbool checkTree(struct TreeNode* root){ \n    if((root->left->val + root->right->val) == root->val){ return true;}\n     else { return false; } \n    }\n```\n\nThe reason why your solution doesn't work is because you are not accessing the values associated with root's child nodes. You were close by attempting to access with `root->left` and `root->right`. However, in order to access the *val* attribute of, for instance, root's left child, you must use `root->left->val`. \n\nThere was also a curly brace facing the wrong direction at the end of your if-statement. This generated one of the errors.\n\nAdditionally, the necessary code could have been condensed to one line without the use of an if-else statement:\n```c\nbool checkTree(struct TreeNode* root){\n    return root->val == (root->left->val + root->right->val);\n}\n```\n\nHere is a link to a markdown guide for leetcode that made the formatting of this comment possible: https://leetcode.com/discuss/general-discussion/1560831/markdown-reference-for-leetcode-formatting-cheatsheet\n\nBest of luck to you on your coding journey, [@Alfiya](/kleinodergross)!\n\n"
                    },
                    {
                        "username": "jerryy147",
                        "content": "despite the fact that this is the easiest question ever, this is also my first time using binary trees, so i got the question wrong once. That means it is officially harder than some other medium questions that i get first try"
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of Binary tree was more than two?\\n\\nhere the code for height more than two: https://leetcode.com/problems/root-equals-sum-of-children/solutions/3410421/what-if-the-height-of-the-tree-was-more-than-two/"
                    },
                    {
                        "username": "dhruvil2511",
                        "content": "wtf is this"
                    },
                    {
                        "username": "itzRAYY",
                        "content": " public boolean checkTree(TreeNode root) {\\n        return root.val == sumNodes(root,true);\\n    }\\n    public int sumNodes(TreeNode node,boolean root){\\n        if(node==null){\\n            return 0;\\n        }\\n        return root==false?node.val+sumNodes(node.left,false)+sumNodes(node.right,false):sumNodes(node.left,false)+sumNodes(node.right,false);\\n    }"
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "Can someone tell me what happens if there is more then n nodes and we have to check for all of them ?"
                    },
                    {
                        "username": "Jeyko28",
                        "content": "I suppose that as in the first part made"
                    }
                ]
            },
            {
                "id": 1991957,
                "content": [
                    {
                        "username": "lazlo2024",
                        "content": "I got a long way to go, this was rocket science to me."
                    },
                    {
                        "username": "MJ12_Believer",
                        "content": "IMO this is a really good intro binary trees. In my data structures class we focused a lot on theory and barely on implementation so this was a really good jumping off point for me."
                    },
                    {
                        "username": "JohnGiorgi",
                        "content": "Is there a reason the `root` argument to `checkTree` is type hinted as `Optional` in `Python3`?"
                    },
                    {
                        "username": "daddyunluck",
                        "content": "bro i searched children sum property leetcode and i got this, i\\'m not complaining tho."
                    },
                    {
                        "username": "kleinodergross",
                        "content": "Hello! Why this solution doesn't work?\n\n`bool checkTree(struct TreeNode* root){\n    if ((root->left + root->right) == root->val)}\n        return true;\n    } else {\n        return false;\n    }\n}` "
                    },
                    {
                        "username": "anonode",
                        "content": "Here is the corrected version of your code:\n```clang\nbool checkTree(struct TreeNode* root){ \n    if((root->left->val + root->right->val) == root->val){ return true;}\n     else { return false; } \n    }\n```\n\nThe reason why your solution doesn't work is because you are not accessing the values associated with root's child nodes. You were close by attempting to access with `root->left` and `root->right`. However, in order to access the *val* attribute of, for instance, root's left child, you must use `root->left->val`. \n\nThere was also a curly brace facing the wrong direction at the end of your if-statement. This generated one of the errors.\n\nAdditionally, the necessary code could have been condensed to one line without the use of an if-else statement:\n```c\nbool checkTree(struct TreeNode* root){\n    return root->val == (root->left->val + root->right->val);\n}\n```\n\nHere is a link to a markdown guide for leetcode that made the formatting of this comment possible: https://leetcode.com/discuss/general-discussion/1560831/markdown-reference-for-leetcode-formatting-cheatsheet\n\nBest of luck to you on your coding journey, [@Alfiya](/kleinodergross)!\n\n"
                    },
                    {
                        "username": "jerryy147",
                        "content": "despite the fact that this is the easiest question ever, this is also my first time using binary trees, so i got the question wrong once. That means it is officially harder than some other medium questions that i get first try"
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of Binary tree was more than two?\\n\\nhere the code for height more than two: https://leetcode.com/problems/root-equals-sum-of-children/solutions/3410421/what-if-the-height-of-the-tree-was-more-than-two/"
                    },
                    {
                        "username": "dhruvil2511",
                        "content": "wtf is this"
                    },
                    {
                        "username": "itzRAYY",
                        "content": " public boolean checkTree(TreeNode root) {\\n        return root.val == sumNodes(root,true);\\n    }\\n    public int sumNodes(TreeNode node,boolean root){\\n        if(node==null){\\n            return 0;\\n        }\\n        return root==false?node.val+sumNodes(node.left,false)+sumNodes(node.right,false):sumNodes(node.left,false)+sumNodes(node.right,false);\\n    }"
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "Can someone tell me what happens if there is more then n nodes and we have to check for all of them ?"
                    },
                    {
                        "username": "Jeyko28",
                        "content": "I suppose that as in the first part made"
                    }
                ]
            },
            {
                "id": 1990410,
                "content": [
                    {
                        "username": "lazlo2024",
                        "content": "I got a long way to go, this was rocket science to me."
                    },
                    {
                        "username": "MJ12_Believer",
                        "content": "IMO this is a really good intro binary trees. In my data structures class we focused a lot on theory and barely on implementation so this was a really good jumping off point for me."
                    },
                    {
                        "username": "JohnGiorgi",
                        "content": "Is there a reason the `root` argument to `checkTree` is type hinted as `Optional` in `Python3`?"
                    },
                    {
                        "username": "daddyunluck",
                        "content": "bro i searched children sum property leetcode and i got this, i\\'m not complaining tho."
                    },
                    {
                        "username": "kleinodergross",
                        "content": "Hello! Why this solution doesn't work?\n\n`bool checkTree(struct TreeNode* root){\n    if ((root->left + root->right) == root->val)}\n        return true;\n    } else {\n        return false;\n    }\n}` "
                    },
                    {
                        "username": "anonode",
                        "content": "Here is the corrected version of your code:\n```clang\nbool checkTree(struct TreeNode* root){ \n    if((root->left->val + root->right->val) == root->val){ return true;}\n     else { return false; } \n    }\n```\n\nThe reason why your solution doesn't work is because you are not accessing the values associated with root's child nodes. You were close by attempting to access with `root->left` and `root->right`. However, in order to access the *val* attribute of, for instance, root's left child, you must use `root->left->val`. \n\nThere was also a curly brace facing the wrong direction at the end of your if-statement. This generated one of the errors.\n\nAdditionally, the necessary code could have been condensed to one line without the use of an if-else statement:\n```c\nbool checkTree(struct TreeNode* root){\n    return root->val == (root->left->val + root->right->val);\n}\n```\n\nHere is a link to a markdown guide for leetcode that made the formatting of this comment possible: https://leetcode.com/discuss/general-discussion/1560831/markdown-reference-for-leetcode-formatting-cheatsheet\n\nBest of luck to you on your coding journey, [@Alfiya](/kleinodergross)!\n\n"
                    },
                    {
                        "username": "jerryy147",
                        "content": "despite the fact that this is the easiest question ever, this is also my first time using binary trees, so i got the question wrong once. That means it is officially harder than some other medium questions that i get first try"
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of Binary tree was more than two?\\n\\nhere the code for height more than two: https://leetcode.com/problems/root-equals-sum-of-children/solutions/3410421/what-if-the-height-of-the-tree-was-more-than-two/"
                    },
                    {
                        "username": "dhruvil2511",
                        "content": "wtf is this"
                    },
                    {
                        "username": "itzRAYY",
                        "content": " public boolean checkTree(TreeNode root) {\\n        return root.val == sumNodes(root,true);\\n    }\\n    public int sumNodes(TreeNode node,boolean root){\\n        if(node==null){\\n            return 0;\\n        }\\n        return root==false?node.val+sumNodes(node.left,false)+sumNodes(node.right,false):sumNodes(node.left,false)+sumNodes(node.right,false);\\n    }"
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "Can someone tell me what happens if there is more then n nodes and we have to check for all of them ?"
                    },
                    {
                        "username": "Jeyko28",
                        "content": "I suppose that as in the first part made"
                    }
                ]
            },
            {
                "id": 1936881,
                "content": [
                    {
                        "username": "lazlo2024",
                        "content": "I got a long way to go, this was rocket science to me."
                    },
                    {
                        "username": "MJ12_Believer",
                        "content": "IMO this is a really good intro binary trees. In my data structures class we focused a lot on theory and barely on implementation so this was a really good jumping off point for me."
                    },
                    {
                        "username": "JohnGiorgi",
                        "content": "Is there a reason the `root` argument to `checkTree` is type hinted as `Optional` in `Python3`?"
                    },
                    {
                        "username": "daddyunluck",
                        "content": "bro i searched children sum property leetcode and i got this, i\\'m not complaining tho."
                    },
                    {
                        "username": "kleinodergross",
                        "content": "Hello! Why this solution doesn't work?\n\n`bool checkTree(struct TreeNode* root){\n    if ((root->left + root->right) == root->val)}\n        return true;\n    } else {\n        return false;\n    }\n}` "
                    },
                    {
                        "username": "anonode",
                        "content": "Here is the corrected version of your code:\n```clang\nbool checkTree(struct TreeNode* root){ \n    if((root->left->val + root->right->val) == root->val){ return true;}\n     else { return false; } \n    }\n```\n\nThe reason why your solution doesn't work is because you are not accessing the values associated with root's child nodes. You were close by attempting to access with `root->left` and `root->right`. However, in order to access the *val* attribute of, for instance, root's left child, you must use `root->left->val`. \n\nThere was also a curly brace facing the wrong direction at the end of your if-statement. This generated one of the errors.\n\nAdditionally, the necessary code could have been condensed to one line without the use of an if-else statement:\n```c\nbool checkTree(struct TreeNode* root){\n    return root->val == (root->left->val + root->right->val);\n}\n```\n\nHere is a link to a markdown guide for leetcode that made the formatting of this comment possible: https://leetcode.com/discuss/general-discussion/1560831/markdown-reference-for-leetcode-formatting-cheatsheet\n\nBest of luck to you on your coding journey, [@Alfiya](/kleinodergross)!\n\n"
                    },
                    {
                        "username": "jerryy147",
                        "content": "despite the fact that this is the easiest question ever, this is also my first time using binary trees, so i got the question wrong once. That means it is officially harder than some other medium questions that i get first try"
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of Binary tree was more than two?\\n\\nhere the code for height more than two: https://leetcode.com/problems/root-equals-sum-of-children/solutions/3410421/what-if-the-height-of-the-tree-was-more-than-two/"
                    },
                    {
                        "username": "dhruvil2511",
                        "content": "wtf is this"
                    },
                    {
                        "username": "itzRAYY",
                        "content": " public boolean checkTree(TreeNode root) {\\n        return root.val == sumNodes(root,true);\\n    }\\n    public int sumNodes(TreeNode node,boolean root){\\n        if(node==null){\\n            return 0;\\n        }\\n        return root==false?node.val+sumNodes(node.left,false)+sumNodes(node.right,false):sumNodes(node.left,false)+sumNodes(node.right,false);\\n    }"
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "Can someone tell me what happens if there is more then n nodes and we have to check for all of them ?"
                    },
                    {
                        "username": "Jeyko28",
                        "content": "I suppose that as in the first part made"
                    }
                ]
            },
            {
                "id": 1926382,
                "content": [
                    {
                        "username": "lazlo2024",
                        "content": "I got a long way to go, this was rocket science to me."
                    },
                    {
                        "username": "MJ12_Believer",
                        "content": "IMO this is a really good intro binary trees. In my data structures class we focused a lot on theory and barely on implementation so this was a really good jumping off point for me."
                    },
                    {
                        "username": "JohnGiorgi",
                        "content": "Is there a reason the `root` argument to `checkTree` is type hinted as `Optional` in `Python3`?"
                    },
                    {
                        "username": "daddyunluck",
                        "content": "bro i searched children sum property leetcode and i got this, i\\'m not complaining tho."
                    },
                    {
                        "username": "kleinodergross",
                        "content": "Hello! Why this solution doesn't work?\n\n`bool checkTree(struct TreeNode* root){\n    if ((root->left + root->right) == root->val)}\n        return true;\n    } else {\n        return false;\n    }\n}` "
                    },
                    {
                        "username": "anonode",
                        "content": "Here is the corrected version of your code:\n```clang\nbool checkTree(struct TreeNode* root){ \n    if((root->left->val + root->right->val) == root->val){ return true;}\n     else { return false; } \n    }\n```\n\nThe reason why your solution doesn't work is because you are not accessing the values associated with root's child nodes. You were close by attempting to access with `root->left` and `root->right`. However, in order to access the *val* attribute of, for instance, root's left child, you must use `root->left->val`. \n\nThere was also a curly brace facing the wrong direction at the end of your if-statement. This generated one of the errors.\n\nAdditionally, the necessary code could have been condensed to one line without the use of an if-else statement:\n```c\nbool checkTree(struct TreeNode* root){\n    return root->val == (root->left->val + root->right->val);\n}\n```\n\nHere is a link to a markdown guide for leetcode that made the formatting of this comment possible: https://leetcode.com/discuss/general-discussion/1560831/markdown-reference-for-leetcode-formatting-cheatsheet\n\nBest of luck to you on your coding journey, [@Alfiya](/kleinodergross)!\n\n"
                    },
                    {
                        "username": "jerryy147",
                        "content": "despite the fact that this is the easiest question ever, this is also my first time using binary trees, so i got the question wrong once. That means it is officially harder than some other medium questions that i get first try"
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of Binary tree was more than two?\\n\\nhere the code for height more than two: https://leetcode.com/problems/root-equals-sum-of-children/solutions/3410421/what-if-the-height-of-the-tree-was-more-than-two/"
                    },
                    {
                        "username": "dhruvil2511",
                        "content": "wtf is this"
                    },
                    {
                        "username": "itzRAYY",
                        "content": " public boolean checkTree(TreeNode root) {\\n        return root.val == sumNodes(root,true);\\n    }\\n    public int sumNodes(TreeNode node,boolean root){\\n        if(node==null){\\n            return 0;\\n        }\\n        return root==false?node.val+sumNodes(node.left,false)+sumNodes(node.right,false):sumNodes(node.left,false)+sumNodes(node.right,false);\\n    }"
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "Can someone tell me what happens if there is more then n nodes and we have to check for all of them ?"
                    },
                    {
                        "username": "Jeyko28",
                        "content": "I suppose that as in the first part made"
                    }
                ]
            },
            {
                "id": 1922463,
                "content": [
                    {
                        "username": "lazlo2024",
                        "content": "I got a long way to go, this was rocket science to me."
                    },
                    {
                        "username": "MJ12_Believer",
                        "content": "IMO this is a really good intro binary trees. In my data structures class we focused a lot on theory and barely on implementation so this was a really good jumping off point for me."
                    },
                    {
                        "username": "JohnGiorgi",
                        "content": "Is there a reason the `root` argument to `checkTree` is type hinted as `Optional` in `Python3`?"
                    },
                    {
                        "username": "daddyunluck",
                        "content": "bro i searched children sum property leetcode and i got this, i\\'m not complaining tho."
                    },
                    {
                        "username": "kleinodergross",
                        "content": "Hello! Why this solution doesn't work?\n\n`bool checkTree(struct TreeNode* root){\n    if ((root->left + root->right) == root->val)}\n        return true;\n    } else {\n        return false;\n    }\n}` "
                    },
                    {
                        "username": "anonode",
                        "content": "Here is the corrected version of your code:\n```clang\nbool checkTree(struct TreeNode* root){ \n    if((root->left->val + root->right->val) == root->val){ return true;}\n     else { return false; } \n    }\n```\n\nThe reason why your solution doesn't work is because you are not accessing the values associated with root's child nodes. You were close by attempting to access with `root->left` and `root->right`. However, in order to access the *val* attribute of, for instance, root's left child, you must use `root->left->val`. \n\nThere was also a curly brace facing the wrong direction at the end of your if-statement. This generated one of the errors.\n\nAdditionally, the necessary code could have been condensed to one line without the use of an if-else statement:\n```c\nbool checkTree(struct TreeNode* root){\n    return root->val == (root->left->val + root->right->val);\n}\n```\n\nHere is a link to a markdown guide for leetcode that made the formatting of this comment possible: https://leetcode.com/discuss/general-discussion/1560831/markdown-reference-for-leetcode-formatting-cheatsheet\n\nBest of luck to you on your coding journey, [@Alfiya](/kleinodergross)!\n\n"
                    },
                    {
                        "username": "jerryy147",
                        "content": "despite the fact that this is the easiest question ever, this is also my first time using binary trees, so i got the question wrong once. That means it is officially harder than some other medium questions that i get first try"
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of Binary tree was more than two?\\n\\nhere the code for height more than two: https://leetcode.com/problems/root-equals-sum-of-children/solutions/3410421/what-if-the-height-of-the-tree-was-more-than-two/"
                    },
                    {
                        "username": "dhruvil2511",
                        "content": "wtf is this"
                    },
                    {
                        "username": "itzRAYY",
                        "content": " public boolean checkTree(TreeNode root) {\\n        return root.val == sumNodes(root,true);\\n    }\\n    public int sumNodes(TreeNode node,boolean root){\\n        if(node==null){\\n            return 0;\\n        }\\n        return root==false?node.val+sumNodes(node.left,false)+sumNodes(node.right,false):sumNodes(node.left,false)+sumNodes(node.right,false);\\n    }"
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "Can someone tell me what happens if there is more then n nodes and we have to check for all of them ?"
                    },
                    {
                        "username": "Jeyko28",
                        "content": "I suppose that as in the first part made"
                    }
                ]
            },
            {
                "id": 1903034,
                "content": [
                    {
                        "username": "lazlo2024",
                        "content": "I got a long way to go, this was rocket science to me."
                    },
                    {
                        "username": "MJ12_Believer",
                        "content": "IMO this is a really good intro binary trees. In my data structures class we focused a lot on theory and barely on implementation so this was a really good jumping off point for me."
                    },
                    {
                        "username": "JohnGiorgi",
                        "content": "Is there a reason the `root` argument to `checkTree` is type hinted as `Optional` in `Python3`?"
                    },
                    {
                        "username": "daddyunluck",
                        "content": "bro i searched children sum property leetcode and i got this, i\\'m not complaining tho."
                    },
                    {
                        "username": "kleinodergross",
                        "content": "Hello! Why this solution doesn't work?\n\n`bool checkTree(struct TreeNode* root){\n    if ((root->left + root->right) == root->val)}\n        return true;\n    } else {\n        return false;\n    }\n}` "
                    },
                    {
                        "username": "anonode",
                        "content": "Here is the corrected version of your code:\n```clang\nbool checkTree(struct TreeNode* root){ \n    if((root->left->val + root->right->val) == root->val){ return true;}\n     else { return false; } \n    }\n```\n\nThe reason why your solution doesn't work is because you are not accessing the values associated with root's child nodes. You were close by attempting to access with `root->left` and `root->right`. However, in order to access the *val* attribute of, for instance, root's left child, you must use `root->left->val`. \n\nThere was also a curly brace facing the wrong direction at the end of your if-statement. This generated one of the errors.\n\nAdditionally, the necessary code could have been condensed to one line without the use of an if-else statement:\n```c\nbool checkTree(struct TreeNode* root){\n    return root->val == (root->left->val + root->right->val);\n}\n```\n\nHere is a link to a markdown guide for leetcode that made the formatting of this comment possible: https://leetcode.com/discuss/general-discussion/1560831/markdown-reference-for-leetcode-formatting-cheatsheet\n\nBest of luck to you on your coding journey, [@Alfiya](/kleinodergross)!\n\n"
                    },
                    {
                        "username": "jerryy147",
                        "content": "despite the fact that this is the easiest question ever, this is also my first time using binary trees, so i got the question wrong once. That means it is officially harder than some other medium questions that i get first try"
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of Binary tree was more than two?\\n\\nhere the code for height more than two: https://leetcode.com/problems/root-equals-sum-of-children/solutions/3410421/what-if-the-height-of-the-tree-was-more-than-two/"
                    },
                    {
                        "username": "dhruvil2511",
                        "content": "wtf is this"
                    },
                    {
                        "username": "itzRAYY",
                        "content": " public boolean checkTree(TreeNode root) {\\n        return root.val == sumNodes(root,true);\\n    }\\n    public int sumNodes(TreeNode node,boolean root){\\n        if(node==null){\\n            return 0;\\n        }\\n        return root==false?node.val+sumNodes(node.left,false)+sumNodes(node.right,false):sumNodes(node.left,false)+sumNodes(node.right,false);\\n    }"
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "Can someone tell me what happens if there is more then n nodes and we have to check for all of them ?"
                    },
                    {
                        "username": "Jeyko28",
                        "content": "I suppose that as in the first part made"
                    }
                ]
            },
            {
                "id": 1878259,
                "content": [
                    {
                        "username": "lazlo2024",
                        "content": "I got a long way to go, this was rocket science to me."
                    },
                    {
                        "username": "MJ12_Believer",
                        "content": "IMO this is a really good intro binary trees. In my data structures class we focused a lot on theory and barely on implementation so this was a really good jumping off point for me."
                    },
                    {
                        "username": "JohnGiorgi",
                        "content": "Is there a reason the `root` argument to `checkTree` is type hinted as `Optional` in `Python3`?"
                    },
                    {
                        "username": "daddyunluck",
                        "content": "bro i searched children sum property leetcode and i got this, i\\'m not complaining tho."
                    },
                    {
                        "username": "kleinodergross",
                        "content": "Hello! Why this solution doesn't work?\n\n`bool checkTree(struct TreeNode* root){\n    if ((root->left + root->right) == root->val)}\n        return true;\n    } else {\n        return false;\n    }\n}` "
                    },
                    {
                        "username": "anonode",
                        "content": "Here is the corrected version of your code:\n```clang\nbool checkTree(struct TreeNode* root){ \n    if((root->left->val + root->right->val) == root->val){ return true;}\n     else { return false; } \n    }\n```\n\nThe reason why your solution doesn't work is because you are not accessing the values associated with root's child nodes. You were close by attempting to access with `root->left` and `root->right`. However, in order to access the *val* attribute of, for instance, root's left child, you must use `root->left->val`. \n\nThere was also a curly brace facing the wrong direction at the end of your if-statement. This generated one of the errors.\n\nAdditionally, the necessary code could have been condensed to one line without the use of an if-else statement:\n```c\nbool checkTree(struct TreeNode* root){\n    return root->val == (root->left->val + root->right->val);\n}\n```\n\nHere is a link to a markdown guide for leetcode that made the formatting of this comment possible: https://leetcode.com/discuss/general-discussion/1560831/markdown-reference-for-leetcode-formatting-cheatsheet\n\nBest of luck to you on your coding journey, [@Alfiya](/kleinodergross)!\n\n"
                    },
                    {
                        "username": "jerryy147",
                        "content": "despite the fact that this is the easiest question ever, this is also my first time using binary trees, so i got the question wrong once. That means it is officially harder than some other medium questions that i get first try"
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of Binary tree was more than two?\\n\\nhere the code for height more than two: https://leetcode.com/problems/root-equals-sum-of-children/solutions/3410421/what-if-the-height-of-the-tree-was-more-than-two/"
                    },
                    {
                        "username": "dhruvil2511",
                        "content": "wtf is this"
                    },
                    {
                        "username": "itzRAYY",
                        "content": " public boolean checkTree(TreeNode root) {\\n        return root.val == sumNodes(root,true);\\n    }\\n    public int sumNodes(TreeNode node,boolean root){\\n        if(node==null){\\n            return 0;\\n        }\\n        return root==false?node.val+sumNodes(node.left,false)+sumNodes(node.right,false):sumNodes(node.left,false)+sumNodes(node.right,false);\\n    }"
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "Can someone tell me what happens if there is more then n nodes and we have to check for all of them ?"
                    },
                    {
                        "username": "Jeyko28",
                        "content": "I suppose that as in the first part made"
                    }
                ]
            },
            {
                "id": 1853444,
                "content": [
                    {
                        "username": "lazlo2024",
                        "content": "I got a long way to go, this was rocket science to me."
                    },
                    {
                        "username": "MJ12_Believer",
                        "content": "IMO this is a really good intro binary trees. In my data structures class we focused a lot on theory and barely on implementation so this was a really good jumping off point for me."
                    },
                    {
                        "username": "JohnGiorgi",
                        "content": "Is there a reason the `root` argument to `checkTree` is type hinted as `Optional` in `Python3`?"
                    },
                    {
                        "username": "daddyunluck",
                        "content": "bro i searched children sum property leetcode and i got this, i\\'m not complaining tho."
                    },
                    {
                        "username": "kleinodergross",
                        "content": "Hello! Why this solution doesn't work?\n\n`bool checkTree(struct TreeNode* root){\n    if ((root->left + root->right) == root->val)}\n        return true;\n    } else {\n        return false;\n    }\n}` "
                    },
                    {
                        "username": "anonode",
                        "content": "Here is the corrected version of your code:\n```clang\nbool checkTree(struct TreeNode* root){ \n    if((root->left->val + root->right->val) == root->val){ return true;}\n     else { return false; } \n    }\n```\n\nThe reason why your solution doesn't work is because you are not accessing the values associated with root's child nodes. You were close by attempting to access with `root->left` and `root->right`. However, in order to access the *val* attribute of, for instance, root's left child, you must use `root->left->val`. \n\nThere was also a curly brace facing the wrong direction at the end of your if-statement. This generated one of the errors.\n\nAdditionally, the necessary code could have been condensed to one line without the use of an if-else statement:\n```c\nbool checkTree(struct TreeNode* root){\n    return root->val == (root->left->val + root->right->val);\n}\n```\n\nHere is a link to a markdown guide for leetcode that made the formatting of this comment possible: https://leetcode.com/discuss/general-discussion/1560831/markdown-reference-for-leetcode-formatting-cheatsheet\n\nBest of luck to you on your coding journey, [@Alfiya](/kleinodergross)!\n\n"
                    },
                    {
                        "username": "jerryy147",
                        "content": "despite the fact that this is the easiest question ever, this is also my first time using binary trees, so i got the question wrong once. That means it is officially harder than some other medium questions that i get first try"
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of Binary tree was more than two?\\n\\nhere the code for height more than two: https://leetcode.com/problems/root-equals-sum-of-children/solutions/3410421/what-if-the-height-of-the-tree-was-more-than-two/"
                    },
                    {
                        "username": "dhruvil2511",
                        "content": "wtf is this"
                    },
                    {
                        "username": "itzRAYY",
                        "content": " public boolean checkTree(TreeNode root) {\\n        return root.val == sumNodes(root,true);\\n    }\\n    public int sumNodes(TreeNode node,boolean root){\\n        if(node==null){\\n            return 0;\\n        }\\n        return root==false?node.val+sumNodes(node.left,false)+sumNodes(node.right,false):sumNodes(node.left,false)+sumNodes(node.right,false);\\n    }"
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "Can someone tell me what happens if there is more then n nodes and we have to check for all of them ?"
                    },
                    {
                        "username": "Jeyko28",
                        "content": "I suppose that as in the first part made"
                    }
                ]
            },
            {
                "id": 1842313,
                "content": [
                    {
                        "username": "lazlo2024",
                        "content": "I got a long way to go, this was rocket science to me."
                    },
                    {
                        "username": "MJ12_Believer",
                        "content": "IMO this is a really good intro binary trees. In my data structures class we focused a lot on theory and barely on implementation so this was a really good jumping off point for me."
                    },
                    {
                        "username": "JohnGiorgi",
                        "content": "Is there a reason the `root` argument to `checkTree` is type hinted as `Optional` in `Python3`?"
                    },
                    {
                        "username": "daddyunluck",
                        "content": "bro i searched children sum property leetcode and i got this, i\\'m not complaining tho."
                    },
                    {
                        "username": "kleinodergross",
                        "content": "Hello! Why this solution doesn't work?\n\n`bool checkTree(struct TreeNode* root){\n    if ((root->left + root->right) == root->val)}\n        return true;\n    } else {\n        return false;\n    }\n}` "
                    },
                    {
                        "username": "anonode",
                        "content": "Here is the corrected version of your code:\n```clang\nbool checkTree(struct TreeNode* root){ \n    if((root->left->val + root->right->val) == root->val){ return true;}\n     else { return false; } \n    }\n```\n\nThe reason why your solution doesn't work is because you are not accessing the values associated with root's child nodes. You were close by attempting to access with `root->left` and `root->right`. However, in order to access the *val* attribute of, for instance, root's left child, you must use `root->left->val`. \n\nThere was also a curly brace facing the wrong direction at the end of your if-statement. This generated one of the errors.\n\nAdditionally, the necessary code could have been condensed to one line without the use of an if-else statement:\n```c\nbool checkTree(struct TreeNode* root){\n    return root->val == (root->left->val + root->right->val);\n}\n```\n\nHere is a link to a markdown guide for leetcode that made the formatting of this comment possible: https://leetcode.com/discuss/general-discussion/1560831/markdown-reference-for-leetcode-formatting-cheatsheet\n\nBest of luck to you on your coding journey, [@Alfiya](/kleinodergross)!\n\n"
                    },
                    {
                        "username": "jerryy147",
                        "content": "despite the fact that this is the easiest question ever, this is also my first time using binary trees, so i got the question wrong once. That means it is officially harder than some other medium questions that i get first try"
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of Binary tree was more than two?\\n\\nhere the code for height more than two: https://leetcode.com/problems/root-equals-sum-of-children/solutions/3410421/what-if-the-height-of-the-tree-was-more-than-two/"
                    },
                    {
                        "username": "dhruvil2511",
                        "content": "wtf is this"
                    },
                    {
                        "username": "itzRAYY",
                        "content": " public boolean checkTree(TreeNode root) {\\n        return root.val == sumNodes(root,true);\\n    }\\n    public int sumNodes(TreeNode node,boolean root){\\n        if(node==null){\\n            return 0;\\n        }\\n        return root==false?node.val+sumNodes(node.left,false)+sumNodes(node.right,false):sumNodes(node.left,false)+sumNodes(node.right,false);\\n    }"
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "Can someone tell me what happens if there is more then n nodes and we have to check for all of them ?"
                    },
                    {
                        "username": "Jeyko28",
                        "content": "I suppose that as in the first part made"
                    }
                ]
            }
        ]
    },
    {
        "title": "Find Resultant Array After Removing Anagrams",
        "question_content": "<p>You are given a <strong>0-indexed</strong> string array <code>words</code>, where <code>words[i]</code> consists of lowercase English letters.</p>\n\n<p>In one operation, select any index <code>i</code> such that <code>0 &lt; i &lt; words.length</code> and <code>words[i - 1]</code> and <code>words[i]</code> are <strong>anagrams</strong>, and <strong>delete</strong> <code>words[i]</code> from <code>words</code>. Keep performing this operation as long as you can select an index that satisfies the conditions.</p>\n\n<p>Return <code>words</code> <em>after performing all operations</em>. It can be shown that selecting the indices for each operation in <strong>any</strong> arbitrary order will lead to the same result.</p>\n\n<p>An <strong>Anagram</strong> is a word or phrase formed by rearranging the letters of a different word or phrase using all the original letters exactly once. For example, <code>&quot;dacb&quot;</code> is an anagram of <code>&quot;abdc&quot;</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;abba&quot;,&quot;baba&quot;,&quot;bbaa&quot;,&quot;cd&quot;,&quot;cd&quot;]\n<strong>Output:</strong> [&quot;abba&quot;,&quot;cd&quot;]\n<strong>Explanation:</strong>\nOne of the ways we can obtain the resultant array is by using the following operations:\n- Since words[2] = &quot;bbaa&quot; and words[1] = &quot;baba&quot; are anagrams, we choose index 2 and delete words[2].\n  Now words = [&quot;abba&quot;,&quot;baba&quot;,&quot;cd&quot;,&quot;cd&quot;].\n- Since words[1] = &quot;baba&quot; and words[0] = &quot;abba&quot; are anagrams, we choose index 1 and delete words[1].\n  Now words = [&quot;abba&quot;,&quot;cd&quot;,&quot;cd&quot;].\n- Since words[2] = &quot;cd&quot; and words[1] = &quot;cd&quot; are anagrams, we choose index 2 and delete words[2].\n  Now words = [&quot;abba&quot;,&quot;cd&quot;].\nWe can no longer perform any operations, so [&quot;abba&quot;,&quot;cd&quot;] is the final answer.</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;]\n<strong>Output:</strong> [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;]\n<strong>Explanation:</strong>\nNo two adjacent strings in words are anagrams of each other, so no operations are performed.</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 10</code></li>\n\t<li><code>words[i]</code> consists of lowercase English letters.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 2040664,
                "title": "java-easy-two-methods-clean-simple",
                "content": "**Method 1**\\n```\\nclass Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        String prev =\"\";\\n        List<String> li=new ArrayList<>();\\n        for(int i=0;i<words.length;i++){\\n            char[] ch=words[i].toCharArray();\\n            Arrays.sort(ch);\\n            String curr=String.valueOf(ch);\\n            if(!curr.equals(prev)){\\n                li.add(words[i]);\\n                prev=curr;\\n            }\\n        }\\n        return li;\\n    }\\n}\\n```\\n\\n**Method 2**\\n```\\nclass Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        Stack<String> stack = new Stack<>();\\n        for(int i = words.length-1;i>= 0;i--){\\n            String s = words[i];\\n            while(!stack.isEmpty() && anagram(stack.peek(),s) == true)stack.pop();\\n            stack.push(s);\\n        }\\n        List<String> res = new ArrayList<>();\\n        while(!stack.isEmpty())res.add(stack.pop());\\n        return res;\\n    }\\n    \\n    public boolean anagram(String p,String q){\\n        int arr[] = new int[26];\\n        for(char i : p.toCharArray())arr[i-\\'a\\']+=1;\\n        for(char i : q.toCharArray())arr[i-\\'a\\']-=1;\\n        for(int i : arr)if(i != 0)return false;\\n        return true;\\n    }\\n}\\n```\\n**IF YOU LIKED THE APPROACH PLEASE UPVOTE \\uD83D\\uDE4F\\uD83D\\uDE4F\\uD83D\\uDE4F**",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        String prev =\"\";\\n        List<String> li=new ArrayList<>();\\n        for(int i=0;i<words.length;i++){\\n            char[] ch=words[i].toCharArray();\\n            Arrays.sort(ch);\\n            String curr=String.valueOf(ch);\\n            if(!curr.equals(prev)){\\n                li.add(words[i]);\\n                prev=curr;\\n            }\\n        }\\n        return li;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        Stack<String> stack = new Stack<>();\\n        for(int i = words.length-1;i>= 0;i--){\\n            String s = words[i];\\n            while(!stack.isEmpty() && anagram(stack.peek(),s) == true)stack.pop();\\n            stack.push(s);\\n        }\\n        List<String> res = new ArrayList<>();\\n        while(!stack.isEmpty())res.add(stack.pop());\\n        return res;\\n    }\\n    \\n    public boolean anagram(String p,String q){\\n        int arr[] = new int[26];\\n        for(char i : p.toCharArray())arr[i-\\'a\\']+=1;\\n        for(char i : q.toCharArray())arr[i-\\'a\\']-=1;\\n        for(int i : arr)if(i != 0)return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2039752,
                "title": "weird-description",
                "content": "Misread this question 2 times and wasted like 20 minutes. \\n\\n**Python 3**\\nWanted to bubble-up this solution by one of our humble commenters below (whose name rhymes with batman). \\n\\nApparently, `itertools.groupby` groups *consecutive* elements by a key (which is `sorted` here). And `next` takes the first element from that group.\\n\\nIt pays to learn vast and powerful Python libraries.\\n\\n```python\\nclass Solution:\\n    def removeAnagrams(self, w: List[str]) -> List[str]:\\n        return [next(g) for _, g in groupby(w, sorted)]\\n```\\n\\nOriginal Solution\\n```python\\nclass Solution:\\n    def removeAnagrams(self, w: List[str]) -> List[str]:\\n        return [w[i] for i in range(0, len(w)) if i == 0 or sorted(w[i]) != sorted(w[i - 1])]\\n```\\n#### Silly Hash\\nThis solution won\\'t work if there are hash collisions (unless we add a check). The idea is to compute a hash using characters value but not position. \\n\\nIf the size of words is limited to 10, computing a hash would be faster than comparing counter for 26 characters.\\n\\n**C++**\\n```cpp\\nvector<string> removeAnagrams(vector<string>& words) {\\n    long long hash = -1;\\n    vector<string> res;\\n    for (auto &w : words)\\n        if (auto new_hash = accumulate(begin(w), end(w), 0LL, [](long long s, char ch){ return s + (1 << (ch - \\'a\\')); });\\n            hash != new_hash) {\\n            res.push_back(w);\\n            hash = new_hash;\\n        }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def removeAnagrams(self, w: List[str]) -> List[str]:\\n        return [next(g) for _, g in groupby(w, sorted)]\\n```\n```python\\nclass Solution:\\n    def removeAnagrams(self, w: List[str]) -> List[str]:\\n        return [w[i] for i in range(0, len(w)) if i == 0 or sorted(w[i]) != sorted(w[i - 1])]\\n```\n```cpp\\nvector<string> removeAnagrams(vector<string>& words) {\\n    long long hash = -1;\\n    vector<string> res;\\n    for (auto &w : words)\\n        if (auto new_hash = accumulate(begin(w), end(w), 0LL, [](long long s, char ch){ return s + (1 << (ch - \\'a\\')); });\\n            hash != new_hash) {\\n            res.push_back(w);\\n            hash = new_hash;\\n        }\\n    return res;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2039931,
                "title": "2-pointers-without-sorting",
                "content": "**Description**:\\n+ For every we will put our **first pointer** at a string and **second pointer** at the next position of first pointer.\\n+ Keep on moving the **second pointer** by one step ahead if the string it is pointing is a anagram of string at **first pointer**.\\n+  If we found a string pointed by **second pointer** is not an anagram of string at first pointer then put string at **first pointer** in the answer array.\\n\\n> Instead of deleting words, we will skip it, this will save our time.\\n\\n# C++\\n\\n    vector<string> removeAnagrams(vector<string>& A) {\\n        vector<string> ans;\\n        int n= size(A);\\n        for(int i=0;i<n;){\\n            int j=i+1;\\n            while( j<n and isang(A[i],A[j]) ) j++;\\n            ans.push_back(A[i]);\\n            i=j;\\n        }\\n        return ans;\\n    }\\n    //function for checking if two string are anagrams or not\\n    bool isang(string p,string q){\\n        vector<int> cnt(26);\\n        int res=0;\\n        for(auto i:p) cnt[i-\\'a\\']++;\\n        for(auto i:q) cnt[i-\\'a\\']--;         \\n        for(auto i:cnt) if(i!=0) return false;\\n        return true;\\n    }\\n\\n# Java\\n    public List<String> removeAnagrams(String[] A) {\\n        List<String> ans= new ArrayList<>();\\n        int n= A.length;\\n        for(int i=0;i<n;){\\n            int j=i+1;\\n            while( j<n && isang(A[i],A[j]) ) j++;\\n            ans.add(A[i]);\\n            i=j;\\n        }\\n        return ans;\\n    }\\n    //function for checking if two string are anagrams or not\\n    boolean isang(String p,String q){\\n        int[] cnt= new int[26];\\n        int res=0;\\n        for(int i=0;i<p.length();i++) cnt[p.charAt(i)-\\'a\\']++;\\n        for(int i=0;i<q.length();i++) cnt[q.charAt(i)-\\'a\\']--;\\n        for(int i:cnt) if(i!=0) return false;\\n        return true;\\n    }\\n\\t\\nTime - O(N * M)\\nSpace - O(1)",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "**Description**:\\n+ For every we will put our **first pointer** at a string and **second pointer** at the next position of first pointer.\\n+ Keep on moving the **second pointer** by one step ahead if the string it is pointing is a anagram of string at **first pointer**.\\n+  If we found a string pointed by **second pointer** is not an anagram of string at first pointer then put string at **first pointer** in the answer array.\\n\\n> Instead of deleting words, we will skip it, this will save our time.\\n\\n# C++\\n\\n    vector<string> removeAnagrams(vector<string>& A) {\\n        vector<string> ans;\\n        int n= size(A);\\n        for(int i=0;i<n;){\\n            int j=i+1;\\n            while( j<n and isang(A[i],A[j]) ) j++;\\n            ans.push_back(A[i]);\\n            i=j;\\n        }\\n        return ans;\\n    }\\n    //function for checking if two string are anagrams or not\\n    bool isang(string p,string q){\\n        vector<int> cnt(26);\\n        int res=0;\\n        for(auto i:p) cnt[i-\\'a\\']++;\\n        for(auto i:q) cnt[i-\\'a\\']--;         \\n        for(auto i:cnt) if(i!=0) return false;\\n        return true;\\n    }\\n\\n# Java\\n    public List<String> removeAnagrams(String[] A) {\\n        List<String> ans= new ArrayList<>();\\n        int n= A.length;\\n        for(int i=0;i<n;){\\n            int j=i+1;\\n            while( j<n && isang(A[i],A[j]) ) j++;\\n            ans.add(A[i]);\\n            i=j;\\n        }\\n        return ans;\\n    }\\n    //function for checking if two string are anagrams or not\\n    boolean isang(String p,String q){\\n        int[] cnt= new int[26];\\n        int res=0;\\n        for(int i=0;i<p.length();i++) cnt[p.charAt(i)-\\'a\\']++;\\n        for(int i=0;i<q.length();i++) cnt[q.charAt(i)-\\'a\\']--;\\n        for(int i:cnt) if(i!=0) return false;\\n        return true;\\n    }\\n\\t\\nTime - O(N * M)\\nSpace - O(1)",
                "codeTag": "Unknown"
            },
            {
                "id": 2039775,
                "title": "easy-c-solution-using-sorting",
                "content": "We take the first element and sort it to compare it with the second element.\\nIf both elements or strings are equal, we then delete ith element, else we go to next element.\\n\\n**Why are we doing i--? :**\\n```\\nOkay, lets take an array a= [\"abb\", \"bax\", \"xab\", \"axb\"]\\nsuppose we start loop, following are the iterations:\\nloop 1: compare \"bax\" with \"abb\", not anagram\\nloop 2: compare \"xab\" with \"bax\", it is anagram and we delete i th(2th) element, i.e, \"xab\", now array is = [\"abb\", \"bax\", \"axb\"];\\n            now i is still 2, we increment it by 3. Since 3>sizeof(arr) we get out of the loop.\\n            See, \"bax\" and \"axb\" are still anagram and we are not checking them.\\n            So while deleting element we decrease size of i, so that we make sure to compare the left elements.\\n```\\n```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        for(int i = 1;i<words.size();i++){\\n            string x = words[i];\\n            sort(x.begin(),x.end());\\n            string y = words[i-1];\\n            sort(y.begin(),y.end());\\n            if(x == y){\\n                words.erase(words.begin() + i);\\n                i--;\\n            }\\n        }\\n        return words;\\n    }\\n};\\n```\\n\\n\\n\\nHope you get it now :)",
                "solutionTags": [],
                "code": "```\\nOkay, lets take an array a= [\"abb\", \"bax\", \"xab\", \"axb\"]\\nsuppose we start loop, following are the iterations:\\nloop 1: compare \"bax\" with \"abb\", not anagram\\nloop 2: compare \"xab\" with \"bax\", it is anagram and we delete i th(2th) element, i.e, \"xab\", now array is = [\"abb\", \"bax\", \"axb\"];\\n            now i is still 2, we increment it by 3. Since 3>sizeof(arr) we get out of the loop.\\n            See, \"bax\" and \"axb\" are still anagram and we are not checking them.\\n            So while deleting element we decrease size of i, so that we make sure to compare the left elements.\\n```\n```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        for(int i = 1;i<words.size();i++){\\n            string x = words[i];\\n            sort(x.begin(),x.end());\\n            string y = words[i-1];\\n            sort(y.begin(),y.end());\\n            if(x == y){\\n                words.erase(words.begin() + i);\\n                i--;\\n            }\\n        }\\n        return words;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2039991,
                "title": "python-beginner-friendly-explanation-with-time-and-space-complexity-analysis",
                "content": "Two words are condidered as **anagram** if they have the same letters with exactly same letter counts. The order of the letters in the words does not matter.\\n\\n`E.g.: abbaa, aabab, aabbb, bbaaa, etc.. are all anagrams of each other as both have 2 letters \\'a\\' and \\'b\\' and both the letters in all the words have the same count, i.e., |a| = 3 and |b| = 2`.\\n\\nNow Since, the order doesn\\'t matter, **sorting them all will make them equal**. \\nE.g.: In the above example, if we sort all the words we get \\'aaabb\\'. Which means all of them are anagrams of each other.\\n\\nI hope finding anagrams is clear.\\n\\nNow, if word[i] and word[i+1] are anagrams, then remove word[i + 1] from the list, do not increment the index and compare again, else ignore and increment the index.\\n\\nThe full code (***written during contest***) is given below:\\n```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        i = 0\\n        while i < len(words) - 1:\\n            if sorted(words[i]) == sorted(words[i + 1]):\\n                words.remove(words[i + 1])\\n                continue\\n            i += 1\\n        return words\\n```\\n\\n**Time and Space complexity Analysis:**\\n* Let n = size of words array, and m = max length of a word.\\n\\nThe loop runs for \\'n\\' times and sorting takes \\'mlogm\\' time, and both are nested (done simultaneously).  Hence, **time complexity = O(n * mlogm)**.\\nNote that the time complexity can be easily reduced to ***O(n *  m)*** as finding anagrams can be done efficiently in O(m) time.\\nWe do not use any extra space, so space complexity = O(1) but sorting takes some internal space O(m). Thus, **space complexity = O(m)**.\\n\\nDo Upvote, if helpful.\\n\\n**EDIT:** The corresponding one liner for the above code (inspired from votrubac):\\n```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        return [words[i] for i in range(0, len(words)) if i == 0 or sorted(words[i]) != sorted(words[i - 1])]\\n```\\n\\n***But wait can\\'t we do better?***\\n\\nYes actually, we can still reduce the time complexity. \\n\\n**Idea:** As anagrams must have same letters with same letter counts. We can count each letter in both the strings in O(n) time and match their counts in O(n) time sequentially (not simultaneously). Hence, **optimized time complexity** = O(n + n)  **= O(n)**.\\n\\nCan we reduce the sapce complexity?? => We will see after this code.\\n\\nThe **optimized solution** is given below:\\n```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        def get_counts(x):\\n            \"\"\"\\n            As there are only 26 alphabets, make an array of constant size = 26 \\n            such that its index 0 maps to letter \\'a\\', 1 maps to \\'b\\' and so on...\\n            upto index 25 that maps to letter \\'z\\'\\n            \\n            E.g.: If we want count of letter \\'c\\', we will get it from count[2], \\n                  as index 2 maps to letter \\'c\\'.\\n                  \\n            But how will we do the mapping?\\n            \\n            There is a function in Python that returns a corresponding integer value for a character.\\n            \\n            ord(c) => return ordinal value of character \\'c\\'.\\n            \\n            index of a = 0 right? => ord(\\'a\\') - ord(\\'a\\')\\n            index of b = 1        => ord(\\'b\\') - ord(\\'a\\')\\n            .\\n            .\\n            .\\n            index of z = 25       => ord(\\'z\\') - ord(\\'a\\')\\n            \\n            \"\"\"\\n            count = [0] * 26 \\n            for c in x:\\n                count[ord(c) - ord(\\'a\\')] += 1\\n            return count\\n        \\n        \\n        if not words:\\n            return []\\n        \\n        \\n        i = 0\\n        while i < len(words) - 1:\\n            # just replace sort function by get_count functions\\n            if get_counts(words[i]) == get_counts(words[i + 1]):\\n                words.remove(words[i + 1])\\n                continue\\n            i += 1\\n        return words\\n```\\n\\nIn the above code we have used a list, but it is always fixed in size (= 26 integers). Also apart from the list, we have used only fixed sized variables.\\n\\nSo **optimized space complexity = O(1)** = constant.\\n\\n`Hope it helps.` ***UPVOTE***.\\n\\n",
                "solutionTags": [
                    "Python",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        i = 0\\n        while i < len(words) - 1:\\n            if sorted(words[i]) == sorted(words[i + 1]):\\n                words.remove(words[i + 1])\\n                continue\\n            i += 1\\n        return words\\n```\n```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        return [words[i] for i in range(0, len(words)) if i == 0 or sorted(words[i]) != sorted(words[i - 1])]\\n```\n```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        def get_counts(x):\\n            \"\"\"\\n            As there are only 26 alphabets, make an array of constant size = 26 \\n            such that its index 0 maps to letter \\'a\\', 1 maps to \\'b\\' and so on...\\n            upto index 25 that maps to letter \\'z\\'\\n            \\n            E.g.: If we want count of letter \\'c\\', we will get it from count[2], \\n                  as index 2 maps to letter \\'c\\'.\\n                  \\n            But how will we do the mapping?\\n            \\n            There is a function in Python that returns a corresponding integer value for a character.\\n            \\n            ord(c) => return ordinal value of character \\'c\\'.\\n            \\n            index of a = 0 right? => ord(\\'a\\') - ord(\\'a\\')\\n            index of b = 1        => ord(\\'b\\') - ord(\\'a\\')\\n            .\\n            .\\n            .\\n            index of z = 25       => ord(\\'z\\') - ord(\\'a\\')\\n            \\n            \"\"\"\\n            count = [0] * 26 \\n            for c in x:\\n                count[ord(c) - ord(\\'a\\')] += 1\\n            return count\\n        \\n        \\n        if not words:\\n            return []\\n        \\n        \\n        i = 0\\n        while i < len(words) - 1:\\n            # just replace sort function by get_count functions\\n            if get_counts(words[i]) == get_counts(words[i + 1]):\\n                words.remove(words[i + 1])\\n                continue\\n            i += 1\\n        return words\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2039961,
                "title": "easy-cpp-solution-for-beginners-simple",
                "content": "```\\n\\nclass Solution {\\npublic:\\n\\nvector<string> removeAnagrams(vector<string>& w) {\\n   vector<string>ans;\\n\\n\\tstring x=w[0];\\n\\tans.push_back(x);\\n\\tsort(x.begin(), x.end());\\n\\n\\n\\tfor(int i=1;i<w.size();i++){\\n\\t\\tstring z=w[i];\\n\\t\\tsort(z.begin(), z.end());\\n\\t\\tif(x==z)\\n\\t\\t\\tcontinue;\\n\\t\\telse{\\n\\t\\t\\tans.push_back(w[i]);\\n\\t\\t\\tx=z;\\n\\t\\t}\\n\\n        }\\n      \\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\nvector<string> removeAnagrams(vector<string>& w) {\\n   vector<string>ans;\\n\\n\\tstring x=w[0];\\n\\tans.push_back(x);\\n\\tsort(x.begin(), x.end());\\n\\n\\n\\tfor(int i=1;i<w.size();i++){\\n\\t\\tstring z=w[i];\\n\\t\\tsort(z.begin(), z.end());\\n\\t\\tif(x==z)\\n\\t\\t\\tcontinue;\\n\\t\\telse{\\n\\t\\t\\tans.push_back(w[i]);\\n\\t\\t\\tx=z;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2039900,
                "title": "python-3-intuitive-how-to-approach-o-n-without-sorting",
                "content": "# Goal\\nReturn the list of words after removing anagrams\\n\\n\\n# Approach\\n## 1. How do we know if those words have the same anagram? \\n\\nThose words have the same anagram if the words have the same letters even though they have different orders of letters.\\n\\n\"baby\" and \"ybba\" are anagrams because they have 2b, 1a, and 1y. It means we count the letters in the word. So, to solve this problem, we need to store the counter of the letter of the word as a key tuple in the dictionary (hashmap) and the value will be the word itself. To make it easier, the counter of the letter will be the list of 26 integers with 0 as the initialized number.\\n\\ne.g \\n- \"ab\" will be [1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\\n- \"bapak\" will be [2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\\n\\n## 2. What if the counter of letters as key tuple exists in anagram? \\n\\nCheck if the previous word doesn\\'t have the same anagram, we can put the current word into result\\n\\nE.g words = [\"ab\", \"c\", \"ba\"]\\n1. \"ab\", we will have dictionary:\\n{(1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0): \\'ab\\'}\\n2. \"c\" we will have dictionary: {(1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0): \\'ab\\', (0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0): \\'c\\'}\\n3. We know that the counter of phrase \"ba\" will be (1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0) which is already exist in the dictionary. \\n\\nSo, does it mean we exclude phrase \"ba\"? The answer is NO because we should check the previous word == the word already stored in the same tuple counter or not. You could take a look the rule in the problem description that `select any index i such that 0 < i < words.length and words[i - 1] and words[i] are anagrams, and delete words[i] from words`. Therefore, if it\\'s not the same, we should include the word.\\n\\nCode:\\n\\n```python\\nclass Solution:\\n  def removeAnagrams(self, words: List[str]) -> List[str]:\\n    res = []\\n    anagrams = {}\\n\\n    for i in range(len(words)):\\n      word = words[i]\\n      counter = [0]*26\\n      for c in word:\\n        counter[ord(c)-ord(\\'a\\')] += 1\\n\\n      if tuple(counter) not in anagrams:\\n        res.append(word)\\n      else:\\n        if anagrams[tuple(counter)] != words[i-1]:\\n          res.append(word)\\n      anagrams[tuple(counter)] = word\\n    return res\\n```\\n\\nTime Complexity: O(n)\\nSpace Complexity: O(n)\\n\\n# Can we do better?\\nYes, we can improve the space complexity slightly better by getting rid of the dictionary (hashmap). We just need to store the previous into the previous list. Thanks @codebreaker176 for the better code.\\n\\n```python\\nclass Solution:\\n  def removeAnagrams(self, words: List[str]) -> List[str]:\\n    res = []\\n    prev = []\\n\\n    for i in range(len(words)):\\n      word = words[i]\\n      counter = [0]*26\\n      for c in word:\\n        counter[ord(c)-ord(\\'a\\')] += 1\\n\\n      if counter != prev:\\n        res.append(word)\\n        prev = counter\\n    return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n  def removeAnagrams(self, words: List[str]) -> List[str]:\\n    res = []\\n    anagrams = {}\\n\\n    for i in range(len(words)):\\n      word = words[i]\\n      counter = [0]*26\\n      for c in word:\\n        counter[ord(c)-ord(\\'a\\')] += 1\\n\\n      if tuple(counter) not in anagrams:\\n        res.append(word)\\n      else:\\n        if anagrams[tuple(counter)] != words[i-1]:\\n          res.append(word)\\n      anagrams[tuple(counter)] = word\\n    return res\\n```\n```python\\nclass Solution:\\n  def removeAnagrams(self, words: List[str]) -> List[str]:\\n    res = []\\n    prev = []\\n\\n    for i in range(len(words)):\\n      word = words[i]\\n      counter = [0]*26\\n      for c in word:\\n        counter[ord(c)-ord(\\'a\\')] += 1\\n\\n      if counter != prev:\\n        res.append(word)\\n        prev = counter\\n    return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832345,
                "title": "c-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        for(int i = 1;i<words.size();i++){\\n            string x = words[i];\\n            sort(x.begin(),x.end());\\n            string y = words[i-1];\\n            sort(y.begin(),y.end());\\n            if(x == y){\\n                words.erase(words.begin() + i);\\n                i--;\\n            }\\n        }\\n        return words;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        for(int i = 1;i<words.size();i++){\\n            string x = words[i];\\n            sort(x.begin(),x.end());\\n            string y = words[i-1];\\n            sort(y.begin(),y.end());\\n            if(x == y){\\n                words.erase(words.begin() + i);\\n                i--;\\n            }\\n        }\\n        return words;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2044880,
                "title": "python-counter-clean-code",
                "content": "```\\nfrom collections import Counter\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        res = [words[0]]\\n        for i in range(1,len(words)):\\n            if Counter(res[-1]) != Counter(words[i]):\\n                res.append(words[i])\\n        return res",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import Counter\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        res = [words[0]]\\n        for i in range(1,len(words)):\\n            if Counter(res[-1]) != Counter(words[i]):\\n                res.append(words[i])\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 2045774,
                "title": "c-solution-with-picture-explanation-two-pointer-easy-solution",
                "content": "This is two-pointer approach. Keep the first pointer at the start of the array and keep moving the second pointer until you find a string which is not the anagram of the first pointer. Just when you find the desired string, move the first pointer to this position and start moving the second pointer ahead again.\\n\\n\\n![image](https://assets.leetcode.com/users/images/e705fbef-1f81-4183-a1d7-a18480ad6fa6_1652728455.4177735.jpeg)\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {        \\n        vector<string> resultant_array;\\n        \\n\\t\\t// Keeping the first pointer at index 0 and the second pointer at index 1\\n        int ptr1 = 0;\\n        int ptr2 = 1;\\n        \\n        while(ptr2<=words.size()){\\n            string s1 = words[ptr1];\\n            sort(s1.begin(),s1.end());\\n            \\n            resultant_array.push_back(words[ptr1]);\\n            \\n            while(ptr2<words.size()){\\n                string s2 = words[ptr2];\\n                sort(s2.begin(), s2.end());\\n                \\n\\t\\t\\t\\t// Remember to compare the sorted arrays to check for anagrams\\n                if(s1!=s2){\\n                    break;\\n                }\\n                else{\\n                    ptr2++;\\n                }\\n            }\\n            \\n            ptr1 = ptr2;\\n            ptr2++;\\n        }\\n        \\n        return resultant_array;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {        \\n        vector<string> resultant_array;\\n        \\n\\t\\t// Keeping the first pointer at index 0 and the second pointer at index 1\\n        int ptr1 = 0;\\n        int ptr2 = 1;\\n        \\n        while(ptr2<=words.size()){\\n            string s1 = words[ptr1];\\n            sort(s1.begin(),s1.end());\\n            \\n            resultant_array.push_back(words[ptr1]);\\n            \\n            while(ptr2<words.size()){\\n                string s2 = words[ptr2];\\n                sort(s2.begin(), s2.end());\\n                \\n\\t\\t\\t\\t// Remember to compare the sorted arrays to check for anagrams\\n                if(s1!=s2){\\n                    break;\\n                }\\n                else{\\n                    ptr2++;\\n                }\\n            }\\n            \\n            ptr1 = ptr2;\\n            ptr2++;\\n        }\\n        \\n        return resultant_array;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3162725,
                "title": "c-easiest-beginner-friendly-sol-o-n-m-26-time-and-o-n-m-space",
                "content": "# Intuition of this Problem:\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**NOTE - PLEASE READ APPROACH FIRST THEN SEE THE CODE. YOU WILL DEFINITELY UNDERSTAND THE CODE LINE BY LINE AFTER SEEING THE APPROACH.**\\n\\n# Approach for this Problem:\\n1. Create a vector called \"count\" with 26 elements, all initialized to 0.\\n2. Compare the length of two strings, if they are not equal, return false.\\n3. Increment the count of elements in \"count\" corresponding to the characters in string s and decrement the count of elements corresponding to the characters in string t.\\n4. Call the function \"countAllZeroes\" to check if all elements in \"count\" are 0, if yes return true, otherwise return false.\\n5. Create a vector called \"uniqueWords\" and insert the first element of the \"words\" vector into it.\\n6. Loop through the rest of the \"words\" vector and compare the current word with the previous word in \"uniqueWords\". If they are anagrams, skip this word and continue with the next word. If they are not anagrams, insert this word into \"uniqueWords\".\\n7. Return \"uniqueWords\".\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Humble Request:\\n- If my solution is helpful to you then please **UPVOTE** my solution, your **UPVOTE** motivates me to post such kind of solution.\\n- Please let me know in comments if there is need to do any improvement in my approach, code....anything.\\n- **Let\\'s connect on** https://www.linkedin.com/in/abhinash-singh-1b851b188\\n\\n![57jfh9.jpg](https://assets.leetcode.com/users/images/c2826b72-fb1c-464c-9f95-d9e578abcaf3_1674104075.4732099.jpeg)\\n\\n# Code:\\n```C++ []\\nclass Solution {\\npublic:\\n    bool countAllZeroes(vector<int>& count) {\\n        for (int i = 0; i < 26; i++) {\\n            if (count[i] != 0)\\n                return false;\\n        }\\n        return true;\\n    }\\n    bool isAnagram(string s, string t) {\\n        int n = s.length();\\n        int m = t.length();\\n        if (n != m)\\n            return false;\\n        vector<int> count(26, 0);\\n        for (int i = 0; i < n; i++) {\\n            count[s[i] - \\'a\\']++;\\n            count[t[i] - \\'a\\']--;\\n        }\\n        if (countAllZeroes(count) == true)\\n            return true;\\n        return false;\\n    }\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        vector<string> uniqueWords;\\n        uniqueWords.push_back(words[0]);\\n        for (int i = 1; i < words.size(); i++) {\\n            if (isAnagram(words[i-1], words[i]))\\n                continue;\\n            else\\n                uniqueWords.push_back(words[i]);\\n        }\\n        return uniqueWords;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public boolean countAllZeroes(int[] count) {\\n        for (int i = 0; i < 26; i++) {\\n            if (count[i] != 0)\\n                return false;\\n        }\\n        return true;\\n    }\\n    public boolean isAnagram(String s, String t) {\\n        int n = s.length();\\n        int m = t.length();\\n        if (n != m)\\n            return false;\\n        int[] count = new int[26];\\n        for (int i = 0; i < n; i++) {\\n            count[s.charAt(i) - \\'a\\']++;\\n            count[t.charAt(i) - \\'a\\']--;\\n        }\\n        if (countAllZeroes(count) == true)\\n            return true;\\n        return false;\\n    }\\n    public List<String> removeAnagrams(String[] words) {\\n        List<String> uniqueWords = new ArrayList<>();\\n        uniqueWords.add(words[0]);\\n        for (int i = 1; i < words.length; i++) {\\n            if (isAnagram(words[i-1], words[i]))\\n                continue;\\n            else\\n                uniqueWords.add(words[i]);\\n        }\\n        return uniqueWords;\\n    }\\n}\\n\\n```\\n```Python []\\nclass Solution:\\n    def countAllZeroes(self, count):\\n        for i in range(26):\\n            if count[i] != 0:\\n                return False\\n        return True\\n    \\n    def isAnagram(self, s, t):\\n        n = len(s)\\n        m = len(t)\\n        if n != m:\\n            return False\\n        count = [0] * 26\\n        for i in range(n):\\n            count[ord(s[i]) - ord(\\'a\\')] += 1\\n            count[ord(t[i]) - ord(\\'a\\')] -= 1\\n        if self.countAllZeroes(count) == True:\\n            return True\\n        return False\\n    \\n    def removeAnagrams(self, words):\\n        uniqueWords = []\\n        uniqueWords.append(words[0])\\n        for i in range(1, len(words)):\\n            if self.isAnagram(words[i-1], words[i]):\\n                continue\\n            else:\\n                uniqueWords.append(words[i])\\n        return uniqueWords\\n\\n```\\n\\n# Time Complexity and Space Complexity:\\n- Time complexity: **O(n * m * 26)**, where n is the number of words in the given list and m is the maximum length of a word. This is because for each pair of words, the time taken to check if they are anagrams of each other is O(m * 26), and this operation is repeated for n-1 pairs, giving us a time complexity of O(n * m * 26).\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(n * m)**, where n is the number of words in the given list and m is the maximum length of a word. This is because we are using a list uniqueWords to store the unique words, and its length can be at most n.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Hash Table",
                    "String"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    bool countAllZeroes(vector<int>& count) {\\n        for (int i = 0; i < 26; i++) {\\n            if (count[i] != 0)\\n                return false;\\n        }\\n        return true;\\n    }\\n    bool isAnagram(string s, string t) {\\n        int n = s.length();\\n        int m = t.length();\\n        if (n != m)\\n            return false;\\n        vector<int> count(26, 0);\\n        for (int i = 0; i < n; i++) {\\n            count[s[i] - \\'a\\']++;\\n            count[t[i] - \\'a\\']--;\\n        }\\n        if (countAllZeroes(count) == true)\\n            return true;\\n        return false;\\n    }\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        vector<string> uniqueWords;\\n        uniqueWords.push_back(words[0]);\\n        for (int i = 1; i < words.size(); i++) {\\n            if (isAnagram(words[i-1], words[i]))\\n                continue;\\n            else\\n                uniqueWords.push_back(words[i]);\\n        }\\n        return uniqueWords;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public boolean countAllZeroes(int[] count) {\\n        for (int i = 0; i < 26; i++) {\\n            if (count[i] != 0)\\n                return false;\\n        }\\n        return true;\\n    }\\n    public boolean isAnagram(String s, String t) {\\n        int n = s.length();\\n        int m = t.length();\\n        if (n != m)\\n            return false;\\n        int[] count = new int[26];\\n        for (int i = 0; i < n; i++) {\\n            count[s.charAt(i) - \\'a\\']++;\\n            count[t.charAt(i) - \\'a\\']--;\\n        }\\n        if (countAllZeroes(count) == true)\\n            return true;\\n        return false;\\n    }\\n    public List<String> removeAnagrams(String[] words) {\\n        List<String> uniqueWords = new ArrayList<>();\\n        uniqueWords.add(words[0]);\\n        for (int i = 1; i < words.length; i++) {\\n            if (isAnagram(words[i-1], words[i]))\\n                continue;\\n            else\\n                uniqueWords.add(words[i]);\\n        }\\n        return uniqueWords;\\n    }\\n}\\n\\n```\n```Python []\\nclass Solution:\\n    def countAllZeroes(self, count):\\n        for i in range(26):\\n            if count[i] != 0:\\n                return False\\n        return True\\n    \\n    def isAnagram(self, s, t):\\n        n = len(s)\\n        m = len(t)\\n        if n != m:\\n            return False\\n        count = [0] * 26\\n        for i in range(n):\\n            count[ord(s[i]) - ord(\\'a\\')] += 1\\n            count[ord(t[i]) - ord(\\'a\\')] -= 1\\n        if self.countAllZeroes(count) == True:\\n            return True\\n        return False\\n    \\n    def removeAnagrams(self, words):\\n        uniqueWords = []\\n        uniqueWords.append(words[0])\\n        for i in range(1, len(words)):\\n            if self.isAnagram(words[i-1], words[i]):\\n                continue\\n            else:\\n                uniqueWords.append(words[i])\\n        return uniqueWords\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2753693,
                "title": "java-easy-solution",
                "content": "class Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        List<String> list = new ArrayList<>();\\n        list.add(words[0]);\\n        for(int i=1;i<words.length;i++){\\n            if(!isAnagram(words[i-1],words[i])){\\n                list.add(words[i]);\\n            }\\n        }\\n        return list;\\n    }\\n    \\n     public boolean isAnagram(String s, String t) {\\n        char[] ss = s.toCharArray();\\n        Arrays.sort(ss);\\n         String s1 = new String(ss);\\n        \\n        char[] tt = t.toCharArray();\\n       Arrays.sort(tt);\\n         String s2 = new String(tt);\\n       \\n        \\n        return s1.equals(s2);\\n    }\\n}\\n// please upvote if it helps :)",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        List<String> list = new ArrayList<>();\\n        list.add(words[0]);\\n        for(int i=1;i<words.length;i++){\\n            if(!isAnagram(words[i-1],words[i])){\\n                list.add(words[i]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3154408,
                "title": "python-easy-solution",
                "content": "# Code\\u2705\\n```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        i = 0\\n        while True:\\n            if i == len(words)-1:\\n                break\\n            if \\'\\'.join(sorted(words[i])) == \\'\\'.join(sorted(words[i+1])):\\n                words.pop(i+1)\\n                i-=1\\n            i+=1\\n        return words\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        i = 0\\n        while True:\\n            if i == len(words)-1:\\n                break\\n            if \\'\\'.join(sorted(words[i])) == \\'\\'.join(sorted(words[i+1])):\\n                words.pop(i+1)\\n                i-=1\\n            i+=1\\n        return words\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3140655,
                "title": "fast-c-using-map-count-sort",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimply sort each string and check adjacent if equal they are anagrams and if not then push them in answer .\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSorting and Hash map\\n**Note**: Instead of normal sort I have used count sort which can be done when we have limited number of characters since string has only 26 charcaters so we can use it . And its time complexity is only $$O(n)$$ so very fast than  normal sort that takes $$O(nlogn)$$\\n# Complexity\\n- Time complexity:O(n*k)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(26) not taking answer as space\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  string count_sort(string s) {\\n        int mp[26] = {0};\\n        for (char c : s) {\\n            mp[c - \\'a\\']++;\\n        }\\n        string t;\\n        for (int c = 0; c < 26; c++) {\\n            t += string(mp[c], c + \\'a\\');\\n        }\\n        return t;\\n    }\\n    vector<string> removeAnagrams(vector<string>& words) {\\n       vector<string>ans;\\n       int n=words.size();\\n       ans.push_back(words[0]);\\n       for(int i=1;i<n;i++)\\n       // insted of count_sort u can stl sort but takes nlogn\\n           if(count_sort(words[i])==count_sort(words[i-1]));\\n           else ans.push_back(words[i]);\\n       \\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  string count_sort(string s) {\\n        int mp[26] = {0};\\n        for (char c : s) {\\n            mp[c - \\'a\\']++;\\n        }\\n        string t;\\n        for (int c = 0; c < 26; c++) {\\n            t += string(mp[c], c + \\'a\\');\\n        }\\n        return t;\\n    }\\n    vector<string> removeAnagrams(vector<string>& words) {\\n       vector<string>ans;\\n       int n=words.size();\\n       ans.push_back(words[0]);\\n       for(int i=1;i<n;i++)\\n       // insted of count_sort u can stl sort but takes nlogn\\n           if(count_sort(words[i])==count_sort(words[i-1]));\\n           else ans.push_back(words[i]);\\n       \\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2351539,
                "title": "java-fast-solution",
                "content": "```\\nPLEASE UPVOTE IF YOU LIKE.\\n```\\n```\\n\\t\\tList<String> ans = new ArrayList<>();\\n        String temp = \"\";\\n        for (String s: words){\\n            char[] carr = s.toCharArray();\\n            Arrays.sort(carr);\\n            String curr = new String(carr);\\n            if (!curr.equals(temp))\\n                ans.add(s);\\n            temp = curr;\\n        }\\n        return ans;",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nPLEASE UPVOTE IF YOU LIKE.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2040051,
                "title": "python-easy-solution-with-comments",
                "content": "```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        if len(words) == 1:\\n            return words\\n        \\n        i = 1\\n        while i < len(words):\\n            anagram = \"\".join(sorted(words[i]))\\n\\t\\t\\t# check if words[i-1] and words[i] are anagrams\\n            if anagram == \"\".join(sorted(words[i - 1])):\\n\\t\\t\\t\\t# if anagrams then remove second instance from the list of words\\n                words.pop(i)\\n            else:\\n                i += 1\\n                \\n        return words\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        if len(words) == 1:\\n            return words\\n        \\n        i = 1\\n        while i < len(words):\\n            anagram = \"\".join(sorted(words[i]))\\n\\t\\t\\t# check if words[i-1] and words[i] are anagrams\\n            if anagram == \"\".join(sorted(words[i - 1])):\\n\\t\\t\\t\\t# if anagrams then remove second instance from the list of words\\n                words.pop(i)\\n            else:\\n                i += 1\\n                \\n        return words\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3632776,
                "title": "remove-anagrams-4-liner-code-least-complexity",
                "content": "# KARRAR\\n>Anagrams...\\n>>Removing anagrams...\\n>>>Low time complexity...\\n>>>>Optimized and generalized solution...\\n>>>>>   Easy to understand...\\n-     PLEASE \\uD83D\\uDC4D\\uD83C\\uDFFB UPVOTE...\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach:\\n            Simplest approach...\\n            Sort the arrays and compare there indeces...\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: Beats 88% (57 ms)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: Beats 15% (16 MB)\\n\\n![image.png](https://assets.leetcode.com/users/images/939680b3-2168-420f-ba83-7b9ea6a45a55_1686651121.8875034.png)\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        ans=[words[0]]\\n        for i in range(1,len(words)):\\n            if(sorted(words[i-1])!=sorted(words[i])):\\n                ans.append(words[i])\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        ans=[words[0]]\\n        for i in range(1,len(words)):\\n            if(sorted(words[i-1])!=sorted(words[i])):\\n                ans.append(words[i])\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466371,
                "title": "simple-approach-c",
                "content": "# Approach\\nThe Approach to this problem is to keep the point in mind that, \"if two strings are anagrams, and we sort them, both of them would be equal\"\\nfor example, \\n\"abba\" and \"bbaa\" are anagrams, and when we sort them, both of them would be \"aabb\" and \"aabb\".\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        \\n        for(int i=1; i<words.size(); i++)\\n        {\\n            string s1 = words[i];\\n            string s2 = words[i-1];\\n            sort(s1.begin(), s1.end());\\n            sort(s2.begin(), s2.end());\\n            if(s1 == s2)\\n            {\\n                words.erase(words.begin() + i);\\n                i--;\\n            }\\n            \\n        }\\n        return words;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        \\n        for(int i=1; i<words.size(); i++)\\n        {\\n            string s1 = words[i];\\n            string s2 = words[i-1];\\n            sort(s1.begin(), s1.end());\\n            sort(s2.begin(), s2.end());\\n            if(s1 == s2)\\n            {\\n                words.erase(words.begin() + i);\\n                i--;\\n            }\\n            \\n        }\\n        return words;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2141419,
                "title": "c-cpp",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        \\n        for(int i = words.size()-1;i>0;i--){\\n            string c1 = words[i];\\n            string c2 = words[i-1];\\n            sort(c1.begin() ,c1.end());\\n            sort(c2.begin() , c2.end());\\n            if(c1 == c2){\\n                words[i] = \"#\";\\n            }\\n        }\\n        vector<string> ans;\\n        for(int i=0;i<words.size();i++){\\n            if(words[i]!= \"#\"){\\n                ans.push_back(words[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        \\n        for(int i = words.size()-1;i>0;i--){\\n            string c1 = words[i];\\n            string c2 = words[i-1];\\n            sort(c1.begin() ,c1.end());\\n            sort(c2.begin() , c2.end());\\n            if(c1 == c2){\\n                words[i] = \"#\";\\n            }\\n        }\\n        vector<string> ans;\\n        for(int i=0;i<words.size();i++){\\n            if(words[i]!= \"#\"){\\n                ans.push_back(words[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2040091,
                "title": "c-map-easy-stl",
                "content": "We will be maintaining a map for storing frequency of every word. If consecutive words have same frequency then word will become \"\".\\n```\\nclass Solution {\\npublic:\\n    bool map_compare (map<char,int>&lhs, map<char,int>&rhs) \\n    {\\n    // No predicate needed because there is operator== for pairs already.\\n    return lhs.size() == rhs.size()&& std::equal(lhs.begin(), lhs.end(),rhs.begin());\\n    }\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        vector<string>ans;\\n        for(int i=0;i<words.size()-1;i++)\\n        {\\n            if(words[i]==\"\")continue;\\n            map<char,int>m1;\\n            for(char c:words[i])\\n            {\\n                m1[c]++;\\n            }\\n            for(int j=i+1;j<words.size();j++)\\n            {\\n                map<char,int>m2;\\n                for(char c:words[j])\\n                {\\n                    m2[c]++;\\n                }    \\n                if(map_compare(m1,m2)){\\n                    words[j]=\"\";                    \\n                } \\n                else\\n                {\\n                    break;\\n                }\\n            }\\n        }\\n        for(string word:words)\\n        {\\n            if(word!=\"\")ans.push_back(word);\\n        }\\n\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool map_compare (map<char,int>&lhs, map<char,int>&rhs) \\n    {\\n    // No predicate needed because there is operator== for pairs already.\\n    return lhs.size() == rhs.size()&& std::equal(lhs.begin(), lhs.end(),rhs.begin());\\n    }\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        vector<string>ans;\\n        for(int i=0;i<words.size()-1;i++)\\n        {\\n            if(words[i]==\"\")continue;\\n            map<char,int>m1;\\n            for(char c:words[i])\\n            {\\n                m1[c]++;\\n            }\\n            for(int j=i+1;j<words.size();j++)\\n            {\\n                map<char,int>m2;\\n                for(char c:words[j])\\n                {\\n                    m2[c]++;\\n                }    \\n                if(map_compare(m1,m2)){\\n                    words[j]=\"\";                    \\n                } \\n                else\\n                {\\n                    break;\\n                }\\n            }\\n        }\\n        for(string word:words)\\n        {\\n            if(word!=\"\")ans.push_back(word);\\n        }\\n\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2942687,
                "title": "c-solution-using-map",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        for(int i = 1; i < words.size(); i++){ //start the loop from first index\\n            string a = words[i-1]; \\n            map <char, int> mp; //stores the details of the (i-1)st word\\n            for(int j = 0; j < a.length(); j++){\\n                mp[words[i-1][j]]++;\\n            }\\n            map <char, int> m; //stores the details of the i th word\\n            for(int h = 0; h < words[i].length(); h++){\\n                m[words[i][h]]++;\\n            }\\n            if(mp == m){ //if maps are equal then the words are anagrams\\n                words.erase(words.begin() + i);\\n                i--; //as we delete from the vector, we need to reset i to i-1\\n            }\\n        }\\n        return words;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        for(int i = 1; i < words.size(); i++){ //start the loop from first index\\n            string a = words[i-1]; \\n            map <char, int> mp; //stores the details of the (i-1)st word\\n            for(int j = 0; j < a.length(); j++){\\n                mp[words[i-1][j]]++;\\n            }\\n            map <char, int> m; //stores the details of the i th word\\n            for(int h = 0; h < words[i].length(); h++){\\n                m[words[i][h]]++;\\n            }\\n            if(mp == m){ //if maps are equal then the words are anagrams\\n                words.erase(words.begin() + i);\\n                i--; //as we delete from the vector, we need to reset i to i-1\\n            }\\n        }\\n        return words;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2056341,
                "title": "python-small-easy-to-understand-solution",
                "content": "Runtime: 52 ms, faster than 96.66% of Python3 online submissions for Find Resultant Array After Removing Anagrams.\\nMemory Usage: 13.8 MB, less than 75.32% of Python3 online submissions for Find Resultant Array After Removing Anagrams.\\n```\\nclass Solution:\\n  def removeAnagrams(self, words: List[str]) -> List[str]:\\n    key = \"\"\\n    result = []\\n    \\n    for word in words:\\n      letters = list(word)\\n      letters.sort()\\n      new_key = \"\".join(letters)\\n      \\n      if new_key != key :\\n        key = new_key\\n        result.append(word)\\n        \\n    return result\\n```\\n\\n**More understanding variant :**\\n\\n**idea of solution :**\\n1. get first word from array and sorting it and retain as **key** and put first word in answer(**result**) \\n2. in loop will give all words from array starting with index 1\\n3. for each word will check : is the sorting rearranging of this word equal **key** or not ?\\n a. is eqaul : ignore this word\\n b. isn\\'t equal : put this word in answer and update **key**\\nRuntime: 56 ms, faster than 93.03% of Python3 online submissions for Find Resultant Array After Removing Anagrams.\\nMemory Usage: 13.8 MB, less than 75.32% of Python3 online submissions for Find Resultant Array After Removing Anagrams.\\n```\\nclass Solution:\\n  def removeAnagrams(self, words: List[str]) -> List[str]:\\n    def sort_construct(word):\\n      letters = list(word)\\n      letters.sort()\\n      return \"\".join(letters)\\n    \\n    key = sort_construct(words[0])\\n    result = [words[0]]\\n    \\n    for i in range(1, len(words)):\\n      new_key = sort_construct(words[i])\\n      if new_key != key :\\n        key = new_key\\n        result.append(words[i])\\n        \\n    return result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n  def removeAnagrams(self, words: List[str]) -> List[str]:\\n    key = \"\"\\n    result = []\\n    \\n    for word in words:\\n      letters = list(word)\\n      letters.sort()\\n      new_key = \"\".join(letters)\\n      \\n      if new_key != key :\\n        key = new_key\\n        result.append(word)\\n        \\n    return result\\n```\n```\\nclass Solution:\\n  def removeAnagrams(self, words: List[str]) -> List[str]:\\n    def sort_construct(word):\\n      letters = list(word)\\n      letters.sort()\\n      return \"\".join(letters)\\n    \\n    key = sort_construct(words[0])\\n    result = [words[0]]\\n    \\n    for i in range(1, len(words)):\\n      new_key = sort_construct(words[i])\\n      if new_key != key :\\n        key = new_key\\n        result.append(words[i])\\n        \\n    return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2043991,
                "title": "clear-and-easily-understandable",
                "content": "```\\nclass Solution {\\n\\tpublic static List<String> removeAnagrams(String[] words) {\\n\\t\\tList<String> ans = new ArrayList<>();\\n\\t\\tString next = \"\";\\n\\t\\tfor (int i = 0; i < words.length; i++) {\\n\\t\\t\\tchar tempArray[] = words[i].toCharArray();\\n\\t\\t\\tArrays.sort(tempArray);\\n\\t\\t\\tString temp = new String(tempArray);\\n\\t\\t\\tif ((!temp.equals(next))) {\\n\\t\\t\\t\\tans.add(words[i]);\\n\\t\\t\\t}\\n\\t\\t\\tnext = temp;\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\tpublic static List<String> removeAnagrams(String[] words) {\\n\\t\\tList<String> ans = new ArrayList<>();\\n\\t\\tString next = \"\";\\n\\t\\tfor (int i = 0; i < words.length; i++) {\\n\\t\\t\\tchar tempArray[] = words[i].toCharArray();\\n\\t\\t\\tArrays.sort(tempArray);\\n\\t\\t\\tString temp = new String(tempArray);\\n\\t\\t\\tif ((!temp.equals(next))) {\\n\\t\\t\\t\\tans.add(words[i]);\\n\\t\\t\\t}\\n\\t\\t\\tnext = temp;\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2040665,
                "title": "c-one-pass-o-1-space",
                "content": "```\\n   int n=words.size();\\n        vector<string> ans;\\n        ans.emplace_back(words[0]);\\n        vector<int> f1(26,0);\\n        for(auto it : words[0]) f1[it-\\'a\\']++;\\n        for(int i=1;i<n;i++)\\n        {\\n            vector<int> f2(26,0);\\n            for(auto it : words[i])\\n            {\\n                f2[it-\\'a\\']++;\\n            }\\n            if(f1==f2) continue;\\n            else \\n            {\\n                ans.emplace_back(words[i]);\\n                f1=f2;\\n            }\\n        }\\n        return ans;   \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n   int n=words.size();\\n        vector<string> ans;\\n        ans.emplace_back(words[0]);\\n        vector<int> f1(26,0);\\n        for(auto it : words[0]) f1[it-\\'a\\']++;\\n        for(int i=1;i<n;i++)\\n        {\\n            vector<int> f2(26,0);\\n            for(auto it : words[i])\\n            {\\n                f2[it-\\'a\\']++;\\n            }\\n            if(f1==f2) continue;\\n            else \\n            {\\n                ans.emplace_back(words[i]);\\n                f1=f2;\\n            }\\n        }\\n        return ans;   \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3409786,
                "title": "find-resultant-array-after-removing-anagrams-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2logn)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        int i=0;\\n        while(i<words.size()-1)\\n        {\\n            string s1 = words[i];\\n            sort(s1.begin(), s1.end());\\n            string s2 = words[i+1];\\n            sort(s2.begin(), s2.end());\\n\\n            if(s1==s2)\\n            {\\n                words.erase(words.begin()+i+1);\\n            }\\n            else\\n            {\\n                i++;\\n            }\\n        }\\n        return words;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/792a2ee3-fa92-4936-9a87-216cd9a9ac02_1682613207.1269994.jpeg)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        int i=0;\\n        while(i<words.size()-1)\\n        {\\n            string s1 = words[i];\\n            sort(s1.begin(), s1.end());\\n            string s2 = words[i+1];\\n            sort(s2.begin(), s2.end());\\n\\n            if(s1==s2)\\n            {\\n                words.erase(words.begin()+i+1);\\n            }\\n            else\\n            {\\n                i++;\\n            }\\n        }\\n        return words;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2762311,
                "title": "java-88-faster-not-using-maps",
                "content": "# Code\\n```\\nclass Solution {\\n\\n    static short[] alph;\\n\\n    public List<String> removeAnagrams(String[] words) {\\n        alph = new short[26];\\n        if (words.length == 1) {\\n            List<String> list = new ArrayList<>();\\n            list.add(words[0]);\\n            return list;\\n        }\\n\\n        List<String> list = new ArrayList<>(words.length);\\n\\n        for (String word : words) {\\n            list.add(word);\\n        }\\n        int idx = 1;\\n        while (idx < list.size()) {\\n            if (hasNextAnagram(list, idx)) {\\n                list.remove(idx);\\n                continue;\\n            }\\n            idx++;\\n        }\\n        return list;\\n    }\\n\\n    private static boolean hasNextAnagram(List<String> list, int idx) {\\n        return isAnagram(list.get(idx), list.get(idx - 1));\\n    }\\n\\n    private static boolean isAnagram(String one, String two) {\\n        for (int i = 0; i < one.length(); i++) {\\n            char c = one.charAt(i);\\n            alph[c - \\'a\\']++;\\n        }\\n        for (int i = 0; i < two.length(); i++) {\\n            char c = two.charAt(i);\\n            alph[c - \\'a\\']--;\\n        }\\n        boolean isAnagram = true;\\n        for (int i = 0; i < alph.length; i++) {\\n            if (alph[i] != 0) {\\n                isAnagram = false;\\n            }\\n            alph[i] = 0;\\n        }\\n        return isAnagram;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    static short[] alph;\\n\\n    public List<String> removeAnagrams(String[] words) {\\n        alph = new short[26];\\n        if (words.length == 1) {\\n            List<String> list = new ArrayList<>();\\n            list.add(words[0]);\\n            return list;\\n        }\\n\\n        List<String> list = new ArrayList<>(words.length);\\n\\n        for (String word : words) {\\n            list.add(word);\\n        }\\n        int idx = 1;\\n        while (idx < list.size()) {\\n            if (hasNextAnagram(list, idx)) {\\n                list.remove(idx);\\n                continue;\\n            }\\n            idx++;\\n        }\\n        return list;\\n    }\\n\\n    private static boolean hasNextAnagram(List<String> list, int idx) {\\n        return isAnagram(list.get(idx), list.get(idx - 1));\\n    }\\n\\n    private static boolean isAnagram(String one, String two) {\\n        for (int i = 0; i < one.length(); i++) {\\n            char c = one.charAt(i);\\n            alph[c - \\'a\\']++;\\n        }\\n        for (int i = 0; i < two.length(); i++) {\\n            char c = two.charAt(i);\\n            alph[c - \\'a\\']--;\\n        }\\n        boolean isAnagram = true;\\n        for (int i = 0; i < alph.length; i++) {\\n            if (alph[i] != 0) {\\n                isAnagram = false;\\n            }\\n            alph[i] = 0;\\n        }\\n        return isAnagram;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2754510,
                "title": "c-solution",
                "content": "```\\n#define MAX_LENGTH      (100+4)\\n\\nint compareChar(const void* c1, const void* c2)\\n{\\n    // ascending order\\n    return (*(char*)c1 - *(char*)c2);\\n}\\n\\nbool isAnagrams(char* pSrc, char* pDst)\\n{\\n    int retVal = false;\\n\\n    char sortSrc[MAX_LENGTH];\\n    memset(sortSrc, 0, sizeof(sortSrc));\\n    snprintf(sortSrc, sizeof(sortSrc), \"%s\", pSrc);\\n    qsort(sortSrc, strlen(sortSrc), sizeof(char), compareChar);\\n\\n    char sortDst[MAX_LENGTH];\\n    memset(sortDst, 0, sizeof(sortDst));\\n    snprintf(sortDst, sizeof(sortDst), \"%s\", pDst);\\n    qsort(sortDst, strlen(sortDst), sizeof(char), compareChar);\\n\\n    if (strcmp(sortSrc, sortDst) == 0)\\n    {\\n        retVal = true;\\n    }\\n\\n    return retVal;\\n}\\n\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nchar ** removeAnagrams(char ** words, int wordsSize, int* returnSize){\\n    (*returnSize) = 1;\\n\\n    int len;\\n    int i;\\n    for (i=1; i<wordsSize; ++i)\\n    {\\n        if (isAnagrams(words[(*returnSize)-1], words[i]) == true)\\n        {\\n            continue;\\n        }\\n\\n        if ((*returnSize) != i)\\n        {\\n            free(words[(*returnSize)]);\\n            words[(*returnSize)] = NULL;\\n\\n            len = strlen(words[i]) + 1;\\n            words[(*returnSize)] = (char*)malloc(len*sizeof(char));\\n            if (words[(*returnSize)] == NULL)\\n            {\\n                perror(\"malloc\");\\n                return words;\\n            }\\n            memset(words[(*returnSize)], 0, len*sizeof(char));\\n            snprintf(words[(*returnSize)], len*sizeof(char), \"%s\", words[i]);\\n        }\\n\\n        (*returnSize)++;\\n    }\\n\\n    return words;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#define MAX_LENGTH      (100+4)\\n\\nint compareChar(const void* c1, const void* c2)\\n{\\n    // ascending order\\n    return (*(char*)c1 - *(char*)c2);\\n}\\n\\nbool isAnagrams(char* pSrc, char* pDst)\\n{\\n    int retVal = false;\\n\\n    char sortSrc[MAX_LENGTH];\\n    memset(sortSrc, 0, sizeof(sortSrc));\\n    snprintf(sortSrc, sizeof(sortSrc), \"%s\", pSrc);\\n    qsort(sortSrc, strlen(sortSrc), sizeof(char), compareChar);\\n\\n    char sortDst[MAX_LENGTH];\\n    memset(sortDst, 0, sizeof(sortDst));\\n    snprintf(sortDst, sizeof(sortDst), \"%s\", pDst);\\n    qsort(sortDst, strlen(sortDst), sizeof(char), compareChar);\\n\\n    if (strcmp(sortSrc, sortDst) == 0)\\n    {\\n        retVal = true;\\n    }\\n\\n    return retVal;\\n}\\n\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nchar ** removeAnagrams(char ** words, int wordsSize, int* returnSize){\\n    (*returnSize) = 1;\\n\\n    int len;\\n    int i;\\n    for (i=1; i<wordsSize; ++i)\\n    {\\n        if (isAnagrams(words[(*returnSize)-1], words[i]) == true)\\n        {\\n            continue;\\n        }\\n\\n        if ((*returnSize) != i)\\n        {\\n            free(words[(*returnSize)]);\\n            words[(*returnSize)] = NULL;\\n\\n            len = strlen(words[i]) + 1;\\n            words[(*returnSize)] = (char*)malloc(len*sizeof(char));\\n            if (words[(*returnSize)] == NULL)\\n            {\\n                perror(\"malloc\");\\n                return words;\\n            }\\n            memset(words[(*returnSize)], 0, len*sizeof(char));\\n            snprintf(words[(*returnSize)], len*sizeof(char), \"%s\", words[i]);\\n        }\\n\\n        (*returnSize)++;\\n    }\\n\\n    return words;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2517232,
                "title": "vector-manipulation",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& ans) {\\n     \\n        vector<string> words = ans;\\n        int i=0;\\n        while(i<words.size()-1){\\n            string s1 = words[i];\\n            string s2 = words[i+1];\\n            \\n            sort(s1.begin(), s1.end());\\n            sort(s2.begin(), s2.end());\\n            \\n            if(s1.compare(s2)==0){\\n                words.erase(words.begin()+i+1);\\n            }\\n            else i++;\\n        }\\n        return words;\\n    }\\n};\\n```",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& ans) {\\n     \\n        vector<string> words = ans;\\n        int i=0;\\n        while(i<words.size()-1){\\n            string s1 = words[i];\\n            string s2 = words[i+1];\\n            \\n            sort(s1.begin(), s1.end());\\n            sort(s2.begin(), s2.end());\\n            \\n            if(s1.compare(s2)==0){\\n                words.erase(words.begin()+i+1);\\n            }\\n            else i++;\\n        }\\n        return words;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2474416,
                "title": "easy-c-solution-o-n",
                "content": "class Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        vector<string> ans;\\n        vector<string> temp;\\n        for(auto s:words)\\n        {\\n            sort(s.begin(),s.end());\\n            temp.push_back(s);\\n        }\\n        for(int i = 0;i<temp.size();i++)\\n        {\\n            if((i==0) || temp[i] != temp[i-1])\\n            {\\n                ans.push_back(words[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        vector<string> ans;\\n        vector<string> temp;\\n        for(auto s:words)\\n        {\\n            sort(s.begin(),s.end());\\n            temp.push_back(s);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2391910,
                "title": "python-one-liner-95-speed",
                "content": "```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        return [words[0]]+[words[i] for i in range(1,len(words)) if sorted(words[i])!=sorted(words[i-1])]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        return [words[0]]+[words[i] for i in range(1,len(words)) if sorted(words[i])!=sorted(words[i-1])]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2345429,
                "title": "python-5-lines",
                "content": "```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        res = [words[0]]\\n        for i in range(len(words)):\\n            #check anagram\\n            if sorted(words[i-1])!=sorted(words[i]):\\n                res.append(words[i])\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        res = [words[0]]\\n        for i in range(len(words)):\\n            #check anagram\\n            if sorted(words[i-1])!=sorted(words[i]):\\n                res.append(words[i])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2208901,
                "title": "time-0-n-and-space-0-1",
                "content": "````\\nvar removeAnagrams = function(words) {\\n    let n = words.length;\\n    \\n    for(let i=0; i<n-1; i++){\\n        if(isAnagram(words[i], words[i+1])){\\n            words.splice(i+1, 1);\\n            i--\\n            n--\\n        }\\n    }\\n    return words\\n};\\n\\nfunction isAnagram(a, b){\\n    \\n    let freqArr = new Array(26).fill(0);\\n    if(a.length != b.length) return false\\n    \\n    for(let i=0; i<a.length; i++){\\n        let idx1 = a[i].charCodeAt(0) - \"a\".charCodeAt(0);\\n        freqArr[idx1]++;\\n        let idx2 = b[i].charCodeAt(0) - \"a\".charCodeAt(0);\\n        freqArr[idx2]--\\n    }\\n\\n    \\n    for(let i=0; i<26; i++){\\n        if(freqArr[i] > 0){\\n            return false\\n        }\\n    }\\n    return true\\n}\\n````",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "````\\nvar removeAnagrams = function(words) {\\n    let n = words.length;\\n    \\n    for(let i=0; i<n-1; i++){\\n        if(isAnagram(words[i], words[i+1])){\\n            words.splice(i+1, 1);\\n            i--\\n            n--\\n        }\\n    }\\n    return words\\n};\\n\\nfunction isAnagram(a, b){\\n    \\n    let freqArr = new Array(26).fill(0);\\n    if(a.length != b.length) return false\\n    \\n    for(let i=0; i<a.length; i++){\\n        let idx1 = a[i].charCodeAt(0) - \"a\".charCodeAt(0);\\n        freqArr[idx1]++;\\n        let idx2 = b[i].charCodeAt(0) - \"a\".charCodeAt(0);\\n        freqArr[idx2]--\\n    }\\n\\n    \\n    for(let i=0; i<26; i++){\\n        if(freqArr[i] > 0){\\n            return false\\n        }\\n    }\\n    return true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2192113,
                "title": "c-basic-solution",
                "content": "\\'\\'\\'\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        vector<string>v1;\\n        v1.push_back(words[0]);\\n        string prev=words[0];\\n        sort(prev.begin(),prev.end());\\n        \\n        for(int i=1;i<words.size();i++)\\n        {\\n            string s = words[i];\\n            sort(s.begin(),s.end());\\n            \\n            if(s!=prev)\\n            {\\n                v1.push_back(words[i]);\\n                prev = s;\\n            }\\n            \\n        }\\n        return v1;  \\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        vector<string>v1;\\n        v1.push_back(words[0]);\\n        string prev=words[0];\\n        sort(prev.begin(),prev.end());\\n        \\n        for(int i=1;i<words.size();i++)\\n        {\\n            string s = words[i];\\n            sort(s.begin(),s.end());\\n            \\n            if(s!=prev)\\n            {\\n                v1.push_back(words[i]);\\n                prev = s;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2127195,
                "title": "simple-and-easy-javascript-typescript-solution",
                "content": "My simple and easy JavaScript/TypeScript solution:\\n```\\nfunction removeAnagrams(words: string[]): string[] {\\n    const newWords = [];\\n    let prevSortedWord = \\'\\';\\n    for (const word of words) {\\n        const sortedWord = word.split(\\'\\').sort().join(\\'\\');\\n        if (sortedWord === prevSortedWord) continue;\\n        \\n        prevSortedWord = sortedWord;\\n        newWords.push(word);\\n    }\\n    return newWords;\\n};\\n```\\nRuntime:\\xA081 ms, faster than\\xA097.92%\\xA0of\\xA0TypeScript\\xA0online submissions for\\xA0Find Resultant Array After Removing Anagrams.\\nMemory Usage:\\xA048.7 MB, less than\\xA089.58%\\xA0of\\xA0TypeScript\\xA0online submissions for\\xA0Find Resultant Array After Removing Anagrams.\\n",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Sorting"
                ],
                "code": "```\\nfunction removeAnagrams(words: string[]): string[] {\\n    const newWords = [];\\n    let prevSortedWord = \\'\\';\\n    for (const word of words) {\\n        const sortedWord = word.split(\\'\\').sort().join(\\'\\');\\n        if (sortedWord === prevSortedWord) continue;\\n        \\n        prevSortedWord = sortedWord;\\n        newWords.push(word);\\n    }\\n    return newWords;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2042605,
                "title": "c",
                "content": "```\\n    public IList<string> RemoveAnagrams(string[] words)\\n    {\\n        IList<string> result = new List<string>();\\n        result.Add(words[0]);\\n        for (int i = 1; i < words.Length; i++)\\n        {\\n            if (String.Concat(words[i].OrderBy(a => a)) != String.Concat(words[i - 1].OrderBy(a => a)))\\n                result.Add(words[i]);\\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public IList<string> RemoveAnagrams(string[] words)\\n    {\\n        IList<string> result = new List<string>();\\n        result.Add(words[0]);\\n        for (int i = 1; i < words.Length; i++)\\n        {\\n            if (String.Concat(words[i].OrderBy(a => a)) != String.Concat(words[i - 1].OrderBy(a => a)))\\n                result.Add(words[i]);\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2039880,
                "title": "c-implementation-clean-and-concise",
                "content": "```\\nclass Solution {\\npublic:\\n    bool anagram(string str1, string str2)\\n{\\n    // Get lengths of both strings\\n    int n1 = str1.length();\\n    int n2 = str2.length();\\n \\n    // If length of both strings is not same, then they\\n    // cannot be anagram\\n    if (n1 != n2)\\n        return false;\\n \\n    // Sort both the strings\\n    sort(str1.begin(), str1.end());\\n    sort(str2.begin(), str2.end());\\n \\n    // Compare sorted strings\\n    for (int i = 0; i < n1; i++)\\n        if (str1[i] != str2[i])\\n            return false;\\n \\n    return true;\\n}\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        \\n        vector<string>ans;\\n        int n=words.size();\\n        int i,j;\\n        map<int,int>ma;\\n        while(1)\\n        {\\n            bool be=false;\\n            \\n            for(i=1;i<n;i++)\\n            {\\n                if(ma[i]!=1 and anagram(words[i],words[i-1]))\\n                {\\n                    ma[i]=1;\\n                    be=true;\\n                    break;\\n                }\\n            }\\n            if(be==false)\\n                break;\\n            \\n        }\\n        for(i=0;i<n;i++)\\n        {\\n            if(ma[i]!=1)\\n                ans.push_back(words[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Pls upvote the post if you found helpful.\\nDo comment down your doubts if any.\\nTill then, happy coding : )**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool anagram(string str1, string str2)\\n{\\n    // Get lengths of both strings\\n    int n1 = str1.length();\\n    int n2 = str2.length();\\n \\n    // If length of both strings is not same, then they\\n    // cannot be anagram\\n    if (n1 != n2)\\n        return false;\\n \\n    // Sort both the strings\\n    sort(str1.begin(), str1.end());\\n    sort(str2.begin(), str2.end());\\n \\n    // Compare sorted strings\\n    for (int i = 0; i < n1; i++)\\n        if (str1[i] != str2[i])\\n            return false;\\n \\n    return true;\\n}\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        \\n        vector<string>ans;\\n        int n=words.size();\\n        int i,j;\\n        map<int,int>ma;\\n        while(1)\\n        {\\n            bool be=false;\\n            \\n            for(i=1;i<n;i++)\\n            {\\n                if(ma[i]!=1 and anagram(words[i],words[i-1]))\\n                {\\n                    ma[i]=1;\\n                    be=true;\\n                    break;\\n                }\\n            }\\n            if(be==false)\\n                break;\\n            \\n        }\\n        for(i=0;i<n;i++)\\n        {\\n            if(ma[i]!=1)\\n                ans.push_back(words[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2039835,
                "title": "c-beginner-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n     vector<string>res;\\n        set<string>st;\\n        for(int i=0;i<words.size();i++){\\n            string temp=words[i];\\n            sort(temp.begin(),temp.end());\\n            if(st.count(temp)){\\n                continue;\\n            }\\n            else{\\n                res.push_back(words[i]);\\n                st.erase(st.begin(),st.end());\\n                st.insert(temp);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n     vector<string>res;\\n        set<string>st;\\n        for(int i=0;i<words.size();i++){\\n            string temp=words[i];\\n            sort(temp.begin(),temp.end());\\n            if(st.count(temp)){\\n                continue;\\n            }\\n            else{\\n                res.push_back(words[i]);\\n                st.erase(st.begin(),st.end());\\n                st.insert(temp);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2039786,
                "title": "c-solution-easy-understanding-sorting",
                "content": "```\\n    vector<string> removeAnagrams(vector<string>& words) {\\n     vector<string>ans;\\n     ans.push_back(words[0]);\\n    for (int i = 1; i<words.size(); i++) \\n    { \\n        string a=words[i];\\n        string b=ans[ans.size()-1];\\n        sort(a.begin(),a.end());\\n        sort(b.begin(),b.end());\\n        if(a!=b)\\n        {\\n            ans.push_back(words[i]);\\n        }\\n    }\\n        return ans;\\n    }",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\n    vector<string> removeAnagrams(vector<string>& words) {\\n     vector<string>ans;\\n     ans.push_back(words[0]);\\n    for (int i = 1; i<words.size(); i++) \\n    { \\n        string a=words[i];\\n        string b=ans[ans.size()-1];\\n        sort(a.begin(),a.end());\\n        sort(b.begin(),b.end());\\n        if(a!=b)\\n        {\\n            ans.push_back(words[i]);\\n        }\\n    }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2039762,
                "title": "java-store-previous-anagrams-string",
                "content": "Store the previous anagram string with characters sorted. Iterate over the words, if the anagramStr is newly seen, add the current to the result and update the lastAnagramStr; if the anagramStr is the same as lastAnagramStr, skip.\\n```\\nclass Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        List<String> result = new LinkedList<>();\\n        String lastAnagramStr = null;\\n        for (String s : words) {\\n            char[] charArr = s.toCharArray();\\n            Arrays.sort(charArr);\\n            String curAnagramStr = new String(charArr);\\n            \\n            if (curAnagramStr.equals(lastAnagramStr)) {\\n                continue;\\n            }\\n            else {\\n                lastAnagramStr = curAnagramStr;\\n                result.add(s);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        List<String> result = new LinkedList<>();\\n        String lastAnagramStr = null;\\n        for (String s : words) {\\n            char[] charArr = s.toCharArray();\\n            Arrays.sort(charArr);\\n            String curAnagramStr = new String(charArr);\\n            \\n            if (curAnagramStr.equals(lastAnagramStr)) {\\n                continue;\\n            }\\n            else {\\n                lastAnagramStr = curAnagramStr;\\n                result.add(s);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2039732,
                "title": "python-simple-solution-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        if len(words)==1:\\n            return words\\n        i = 1 \\n        while i<len(words):\\n            if sorted(list(words[i]))==sorted(list(words[i-1])):\\n                words.pop(i)\\n            else:\\n                i+=1 \\n        return words\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        if len(words)==1:\\n            return words\\n        i = 1 \\n        while i<len(words):\\n            if sorted(list(words[i]))==sorted(list(words[i-1])):\\n                words.pop(i)\\n            else:\\n                i+=1 \\n        return words\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2039720,
                "title": "create-stack-and-compare-with-top-of-stack",
                "content": "```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        stack = []\\n        for w in words:\\n            if len(stack) == 0 or sorted(w) != sorted(stack[-1]):\\n                stack.append(w)\\n        return stack\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        stack = []\\n        for w in words:\\n            if len(stack) == 0 or sorted(w) != sorted(stack[-1]):\\n                stack.append(w)\\n        return stack\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3924820,
                "title": "java-solution-easy-to-understand",
                "content": "\\n\\n## Intuition\\nThe problem is about removing anagrams from an array of strings and returning a list of strings where each string is not an anagram of any other string in the list.\\n\\n## Approach\\n1. **isAnagram Method**: The `isAnagram` method checks whether two input strings are anagrams of each other or not. It sorts the characters of both strings and compares them. If the sorted arrays of characters are equal, then the strings are anagrams.\\n\\n2. **removeAnagrams Method**: The `removeAnagrams` method iterates through the array of strings and uses the `isAnagram` method to identify and mark anagrams.\\n   - It maintains a boolean array `vis` to track visited words (anagrams are marked as visited).\\n   - For each word at index `i`, it searches for the next non-visited word (starting from `i + 1`) and marks it as visited if it\\'s an anagram.\\n   - After marking all anagrams, the method adds the non-visited words to the result list.\\n\\n## Complexity\\n- **Time complexity**:\\n   - The `isAnagram` method sorts two char arrays, which takes O(k * log(k)) time complexity, where k is the length of the longest string in the array.\\n   - The main part of the time complexity comes from the nested loops in the `removeAnagrams` method. The outer loop runs in O(n) time, and for each word, the inner loop can run up to n - 1 times (when all words are anagrams of each other). The `isAnagram` method itself takes O(k * log(k)) time in the worst case. So, the overall time complexity is O(n^2 * k * log(k)).\\n\\n- **Space complexity**:\\n   - The space complexity of the `isAnagram` method is O(k), where k is the length of the longest string.\\n   - The `removeAnagrams` method uses a boolean array `vis` of size n to mark visited words, so the space complexity is O(n).\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isAnagram(String s1,String s2){\\n        if(s1.length()!=s2.length())return false;\\n        char a[]=s1.toCharArray();\\n        char b[]=s2.toCharArray();\\n        Arrays.sort(a);\\n        Arrays.sort(b);\\n        for(int i=0;i<a.length;i++){\\n            if(a[i]!=b[i])return false;\\n        }\\n        return true;\\n    }\\n    public List<String> removeAnagrams(String[] words) {\\n        List<String> list=new ArrayList<>();\\n        boolean vis[]=new boolean[words.length];\\n        for(int i=0;i<words.length-1;i++){\\n            int j=i+1;\\n            while(vis[j]==true){\\n                j++;\\n            }\\n            if(isAnagram(words[i],words[j])){\\n                vis[j]=true;\\n            }\\n        }\\n        for(int i=0;i<words.length;i++){\\n            // System.out.print(i+\"--\"+vis[i]);\\n            if(vis[i]==false)\\n            {\\n                list.add(words[i]);\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```\\n# Give me ThumsUp if it helps for you \\uD83D\\uDC4D\\uD83D\\uDC4D\\uD83D\\uDE09\\uD83D\\uDE09",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isAnagram(String s1,String s2){\\n        if(s1.length()!=s2.length())return false;\\n        char a[]=s1.toCharArray();\\n        char b[]=s2.toCharArray();\\n        Arrays.sort(a);\\n        Arrays.sort(b);\\n        for(int i=0;i<a.length;i++){\\n            if(a[i]!=b[i])return false;\\n        }\\n        return true;\\n    }\\n    public List<String> removeAnagrams(String[] words) {\\n        List<String> list=new ArrayList<>();\\n        boolean vis[]=new boolean[words.length];\\n        for(int i=0;i<words.length-1;i++){\\n            int j=i+1;\\n            while(vis[j]==true){\\n                j++;\\n            }\\n            if(isAnagram(words[i],words[j])){\\n                vis[j]=true;\\n            }\\n        }\\n        for(int i=0;i<words.length;i++){\\n            // System.out.print(i+\"--\"+vis[i]);\\n            if(vis[i]==false)\\n            {\\n                list.add(words[i]);\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3752922,
                "title": "python-easy-solution-stack",
                "content": "# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def check(self,word1: str,word2: str)->bool:\\n        word1=list(word1)\\n        word1.sort()\\n        word2=list(word2)\\n        word2.sort()\\n        if word1==word2:\\n            return 1\\n        return 0\\n\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        lis=[]\\n        for i in range(len(words)):\\n            if len(lis)==0 or Solution.check(self,lis[len(lis)-1],words[i])==0:\\n                lis.append(words[i])\\n        return lis            \\n```",
                "solutionTags": [
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def check(self,word1: str,word2: str)->bool:\\n        word1=list(word1)\\n        word1.sort()\\n        word2=list(word2)\\n        word2.sort()\\n        if word1==word2:\\n            return 1\\n        return 0\\n\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        lis=[]\\n        for i in range(len(words)):\\n            if len(lis)==0 or Solution.check(self,lis[len(lis)-1],words[i])==0:\\n                lis.append(words[i])\\n        return lis            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3490966,
                "title": "pattern-c",
                "content": "# Intuition\\nBasic two pointer pattern.\\n\\nA lot of similar questions can be solved with this like \\nhttps://leetcode.com/problems/sort-array-by-parity-ii\\nremove element \\nRemove Duplicates from Sorted Array - LeetCode\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe can have two pointers as i=0,j=0 and k=0 as counter to replace the words vector according to question.\\nIncrease j till words[i] and words[j] aree not anagrams anymore\\n\\n         - - - - - -\\n         i     j\\n\\nso we got one element words[i] do the same for all the elements \\none corner case has to be taken into account\\n# Complexity\\n- Time complexity:\\nO(n*m)\\n\\n- Space complexity:\\nO(1);\\n\\n# Code\\nclass Solution {\\npublic:\\n\\n    bool anagram(string &str1,string &str2){\\n        int cnt[256]={0};\\n        int n=str1.length();\\n        int m=str2.length();\\n        if(n != m){\\n            return false;\\n        }\\n        for(int i=0;i<n;i++){\\n            cnt[str1[i]-\\'a\\']++;\\n            cnt[str2[i]-\\'a\\']--;\\n        }\\n        for(int i=0;i<256;i++){\\n            if(cnt[i] !=0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        int r= words.size();\\n        int i=0,j=0,k=0;\\n        while(j<r){\\n            \\n            while(j<r && anagram(words[j],words[i]) == true){\\n                j++;\\n            }\\n            \\n            if(j<r && !anagram(words[j],words[i])){\\n                words[k]=words[i];\\n                cout<<k;\\n                k++;\\n                i=j;\\n            }\\n        }\\n        // if(k==0){\\n        //     words.resize(1);\\n        // }\\n        // else{\\n        //     words.resize(k);\\n        // }\\n\\n        if(j==r){\\n            words[k]=words[i];\\n        }\\n        k++;\\n        words.resize(k);\\n        return  words;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "class Solution {\\npublic:\\n\\n    bool anagram(string &str1,string &str2){\\n        int cnt[256]={0}",
                "codeTag": "Java"
            },
            {
                "id": 3280257,
                "title": "easy-solution",
                "content": "# Code\\n```\\nfunc removeAnagrams(words []string) []string {\\n    \\n    j := 0\\n\\n    for i, v := range words {\\n        if v != \"\" {\\n             for j := i+1; j < len(words); j++ {\\n                if sort(v) == sort(words[j]) {\\n                    words[j] = \"\"\\n                }else{\\n                    break\\n                }\\n            }\\n            words[j] = v\\n            j++\\n        }\\n    }\\n    \\n\\n    return words[:j]\\n}\\n\\nfunc sort(str string) string {\\n  runes := []rune(str)\\n\\n    // Bubble sort the slice of runes\\n    for i := 0; i < len(runes); i++ {\\n        for j := i + 1; j < len(runes); j++ {\\n            if runes[i] > runes[j] {\\n                temp := runes[i]\\n                runes[i] = runes[j]\\n                runes[j] = temp\\n            }\\n        }\\n    }\\n\\n    // Convert the slice of runes back to a string\\n    sortedStr := string(runes)\\n\\n    return sortedStr\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc removeAnagrams(words []string) []string {\\n    \\n    j := 0\\n\\n    for i, v := range words {\\n        if v != \"\" {\\n             for j := i+1; j < len(words); j++ {\\n                if sort(v) == sort(words[j]) {\\n                    words[j] = \"\"\\n                }else{\\n                    break\\n                }\\n            }\\n            words[j] = v\\n            j++\\n        }\\n    }\\n    \\n\\n    return words[:j]\\n}\\n\\nfunc sort(str string) string {\\n  runes := []rune(str)\\n\\n    // Bubble sort the slice of runes\\n    for i := 0; i < len(runes); i++ {\\n        for j := i + 1; j < len(runes); j++ {\\n            if runes[i] > runes[j] {\\n                temp := runes[i]\\n                runes[i] = runes[j]\\n                runes[j] = temp\\n            }\\n        }\\n    }\\n\\n    // Convert the slice of runes back to a string\\n    sortedStr := string(runes)\\n\\n    return sortedStr\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3202524,
                "title": "5-lines-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        x=[words[0]]\\n        for i in range(1,len(words)):\\n            if sorted(x[-1])!=sorted(words[i]):\\n                x.append(words[i])\\n        return x\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        x=[words[0]]\\n        for i in range(1,len(words)):\\n            if sorted(x[-1])!=sorted(words[i]):\\n                x.append(words[i])\\n        return x\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3031282,
                "title": "itertools-is-awesome",
                "content": "Here\\'s a one-liner\\n\\n```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        return (next(val) for _, val in groupby(words, key=sorted))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        return (next(val) for _, val in groupby(words, key=sorted))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2902430,
                "title": "easy-js-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string[]} words\\n * @return {string[]}\\n */\\nvar removeAnagrams = function(words) {\\n   for(let i =1;i<words.length; i++){\\n       if(isAnagram(words[i], words[i-1])){\\n           words.splice(i,1);\\n           i--;\\n       }\\n   } \\n    return words;\\n   function isAnagram(s1, s2){\\n       let arr1 = s1.split(\"\");\\n       let arr2 = s2.split(\"\");\\n       if(arr1.length != arr2.length) return false;\\n       for(let i =0; i<arr1.length; i++){\\n           if(arr2.includes(arr1[i])){\\n               arr2.splice(arr2.indexOf(arr1[i]),1);\\n           }\\n       }\\n       return arr2.length ===0;\\n   }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @return {string[]}\\n */\\nvar removeAnagrams = function(words) {\\n   for(let i =1;i<words.length; i++){\\n       if(isAnagram(words[i], words[i-1])){\\n           words.splice(i,1);\\n           i--;\\n       }\\n   } \\n    return words;\\n   function isAnagram(s1, s2){\\n       let arr1 = s1.split(\"\");\\n       let arr2 = s2.split(\"\");\\n       if(arr1.length != arr2.length) return false;\\n       for(let i =0; i<arr1.length; i++){\\n           if(arr2.includes(arr1[i])){\\n               arr2.splice(arr2.indexOf(arr1[i]),1);\\n           }\\n       }\\n       return arr2.length ===0;\\n   }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2849481,
                "title": "simple-c-solution-for-beginners-c-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCompare the two adjacent elemets and if not equal push into result array\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSort the two strings for comparision\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n  O(nlogn)\\n- Space complexity:\\n- O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\\\\\n        vector<string> ans;\\n        ans.push_back(words[0]);\\n        for(int i=1;i<words.size();i++) {\\n            string a = words[i] , b = words[i-1];\\n            sort(a.begin() , a.end());\\n            sort(b.begin() , b.end());\\n            if(a != b) ans.push_back(words[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\\\\\n        vector<string> ans;\\n        ans.push_back(words[0]);\\n        for(int i=1;i<words.size();i++) {\\n            string a = words[i] , b = words[i-1];\\n            sort(a.begin() , a.end());\\n            sort(b.begin() , b.end());\\n            if(a != b) ans.push_back(words[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2751510,
                "title": "python-counter-solution",
                "content": "```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        res=[words[0]] \\n        for i in range(1,len(words)):\\n            mp1,mp2=Counter(words[i-1]),Counter(words[i]) \\n            if mp1!=mp2:\\n                res.append(words[i]) \\n        return res\\n\\t\\t#misread easy to medium\\n        # s=[]\\n        # ans=[]\\n        # for i in words:\\n        #     mp=[0]*26 \\n        #     for j in i:\\n        #         mp[ord(j)-ord(\"a\")]+=1\\n        #     if str(mp) in s:\\n        #         continue\\n        #     else:\\n        #         ans.append(i)\\n        #         s.append(str(mp))\\n        # return ans\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        res=[words[0]] \\n        for i in range(1,len(words)):\\n            mp1,mp2=Counter(words[i-1]),Counter(words[i]) \\n            if mp1!=mp2:\\n                res.append(words[i]) \\n        return res\\n\\t\\t#misread easy to medium\\n        # s=[]\\n        # ans=[]\\n        # for i in words:\\n        #     mp=[0]*26 \\n        #     for j in i:\\n        #         mp[ord(j)-ord(\"a\")]+=1\\n        #     if str(mp) in s:\\n        #         continue\\n        #     else:\\n        #         ans.append(i)\\n        #         s.append(str(mp))\\n        # return ans\\n",
                "codeTag": "Java"
            },
            {
                "id": 2599969,
                "title": "java-string-sorting-simple-solution",
                "content": "```\\nclass Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        String prev = \"\";\\n        ArrayList<String> li=new ArrayList<>();\\n        for(int i=0;i<words.length;i++){\\n            char[] ch=words[i].toCharArray();\\n            Arrays.sort(ch);\\n            String curr=String.valueOf(ch);\\n            if(!curr.equals(prev)){\\n                li.add(words[i]);\\n                prev=curr;\\n            }\\n        }\\n        return li;\\n    }\\n}\\n```\\nKindly upvote if you like the code.",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        String prev = \"\";\\n        ArrayList<String> li=new ArrayList<>();\\n        for(int i=0;i<words.length;i++){\\n            char[] ch=words[i].toCharArray();\\n            Arrays.sort(ch);\\n            String curr=String.valueOf(ch);\\n            if(!curr.equals(prev)){\\n                li.add(words[i]);\\n                prev=curr;\\n            }\\n        }\\n        return li;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2597106,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        if(words.size()==1)\\n        {\\n            return {words[0]};\\n        }\\n        vector<string>ans;\\n        string temp1=\"\";\\n        string temp2=\"\";\\n        int i=0;\\n        int j=1;\\n        temp1=words[i];\\n        sort(temp1.begin(),temp1.end());\\n        temp2=words[j];\\n        sort(temp2.begin(),temp2.end());\\n        while(j<words.size())\\n        {\\n            temp2=words[j];\\n            sort(temp2.begin(),temp2.end());\\n            if(temp1==temp2)\\n            {\\n                j++;\\n            }\\n            else\\n            {\\n                ans.push_back(words[i]);\\n                i=j;\\n                temp1=words[i];\\n                sort(temp1.begin(),temp1.end());\\n                j++;\\n            }\\n        }\\n        if(temp1==temp2)\\n        {\\n            ans.push_back(words[i]);\\n        }\\n        else\\n        {\\n             ans.push_back(words[i]);\\n              ans.push_back(words[j]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        if(words.size()==1)\\n        {\\n            return {words[0]};\\n        }\\n        vector<string>ans;\\n        string temp1=\"\";\\n        string temp2=\"\";\\n        int i=0;\\n        int j=1;\\n        temp1=words[i];\\n        sort(temp1.begin(),temp1.end());\\n        temp2=words[j];\\n        sort(temp2.begin(),temp2.end());\\n        while(j<words.size())\\n        {\\n            temp2=words[j];\\n            sort(temp2.begin(),temp2.end());\\n            if(temp1==temp2)\\n            {\\n                j++;\\n            }\\n            else\\n            {\\n                ans.push_back(words[i]);\\n                i=j;\\n                temp1=words[i];\\n                sort(temp1.begin(),temp1.end());\\n                j++;\\n            }\\n        }\\n        if(temp1==temp2)\\n        {\\n            ans.push_back(words[i]);\\n        }\\n        else\\n        {\\n             ans.push_back(words[i]);\\n              ans.push_back(words[j]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2549497,
                "title": "my-js-solution-easy-and-simple-to-understand",
                "content": "```javascript\\nconst removeAnagrams = function(words) {  \\n  if (words.length === 0) return [];\\n  \\n const result = [words[0]];\\n  for (let i = 1, j = 0; i < words.length; i++) {\\n    const isAnagramTrue = isAnagram(result[j], words[i]);\\n    \\n    if (!isAnagramTrue) {\\n      result.push(words[i]);\\n      j++;\\n    }\\n  }\\n\\n  return result;\\n};\\n\\nconst isAnagram = function (str1, str2) {\\n  const firstStr = str1;\\n  const secondStr = str2;\\n  \\n  if (firstStr === secondStr) return true;\\n  if (firstStr.length !== secondStr.length) return false;\\n  \\n  const firstHashMap = {};\\n  const secondHashMap = {};\\n  \\n  for (let i = 0; i < firstStr.length; i++) {\\n    if (firstHashMap[firstStr[i]])\\n      firstHashMap[firstStr[i]]++;\\n    else\\n      firstHashMap[firstStr[i]] = 1;\\n    \\n    if (secondHashMap[secondStr[i]])\\n      secondHashMap[secondStr[i]]++;\\n    else \\n      secondHashMap[secondStr[i]] = 1;\\n  }\\n\\n  \\n  for (let i = 0; i < firstStr.length; i++) {\\n    if (firstHashMap[firstStr[i]] !== secondHashMap[firstStr[i]]) return false;\\n  }\\n  \\n  return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nconst removeAnagrams = function(words) {  \\n  if (words.length === 0) return [];\\n  \\n const result = [words[0]];\\n  for (let i = 1, j = 0; i < words.length; i++) {\\n    const isAnagramTrue = isAnagram(result[j], words[i]);\\n    \\n    if (!isAnagramTrue) {\\n      result.push(words[i]);\\n      j++;\\n    }\\n  }\\n\\n  return result;\\n};\\n\\nconst isAnagram = function (str1, str2) {\\n  const firstStr = str1;\\n  const secondStr = str2;\\n  \\n  if (firstStr === secondStr) return true;\\n  if (firstStr.length !== secondStr.length) return false;\\n  \\n  const firstHashMap = {};\\n  const secondHashMap = {};\\n  \\n  for (let i = 0; i < firstStr.length; i++) {\\n    if (firstHashMap[firstStr[i]])\\n      firstHashMap[firstStr[i]]++;\\n    else\\n      firstHashMap[firstStr[i]] = 1;\\n    \\n    if (secondHashMap[secondStr[i]])\\n      secondHashMap[secondStr[i]]++;\\n    else \\n      secondHashMap[secondStr[i]] = 1;\\n  }\\n\\n  \\n  for (let i = 0; i < firstStr.length; i++) {\\n    if (firstHashMap[firstStr[i]] !== secondHashMap[firstStr[i]]) return false;\\n  }\\n  \\n  return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2531100,
                "title": "find-resultant-array-after-removing-anagrams-solution",
                "content": "C++ Simple Solution\\n\\n```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        vector<string> res;\\n        for(int i=0;i<words.size();i++){\\n            string str = words[i];\\n            sort(words[i].begin(),words[i].end());\\n            if( i > 0 && words[i]==words[i-1]) continue;\\n            res.push_back(str);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        vector<string> res;\\n        for(int i=0;i<words.size();i++){\\n            string str = words[i];\\n            sort(words[i].begin(),words[i].end());\\n            if( i > 0 && words[i]==words[i-1]) continue;\\n            res.push_back(str);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2530295,
                "title": "c-solution-faster-than-100",
                "content": "```\\npublic class Solution {\\n    public IList<string> RemoveAnagrams(string[] words) {\\n            IList<string> list = new List<string>();\\n            Stack<string> stack = new Stack<string>();\\n            int n = words.Length;\\n            for (int i = 0; i < n; i++)\\n            {\\n                char[] str = words[i].ToCharArray();\\n                Array.Sort(str);\\n                if (stack.Count == 0)\\n                {\\n                    stack.Push(new string(str));\\n                    list.Add(words[i]);\\n                }\\n                else\\n                {\\n                    if(!stack.Peek().Equals(new string(str)))\\n                    {\\n                        list.Add(words[i]);\\n                        stack.Push(new string(str));\\n                    }\\n                }\\n            }\\n            return list;\\n    }\\n}",
                "solutionTags": [
                    "C#",
                    "String",
                    "Stack"
                ],
                "code": "class Solution {\\n    public IList<string> RemoveAnagrams(string[] words) {\\n            IList<string> list = new List<string>();\\n            Stack<string> stack = new Stack<string>();\\n            int n = words.Length;\\n            for (int i = 0; i < n; i++)\\n            {\\n                char[] str = words[i].ToCharArray();\\n                Array.Sort(str);\\n                if (stack.Count == 0)\\n                {\\n                    stack.Push(new string(str));\\n                    list.Add(words[i]);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2372879,
                "title": "python-easy-solution",
                "content": "```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        res = [words[0]]\\n        print(res)\\n        for i in range(1,len(words)):\\n            if sorted(words[i])!=sorted(words[i-1]):\\n                res.append(words[i])\\n        return res\\n```\\n***if useful then vote up***",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        res = [words[0]]\\n        print(res)\\n        for i in range(1,len(words)):\\n            if sorted(words[i])!=sorted(words[i-1]):\\n                res.append(words[i])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2345096,
                "title": "java-o-n-2-solution-with-comments-to-understand-2-pointer-method",
                "content": "**Please Upvote if  you liked and simply understand the solution it means world to me!!**\\n```\\nclass Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        List<String> ans = new ArrayList<>();\\n        for (int i = 0; i < words.length;) {\\n\\t\\t// we will run loop from 0 to words.length for i.\\n            int j;\\n            for (j = i + 1; j < words.length; j++) {\\n\\t\\t\\t// we will check if anagram strings or not\\n\\t\\t\\t// if not then we will break the looop\\n                if (!isAnagram(words[i], words[j])) {\\n                    break;\\n                }\\n            }\\n\\t\\t\\t// after breaking the loop we will add our first anagram number ar ith index \\n\\t\\t\\t//after that we will set i to j\\n            ans.add(words[i]);\\n            i = j;\\n        }\\n\\n        return ans;\\n    }\\n\\t\\n\\t// function to know wheather two strings are anagram or not\\n    boolean isAnagram(String s, String t) {\\n\\t\\n\\t//if lengths of both strings is not equal they cannot be anagram\\n        if (s.length() != t.length()) {\\n            return false;\\n        }\\n\\t\\t\\n\\t\\t//conver the both strings into the character arrays\\n        char[] c1 = s.toCharArray();\\n        char[] c2 = t.toCharArray();\\n\\t\\t\\n\\t\\t//sort the respectively both arrays\\n        Arrays.sort(c1);\\n        Arrays.sort(c2);\\n\\n\\t\\t// check if elements of both sorted arrays are equal or not\\n        for (int i = 0; i < c2.length; i++) {\\n            if (c1[i] != c2[i]) {\\n\\t\\t\\t// if elements are not equal then return false.\\n                return false;\\n            }\\n        }\\n\\t\\t// loop over means all the elements are equal so it is anagram reutrning true\\n        return true;\\n}\\n}\\n```\\n**Thank You!!**\\n**if you liked solution please upvote!!**",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        List<String> ans = new ArrayList<>();\\n        for (int i = 0; i < words.length;) {\\n\\t\\t// we will run loop from 0 to words.length for i.\\n            int j;\\n            for (j = i + 1; j < words.length; j++) {\\n\\t\\t\\t// we will check if anagram strings or not\\n\\t\\t\\t// if not then we will break the looop\\n                if (!isAnagram(words[i], words[j])) {\\n                    break;\\n                }\\n            }\\n\\t\\t\\t// after breaking the loop we will add our first anagram number ar ith index \\n\\t\\t\\t//after that we will set i to j\\n            ans.add(words[i]);\\n            i = j;\\n        }\\n\\n        return ans;\\n    }\\n\\t\\n\\t// function to know wheather two strings are anagram or not\\n    boolean isAnagram(String s, String t) {\\n\\t\\n\\t//if lengths of both strings is not equal they cannot be anagram\\n        if (s.length() != t.length()) {\\n            return false;\\n        }\\n\\t\\t\\n\\t\\t//conver the both strings into the character arrays\\n        char[] c1 = s.toCharArray();\\n        char[] c2 = t.toCharArray();\\n\\t\\t\\n\\t\\t//sort the respectively both arrays\\n        Arrays.sort(c1);\\n        Arrays.sort(c2);\\n\\n\\t\\t// check if elements of both sorted arrays are equal or not\\n        for (int i = 0; i < c2.length; i++) {\\n            if (c1[i] != c2[i]) {\\n\\t\\t\\t// if elements are not equal then return false.\\n                return false;\\n            }\\n        }\\n\\t\\t// loop over means all the elements are equal so it is anagram reutrning true\\n        return true;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2338945,
                "title": "py-nerd-counter-frequency-list-no-sorting",
                "content": "### The main idea:\\n1. use Counter or Frequency list to identify anagrams\\n2. use `prev` (the most recent Counter) to remove adjcent anagrams\\n\\nComment below for any questions / corrections\\n\\n\\n### how to implement Freq. list\\n```\\nlst = [0] * 26\\noffset = ord(\\'a\\')\\nfor c in s:\\n\\tlst[ord(c) - offset] +=1\\n```\\n\\n### Main algo\\n```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        res = []\\n        prev = None\\n        for w in words:\\n            count = Counter(w)\\n            if count != prev:\\n                res.append(w)\\n                prev = count\\n        return res\\n    # time O(n * k) visit each word, and Counter takes k = longest word len\\n    # space O(n) at most save n words\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nlst = [0] * 26\\noffset = ord(\\'a\\')\\nfor c in s:\\n\\tlst[ord(c) - offset] +=1\\n```\n```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        res = []\\n        prev = None\\n        for w in words:\\n            count = Counter(w)\\n            if count != prev:\\n                res.append(w)\\n                prev = count\\n        return res\\n    # time O(n * k) visit each word, and Counter takes k = longest word len\\n    # space O(n) at most save n words\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2227786,
                "title": "simple-and-easy-c-sorting",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        vector<string> res;\\n        res.push_back(words[0]);\\n        for(int i=1;i<words.size();i++)\\n        {\\n            string temp1 = words[i];\\n            string temp2 = words[i-1];\\n            sort(temp1.begin(), temp1.end());\\n            sort(temp2.begin(), temp2.end());\\n            if(temp1!= temp2)\\n                res.push_back(words[i]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        vector<string> res;\\n        res.push_back(words[0]);\\n        for(int i=1;i<words.size();i++)\\n        {\\n            string temp1 = words[i];\\n            string temp2 = words[i-1];\\n            sort(temp1.begin(), temp1.end());\\n            sort(temp2.begin(), temp2.end());\\n            if(temp1!= temp2)\\n                res.push_back(words[i]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2110139,
                "title": "stack-based-solution-c",
                "content": "```\\n\\n```class Solution {\\npublic:\\n    bool isanagram(string x,string y)\\n    {\\n        sort(x.begin(),x.end());\\n        sort(y.begin(),y.end());\\n        if(x==y)\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        vector<string>ans;\\n        int i=0;\\n        stack<string>s;\\n        s.push(words[0]);\\n        for(int i=1;i<words.size();i++)\\n        {\\n            if(isanagram(s.top(),words[i]))\\n            {\\n                continue;\\n            }\\n            s.push(words[i]);\\n        }\\n        while(!s.empty())\\n        {\\n            ans.push_back(s.top());\\n            s.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2104358,
                "title": "python3-solution",
                "content": "```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        \\n        tmp = words[0] \\n        words = words[1:]\\n        ans = [tmp] \\n        while words: \\n            if sorted(words[0]) != sorted(tmp): \\n                tmp = words[0]\\n                ans.append(tmp)\\n            words.pop(0)\\n                \\n        return ans",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        \\n        tmp = words[0] \\n        words = words[1:]\\n        ans = [tmp] \\n        while words: \\n            if sorted(words[0]) != sorted(tmp): \\n                tmp = words[0]\\n                ans.append(tmp)\\n            words.pop(0)\\n                \\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 2104211,
                "title": "simple-python-solution-easy-to-understand",
                "content": "```\\n\\n```def removeAnagrams(self, words: List[str]) -> List[str]:\\n        \\n        save = []\\n        save.append(words[0])\\n        \\n        for i in range(1, len(words)):\\n            save.append(words[i])\\n            if sorted(words[i]) == sorted(words[i-1]):\\n                save.pop()\\n        \\n        return save",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2085199,
                "title": "swift-simple-and-easy-to-understand-solution",
                "content": "```\\nlass Solution {\\n    func removeAnagrams(_ words: [String]) -> [String] {\\n\\n        var answer = words\\n        var i = 0\\n\\n        while i < answer.count - 1 {\\n\\n            if answer[i].sorted() == answer[i+1].sorted() {\\n                answer.remove(at: i+1)\\n            } else {\\n                i += 1\\n            }\\n        }\\n\\t\\t\\n        return answer\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nlass Solution {\\n    func removeAnagrams(_ words: [String]) -> [String] {\\n\\n        var answer = words\\n        var i = 0\\n\\n        while i < answer.count - 1 {\\n\\n            if answer[i].sorted() == answer[i+1].sorted() {\\n                answer.remove(at: i+1)\\n            } else {\\n                i += 1\\n            }\\n        }\\n\\t\\t\\n        return answer\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2081579,
                "title": "easy-cpp-maps",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        vector<string>ans;\\n        vector<string>temp=words;\\n        for(int i=0;i<words.size();i++)\\n        {\\n            sort(temp[i].begin(),temp[i].end());\\n        }\\n        unordered_map<string,int>s;\\n        for(int i=0;i<words.size();i++)\\n        {\\n            auto it=s.find(temp[i]);\\n            \\n            if(it==s.end()||i-it->second>1)\\n            {\\n               ans.push_back(words[i]);\\n            }\\n            else if(it!=s.end())\\n            {\\n                s.erase(temp[i]);\\n            }\\n            s[temp[i]]=i;\\n            \\n        }\\n       \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        vector<string>ans;\\n        vector<string>temp=words;\\n        for(int i=0;i<words.size();i++)\\n        {\\n            sort(temp[i].begin(),temp[i].end());\\n        }\\n        unordered_map<string,int>s;\\n        for(int i=0;i<words.size();i++)\\n        {\\n            auto it=s.find(temp[i]);\\n            \\n            if(it==s.end()||i-it->second>1)\\n            {\\n               ans.push_back(words[i]);\\n            }\\n            else if(it!=s.end())\\n            {\\n                s.erase(temp[i]);\\n            }\\n            s[temp[i]]=i;\\n            \\n        }\\n       \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2077569,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        List<String> res = new ArrayList<>();\\n        res.add(words[0]);\\n        for(int i=1; i<words.length; i++){\\n            String left = toSorted(words[i-1]);\\n            String right = toSorted(words[i]);\\n            if(!left.equals(right)){\\n                res.add(words[i]);\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    public String toSorted(String strs){\\n        char[] ch = strs.toCharArray();\\n        Arrays.sort(ch);\\n        String key = String.valueOf(ch);\\n       \\n        return key;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        List<String> res = new ArrayList<>();\\n        res.add(words[0]);\\n        for(int i=1; i<words.length; i++){\\n            String left = toSorted(words[i-1]);\\n            String right = toSorted(words[i]);\\n            if(!left.equals(right)){\\n                res.add(words[i]);\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    public String toSorted(String strs){\\n        char[] ch = strs.toCharArray();\\n        Arrays.sort(ch);\\n        String key = String.valueOf(ch);\\n       \\n        return key;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2067894,
                "title": "easy-simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isequal(string x, string y) {\\n        vector<int> ans(26, 0);\\n        for (int j = 0; j < x.size(); j++) {\\n            ans[x[j] - \\'a\\']++;\\n        }\\n        for (int k = 0; k < y.size(); k++) {\\n            ans[y[k] - \\'a\\']--;\\n        }\\n        for (int k = 0; k < ans.size(); k++) {\\n            if (ans[k] != 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        vector<string> harsh;\\n        for (int i = 0; i < words.size();) {\\n            int j = i + 1;\\n            for (; j < words.size() and isequal(words[i], words[j]);) {\\n                j++;\\n            }\\n            harsh.push_back(words[i]);\\n            i = j;\\n        }\\n        return harsh;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isequal(string x, string y) {\\n        vector<int> ans(26, 0);\\n        for (int j = 0; j < x.size(); j++) {\\n            ans[x[j] - \\'a\\']++;\\n        }\\n        for (int k = 0; k < y.size(); k++) {\\n            ans[y[k] - \\'a\\']--;\\n        }\\n        for (int k = 0; k < ans.size(); k++) {\\n            if (ans[k] != 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        vector<string> harsh;\\n        for (int i = 0; i < words.size();) {\\n            int j = i + 1;\\n            for (; j < words.size() and isequal(words[i], words[j]);) {\\n                j++;\\n            }\\n            harsh.push_back(words[i]);\\n            i = j;\\n        }\\n        return harsh;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2066230,
                "title": "python3-solution-readable",
                "content": "```\\nclass Solution:\\n    \\n    def anagram_detector(self, a: str, b: str) -> bool:\\n        a =sorted(list(a))\\n        b = sorted(list(b))\\n        if a == b:\\n            return True\\n        else:\\n            return False\\n        \\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        if len(words) == 1:\\n            return words\\n        while len(words) > 2:\\n            detected = False\\n            for i in range(1,len(words)):\\n                if self.anagram_detector(words[i],words[i-1]):\\n                    del words[i]\\n                    detected = True\\n                    break\\n            if not detected:\\n                return words\\n        if self.anagram_detector(words[0],words[1]):\\n            del words[1]\\n        return words\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    \\n    def anagram_detector(self, a: str, b: str) -> bool:\\n        a =sorted(list(a))\\n        b = sorted(list(b))\\n        if a == b:\\n            return True\\n        else:\\n            return False\\n        \\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        if len(words) == 1:\\n            return words\\n        while len(words) > 2:\\n            detected = False\\n            for i in range(1,len(words)):\\n                if self.anagram_detector(words[i],words[i-1]):\\n                    del words[i]\\n                    detected = True\\n                    break\\n            if not detected:\\n                return words\\n        if self.anagram_detector(words[0],words[1]):\\n            del words[1]\\n        return words\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2064281,
                "title": "java-simple-fast-low-memory",
                "content": "```\\nclass Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        ArrayList<String> ans = new ArrayList<>(words.length);\\n        byte[] sign = new byte[26], tmp, buf = new byte[26];\\n        for (String s : words) {\\n            Arrays.fill(buf, (byte) 0);\\n            for (int i=0, slen=s.length(); i < slen; i++) {\\n                buf[s.charAt(i) - \\'a\\']++;\\n            }\\n            if (Arrays.equals(sign, buf)) continue;\\n            tmp = sign; sign = buf; buf = tmp; // swap\\n            ans.add(s);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        ArrayList<String> ans = new ArrayList<>(words.length);\\n        byte[] sign = new byte[26], tmp, buf = new byte[26];\\n        for (String s : words) {\\n            Arrays.fill(buf, (byte) 0);\\n            for (int i=0, slen=s.length(); i < slen; i++) {\\n                buf[s.charAt(i) - \\'a\\']++;\\n            }\\n            if (Arrays.equals(sign, buf)) continue;\\n            tmp = sign; sign = buf; buf = tmp; // swap\\n            ans.add(s);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2054934,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        List<String>res = new LinkedList<>();\\n        for (String word:words){\\n            if (res.isEmpty() || !isAnagram(word, res.get(res.size()-1)))res.add(word);\\n        }\\n        return res;\\n    }\\n    \\n    public Boolean isAnagram(String w1, String w2){\\n        if (w1.length()!=w2.length())return false;\\n        else {\\n            char[] word1 = w1.toCharArray();\\n            Arrays.sort(word1);\\n            char[] word2 = w2.toCharArray();\\n            Arrays.sort(word2);\\n            return Arrays.equals(word1, word2);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        List<String>res = new LinkedList<>();\\n        for (String word:words){\\n            if (res.isEmpty() || !isAnagram(word, res.get(res.size()-1)))res.add(word);\\n        }\\n        return res;\\n    }\\n    \\n    public Boolean isAnagram(String w1, String w2){\\n        if (w1.length()!=w2.length())return false;\\n        else {\\n            char[] word1 = w1.toCharArray();\\n            Arrays.sort(word1);\\n            char[] word2 = w2.toCharArray();\\n            Arrays.sort(word2);\\n            return Arrays.equals(word1, word2);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2054810,
                "title": "4-lines-solution-with-counter",
                "content": "What do you think about this solution?\\n\\n```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n\\n\\t\\t\\t# `Counter` makes a letter frequency dictionary\\n\\t\\t\\t#  the == operator compares the two dictionaries\\n\\t\\t\\t#  if anagrams then delete the next word\\n\\t\\t\\t#  otherwise, we increment the pointer\\n        \\n        pointer = 0\\n        while pointer < len(words)-1:\\n            if ( Counter(words[pointer]) == Counter(words[pointer+1])  ):\\n                words.pop(pointer+1)\\n            else:\\n                pointer+=1\\n        return words\\n\\t```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n\\n\\t\\t\\t# `Counter` makes a letter frequency dictionary\\n\\t\\t\\t#  the == operator compares the two dictionaries\\n\\t\\t\\t#  if anagrams then delete the next word\\n\\t\\t\\t#  otherwise, we increment the pointer\\n        \\n        pointer = 0\\n        while pointer < len(words)-1:\\n            if ( Counter(words[pointer]) == Counter(words[pointer+1])  ):\\n                words.pop(pointer+1)\\n            else:\\n                pointer+=1\\n        return words\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 2053561,
                "title": "c-easy-understanding-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n    /* \\n      words[i-1] and words[i] are anagrams when:\\n        +) words[i-1].size() == words[i].size();\\n        +) occurrence of each letter in words[i] equals to that in words[i-1]\\n    */\\n    for (int i = 1; i < words.size();){\\n        // We iterate from 1 to the end of list\\n        map<char, int> mp1, mp2;\\n        // We use map to store the occurrence of each letter in words[i] and words[i-1]\\n        for(char &x : words[i-1]) mp1[x]++;\\n        for(char &x : words[i]) mp2[x]++;\\n        if(mp1 == mp2){\\n            // If words[i] and words[i-1] are anagrams, we delete words[i] from the list\\n            words.erase(words.begin()+i);\\n        }else i++;\\n    }\\n    return words;        \\n}\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n    /* \\n      words[i-1] and words[i] are anagrams when:\\n        +) words[i-1].size() == words[i].size();\\n        +) occurrence of each letter in words[i] equals to that in words[i-1]\\n    */\\n    for (int i = 1; i < words.size();){\\n        // We iterate from 1 to the end of list\\n        map<char, int> mp1, mp2;\\n        // We use map to store the occurrence of each letter in words[i] and words[i-1]\\n        for(char &x : words[i-1]) mp1[x]++;\\n        for(char &x : words[i]) mp2[x]++;\\n        if(mp1 == mp2){\\n            // If words[i] and words[i-1] are anagrams, we delete words[i] from the list\\n            words.erase(words.begin()+i);\\n        }else i++;\\n    }\\n    return words;        \\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2050674,
                "title": "java-solution",
                "content": "```java \\nclass Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        ArrayList<String> a = new ArrayList<String>();\\n        a.add(words[0]);\\n        for(int i=1;i<words.length;i++)\\n        {\\n            if(check(words[i],words[i-1])==false)\\n                a.add(words[i]);\\n        }\\n        return a;\\n    }\\n    \\n    private boolean check(String s, String t)\\n    {\\n        int[] a = new int[26];\\n        int[] b = new int[26];\\n        \\n        for(int i=0;i<Math.max(s.length(),t.length());i++)\\n        {\\n            if(i<s.length())\\n            a[s.charAt(i)-\\'a\\']++;\\n            if(i<t.length())\\n            b[t.charAt(i)-\\'a\\']++;\\n        }\\n        \\n        for(int i=0;i<26;i++)\\n        {\\n            if(a[i]!=b[i])\\n                return false;\\n        }\\n        return true;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        ArrayList<String> a = new ArrayList<String>();\\n        a.add(words[0]);\\n        for(int i=1;i<words.length;i++)\\n        {\\n            if(check(words[i],words[i-1])==false)\\n                a.add(words[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2046324,
                "title": "python3-simple",
                "content": "itertools.groupby is very cool but this is more beginner friendly\\n\\n```python\\ndef removeAnagrams(self, words: List[str]) -> List[str]:\\n        last_sorted_word = \\'\\'\\n        res = []\\n        for w in words:\\n            cur_sorted_word = \\'\\'.join(sorted(w))\\n            if cur_sorted_word != last_sorted_word:\\n                res.append(w)\\n            last_sorted_word = cur_sorted_word\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\ndef removeAnagrams(self, words: List[str]) -> List[str]:\\n        last_sorted_word = \\'\\'\\n        res = []\\n        for w in words:\\n            cur_sorted_word = \\'\\'.join(sorted(w))\\n            if cur_sorted_word != last_sorted_word:\\n                res.append(w)\\n            last_sorted_word = cur_sorted_word\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2042701,
                "title": "python-beat-both-100-no-sort-but-dictionary",
                "content": "sort will cause log(l) factor. \\nTo match, we have two approches. One is to make them ordered, so that we can compare one by one, at cost of O(logL) (L is length)\\nBut we want to know if exist or not. So why don\\'t we use dictionary(counter) instead?  Same length, and for each char, the count is same. Then the COUNT of each char is matched. and it saves a logL.\\n```\\nclass Solution(object):\\n    def removeAnagrams(self, words):\\n        \"\"\"\\n        :type words: List[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        D = Counter(words[0])\\n        res = [words[0]]\\n        for word in words[1:]:\\n            temp = Counter(word)\\n            \\n            found = True\\n            if len(temp) != len(D):\\n                found = False\\n            for key in temp:\\n                if temp[key]!= D[key]:\\n                    found = False\\n                    break\\n            if not found:\\n                res.append(word)\\n            D = temp\\n        return res\\n\\t\\t``",
                "solutionTags": [
                    "Python"
                ],
                "code": "sort will cause log(l) factor. \\nTo match, we have two approches. One is to make them ordered, so that we can compare one by one, at cost of O(logL) (L is length)\\nBut we want to know if exist or not. So why don\\'t we use dictionary(counter) instead?  Same length, and for each char, the count is same. Then the COUNT of each char is matched. and it saves a logL.\\n```\\nclass Solution(object):\\n    def removeAnagrams(self, words):\\n        \"\"\"\\n        :type words: List[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        D = Counter(words[0])\\n        res = [words[0]]\\n        for word in words[1:]:\\n            temp = Counter(word)\\n            \\n            found = True\\n            if len(temp) != len(D):\\n                found = False\\n            for key in temp:\\n                if temp[key]!= D[key]:\\n                    found = False\\n                    break\\n            if not found:\\n                res.append(word)\\n            D = temp\\n        return res\\n\\t\\t``",
                "codeTag": "Java"
            },
            {
                "id": 2041969,
                "title": "without-sorting-c-o-n-using-set",
                "content": "```\\nvector<string> removeAnagrams(vector<string>& words) {\\n        unordered_set<int> set;\\n        for(int i = 0; i < words.size() - 1; i++) {\\n            string s = words[i];\\n            string t = words[i + 1];\\n\\n            if(s.size() == t.size()) {\\n                vector<int> v(26, 0);\\n                int sChars = s.size();\\n\\n                for(int j = 0; j < s.length(); j++) v[s[j] - \\'a\\']++;\\n\\n                vector<int> h = v;\\n                int tChars = sChars;\\n\\n                for(int k = 0; k < t.size(); k++)\\n                    if(h[t[k] - \\'a\\']-- >= 1)\\n                        tChars--;\\n\\n                if(tChars == 0) set.insert(i + 1);\\n            }\\n        }\\n        vector<string> ans;\\n        for(int i = 0; i < words.size(); i++) {\\n            if(set.find(i) == set.end())\\n                ans.push_back(words[i]);\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nvector<string> removeAnagrams(vector<string>& words) {\\n        unordered_set<int> set;\\n        for(int i = 0; i < words.size() - 1; i++) {\\n            string s = words[i];\\n            string t = words[i + 1];\\n\\n            if(s.size() == t.size()) {\\n                vector<int> v(26, 0);\\n                int sChars = s.size();\\n\\n                for(int j = 0; j < s.length(); j++) v[s[j] - \\'a\\']++;\\n\\n                vector<int> h = v;\\n                int tChars = sChars;\\n\\n                for(int k = 0; k < t.size(); k++)\\n                    if(h[t[k] - \\'a\\']-- >= 1)\\n                        tChars--;\\n\\n                if(tChars == 0) set.insert(i + 1);\\n            }\\n        }\\n        vector<string> ans;\\n        for(int i = 0; i < words.size(); i++) {\\n            if(set.find(i) == set.end())\\n                ans.push_back(words[i]);\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2041397,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    pub fn remove_anagrams(words: Vec<String>) -> Vec<String> {\\n        let mut res = vec![];\\n        let mut prev_count = [0; 26];\\n        for word in words {\\n            let mut count = [0; 26];\\n            word.bytes().for_each(|b| count[(b - b\\'a\\') as usize] += 1);\\n            \\n            if prev_count != count {\\n                res.push(word);\\n            }\\n            prev_count = count;\\n        }\\n        res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn remove_anagrams(words: Vec<String>) -> Vec<String> {\\n        let mut res = vec![];\\n        let mut prev_count = [0; 26];\\n        for word in words {\\n            let mut count = [0; 26];\\n            word.bytes().for_each(|b| count[(b - b\\'a\\') as usize] += 1);\\n            \\n            if prev_count != count {\\n                res.push(word);\\n            }\\n            prev_count = count;\\n        }\\n        res\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2041302,
                "title": "c-map-vector-easiest-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& s) {\\n         unordered_map<string,int> mp;\\n        vector<string> ans;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            string t=s[i];\\n            sort(t.begin(),t.end());\\n            if(!mp.count(t) or i-mp[t]>1)\\n                ans.push_back(s[i]); \\n            mp[t]=i;\\n        }\\n      \\n    return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& s) {\\n         unordered_map<string,int> mp;\\n        vector<string> ans;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            string t=s[i];\\n            sort(t.begin(),t.end());\\n            if(!mp.count(t) or i-mp[t]>1)\\n                ans.push_back(s[i]); \\n            mp[t]=i;\\n        }\\n      \\n    return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2040180,
                "title": "100-faster-and-easy-solution-explained-5-liner",
                "content": "```\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        stack=[words[0]]      #We need a stack for this beacuse we have to delete those who are same as first one \\n        for i in range(len(words)):\\n            if stack:\\n                pr=sorted(stack[-1])       #We have to sort last element of stack and our current element\\n                cur=sorted(words[i])\\n                if pr!=cur :     #If they are equal we don\\'t add it to stack else we append it to stack\\n                    stack.append(words[i])            \\n        return stack\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        stack=[words[0]]      #We need a stack for this beacuse we have to delete those who are same as first one \\n        for i in range(len(words)):\\n            if stack:\\n                pr=sorted(stack[-1])       #We have to sort last element of stack and our current element\\n                cur=sorted(words[i])\\n                if pr!=cur :     #If they are equal we don\\'t add it to stack else we append it to stack\\n                    stack.append(words[i])            \\n        return stack\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2040106,
                "title": "c-two-pointers",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    string sortStr(string s){\\n        sort(s.begin(),s.end());\\n        return s;\\n    }\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        vector<string>ans;\\n        int i=0;\\n        int j=0;\\n        while(i<words.size() || j<words.size()){\\n            string temp = sortStr(words[j]);\\n            \\n            ans.push_back(words[j]);\\n            while(i<words.size() and temp==sortStr(words[i]))\\n                i++;\\n        j = i;\\n        i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    string sortStr(string s){\\n        sort(s.begin(),s.end());\\n        return s;\\n    }\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        vector<string>ans;\\n        int i=0;\\n        int j=0;\\n        while(i<words.size() || j<words.size()){\\n            string temp = sortStr(words[j]);\\n            \\n            ans.push_back(words[j]);\\n            while(i<words.size() and temp==sortStr(words[i]))\\n                i++;\\n        j = i;\\n        i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2040097,
                "title": "unnecessarily-complicated-the-description-c-solution",
                "content": "If the anagram of current word is present in the map and the index of that anagram is current index - 1, we get the required word.\\n```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        vector<string> ans;\\n        unordered_map<string, int> found;\\n \\n        for (int i = 0; i < words.size(); i++) {\\n              string word = words[i];\\n              sort(begin(word), end(word));\\n\\n        if (found.find(word) == found.end() || found[word] != i - 1) {\\n            ans.push_back(words[i]);\\n        }\\n        found[word] = i;\\n    }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        vector<string> ans;\\n        unordered_map<string, int> found;\\n \\n        for (int i = 0; i < words.size(); i++) {\\n              string word = words[i];\\n              sort(begin(word), end(word));\\n\\n        if (found.find(word) == found.end() || found[word] != i - 1) {\\n            ans.push_back(words[i]);\\n        }\\n        found[word] = i;\\n    }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2039952,
                "title": "find-resultant-array-after-removing-anagrams",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        int i=1;\\n        while(i<words.size()){\\n            string a = words[i];\\n            string b = words[i-1];\\n            sort(a.begin(),a.end());\\n            sort(b.begin(),b.end());\\n            if(a == b){\\n                words.erase (words.begin()+i);\\n            }else{\\n                i++;\\n            }\\n        }\\n        \\n        return words;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        int i=1;\\n        while(i<words.size()){\\n            string a = words[i];\\n            string b = words[i-1];\\n            sort(a.begin(),a.end());\\n            sort(b.begin(),b.end());\\n            if(a == b){\\n                words.erase (words.begin()+i);\\n            }else{\\n                i++;\\n            }\\n        }\\n        \\n        return words;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2039935,
                "title": "easy-c",
                "content": "class Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n       for(int i = 1;i<words.size();i++){\\n            string str1 = words[i];\\n            sort(str1.begin(),str1.end());\\n            string str2 = words[i-1];\\n            sort(str2.begin(),str2.end());\\n            if(str1 == str1){\\n                words.erase(words.begin() + i);\\n                i--;\\n            }\\n        }\\n        return words;\\n    \\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n       for(int i = 1;i<words.size();i++){\\n            string str1 = words[i];\\n            sort(str1.begin(),str1.end());\\n            string str2 = words[i-1];\\n            sort(str2.begin(),str2.end());\\n            if(str1 == str1){\\n                words.erase(words.begin() + i);\\n                i--;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2039928,
                "title": "easy-n-k-log-k-solution-k-is-average-size-of-string",
                "content": "\\'\\'\\'\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) \\n    {\\n        int n=words.size();\\n        vector<pair<int,string>>g;\\n        for(int i=0;i<n;i++)\\n        {\\n            //temporary vectory storing original strings with index\\n            g.push_back({i,words[i]});\\n        }\\n        for(int i=0;i<n;i++)\\n          {  \\n            //sorting string for comparison\\n            sort(words[i].begin(),words[i].end());\\n          }\\n        vector<pair<string,int>>v;\\n        v.push_back({words[0],0});\\n        for(int i=1;i<n;i++)\\n        {\\n            if(words[i]==(v[(v.size()-1)].first))\\n            {\\n                //dont put into vector if same string\\n            }\\n            else\\n            {\\n                v.push_back({words[i],i});\\n            }\\n        }\\n        vector<string>ans;\\n        int len=v.size();\\n        for(int i=0;i<len;i++)\\n        {\\n            int t=v[i].second;\\n            for(int j=0;j<n;j++)\\n            {\\n                int t1=g[j].first;\\n                //retrieving original string\\n                if(t==t1)\\n                {\\n                    ans.push_back(g[j].second);\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [
                    "C",
                    "String",
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) \\n    {\\n        int n=words.size();\\n        vector<pair<int,string>>g;\\n        for(int i=0;i<n;i++)\\n        {\\n            //temporary vectory storing original strings with index\\n            g.push_back({i,words[i]}",
                "codeTag": "Java"
            },
            {
                "id": 2039920,
                "title": "cpp-2-pointer",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        int i=0,j=1;\\n        int n = words.size();\\n        vector<string> res;\\n        while(j<n){\\n            string str1 = words[j], str2= words[i];\\n            sort(str1.begin(),str1.end());\\n            sort(str2.begin(),str2.end());\\n            if(str1==str2){\\n                words[j] = \"-1\";\\n                j++;\\n            }\\n            else{\\n                i=j;\\n                j++;\\n            }\\n        }\\n        for(auto str:words){\\n            if(str!=\"-1\"){\\n                res.push_back(str);\\n            }\\n        }\\n        return res;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        int i=0,j=1;\\n        int n = words.size();\\n        vector<string> res;\\n        while(j<n){\\n            string str1 = words[j], str2= words[i];\\n            sort(str1.begin(),str1.end());\\n            sort(str2.begin(),str2.end());\\n            if(str1==str2){\\n                words[j] = \"-1\";\\n                j++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2039901,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        List<String> ans = new ArrayList<>();\\n        for (int i = words.length - 1; i > 0; i--){\\n            if(helper(words[i], words[i-1]) == false){\\n                ans.add(words[i]);\\n            }\\n        }\\n        ans.add(words[0]);\\n        Collections.reverse(ans);\\n        return ans;\\n    }\\n    \\n    public boolean helper(String s1, String s2){\\n        if(s1.length() != s2.length()) return false;\\n        char[] c1 = s1.toCharArray();\\n        char[] c2 = s2.toCharArray();\\n        Arrays.sort(c1);\\n        Arrays.sort(c2);\\n        for(int i = 0; i < c1.length; i++){\\n            if(c1[i] != c2[i]) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        List<String> ans = new ArrayList<>();\\n        for (int i = words.length - 1; i > 0; i--){\\n            if(helper(words[i], words[i-1]) == false){\\n                ans.add(words[i]);\\n            }\\n        }\\n        ans.add(words[0]);\\n        Collections.reverse(ans);\\n        return ans;\\n    }\\n    \\n    public boolean helper(String s1, String s2){\\n        if(s1.length() != s2.length()) return false;\\n        char[] c1 = s1.toCharArray();\\n        char[] c2 = s2.toCharArray();\\n        Arrays.sort(c1);\\n        Arrays.sort(c2);\\n        for(int i = 0; i < c1.length; i++){\\n            if(c1[i] != c2[i]) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2039864,
                "title": "c-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isAnagram(string s1,string s2)\\n    {\\n        unordered_map<char,int> mp;\\n        for(char c:s1) mp[c]++;\\n        for(char c:s2) mp[c]--;\\n        \\n        for(auto itr=mp.begin();itr!=mp.end();itr++)\\n        {\\n            if(itr->second != 0) return false;\\n        }\\n        return true;\\n    }\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        vector<string> ans;\\n        for(string word:words)\\n        {\\n            if(ans.empty()) ans.push_back(word);\\n            else\\n            {\\n                if(isAnagram(word,ans[ans.size()-1]))\\n                    continue;\\n                ans.push_back(word);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isAnagram(string s1,string s2)\\n    {\\n        unordered_map<char,int> mp;\\n        for(char c:s1) mp[c]++;\\n        for(char c:s2) mp[c]--;\\n        \\n        for(auto itr=mp.begin();itr!=mp.end();itr++)\\n        {\\n            if(itr->second != 0) return false;\\n        }\\n        return true;\\n    }\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        vector<string> ans;\\n        for(string word:words)\\n        {\\n            if(ans.empty()) ans.push_back(word);\\n            else\\n            {\\n                if(isAnagram(word,ans[ans.size()-1]))\\n                    continue;\\n                ans.push_back(word);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2039828,
                "title": "c-easy-to-understand-hashing",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        vector<string> ans;\\n        int n=words.size();\\n        int i=0;\\n        while(i<n){\\n            string s=words[i];\\n            int cnt[26]={0};\\n            for(auto k:s) cnt[k-\\'a\\']++;\\n            int j=i+1;\\n            while(j<n){\\n                string s2=words[j];\\n                int cnt2[26]={0};\\n                for(auto k:s2) cnt2[k-\\'a\\']++;\\n                bool f=0;\\n                for(int k=0;k<26;k++){\\n                    if(cnt[k]!=cnt2[k]){ f=1; break;}\\n                }\\n                if(f) break; \\n                j++;\\n            }\\n            i=j;\\n            ans.push_back(s);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        vector<string> ans;\\n        int n=words.size();\\n        int i=0;\\n        while(i<n){\\n            string s=words[i];\\n            int cnt[26]={0};\\n            for(auto k:s) cnt[k-\\'a\\']++;\\n            int j=i+1;\\n            while(j<n){\\n                string s2=words[j];\\n                int cnt2[26]={0};\\n                for(auto k:s2) cnt2[k-\\'a\\']++;\\n                bool f=0;\\n                for(int k=0;k<26;k++){\\n                    if(cnt[k]!=cnt2[k]){ f=1; break;}\\n                }\\n                if(f) break; \\n                j++;\\n            }\\n            i=j;\\n            ans.push_back(s);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2039804,
                "title": "c-simple-and-straight-forward-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        if(words.size()<=1){\\n            return words;\\n        }\\n        vector<string> temp = words;\\n        for(int i=0;i<words.size();i++){\\n            sort(temp[i].begin(),temp[i].end()); // sorting to make work easier in temporary array\\n        }\\n        vector<string> ans;\\n        // for(int i=0;i<words.size();i++){\\n        //     cout<<temp[i]<<endl;\\n        // }\\n        int i=0,j=1;\\n        // we will add the first words[i] which comes in array with anagrams\\n        while( (i < words.size()) && (j < words.size())){\\n            if(temp[i]!=temp[j]){ // we push first anagram , when next is not equal to previous as it means the word has changed and we update to new word anagram\\n                ans.push_back(words[i]);\\n                i=j;\\n                j++;\\n            }\\n            else{\\n                j++;\\n            }\\n            \\n            \\n            // cout<<ans[i]<<endl;\\n        }\\n        j = words.size()-1;\\n        if(  (temp[j-1] != temp[j])){\\n                ans.push_back(words[j]);\\n                // break;\\n                \\n        }\\n        if((j==words.size()-1) && (temp[j-1] == temp[j])){\\n            ans.push_back(words[i]);\\n                // break;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        if(words.size()<=1){\\n            return words;\\n        }\\n        vector<string> temp = words;\\n        for(int i=0;i<words.size();i++){\\n            sort(temp[i].begin(),temp[i].end()); // sorting to make work easier in temporary array\\n        }\\n        vector<string> ans;\\n        // for(int i=0;i<words.size();i++){\\n        //     cout<<temp[i]<<endl;\\n        // }\\n        int i=0,j=1;\\n        // we will add the first words[i] which comes in array with anagrams\\n        while( (i < words.size()) && (j < words.size())){\\n            if(temp[i]!=temp[j]){ // we push first anagram , when next is not equal to previous as it means the word has changed and we update to new word anagram\\n                ans.push_back(words[i]);\\n                i=j;\\n                j++;\\n            }\\n            else{\\n                j++;\\n            }\\n            \\n            \\n            // cout<<ans[i]<<endl;\\n        }\\n        j = words.size()-1;\\n        if(  (temp[j-1] != temp[j])){\\n                ans.push_back(words[j]);\\n                // break;\\n                \\n        }\\n        if((j==words.size()-1) && (temp[j-1] == temp[j])){\\n            ans.push_back(words[i]);\\n                // break;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2039790,
                "title": "c-short-solutions-with-explanation-2-approaches-for-comparing-words",
                "content": "**Approach 1:** Using Multiset\\n\\nMultisets are a type of associative containers similar to the set, with the exception that multiple elements can have the same values.\\n* Compare multisets of adjacent words\\n* If multisets are equal, erase next word and decrease the index\\n```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        for(int i=0; i < words.size()-1; i++)\\n            if(multiset<char>(words[i].begin(), words[i].end()) == multiset<char>(words[i+1].begin(), words[i+1].end()))\\n                words.erase(words.begin() + 1 + i--);\\n        return words;\\n    }\\n};\\n```\\n**Approach 2:** Using Map\\n* Make maps for adjacent words to count frequency for all letters\\n* If maps are equal, erase next word and decrease the index\\n```\\nclass Solution {\\npublic:\\n    bool isagm(string s1,string s2){\\n        map<char,int>m1,m2;\\n        for(auto i:s1)  m1[i]++;\\n        for(auto i:s2)  m2[i]++;\\n        return m1==m2;\\n    }\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        for(int i=0; i < words.size()-1; i++)\\n            if(isagm(words[i], words[i+1]))     words.erase(words.begin() + 1 + i--);\\n        return words;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        for(int i=0; i < words.size()-1; i++)\\n            if(multiset<char>(words[i].begin(), words[i].end()) == multiset<char>(words[i+1].begin(), words[i+1].end()))\\n                words.erase(words.begin() + 1 + i--);\\n        return words;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isagm(string s1,string s2){\\n        map<char,int>m1,m2;\\n        for(auto i:s1)  m1[i]++;\\n        for(auto i:s2)  m2[i]++;\\n        return m1==m2;\\n    }\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        for(int i=0; i < words.size()-1; i++)\\n            if(isagm(words[i], words[i+1]))     words.erase(words.begin() + 1 + i--);\\n        return words;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2039788,
                "title": "easy-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n          int index  = 1 ;\\n          vector<string> ans, word_cp ; \\n          word_cp = words ; \\n          int j =0 ; \\n          for(int i = 0 ; i < words.size(); i ++) {\\n              sort(words[i].begin(), words[i].end()); \\n               if(ans.size() == 0 ) {\\n                    ans.push_back(word_cp[i]); \\n               }else {\\n                   if(ans.size() > 0  and words[j] != words[i]) {\\n                        j = i ; \\n                        ans.push_back(word_cp[i]); \\n                   } \\n               }\\n          }\\n        return ans ; \\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n          int index  = 1 ;\\n          vector<string> ans, word_cp ; \\n          word_cp = words ; \\n          int j =0 ; \\n          for(int i = 0 ; i < words.size(); i ++) {\\n              sort(words[i].begin(), words[i].end()); \\n               if(ans.size() == 0 ) {\\n                    ans.push_back(word_cp[i]); \\n               }else {\\n                   if(ans.size() > 0  and words[j] != words[i]) {\\n                        j = i ; \\n                        ans.push_back(word_cp[i]); \\n                   } \\n               }\\n          }\\n        return ans ; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2039787,
                "title": "iterative-solution-o-n-loop",
                "content": "```\\nfrom collections import Counter\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        i =0 \\n        while i < len(words)-1:\\n            if Counter(words[i]) == Counter(words[i+1]):\\n                words.pop(i+1)\\n            else:\\n                i += 1\\n        return words\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import Counter\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        i =0 \\n        while i < len(words)-1:\\n            if Counter(words[i]) == Counter(words[i+1]):\\n                words.pop(i+1)\\n            else:\\n                i += 1\\n        return words\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2039781,
                "title": "c-easy",
                "content": "```\\nclass Solution {\\n    bool areAnagram(string str1, string str2){\\n        int n1 = str1.length();\\n        int n2 = str2.length();\\n        if (n1 != n2)\\n            return false;\\n\\n        sort(str1.begin(), str1.end());\\n        sort(str2.begin(), str2.end());\\n\\n        for (int i = 0; i < n1; i++)\\n            if (str1[i] != str2[i])\\n                return false;\\n\\n        return true;\\n    }\\npublic:\\n    vector<string> removeAnagrams(vector<string>& w) {\\n        for(int i=1; i<w.size(); i++){\\n            if(areAnagram(w[i-1], w[i])){\\n                w.erase(w.begin() + i);\\n                i--;\\n            }\\n        }\\n        return w;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    bool areAnagram(string str1, string str2){\\n        int n1 = str1.length();\\n        int n2 = str2.length();\\n        if (n1 != n2)\\n            return false;\\n\\n        sort(str1.begin(), str1.end());\\n        sort(str2.begin(), str2.end());\\n\\n        for (int i = 0; i < n1; i++)\\n            if (str1[i] != str2[i])\\n                return false;\\n\\n        return true;\\n    }\\npublic:\\n    vector<string> removeAnagrams(vector<string>& w) {\\n        for(int i=1; i<w.size(); i++){\\n            if(areAnagram(w[i-1], w[i])){\\n                w.erase(w.begin() + i);\\n                i--;\\n            }\\n        }\\n        return w;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2039709,
                "title": "easy-solution-with-sort-how-i-wasted-first-30-minutes-in-contest",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        for(int i = 0 ; i < words.size() -1; i++){\\n            int idx = i;\\n            string s1 = words[i];\\n            sort(s1.begin(),s1.end());\\n            string s2 = words[i+1];\\n            sort(s2.begin(),s2.end());\\n            if(s1 == s2){\\n                words.erase(words.begin() + i+1);\\n                i = idx - 1;\\n            }\\n         }\\n        return words;\\n        \\n    }\\n};\\n```\\n\\n**2 days ago i have solved question no 49. Group Anagrams  problem and today in contest when i saw the test cases of this problem i think it\\'s almost same . . and i have started solving with my previous approach . and wasted 30 minutes . \\nand then read the question carefully .**\\n\\n***So specially beginners please always read the question carefully . don\\'t be overconfident*** \\n",
                "solutionTags": [
                    "C",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        for(int i = 0 ; i < words.size() -1; i++){\\n            int idx = i;\\n            string s1 = words[i];\\n            sort(s1.begin(),s1.end());\\n            string s2 = words[i+1];\\n            sort(s2.begin(),s2.end());\\n            if(s1 == s2){\\n                words.erase(words.begin() + i+1);\\n                i = idx - 1;\\n            }\\n         }\\n        return words;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4081776,
                "title": "find-resultant-array-after-removing-anagrams",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCreate a function to check anagaram between two words, if true remove them and repeat the process\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string[]} words\\n * @return {string[]}\\n */\\n const removeAnagrams =   function(words) {\\n    if(words.length === 0) { return false}\\n    let i = 0;\\n     while (i < words.length - 1) {\\n        if(!words[i+1]){ return;}\\n\\n        const ifAnagram =  validAnagram(words[i], words[i+1])\\n   if (ifAnagram){\\n       words.splice(i+1,1)\\n  \\n   }else{\\n   i+=1}\\n    }\\n    return words\\n};\\n\\n function validAnagram(str1, str2) {\\n  if (str1.length !== str2.length) {\\n    return false;\\n  }\\n\\n  let first = {};\\n  let second = {};\\n\\n  for (let i = 0; i < str1.length; i++) {\\n    first[str1[i]] = (first[str1[i]] || 0) + 1;\\n    second[str2[i]] = (second[str2[i]] || 0) + 1;\\n  }\\n\\n  console.log(first, second);\\n\\n  for (let key in first) {\\n    if (!(key in second)) {\\n      return false;\\n    }\\n    if (second[key] !== first[key]) {\\n      return false;\\n    }\\n  }\\n  return true;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @return {string[]}\\n */\\n const removeAnagrams =   function(words) {\\n    if(words.length === 0) { return false}\\n    let i = 0;\\n     while (i < words.length - 1) {\\n        if(!words[i+1]){ return;}\\n\\n        const ifAnagram =  validAnagram(words[i], words[i+1])\\n   if (ifAnagram){\\n       words.splice(i+1,1)\\n  \\n   }else{\\n   i+=1}\\n    }\\n    return words\\n};\\n\\n function validAnagram(str1, str2) {\\n  if (str1.length !== str2.length) {\\n    return false;\\n  }\\n\\n  let first = {};\\n  let second = {};\\n\\n  for (let i = 0; i < str1.length; i++) {\\n    first[str1[i]] = (first[str1[i]] || 0) + 1;\\n    second[str2[i]] = (second[str2[i]] || 0) + 1;\\n  }\\n\\n  console.log(first, second);\\n\\n  for (let key in first) {\\n    if (!(key in second)) {\\n      return false;\\n    }\\n    if (second[key] !== first[key]) {\\n      return false;\\n    }\\n  }\\n  return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4079550,
                "title": "easy-cpp-solution-beats-93-3-in-runtime-beginner-friendly",
                "content": "![image.png](https://assets.leetcode.com/users/images/7f806d18-d0f6-4b9e-b408-0189ba787cdf_1695453036.5051134.png)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        vector<string> ans;\\n        int sz=words.size();\\n        vector<bool> vis(sz, false);\\n        for(int i=0; i<sz; i++){\\n            if(vis[i]) continue;\\n            int t = 0;\\n            string tmp = words[i];\\n            sort(tmp.begin(), tmp.end());\\n            for(int j=i+1; j<sz; j++){\\n                if(t != j-i-1) break;\\n                if(words[i].length() == words[j].length() && vis[j] == false){\\n                    string tmp2 = words[j];\\n                    sort(tmp2.begin(), tmp2.end());\\n                    if(tmp == tmp2){\\n                        vis[j] = true;\\n                        t++;\\n                    }\\n                }\\n            }\\n            ans.push_back(words[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        vector<string> ans;\\n        int sz=words.size();\\n        vector<bool> vis(sz, false);\\n        for(int i=0; i<sz; i++){\\n            if(vis[i]) continue;\\n            int t = 0;\\n            string tmp = words[i];\\n            sort(tmp.begin(), tmp.end());\\n            for(int j=i+1; j<sz; j++){\\n                if(t != j-i-1) break;\\n                if(words[i].length() == words[j].length() && vis[j] == false){\\n                    string tmp2 = words[j];\\n                    sort(tmp2.begin(), tmp2.end());\\n                    if(tmp == tmp2){\\n                        vis[j] = true;\\n                        t++;\\n                    }\\n                }\\n            }\\n            ans.push_back(words[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4072676,
                "title": "70-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string[]} words\\n * @return {string[]}\\n */\\nvar removeAnagrams = function(words) {\\n    if(words.length <= 0){\\n        return []\\n    }\\n    for(let i = 0; i < words.length-1;i++){\\n        let x = words[i].split(\"\").sort().join(\"\")\\n        let y = words[i+1].split(\"\").sort().join(\"\")\\n\\n        if(x == y){\\n            words.splice(i+1,1)\\n            i--;\\n        }\\n    }\\n    return words\\n\\n  \\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @return {string[]}\\n */\\nvar removeAnagrams = function(words) {\\n    if(words.length <= 0){\\n        return []\\n    }\\n    for(let i = 0; i < words.length-1;i++){\\n        let x = words[i].split(\"\").sort().join(\"\")\\n        let y = words[i+1].split(\"\").sort().join(\"\")\\n\\n        if(x == y){\\n            words.splice(i+1,1)\\n            i--;\\n        }\\n    }\\n    return words\\n\\n  \\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4061949,
                "title": "easy-simple-c-solution",
                "content": "\\n# Approach\\nSort the words and compare. Always add accept the first array element.\\n\\n# Complexity\\n- Time complexity:\\nO(m * n log n)\\n\\n- Space complexity:\\nO(m + n)\\n\\n# Code\\n```\\npublic class Solution {\\n    public IList<string> RemoveAnagrams(string[] words) {\\n        List<string> wordList = new();\\n        for(int i = 0; i<words.Length; i++)\\n        {   \\n            if(i==0)\\n            {\\n                wordList.Add(words[i]);\\n                continue;\\n            }\\n            //char and sort words i, i-1 and i+1\\n            char[] less = words[i-1].ToCharArray();\\n            char[] same = words[i].ToCharArray();\\n            Array.Sort(less);\\n            Array.Sort(same);\\n            string str = new string(same);\\n            string strLess = new string(less);\\n            if(str != strLess)\\n                wordList.Add(words[i]);\\n            \\n        }\\n        return wordList;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public IList<string> RemoveAnagrams(string[] words) {\\n        List<string> wordList = new();\\n        for(int i = 0; i<words.Length; i++)\\n        {   \\n            if(i==0)\\n            {\\n                wordList.Add(words[i]);\\n                continue;\\n            }\\n            //char and sort words i, i-1 and i+1\\n            char[] less = words[i-1].ToCharArray();\\n            char[] same = words[i].ToCharArray();\\n            Array.Sort(less);\\n            Array.Sort(same);\\n            string str = new string(same);\\n            string strLess = new string(less);\\n            if(str != strLess)\\n                wordList.Add(words[i]);\\n            \\n        }\\n        return wordList;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4059240,
                "title": "find-resultant-array-after-removing-anagrams-using-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        stack<string> s1;\\n        for(int i=0;i<words.size();i++){\\n            if(s1.empty()){\\n                s1.push(words[i]);\\n            }\\n            else{\\n                string s=s1.top(),s2=words[i];\\n                sort(s.begin(),s.end());\\n                sort(s2.begin(),s2.end());\\n                if(s==s2){\\n                    continue;\\n                }\\n                else{\\n                    s1.push(words[i]);\\n                }\\n            }\\n        }\\n        vector<string> ans;\\n        while(!s1.empty()){\\n            ans.push_back(s1.top());\\n            s1.pop();\\n        } \\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        stack<string> s1;\\n        for(int i=0;i<words.size();i++){\\n            if(s1.empty()){\\n                s1.push(words[i]);\\n            }\\n            else{\\n                string s=s1.top(),s2=words[i];\\n                sort(s.begin(),s.end());\\n                sort(s2.begin(),s2.end());\\n                if(s==s2){\\n                    continue;\\n                }\\n                else{\\n                    s1.push(words[i]);\\n                }\\n            }\\n        }\\n        vector<string> ans;\\n        while(!s1.empty()){\\n            ans.push_back(s1.top());\\n            s1.pop();\\n        } \\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4052298,
                "title": "java-best-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        List<String> list = new ArrayList<>();\\n        list.add(words[0]);\\n        for(int i=1;i<words.length;i++){\\n            if(!isAnagram(words[i],words[i-1])){\\n                list.add(words[i]);\\n            }\\n        }\\n        return list;\\n    }\\n    public boolean isAnagram(String s1,String s2){\\n        if(s1.length()!=s2.length())\\n            return false;\\n        if(s1==s2)\\n            return true;\\n        int[] arr = new int[26];    \\n        for(int i=0;i<s1.length();i++){\\n            arr[s1.charAt(i)-\\'a\\']++;\\n            arr[s2.charAt(i)-\\'a\\']--;\\n        }\\n        for(int i=0;i<26;i++){\\n            if(arr[i]!=0)\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        List<String> list = new ArrayList<>();\\n        list.add(words[0]);\\n        for(int i=1;i<words.length;i++){\\n            if(!isAnagram(words[i],words[i-1])){\\n                list.add(words[i]);\\n            }\\n        }\\n        return list;\\n    }\\n    public boolean isAnagram(String s1,String s2){\\n        if(s1.length()!=s2.length())\\n            return false;\\n        if(s1==s2)\\n            return true;\\n        int[] arr = new int[26];    \\n        for(int i=0;i<s1.length();i++){\\n            arr[s1.charAt(i)-\\'a\\']++;\\n            arr[s2.charAt(i)-\\'a\\']--;\\n        }\\n        for(int i=0;i<26;i++){\\n            if(arr[i]!=0)\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4024985,
                "title": "easy-c-sorting-and-unordered-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIterating through the string vector\\nsorting the each string element\\nChecking if it is already present in hashmap\\nIf not present pushing it into the result vector\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe will push the very first element in the result vector.\\nThen we will sort the string a put that string in map \\nwhen frequency is 1 we will push the string in the result vector.\\nif frequecy is greater than 1 we will not push that string in the result.\\nreturn the result vector\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nmlogn)\\nn - number of strings\\nm -  avg length of a string\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(nm)\\nn - given string vector\\nm -  size of result string vector\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        vector<string>res;\\n        unordered_map<string,int>mp;\\n        res.push_back(words[0]);\\n        sort(words[0].begin(),words[0].end());\\n        mp[words[0]]++;\\n        for(int i=1;i<words.size();i++){\\n            string temp = words[i];\\n            sort(words[i].begin(),words[i].end());\\n            mp[words[i]]++;\\n            if(mp[words[i]] == 1 || (words[i-1] != words[i])){\\n                res.push_back(temp);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        vector<string>res;\\n        unordered_map<string,int>mp;\\n        res.push_back(words[0]);\\n        sort(words[0].begin(),words[0].end());\\n        mp[words[0]]++;\\n        for(int i=1;i<words.size();i++){\\n            string temp = words[i];\\n            sort(words[i].begin(),words[i].end());\\n            mp[words[i]]++;\\n            if(mp[words[i]] == 1 || (words[i-1] != words[i])){\\n                res.push_back(temp);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4016784,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\n\\nclass Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        List<String> result = new ArrayList<>();\\n        \\n        if (words.length == 0) {\\n            return result;\\n        }\\n\\n        result.add(words[0]);\\n\\n        for (int i = 1; i < words.length; i++) {\\n            if (!areAnagrams(words[i], words[i - 1])) {\\n                result.add(words[i]);\\n            }\\n        }\\n\\n        return result;\\n    }\\n\\n    private boolean areAnagrams(String s1, String s2) {\\n        if (s1.length() != s2.length()) {\\n            return false;\\n        }\\n\\n        int[] charCount = new int[26];\\n        \\n        for (int i = 0; i < s1.length(); i++) {\\n            charCount[s1.charAt(i) - \\'a\\']++;\\n            charCount[s2.charAt(i) - \\'a\\']--;\\n        }\\n\\n        for (int count : charCount) {\\n            if (count != 0) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\n\\nclass Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        List<String> result = new ArrayList<>();\\n        \\n        if (words.length == 0) {\\n            return result;\\n        }\\n\\n        result.add(words[0]);\\n\\n        for (int i = 1; i < words.length; i++) {\\n            if (!areAnagrams(words[i], words[i - 1])) {\\n                result.add(words[i]);\\n            }\\n        }\\n\\n        return result;\\n    }\\n\\n    private boolean areAnagrams(String s1, String s2) {\\n        if (s1.length() != s2.length()) {\\n            return false;\\n        }\\n\\n        int[] charCount = new int[26];\\n        \\n        for (int i = 0; i < s1.length(); i++) {\\n            charCount[s1.charAt(i) - \\'a\\']++;\\n            charCount[s2.charAt(i) - \\'a\\']--;\\n        }\\n\\n        for (int count : charCount) {\\n            if (count != 0) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4013537,
                "title": "easy-to-understand-java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n         List<String> ans = new ArrayList<>();\\n         if(words.length == 1)\\n         return Arrays.asList(words[0]);\\n         \\n         for(int i = words.length-1 ; i> 0 ;i--){\\n             char[] ch1 = words[i].toCharArray();\\n             char[] ch2 = words[i-1].toCharArray();\\n             Arrays.sort(ch1);\\n             Arrays.sort(ch2);\\n             if(!Arrays.equals(ch1,ch2)){\\n                 ans.add(words[i]);\\n             }\\n             if(i == 1)\\n             ans.add(words[i-1]);\\n         }\\n         Collections.reverse(ans);\\n         return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n         List<String> ans = new ArrayList<>();\\n         if(words.length == 1)\\n         return Arrays.asList(words[0]);\\n         \\n         for(int i = words.length-1 ; i> 0 ;i--){\\n             char[] ch1 = words[i].toCharArray();\\n             char[] ch2 = words[i-1].toCharArray();\\n             Arrays.sort(ch1);\\n             Arrays.sort(ch2);\\n             if(!Arrays.equals(ch1,ch2)){\\n                 ans.add(words[i]);\\n             }\\n             if(i == 1)\\n             ans.add(words[i-1]);\\n         }\\n         Collections.reverse(ans);\\n         return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4006864,
                "title": "c-simple-just-do-what-ask-simple-sorting-apporach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        int sz=words.size();\\n         vector<string> res;\\n          for(int i=0;i<sz;i++)\\n            {\\n              \\n              string curr=words[i];\\n              //just sort the curr string so that we can check anagaram of that string\\n               sort(curr.begin(),curr.end());\\n                int j=i+1;\\n                for(;j<sz;j++)\\n                  {\\n                    string s=words[j];\\n                    //sort adjacnet string also that we can compare 2 string\\n                      sort(begin(s),end(s));\\n                      //if both are equal then just continue\\n                      if(s==curr)\\n                           continue;\\n                      else\\n                      break;\\n                  }\\n            \\n                  res.push_back(words[i]);\\n                \\n                        i=j-1;\\n            }\\n            return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        int sz=words.size();\\n         vector<string> res;\\n          for(int i=0;i<sz;i++)\\n            {\\n              \\n              string curr=words[i];\\n              //just sort the curr string so that we can check anagaram of that string\\n               sort(curr.begin(),curr.end());\\n                int j=i+1;\\n                for(;j<sz;j++)\\n                  {\\n                    string s=words[j];\\n                    //sort adjacnet string also that we can compare 2 string\\n                      sort(begin(s),end(s));\\n                      //if both are equal then just continue\\n                      if(s==curr)\\n                           continue;\\n                      else\\n                      break;\\n                  }\\n            \\n                  res.push_back(words[i]);\\n                \\n                        i=j-1;\\n            }\\n            return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3985510,
                "title": "easy-solution-beats-95-time",
                "content": "# Code\\n```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n\\n        w = []\\n        w.append(words[0])\\n\\n        for i in range(1,len(words)):\\n            if sorted(words[i]) == sorted(words[i-1]):\\n                continue\\n            else:\\n                w.append(words[i])\\n        return w\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n\\n        w = []\\n        w.append(words[0])\\n\\n        for i in range(1,len(words)):\\n            if sorted(words[i]) == sorted(words[i-1]):\\n                continue\\n            else:\\n                w.append(words[i])\\n        return w\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3985262,
                "title": "simple-java-solution-without-sort",
                "content": "```\\nclass Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        List<String> res = new ArrayList<>();\\n        char[][] table = new char[words.length][26];\\n        for(int i = 0; i < words.length; i++){\\n            String word = words[i];\\n            for(char c : word.toCharArray()){\\n                table[i][c - \\'a\\']++;\\n            }\\n        }\\n        int i = 0;\\n        while(i < words.length){\\n            res.add(words[i]);\\n            int j = i + 1;\\n            while(j < words.length && words[i].length() == words[j].length() && Arrays.equals(table[i], table[j])){\\n                j++;\\n            }\\n            i = j;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        List<String> res = new ArrayList<>();\\n        char[][] table = new char[words.length][26];\\n        for(int i = 0; i < words.length; i++){\\n            String word = words[i];\\n            for(char c : word.toCharArray()){\\n                table[i][c - \\'a\\']++;\\n            }\\n        }\\n        int i = 0;\\n        while(i < words.length){\\n            res.add(words[i]);\\n            int j = i + 1;\\n            while(j < words.length && words[i].length() == words[j].length() && Arrays.equals(table[i], table[j])){\\n                j++;\\n            }\\n            i = j;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3980926,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        List<String> list= new  ArrayList();\\n        boolean vis[]=new boolean[words.length];\\n        for(int i=0;i<words.length-1;i++){\\n            int j=i+1;\\n            if(isAnagram(words[i] , words[j] )){\\n                vis[j]=true;\\n            }\\n            \\n        }\\n        for(int i=0;i<words.length;i++){\\n            // System.out.print(i+\"--\"+vis[i]);\\n            if(vis[i]==false)\\n            {\\n                list.add(words[i]);\\n            }\\n        }\\n        return list;\\n\\n        \\n        \\n        \\n    }\\n    public boolean isAnagram(String s, String t) {\\n        if(s.length()!=t.length())return false;\\n        char[]c0=s.toCharArray();\\n        char[]c1=t.toCharArray();\\n        Arrays.sort(c0);\\n        Arrays.sort(c1);\\n        return Arrays.equals(c0,c1);\\n\\n\\n\\n        }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        List<String> list= new  ArrayList();\\n        boolean vis[]=new boolean[words.length];\\n        for(int i=0;i<words.length-1;i++){\\n            int j=i+1;\\n            if(isAnagram(words[i] , words[j] )){\\n                vis[j]=true;\\n            }\\n            \\n        }\\n        for(int i=0;i<words.length;i++){\\n            // System.out.print(i+\"--\"+vis[i]);\\n            if(vis[i]==false)\\n            {\\n                list.add(words[i]);\\n            }\\n        }\\n        return list;\\n\\n        \\n        \\n        \\n    }\\n    public boolean isAnagram(String s, String t) {\\n        if(s.length()!=t.length())return false;\\n        char[]c0=s.toCharArray();\\n        char[]c1=t.toCharArray();\\n        Arrays.sort(c0);\\n        Arrays.sort(c1);\\n        return Arrays.equals(c0,c1);\\n\\n\\n\\n        }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3979398,
                "title": "simple-c-only-sorting-techniq",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        \\n        for(int i=1; i<words.size(); i++)\\n        {\\n            string str1 = words[i];\\n            string str2 = words[i-1];\\n\\n            sort(str1.begin(), str1.end());\\n            sort(str2.begin(), str2.end());\\n\\n            if(str1==str2)\\n            {\\n                words.erase(words.begin() + i);\\n                i--;\\n            }\\n            \\n        }\\n        return words;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        \\n        for(int i=1; i<words.size(); i++)\\n        {\\n            string str1 = words[i];\\n            string str2 = words[i-1];\\n\\n            sort(str1.begin(), str1.end());\\n            sort(str2.begin(), str2.end());\\n\\n            if(str1==str2)\\n            {\\n                words.erase(words.begin() + i);\\n                i--;\\n            }\\n            \\n        }\\n        return words;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3977773,
                "title": "python-one-liner-beats-98-98-with-comments",
                "content": "# Intuition\\nIf two sorted words are the same they are anagrams.\\n\\n# Approach\\nLoop through the list and check if $$adjacent$$ words are anagrams. The first word will always meet the requirement, so we can add that to the final list.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n\\n# Code\\n```\\nclass Solution(object):\\n    def removeAnagrams(self, words):\\n        \"\"\"\\n        :type words: List[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        return [words[0]] + [words[i] for i in range(1, len(words)) if sorted(words[i]) != sorted(words[i-1])]\\n        # Check if the previous word is an anagram of the current word. Add the first word in words as well.\\n        \\n```\\n\\n**Please upvote if this helped!!!**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def removeAnagrams(self, words):\\n        \"\"\"\\n        :type words: List[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        return [words[0]] + [words[i] for i in range(1, len(words)) if sorted(words[i]) != sorted(words[i-1])]\\n        # Check if the previous word is an anagram of the current word. Add the first word in words as well.\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3976691,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private boolean isAnagram(String str1, String str2){\\n        if(str1.length() != str2.length())return false;\\n        int[] ans =  new int[26];\\n        for(int i=0; i<str1.length(); i++){\\n            ans[str1.charAt(i)-\\'a\\']++;\\n            ans[str2.charAt(i)-\\'a\\']--;\\n        }\\n        for(int i=0; i<26; i++){\\n            if(ans[i] != 0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    public List<String> removeAnagrams(String[] words) {\\n        List<String> list =  new ArrayList<>();\\n        boolean ans[]=new boolean[words.length];\\n        for(int i=0; i<words.length-1; i++){\\n            int j = i+1;\\n            while(ans[j]){\\n                j++;\\n            }\\n            if(isAnagram(words[i], words[j])){\\n                ans[j] =  true;\\n            }\\n        }\\n\\n        for(int i=0; i<words.length; i++){\\n            if(ans[i] == false){\\n                list.add(words[i]);\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private boolean isAnagram(String str1, String str2){\\n        if(str1.length() != str2.length())return false;\\n        int[] ans =  new int[26];\\n        for(int i=0; i<str1.length(); i++){\\n            ans[str1.charAt(i)-\\'a\\']++;\\n            ans[str2.charAt(i)-\\'a\\']--;\\n        }\\n        for(int i=0; i<26; i++){\\n            if(ans[i] != 0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    public List<String> removeAnagrams(String[] words) {\\n        List<String> list =  new ArrayList<>();\\n        boolean ans[]=new boolean[words.length];\\n        for(int i=0; i<words.length-1; i++){\\n            int j = i+1;\\n            while(ans[j]){\\n                j++;\\n            }\\n            if(isAnagram(words[i], words[j])){\\n                ans[j] =  true;\\n            }\\n        }\\n\\n        for(int i=0; i<words.length; i++){\\n            if(ans[i] == false){\\n                list.add(words[i]);\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3976357,
                "title": "easy-logic-java-using-2-functions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String convertString(String[] words, int i){\\n        String str = words[i];\\n            char arr[] = str.toCharArray();\\n            Arrays.sort(arr);\\n\\n            str = new String(arr); \\n            return str;\\n    }\\n    public List<String> removeAnagrams(String[] words) {\\n        //go from n to 0\\n        //check i and i-1\\n        List<String> res = new ArrayList<>();\\n        int i = words.length-1;\\n            //string in sorted manner\\n            //now compare i with i-1\\n            while(i>0){\\n                String str1 = convertString(words, i);\\n                String str2 = convertString(words, i-1);\\n                \\n                if(!str1.equals(str2)){\\n                    res.add(words[i]);\\n                }\\n                i--;\\n            }\\n            res.add(words[0]); \\n\\n            Collections.reverse(res);\\n            return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String convertString(String[] words, int i){\\n        String str = words[i];\\n            char arr[] = str.toCharArray();\\n            Arrays.sort(arr);\\n\\n            str = new String(arr); \\n            return str;\\n    }\\n    public List<String> removeAnagrams(String[] words) {\\n        //go from n to 0\\n        //check i and i-1\\n        List<String> res = new ArrayList<>();\\n        int i = words.length-1;\\n            //string in sorted manner\\n            //now compare i with i-1\\n            while(i>0){\\n                String str1 = convertString(words, i);\\n                String str2 = convertString(words, i-1);\\n                \\n                if(!str1.equals(str2)){\\n                    res.add(words[i]);\\n                }\\n                i--;\\n            }\\n            res.add(words[0]); \\n\\n            Collections.reverse(res);\\n            return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3973732,
                "title": "easy-to-understand-python3-solution-tc-o-n-sc-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        res = [words[0]]\\n        for word in words[1:]:\\n            curr = \"\".join(sorted(word))\\n            if curr != \"\".join(sorted(res[-1])):\\n                res.append(word)\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        res = [words[0]]\\n        for word in words[1:]:\\n            curr = \"\".join(sorted(word))\\n            if curr != \"\".join(sorted(res[-1])):\\n                res.append(word)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3970787,
                "title": "runtime-59ms-beats-95-24-memory-45-39-mb-beats-100",
                "content": "```\\nfunction removeAnagrams(words: string[]): string[] {\\n    let i = 1\\n\\n    while (i < words.length) {\\n        if (isAnagram(words[i - 1], words[i])) {\\n            words.splice(i,1)\\n            i = 1\\n            continue\\n        }\\n\\n        i++\\n    }\\n\\n    return words\\n};\\n\\n\\nconst isAnagram = (word1: string, word2: string): boolean => {\\n    if (word1.length !== word2.length) return false\\n    if (word1 === word2) return true\\n\\n    for (let i = 0; i < word1.length; i++) {\\n        const letter = word1[i]\\n        word2 = word2.replace(letter, \\'\\')\\n    }\\n\\n    return !word2\\n}\\n```\\n\\n",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction removeAnagrams(words: string[]): string[] {\\n    let i = 1\\n\\n    while (i < words.length) {\\n        if (isAnagram(words[i - 1], words[i])) {\\n            words.splice(i,1)\\n            i = 1\\n            continue\\n        }\\n\\n        i++\\n    }\\n\\n    return words\\n};\\n\\n\\nconst isAnagram = (word1: string, word2: string): boolean => {\\n    if (word1.length !== word2.length) return false\\n    if (word1 === word2) return true\\n\\n    for (let i = 0; i < word1.length; i++) {\\n        const letter = word1[i]\\n        word2 = word2.replace(letter, \\'\\')\\n    }\\n\\n    return !word2\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3932999,
                "title": "rust-0ms-linear-solution",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn remove_anagrams(words: Vec<String>) -> Vec<String> {\\n        let maps = words\\n            .iter()\\n            .map(|w| {\\n                let mut lut = [0; 26];\\n                for c in w.chars() {\\n                    lut[c as usize - \\'a\\' as usize] += 1;\\n                }\\n                lut\\n            })\\n            .collect::<Vec<[i32; 26]>>();\\n\\n        let mut res = vec![];\\n\\n        res.push(words[0].clone());\\n        for i in 1..words.len() {\\n            if maps[i] != maps[i - 1] {\\n                res.push(words[i].clone());\\n            }\\n        }\\n        res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn remove_anagrams(words: Vec<String>) -> Vec<String> {\\n        let maps = words\\n            .iter()\\n            .map(|w| {\\n                let mut lut = [0; 26];\\n                for c in w.chars() {\\n                    lut[c as usize - \\'a\\' as usize] += 1;\\n                }\\n                lut\\n            })\\n            .collect::<Vec<[i32; 26]>>();\\n\\n        let mut res = vec![];\\n\\n        res.push(words[0].clone());\\n        for i in 1..words.len() {\\n            if maps[i] != maps[i - 1] {\\n                res.push(words[i].clone());\\n            }\\n        }\\n        res\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3924581,
                "title": "clean-easy-to-understand-solution-beats-100-java",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n     boolean isAnagram(String word1, String word2){\\n        if(word1 == null || word2 == null)return false;\\n\\n        int[] freq=new int[26];\\n\\n        for(int i=0;i<word1.length();i++){\\n            int ascii = word1.charAt(i) - \\'a\\';\\n            freq[ascii] = freq[ascii] + 1;\\n        }\\n\\n        for(int i=0;i<word2.length();i++){\\n            int ascii = word2.charAt(i) - \\'a\\';\\n            freq[ascii] = freq[ascii] - 1;\\n        }\\n\\n        for(int i=0; i<26; i++){\\n            if(freq[i] != 0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public List<String> removeAnagrams(String[] words){\\n        List<String> ans = new ArrayList<>();\\n        while(true){\\n            boolean changed = false;\\n            for(int i=words.length-1;i>=1;i--){\\n                if(words[i] == null)\\n                    continue;\\n                if(isAnagram(words[i],words[i-1])){\\n                    words[i] = null;\\n                    changed = true;\\n                }\\n            }\\n            if(changed == false){\\n                for(int i= 0; i< words.length; i++){\\n                    if(words[i] != null){\\n                        ans.add(words[i]);\\n                    }\\n                }\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n     boolean isAnagram(String word1, String word2){\\n        if(word1 == null || word2 == null)return false;\\n\\n        int[] freq=new int[26];\\n\\n        for(int i=0;i<word1.length();i++){\\n            int ascii = word1.charAt(i) - \\'a\\';\\n            freq[ascii] = freq[ascii] + 1;\\n        }\\n\\n        for(int i=0;i<word2.length();i++){\\n            int ascii = word2.charAt(i) - \\'a\\';\\n            freq[ascii] = freq[ascii] - 1;\\n        }\\n\\n        for(int i=0; i<26; i++){\\n            if(freq[i] != 0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public List<String> removeAnagrams(String[] words){\\n        List<String> ans = new ArrayList<>();\\n        while(true){\\n            boolean changed = false;\\n            for(int i=words.length-1;i>=1;i--){\\n                if(words[i] == null)\\n                    continue;\\n                if(isAnagram(words[i],words[i-1])){\\n                    words[i] = null;\\n                    changed = true;\\n                }\\n            }\\n            if(changed == false){\\n                for(int i= 0; i< words.length; i++){\\n                    if(words[i] != null){\\n                        ans.add(words[i]);\\n                    }\\n                }\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3923974,
                "title": "c-easy-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        for(int i = 1;i<words.size();i++){\\n            string temp1 = words[i];\\n            sort(temp1.begin(),temp1.end());\\n            string temp2 = words[i-1];\\n            sort(temp2.begin(),temp2.end());\\n            if(temp1 == temp2){\\n                words.erase(words.begin() + i);\\n                i--;\\n            }\\n        }\\n        return words;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        for(int i = 1;i<words.size();i++){\\n            string temp1 = words[i];\\n            sort(temp1.begin(),temp1.end());\\n            string temp2 = words[i-1];\\n            sort(temp2.begin(),temp2.end());\\n            if(temp1 == temp2){\\n                words.erase(words.begin() + i);\\n                i--;\\n            }\\n        }\\n        return words;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3915665,
                "title": "simple-c-one-traversal-no-map-used",
                "content": "# Complexity\\n- Time complexity: O(n * (wordLen log(wordLen)))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1) Not considering returing vector\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        int n = words.size();\\n        vector<string> res;\\n\\n        res.push_back(words[0]);\\n        for(int i=1; i<n; i++){\\n            string prevStr = words[i-1];\\n            string currStr = words[i];\\n\\n            sort(prevStr.begin(), prevStr.end());\\n            sort(currStr.begin(), currStr.end());\\n\\n            if(prevStr != currStr)\\n                res.push_back(words[i]);\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        int n = words.size();\\n        vector<string> res;\\n\\n        res.push_back(words[0]);\\n        for(int i=1; i<n; i++){\\n            string prevStr = words[i-1];\\n            string currStr = words[i];\\n\\n            sort(prevStr.begin(), prevStr.end());\\n            sort(currStr.begin(), currStr.end());\\n\\n            if(prevStr != currStr)\\n                res.push_back(words[i]);\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3915357,
                "title": "python3-list-of-sorted-words-beats-99-26",
                "content": "# Code\\n```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        srt = [sorted(words[0])]\\n        res = [words[0]]\\n        for word in words[1:]:\\n            sorted_word = sorted(word)\\n            if sorted_word != srt[-1]:\\n                srt.append(sorted_word)\\n                res.append(word)\\n\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        srt = [sorted(words[0])]\\n        res = [words[0]]\\n        for word in words[1:]:\\n            sorted_word = sorted(word)\\n            if sorted_word != srt[-1]:\\n                srt.append(sorted_word)\\n                res.append(word)\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3911604,
                "title": "python-2-pointers-while",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        i = 0\\n        j = i+1\\n        n = len(words)\\n        res = []\\n        while j < n:\\n            if sorted(words[i]) == sorted(words[j]): \\n                if j == i+1:\\n                    res.append(words[i])\\n            else: \\n                if j == i+1:\\n                    res.append(words[i])\\n                i = j\\n            j += 1\\n\\n        if j == i+1:\\n            res.append(words[i])  \\n        return res\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        i = 0\\n        j = i+1\\n        n = len(words)\\n        res = []\\n        while j < n:\\n            if sorted(words[i]) == sorted(words[j]): \\n                if j == i+1:\\n                    res.append(words[i])\\n            else: \\n                if j == i+1:\\n                    res.append(words[i])\\n                i = j\\n            j += 1\\n\\n        if j == i+1:\\n            res.append(words[i])  \\n        return res\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3906583,
                "title": "easiest-c-code",
                "content": "# Code\\n```\\npublic class Solution {\\n    private int[] GetCharMap(string s) {\\n        int[] map = new int[26];\\n\\n        foreach (char c in s) {\\n            map[c - \\'a\\']++;\\n        }\\n\\n        return map;\\n    }\\n\\n    private bool IsSameCharMap(int[] arr1, int[] arr2) {\\n        for (int i = 0; i < arr1.Length; i++) {\\n            if (arr1[i] != arr2[i]) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n\\n    public IList<string> RemoveAnagrams(string[] words) {\\n        List<string> result = new List<string> { words[0] };\\n        int[] charMap = GetCharMap(words[0]);\\n\\n        for (int i = 1; i < words.Length; i++) {\\n            int[] nextCharMap = GetCharMap(words[i]);\\n\\n            if (!IsSameCharMap(charMap, nextCharMap)) {\\n                charMap = nextCharMap;\\n                result.Add(words[i]);\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    private int[] GetCharMap(string s) {\\n        int[] map = new int[26];\\n\\n        foreach (char c in s) {\\n            map[c - \\'a\\']++;\\n        }\\n\\n        return map;\\n    }\\n\\n    private bool IsSameCharMap(int[] arr1, int[] arr2) {\\n        for (int i = 0; i < arr1.Length; i++) {\\n            if (arr1[i] != arr2[i]) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n\\n    public IList<string> RemoveAnagrams(string[] words) {\\n        List<string> result = new List<string> { words[0] };\\n        int[] charMap = GetCharMap(words[0]);\\n\\n        for (int i = 1; i < words.Length; i++) {\\n            int[] nextCharMap = GetCharMap(words[i]);\\n\\n            if (!IsSameCharMap(charMap, nextCharMap)) {\\n                charMap = nextCharMap;\\n                result.Add(words[i]);\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3899171,
                "title": "by-using-one-for-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string[]} words\\n * @return {string[]}\\n */\\nvar removeAnagrams = function(words) {\\n    for(var i=0;i<words.length-1;i++)\\n    {\\n        var x=words[i].split(\"\").sort().join(\"\");\\n        var y=words[i+1].split(\"\").sort().join(\"\");\\n        if(x==y)\\n        {\\n            words.splice(i+1,1)\\n            i--;\\n        }\\n    }\\n    return words;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @return {string[]}\\n */\\nvar removeAnagrams = function(words) {\\n    for(var i=0;i<words.length-1;i++)\\n    {\\n        var x=words[i].split(\"\").sort().join(\"\");\\n        var y=words[i+1].split(\"\").sort().join(\"\");\\n        if(x==y)\\n        {\\n            words.splice(i+1,1)\\n            i--;\\n        }\\n    }\\n    return words;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3892186,
                "title": "java-best-solution-4-ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n     Brute Force\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(nklogk)\\n\\n# Code\\n```\\nclass Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        ArrayList<String> list=new ArrayList<>();\\n        String temp=\"\";\\n        for(String s:words){\\n            char[] c=s.toCharArray();\\n            Arrays.sort(c);\\n            String current=new String(c);\\n            if(!current.equals(temp))\\n                list.add(s);\\n            temp=current;\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        ArrayList<String> list=new ArrayList<>();\\n        String temp=\"\";\\n        for(String s:words){\\n            char[] c=s.toCharArray();\\n            Arrays.sort(c);\\n            String current=new String(c);\\n            if(!current.equals(temp))\\n                list.add(s);\\n            temp=current;\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3879943,
                "title": "simplest-python-solution",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        res = []\\n        left = [0] * 26\\n        for w in words:\\n            right = [0] * 26\\n            for c in w:\\n                right[ord(c)-ord(\\'a\\')] +=1\\n\\n            if left != right:\\n                res.append(w)\\n            left, right = right, left \\n        \\n        return res\\n        \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        res = []\\n        left = [0] * 26\\n        for w in words:\\n            right = [0] * 26\\n            for c in w:\\n                right[ord(c)-ord(\\'a\\')] +=1\\n\\n            if left != right:\\n                res.append(w)\\n            left, right = right, left \\n        \\n        return res\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3879899,
                "title": "easy-to-understand-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMy first thought is to use what I learned from validAnagrams. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI used a while loop to loop through the words list. If words[i] and words[i+1] are anagrams, I will pop words[i+1] from the list. And then, in the next loop, the words[i+1] becomes the next element of the poped element from last cycle.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nI am not sure about the time complexity, I guess it\\'s O(n2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nI am guessing O(n) for space complexity\\n# Code\\n```\\n\\nclass Solution:\\n\\n    def checkAnagrams(self, string1, string2):\\n        dict1 = {}\\n        dict2 = {}\\n        for char in string1:\\n            dict1[char] = 1 + dict1.get(char, 0)\\n        for char in string2:\\n            dict2[char] = 1 + dict2.get(char, 0)\\n        return dict1 == dict2\\n\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        i = 0\\n        while i < len(words) - 1:\\n            if self.checkAnagrams(words[i], words[i+1]):\\n                words.pop(i+1)\\n            else:\\n                i+=1\\n\\n        return words\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n\\nclass Solution:\\n\\n    def checkAnagrams(self, string1, string2):\\n        dict1 = {}\\n        dict2 = {}\\n        for char in string1:\\n            dict1[char] = 1 + dict1.get(char, 0)\\n        for char in string2:\\n            dict2[char] = 1 + dict2.get(char, 0)\\n        return dict1 == dict2\\n\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        i = 0\\n        while i < len(words) - 1:\\n            if self.checkAnagrams(words[i], words[i+1]):\\n                words.pop(i+1)\\n            else:\\n                i+=1\\n\\n        return words\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3877970,
                "title": "very-simple-and-easy-cpp-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isAnagram(string s, string t){\\n        sort(s.begin(),s.end());\\n        sort(t.begin(),t.end());\\n        return (s == t) ? true : false;\\n    }\\n    vector<string> removeAnagrams(vector<string>& v) {\\n        int n = v.size();\\n        vector<string> ans = {v[0]}; \\n        \\n        for(int i = 0; i<n ;i++){\\n            if( isAnagram(v[i] , ans[ans.size()-1]) ){\\n                // do nothing\\n            }\\n            else{\\n                ans.push_back(v[i]);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isAnagram(string s, string t){\\n        sort(s.begin(),s.end());\\n        sort(t.begin(),t.end());\\n        return (s == t) ? true : false;\\n    }\\n    vector<string> removeAnagrams(vector<string>& v) {\\n        int n = v.size();\\n        vector<string> ans = {v[0]}; \\n        \\n        for(int i = 0; i<n ;i++){\\n            if( isAnagram(v[i] , ans[ans.size()-1]) ){\\n                // do nothing\\n            }\\n            else{\\n                ans.push_back(v[i]);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3868647,
                "title": "js-short-60-90",
                "content": "# Code\\n```\\n/**\\n * @param {string[]} words\\n * @return {string[]}\\n */\\nconst sortWord = (word) => word.split(\\'\\').sort().join(\\'\\');\\n\\nconst removeAnagrams = (words) => {\\n    for (let i = 1; i < words.length;) {\\n        if (sortWord(words[i - 1]) === sortWord(words[i])) words.splice(i, 1);\\n        else i++;\\n    }\\n\\n    return words;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @return {string[]}\\n */\\nconst sortWord = (word) => word.split(\\'\\').sort().join(\\'\\');\\n\\nconst removeAnagrams = (words) => {\\n    for (let i = 1; i < words.length;) {\\n        if (sortWord(words[i - 1]) === sortWord(words[i])) words.splice(i, 1);\\n        else i++;\\n    }\\n\\n    return words;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3861202,
                "title": "find-resultant-array-after-removing-anagrams",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        String  s = \"\";\\n        List<String> li = new ArrayList<>();\\n        for(int i=0;i<words.length;i++){\\n            char[] arr =words[i].toCharArray();\\n            Arrays.sort(arr);\\n            String cur = String.valueOf(arr);\\n            if(!cur.equals(s)){\\n                li.add(words[i]);\\n                s = cur;\\n            }\\n        }\\n        return li;\\n        \\n\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        String  s = \"\";\\n        List<String> li = new ArrayList<>();\\n        for(int i=0;i<words.length;i++){\\n            char[] arr =words[i].toCharArray();\\n            Arrays.sort(arr);\\n            String cur = String.valueOf(arr);\\n            if(!cur.equals(s)){\\n                li.add(words[i]);\\n                s = cur;\\n            }\\n        }\\n        return li;\\n        \\n\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3842125,
                "title": "one-line-solution-runtime-40ms-100-00",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n\\n        return list(map(lambda word: next(word[1]), groupby(words, key= sorted)))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n\\n        return list(map(lambda word: next(word[1]), groupby(words, key= sorted)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3833155,
                "title": "cpp-easy-code-clean-code",
                "content": "\\n# Complexity\\n- Time complexity:O(n*log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isanagram(string s,string t){\\n        sort(s.begin(),s.end());\\n        sort(t.begin(),t.end());\\n        return s==t;\\n    }\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        int n=words.size();\\n        for(int i=n-1;i>0;i--){\\n            if(isanagram(words[i],words[i-1])){\\n                words[i]=\"AMAN\";\\n            }\\n        }\\n        vector<string> ans;\\n        for(auto e: words){\\n            if(e==\"AMAN\")continue;\\n            ans.push_back(e);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isanagram(string s,string t){\\n        sort(s.begin(),s.end());\\n        sort(t.begin(),t.end());\\n        return s==t;\\n    }\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        int n=words.size();\\n        for(int i=n-1;i>0;i--){\\n            if(isanagram(words[i],words[i-1])){\\n                words[i]=\"AMAN\";\\n            }\\n        }\\n        vector<string> ans;\\n        for(auto e: words){\\n            if(e==\"AMAN\")continue;\\n            ans.push_back(e);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3826214,
                "title": "js-ez",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string[]} words\\n * @return {string[]}\\n */\\nvar removeAnagrams = function(words) {\\n    for (let i = words.length - 1; i > 0; i--) {\\n        if (isAnagram(words[i], words[i - 1])) {\\n            words.splice(i, 1);\\n        }\\n    }\\n\\n    return words;\\n};\\n\\nconst isAnagram = (wordOne, wordTwo) => {\\n    return wordOne.split(\"\").sort().join(\"\") === wordTwo.split(\"\").sort().join(\"\")\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @return {string[]}\\n */\\nvar removeAnagrams = function(words) {\\n    for (let i = words.length - 1; i > 0; i--) {\\n        if (isAnagram(words[i], words[i - 1])) {\\n            words.splice(i, 1);\\n        }\\n    }\\n\\n    return words;\\n};\\n\\nconst isAnagram = (wordOne, wordTwo) => {\\n    return wordOne.split(\"\").sort().join(\"\") === wordTwo.split(\"\").sort().join(\"\")\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3822486,
                "title": "java-very-easy-0sec",
                "content": "# Intuition\\n![upvote.png](https://assets.leetcode.com/users/images/2fa81ae1-1e2a-48d1-9974-f32a110a86f3_1690442496.7153208.png)\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        String prev =\"\";\\n        List<String> li=new ArrayList<>();\\n        for(int i=0;i<words.length;i++){\\n            char[] ch=words[i].toCharArray();\\n            Arrays.sort(ch);\\n            String curr=String.valueOf(ch);\\n            if(!curr.equals(prev)){\\n                li.add(words[i]);\\n                prev=curr;\\n            }\\n        }\\n        return li;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        String prev =\"\";\\n        List<String> li=new ArrayList<>();\\n        for(int i=0;i<words.length;i++){\\n            char[] ch=words[i].toCharArray();\\n            Arrays.sort(ch);\\n            String curr=String.valueOf(ch);\\n            if(!curr.equals(prev)){\\n                li.add(words[i]);\\n                prev=curr;\\n            }\\n        }\\n        return li;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3820055,
                "title": "java-solution-using-string-comparison",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isanagram(String s1,String s2){\\n        char[] a=s1.toCharArray();\\n        char[] b=s2.toCharArray();\\n        Arrays.sort(a);\\n        Arrays.sort(b);\\n        String s11=String.valueOf(a);\\n        String s22=String.valueOf(b);\\n        return s11.equals(s22);\\n    }\\n    public List<String> removeAnagrams(String[] words) {\\n       List<String> list=new ArrayList<>();\\n       list.add(words[0]);\\n       for(int i=1;i<words.length;i++){\\n           if(!isanagram(words[i-1],words[i])){\\n               list.add(words[i]);\\n           }\\n       } \\n       return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isanagram(String s1,String s2){\\n        char[] a=s1.toCharArray();\\n        char[] b=s2.toCharArray();\\n        Arrays.sort(a);\\n        Arrays.sort(b);\\n        String s11=String.valueOf(a);\\n        String s22=String.valueOf(b);\\n        return s11.equals(s22);\\n    }\\n    public List<String> removeAnagrams(String[] words) {\\n       List<String> list=new ArrayList<>();\\n       list.add(words[0]);\\n       for(int i=1;i<words.length;i++){\\n           if(!isanagram(words[i-1],words[i])){\\n               list.add(words[i]);\\n           }\\n       } \\n       return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3813406,
                "title": "php-two-pointers-solution",
                "content": "# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n\\n\\n    /**\\n     * @param String[] $words\\n     * @return String[]\\n     */\\n    function removeAnagrams($words) {     \\n        $left = 0;\\n        $right = 1;\\n        while (isset($words[$right])) {\\n            // Check if the current word is an anagram of the next word\\n            if ($this->isAnagram($words[$left], $words[$right]) === true) {\\n                unset($words[$right]); // Remove the anagram from the array\\n            } else {\\n                $left = $right; // Move the left pointer to the next non-anagram word\\n            }\\n            $right++; // Move the right pointer to the next word to be compared\\n        }\\n\\n        return $words;\\n    }\\n\\n    /**\\n     * Check if two words are anagrams.\\n     * Anagrams are words that have the same characters but in a different order.\\n     * @param string $current The first word\\n     * @param string $next The second word\\n     * @return bool True if the words are anagrams, False otherwise\\n     */\\n    function isAnagram(string $current, string $next) {\\n        $a = str_split($current);\\n        $b = str_split($next);\\n        sort($a);                 // Sort the characters of the first word in alphabetical order\\n        sort($b);                 // Sort the characters of the second word in alphabetical order\\n        return implode($a) == implode($b); // Check if the sorted words are equal, i.e., they are anagrams\\n    }\\n \\n}\\n```",
                "solutionTags": [
                    "PHP",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n\\n\\n    /**\\n     * @param String[] $words\\n     * @return String[]\\n     */\\n    function removeAnagrams($words) {     \\n        $left = 0;\\n        $right = 1;\\n        while (isset($words[$right])) {\\n            // Check if the current word is an anagram of the next word\\n            if ($this->isAnagram($words[$left], $words[$right]) === true) {\\n                unset($words[$right]); // Remove the anagram from the array\\n            } else {\\n                $left = $right; // Move the left pointer to the next non-anagram word\\n            }\\n            $right++; // Move the right pointer to the next word to be compared\\n        }\\n\\n        return $words;\\n    }\\n\\n    /**\\n     * Check if two words are anagrams.\\n     * Anagrams are words that have the same characters but in a different order.\\n     * @param string $current The first word\\n     * @param string $next The second word\\n     * @return bool True if the words are anagrams, False otherwise\\n     */\\n    function isAnagram(string $current, string $next) {\\n        $a = str_split($current);\\n        $b = str_split($next);\\n        sort($a);                 // Sort the characters of the first word in alphabetical order\\n        sort($b);                 // Sort the characters of the second word in alphabetical order\\n        return implode($a) == implode($b); // Check if the sorted words are equal, i.e., they are anagrams\\n    }\\n \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3804154,
                "title": "remove-anagrams-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def removeAnagrams(self, words):\\n        def anagrams(str1,str2):\\n            str1,str2 = str1.lower(), str2.lower()\\n            if sorted(str1) == sorted(str2):\\n                return True\\n            else:\\n                return False\\n\\n        i = 0\\n        length = len(words)\\n        while(i<length-1):\\n            if anagrams(words[i],words[i+1]):\\n                words.pop(i+1)\\n                i -= 1\\n                length -= 1\\n            i += 1\\n        return words\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def removeAnagrams(self, words):\\n        def anagrams(str1,str2):\\n            str1,str2 = str1.lower(), str2.lower()\\n            if sorted(str1) == sorted(str2):\\n                return True\\n            else:\\n                return False\\n\\n        i = 0\\n        length = len(words)\\n        while(i<length-1):\\n            if anagrams(words[i],words[i+1]):\\n                words.pop(i+1)\\n                i -= 1\\n                length -= 1\\n            i += 1\\n        return words\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3795474,
                "title": "stack-based-solution",
                "content": "# Intuition : \\nusing merging interval intuition \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach : \\nusing stack instead of map\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        stack<string>s;\\n        s.push(words[0]);\\n        for(int i=1;i<words.size();i++){\\n            string a = words[i];\\n            string b = s.top();\\n            sort(b.begin(),b.end());\\n            sort(a.begin(),a.end());\\n            if(a==b){\\n                continue;\\n            }\\n            else{\\n                s.push(words[i]);\\n            }\\n        }\\n        vector<string>ans;\\n        while(!s.empty()){\\n            string a = s.top();\\n            ans.push_back(a);\\n            s.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        stack<string>s;\\n        s.push(words[0]);\\n        for(int i=1;i<words.size();i++){\\n            string a = words[i];\\n            string b = s.top();\\n            sort(b.begin(),b.end());\\n            sort(a.begin(),a.end());\\n            if(a==b){\\n                continue;\\n            }\\n            else{\\n                s.push(words[i]);\\n            }\\n        }\\n        vector<string>ans;\\n        while(!s.empty()){\\n            string a = s.top();\\n            ans.push_back(a);\\n            s.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3793306,
                "title": "easy-java-solution-two-pointer",
                "content": "# Complexity\\n- Time complexity:  O(n*log(n)) \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:  O(n + m) \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<String> removeAnagrams(String[] strs) {\\n        List<Integer> toBeRemoved = new ArrayList<>();\\n        List<String> res = new ArrayList<>();\\n        int prev = 0;\\n        int current = 1;\\n        while (current < strs.length) {\\n            if (isAnagram(strs[current], strs[prev]))\\n                toBeRemoved.add(current);\\n            else\\n                prev = current;\\n\\n            current++;\\n        }\\n        for (int str = 0; str < strs.length; str++) {\\n            if (!toBeRemoved.contains(str)) {\\n                res.add(strs[str]);\\n            }\\n        }\\n        return res;\\n    }\\n    public boolean isAnagram(String str1, String str2) {\\n        char[] chars = str1.toCharArray();\\n        Arrays.sort(chars);\\n        String sortedStr1 = new String(chars);\\n        chars = str2.toCharArray();\\n        Arrays.sort(chars);\\n        String sortedStr2 = new String(chars);\\n        return sortedStr1.equals(sortedStr2);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> removeAnagrams(String[] strs) {\\n        List<Integer> toBeRemoved = new ArrayList<>();\\n        List<String> res = new ArrayList<>();\\n        int prev = 0;\\n        int current = 1;\\n        while (current < strs.length) {\\n            if (isAnagram(strs[current], strs[prev]))\\n                toBeRemoved.add(current);\\n            else\\n                prev = current;\\n\\n            current++;\\n        }\\n        for (int str = 0; str < strs.length; str++) {\\n            if (!toBeRemoved.contains(str)) {\\n                res.add(strs[str]);\\n            }\\n        }\\n        return res;\\n    }\\n    public boolean isAnagram(String str1, String str2) {\\n        char[] chars = str1.toCharArray();\\n        Arrays.sort(chars);\\n        String sortedStr1 = new String(chars);\\n        chars = str2.toCharArray();\\n        Arrays.sort(chars);\\n        String sortedStr2 = new String(chars);\\n        return sortedStr1.equals(sortedStr2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3791459,
                "title": "python-simple-python-solution-sorting",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 69 ms, faster than 71.36% of Python3 online submissions for Find Resultant Array After Removing Anagrams.\\n# Memory Usage: 16.4 MB, less than 25.48% of Python3 online submissions for Find Resultant Array After Removing Anagrams.\\n\\n\\tclass Solution:\\n\\t\\tdef removeAnagrams(self, words: List[str]) -> List[str]:\\n\\n\\t\\t\\tresult = [words[0]]\\n\\n\\t\\t\\tfor word in words[1:]:\\n\\n\\t\\t\\t\\tif sorted(result[-1]) != sorted(word):\\n\\t\\t\\t\\t\\tresult.append(word)\\n\\n\\t\\t\\treturn result\\n\\t\\t\\t\\n# Time complexity: O(N)\\n# Space complexity: O(N)\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String",
                    "Stack",
                    "Sorting"
                ],
                "code": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 69 ms, faster than 71.36% of Python3 online submissions for Find Resultant Array After Removing Anagrams.\\n# Memory Usage: 16.4 MB, less than 25.48% of Python3 online submissions for Find Resultant Array After Removing Anagrams.\\n\\n\\tclass Solution:\\n\\t\\tdef removeAnagrams(self, words: List[str]) -> List[str]:\\n\\n\\t\\t\\tresult = [words[0]]\\n\\n\\t\\t\\tfor word in words[1:]:\\n\\n\\t\\t\\t\\tif sorted(result[-1]) != sorted(word):\\n\\t\\t\\t\\t\\tresult.append(word)\\n\\n\\t\\t\\treturn result\\n\\t\\t\\t\\n# Time complexity: O(N)\\n# Space complexity: O(N)\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "codeTag": "Java"
            },
            {
                "id": 3790903,
                "title": "for-loop-and-counter",
                "content": "# Code\\n```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        check = Counter(words[0])\\n        result = [0]\\n        for i in range(1, len(words)):\\n            word = Counter(words[i])\\n            if check != word:\\n                result.append(i)\\n                check = word\\n        return [words[i] for i in result]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        check = Counter(words[0])\\n        result = [0]\\n        for i in range(1, len(words)):\\n            word = Counter(words[i])\\n            if check != word:\\n                result.append(i)\\n                check = word\\n        return [words[i] for i in result]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3787106,
                "title": "easy-javascript-solution-satisfying-all-test-cases",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string[]} words\\n * @return {string[]}\\n */\\nvar removeAnagrams = function(words) {\\n    let sortedWords = words.map((word) => {\\n        return word.split(\"\").sort().join(\"\");\\n    });\\n\\n     for(let i=0; i< sortedWords.length;i++) {\\n         if(sortedWords[i+1] === sortedWords[i]) {\\n             sortedWords.splice(i+1,1);\\n             words.splice(i+1,1);\\n             i--;\\n         }\\n     }\\n\\n    return words;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @return {string[]}\\n */\\nvar removeAnagrams = function(words) {\\n    let sortedWords = words.map((word) => {\\n        return word.split(\"\").sort().join(\"\");\\n    });\\n\\n     for(let i=0; i< sortedWords.length;i++) {\\n         if(sortedWords[i+1] === sortedWords[i]) {\\n             sortedWords.splice(i+1,1);\\n             words.splice(i+1,1);\\n             i--;\\n         }\\n     }\\n\\n    return words;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3785264,
                "title": "c-solution",
                "content": "```\\nvector<string> removeAnagrams(vector<string>& words) {\\n\\tvector<string> res;\\n\\tfor (int i = 0; i < words.size(); i++) {\\n\\t\\tres.push_back(words[i]);\\n\\t\\tstring sorted = words[i];\\n\\t\\tsort(begin(sorted), end(sorted));\\n\\t\\tint j = i + 1;\\n\\t\\twhile (j < words.size()) {\\n\\t\\t\\tstring sortedj = words[j++];\\n\\t\\t\\tsort(begin(sortedj), end(sortedj));\\n\\t\\t\\tif (sorted == sortedj)\\n\\t\\t\\t\\ti++;\\n\\t\\t\\telse\\n\\t\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n\\treturn res;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nvector<string> removeAnagrams(vector<string>& words) {\\n\\tvector<string> res;\\n\\tfor (int i = 0; i < words.size(); i++) {\\n\\t\\tres.push_back(words[i]);\\n\\t\\tstring sorted = words[i];\\n\\t\\tsort(begin(sorted), end(sorted));\\n\\t\\tint j = i + 1;\\n\\t\\twhile (j < words.size()) {\\n\\t\\t\\tstring sortedj = words[j++];\\n\\t\\t\\tsort(begin(sortedj), end(sortedj));\\n\\t\\t\\tif (sorted == sortedj)\\n\\t\\t\\t\\ti++;\\n\\t\\t\\telse\\n\\t\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3776388,
                "title": "easy-to-understand-python-3",
                "content": "## **Runtime**\\n- 65ms\\nBeats 85.32% of users with Python3\\n\\n## **Memory**\\n- 16.34mb\\nBeats 62.96%of users with Python3\\n\\n# Code\\n```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        res = []\\n        p = words[0]\\n        for i in words:\\n            if sorted(i) != sorted(p):\\n                res.append(p)\\n                p = i\\n        res.append(p)\\n        return res\\n                \\n\\n                \\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        res = []\\n        p = words[0]\\n        for i in words:\\n            if sorted(i) != sorted(p):\\n                res.append(p)\\n                p = i\\n        res.append(p)\\n        return res\\n                \\n\\n                \\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3772853,
                "title": "find-resultant-array-after-removing-anagrams-c-9ms-solution-easy-approch-o-n-2logn",
                "content": "# Intuition :-\\n<ul><li>The one basic intution about \"Anagrams\" is that an \"Anagram\" is a string which has the same frequency of character with another string. (or) ,</li>\\n<br/>\\n<li>An \"anagram\" of a string is another string that contains the same characters, only the order of characters can be different eg:- \"abba\" is an anagram of \"abab\" and vice-verse as freq of a=2 and b=2 here.</li>\\n<br/>\\n<li>Now coming to idea the basic approch to this is sorting the string and checking.</li>\\n</ul>\\n\\n# Approach :-\\n<ul><li>At first we store the words vector into a temporary vector for our processing and maintaining the string we want.</li>  \\n    <br/>\\n    <li>Now for anagram we sort the words as after sorting we check weather the loop have any one equal word or not if not we return n-1 as all the words in words vector are anagrams.</li>\\n    <br/>\\n<li>If not then in the below for loop we check weather the two adjacent words that is words[i]==words[i+1] if they are we also have to check if this word already present in our ans if it is we can\\'t insert more of this as we want all the words(elements) of res to be anagram same if they are not equal also.</li>\\n    <br/>\\n<li>Fianlly we check if the beginning word is equal to adjacent or not as we were not able to insert if it was into res.</li>\\n<br/>\\n<li>Finally returning res as answer.</li>\\n</ul>\\n\\n# Complexity :-\\n- Time complexity:\\nO((n^2)logn)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        int n = words.size();\\n        vector<string>temp;\\n        vector<string>res;\\n        unordered_map<string,bool>m;\\n\\n        temp = words;\\n\\n        for(int i=0;i<n;i++) {\\n            sort(temp[i].begin(),temp[i].end());\\n        }\\n\\n        int c=0;\\n        for(int i=0;i<n-1;i++) {\\n            if(temp[i]!=temp[i+1]) c++;\\n        }\\n        \\n        // If all the words are anagrams.\\n        if(c==n-1) res = words;\\n\\n        // If not then we process and find the only anagrams.\\n        else {\\n            for(int i=0;i<n-1;i++) {\\n                if(m[temp[i]]!=true && temp[i]==temp[i+1]) {\\n                    res.push_back(words[i]);\\n                    m[temp[i]] = true;\\n                }\\n                else {\\n                    if(temp[i]!=temp[i+1]) {\\n                        res.push_back(words[i+1]);\\n                        m[temp[i+1]] = true;\\n                    }\\n                }\\n            }\\n\\n            if(temp.size()>1 && temp[0]!=temp[1]) {\\n                res.insert(res.begin(),words[0]);\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```\\n<img src=\"https://i.imgflip.com/7abc56.jpg\" alt=\"Please Upvote\">",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        int n = words.size();\\n        vector<string>temp;\\n        vector<string>res;\\n        unordered_map<string,bool>m;\\n\\n        temp = words;\\n\\n        for(int i=0;i<n;i++) {\\n            sort(temp[i].begin(),temp[i].end());\\n        }\\n\\n        int c=0;\\n        for(int i=0;i<n-1;i++) {\\n            if(temp[i]!=temp[i+1]) c++;\\n        }\\n        \\n        // If all the words are anagrams.\\n        if(c==n-1) res = words;\\n\\n        // If not then we process and find the only anagrams.\\n        else {\\n            for(int i=0;i<n-1;i++) {\\n                if(m[temp[i]]!=true && temp[i]==temp[i+1]) {\\n                    res.push_back(words[i]);\\n                    m[temp[i]] = true;\\n                }\\n                else {\\n                    if(temp[i]!=temp[i+1]) {\\n                        res.push_back(words[i+1]);\\n                        m[temp[i+1]] = true;\\n                    }\\n                }\\n            }\\n\\n            if(temp.size()>1 && temp[0]!=temp[1]) {\\n                res.insert(res.begin(),words[0]);\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3770019,
                "title": "o-1-sc-and-o-n-log-n-tc-simple-approach",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(n * log(n))\\n\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        int n = words.length;\\n        \\n        List<String> li = new ArrayList<>();\\n        int i = 0;\\n        while(i<n){\\n            li.add(words[i]);\\n            char curr[] = words[i].toCharArray();\\n            Arrays.sort(curr);\\n            String current = new String(curr);\\n            String prev = current;\\n            while(current.equals(prev)){\\n                i++;\\n                if(i<n){\\n                    curr = words[i].toCharArray();\\n                    Arrays.sort(curr);\\n                    prev = new String(curr);\\n                }else{\\n                    break;\\n                }\\n                \\n            }\\n        }\\n\\n        return li;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        int n = words.length;\\n        \\n        List<String> li = new ArrayList<>();\\n        int i = 0;\\n        while(i<n){\\n            li.add(words[i]);\\n            char curr[] = words[i].toCharArray();\\n            Arrays.sort(curr);\\n            String current = new String(curr);\\n            String prev = current;\\n            while(current.equals(prev)){\\n                i++;\\n                if(i<n){\\n                    curr = words[i].toCharArray();\\n                    Arrays.sort(curr);\\n                    prev = new String(curr);\\n                }else{\\n                    break;\\n                }\\n                \\n            }\\n        }\\n\\n        return li;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3766658,
                "title": "java-comparing-alphabet-arrays-beats-99",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        List<String> list = new ArrayList<>();\\n        int[] prev = new int[26];\\n        for(String word: words) {\\n            int[] curr = new int[26];\\n            for(char ch: word.toCharArray()) curr[ch - \\'a\\']++;\\n            if(list.isEmpty()|| !Arrays.equals(curr, prev)) {\\n                list.add(word);\\n                prev = curr;\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        List<String> list = new ArrayList<>();\\n        int[] prev = new int[26];\\n        for(String word: words) {\\n            int[] curr = new int[26];\\n            for(char ch: word.toCharArray()) curr[ch - \\'a\\']++;\\n            if(list.isEmpty()|| !Arrays.equals(curr, prev)) {\\n                list.add(word);\\n                prev = curr;\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3758014,
                "title": "c-easy-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nexplained line by line in below code see\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        for(int i=1;i<words.size();i++)\\n        {\\n            string frst=words[i];\\n            sort(frst.begin(),frst.end());\\n            string scnd=words[i-1];\\n            sort(scnd.begin(),scnd.end());\\n            if(frst==scnd)\\n            {\\n                words.erase(words.begin()+i);\\n                i--;\\n            }\\n           \\n        }\\n        return words;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        for(int i=1;i<words.size();i++)\\n        {\\n            string frst=words[i];\\n            sort(frst.begin(),frst.end());\\n            string scnd=words[i-1];\\n            sort(scnd.begin(),scnd.end());\\n            if(frst==scnd)\\n            {\\n                words.erase(words.begin()+i);\\n                i--;\\n            }\\n           \\n        }\\n        return words;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3754616,
                "title": "brute-force",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBrute Force\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBrute Force, use for loops\\n\\n# Complexity\\n- Time complexity: O(len(words) * len(words[i]))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n**        #mark elements to be removed**\\n        mark_idx = [0] * len(words)\\n\\n**        #itr through the list, mark**\\n        for i in range(len(words) - 1):\\n            my_array = [0] * 26\\n            for j in range(len(words[i])):\\n                my_array[ord(words[i][j]) - 97] += 1\\n            comp_array = [0] * 26\\n            for l in range(len(words[i+1])):\\n                comp_array[ord(words[i+1][l]) - 97] += 1\\n            if all(elt1 == elt2 for elt1, elt2 in zip(my_array, comp_array)):\\n                mark_idx[i+1] = 1\\n\\n**        #list to return**\\n        return_array = []\\n        for i in range(len(words)):\\n            if (mark_idx[i] == 0):\\n                return_array.append(words[i])\\n        return return_array\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n**        #mark elements to be removed**\\n        mark_idx = [0] * len(words)\\n\\n**        #itr through the list, mark**\\n        for i in range(len(words) - 1):\\n            my_array = [0] * 26\\n            for j in range(len(words[i])):\\n                my_array[ord(words[i][j]) - 97] += 1\\n            comp_array = [0] * 26\\n            for l in range(len(words[i+1])):\\n                comp_array[ord(words[i+1][l]) - 97] += 1\\n            if all(elt1 == elt2 for elt1, elt2 in zip(my_array, comp_array)):\\n                mark_idx[i+1] = 1\\n\\n**        #list to return**\\n        return_array = []\\n        for i in range(len(words)):\\n            if (mark_idx[i] == 0):\\n                return_array.append(words[i])\\n        return return_array\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3741761,
                "title": "two-pointers-erase-not-reqd-c-easy",
                "content": "# Intuition\\nTwo Pointers without using erase function\\n\\n# Complexity\\n- Time complexity:\\nO(nklogk)  (k is the max length of string)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        int n=words.size();\\n        vector<string> ans;\\n        // ans.push_back(words[0]);\\n        int prev=0,i=1;\\n        if(n==1)\\n            return words;\\n        while(i<n)\\n        {\\n            while(i<n && isanagram(words[i],words[prev]))\\n            {\\n                i++;\\n            }\\n            ans.push_back(words[prev]);\\n            if(i==n-1)\\n                ans.push_back(words[i]);\\n            prev=i;\\n            i++;\\n        }\\n        return ans;\\n    }\\n   bool isanagram(string a,string b)\\n   {\\n       if(a.length()!=b.length())\\n        return false;\\n        sort(a.begin(),a.end());\\n        sort(b.begin(),b.end());\\n        if(a==b)\\n            return true;\\n        return false;\\n   }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        int n=words.size();\\n        vector<string> ans;\\n        // ans.push_back(words[0]);\\n        int prev=0,i=1;\\n        if(n==1)\\n            return words;\\n        while(i<n)\\n        {\\n            while(i<n && isanagram(words[i],words[prev]))\\n            {\\n                i++;\\n            }\\n            ans.push_back(words[prev]);\\n            if(i==n-1)\\n                ans.push_back(words[i]);\\n            prev=i;\\n            i++;\\n        }\\n        return ans;\\n    }\\n   bool isanagram(string a,string b)\\n   {\\n       if(a.length()!=b.length())\\n        return false;\\n        sort(a.begin(),a.end());\\n        sort(b.begin(),b.end());\\n        if(a==b)\\n            return true;\\n        return false;\\n   }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3740806,
                "title": "remove-anagrams-js-intuitive-92",
                "content": "1. Solution simple but slow ( double sorting ) - Beats 26.5 %\\n```\\n/**\\n * @param {string[]} words\\n * @return {string[]}\\n */\\nvar removeAnagrams = function(words) {\\n    \\n    for (let i = 1; i < words.length; i++) {\\n        if (anagram(words[i-1], words[i])) {\\n            words.splice(i, 1), i--\\n        }\\n    }\\n\\n    function anagram(str1, str2) {\\n        if (str1.length != str2.length) return false\\n        return str1.split(\\'\\').sort().join() == str2.split(\\'\\').sort().join()\\n    }\\n\\n    return words\\n};\\n```\\n2. Solution 2x times faster ( once sort every words[i] ) - Beats 92.37 %\\n```\\n/**\\n * @param {string[]} words\\n * @return {string[]}\\n */\\nvar removeAnagrams = function(words) {\\n    prev = \\'\\'\\n\\n    for (let i = 0; i < words.length; i++) {\\n        str = words[i].split(\\'\\').sort().join(\\'\\')\\n        str == prev && words.splice(i, 1) && i--\\n        prev = str\\n    }\\n\\n    return words\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @return {string[]}\\n */\\nvar removeAnagrams = function(words) {\\n    \\n    for (let i = 1; i < words.length; i++) {\\n        if (anagram(words[i-1], words[i])) {\\n            words.splice(i, 1), i--\\n        }\\n    }\\n\\n    function anagram(str1, str2) {\\n        if (str1.length != str2.length) return false\\n        return str1.split(\\'\\').sort().join() == str2.split(\\'\\').sort().join()\\n    }\\n\\n    return words\\n};\\n```\n```\\n/**\\n * @param {string[]} words\\n * @return {string[]}\\n */\\nvar removeAnagrams = function(words) {\\n    prev = \\'\\'\\n\\n    for (let i = 0; i < words.length; i++) {\\n        str = words[i].split(\\'\\').sort().join(\\'\\')\\n        str == prev && words.splice(i, 1) && i--\\n        prev = str\\n    }\\n\\n    return words\\n};\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1683714,
                "content": [
                    {
                        "username": "Sudha_S",
                        "content": "words = [\"a\", \"b\", \"a\"]\\nOutput  = [\"a\", \"b\"]\\nExpected = [\"a\", \"b\", \"a\"]\\n\\nTestcase 167 is wrong. Please look into it. "
                    },
                    {
                        "username": "wyldbill",
                        "content": "Actually, I\\'m going to revise my statement. The problem statement says:\\n\"In one operation, select any index i such that 0 < i < words.length and words[i - 1] and words[i] are anagrams, and delete words[i] from words\"\\n\\nEssentially we are supposed to remove _consecutive_ anagrams, not all anagrams present. It\\'d be nice if the problem was stated and/or named that way. If that is correct, then this test case is correct."
                    },
                    {
                        "username": "wyldbill",
                        "content": "Yup. \\nActually got a passing submission until I read this comment, then re-implemented exactly as specified in the problem statement....."
                    },
                    {
                        "username": "speeep",
                        "content": "So true"
                    },
                    {
                        "username": "heg816",
                        "content": "Please change title to \"Find Resultant Array After Removing Consecutive Anagrams\" or include example testcase that demonstates this-- it seems easy to miss this detail."
                    },
                    {
                        "username": "Ber40",
                        "content": "words =[\"ab\",\"bc\",\"cb\",\"ab\",\"bc\"]\\nOutput = [\"ab\",\"bc\"]\\nExpected = [\"ab\",\"bc\",\"ab\",\"bc\"]\\n\\nTestcase 195 is wrong. "
                    },
                    {
                        "username": "user2285TI",
                        "content": "Problem statement specifies that when two adjacent words are anagrams, the later one in the list should be deleted. What you are doing here is deleting all later cases of anagrams and not just from adjacent pairs.  "
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Tip :\\nFor every index i, find the largest index j < i such that words[j] will be present in the final answer.\\nCheck if words[i] and words[j] are anagrams. If they are, then it can be confirmed that words[i] will not be present in the final answer.\\n"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "For those whose test case fails at : \\nwords = [\"a\", \"b\", \"a\"]\\nOutput = [\"a\", \"b\"]\\nExpected = [\"a\", \"b\", \"a\"]\\nRead question statement carefully, we have to delete adjacent anagrams, not all possible anagrams from vector.\\n\\nIn one operation, select any index i such that 0 < i < words.length and words[i - 1] and words[i] are anagrams, and delete words[i] from words."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "````\\n[\"z\",\"z\",\"z\",\"gsw\",\"wsg\",\"gsw\",\"krptu\"]\\noutput - [\"gsw\",\"krptu\",\"z\"]\\nexpected - [\"z\",\"gsw\",\"krptu\"]\\n````\\nWhy my ans is wrong?"
                    },
                    {
                        "username": "sarthak6596",
                        "content": "what should be the ouput for this one:\\ninput:\\n[\"az\",\"azz\"]\\noutput:\\n[\"az\"]\\nexpected:\\n[\"az\",\"azz\"]"
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "\"azz\" and \"az\" are not anagrams since they dont have the same number of alphabets in the first place. \"za\" is an anagram for \"az\" or \"zaz\" is an anagram for \"azz\" but the two arent anagrams to each other "
                    },
                    {
                        "username": "topswe",
                        "content": "You want the first unique anagrams in some consecutive sequence of anagrams."
                    }
                ]
            },
            {
                "id": 1786585,
                "content": [
                    {
                        "username": "Sudha_S",
                        "content": "words = [\"a\", \"b\", \"a\"]\\nOutput  = [\"a\", \"b\"]\\nExpected = [\"a\", \"b\", \"a\"]\\n\\nTestcase 167 is wrong. Please look into it. "
                    },
                    {
                        "username": "wyldbill",
                        "content": "Actually, I\\'m going to revise my statement. The problem statement says:\\n\"In one operation, select any index i such that 0 < i < words.length and words[i - 1] and words[i] are anagrams, and delete words[i] from words\"\\n\\nEssentially we are supposed to remove _consecutive_ anagrams, not all anagrams present. It\\'d be nice if the problem was stated and/or named that way. If that is correct, then this test case is correct."
                    },
                    {
                        "username": "wyldbill",
                        "content": "Yup. \\nActually got a passing submission until I read this comment, then re-implemented exactly as specified in the problem statement....."
                    },
                    {
                        "username": "speeep",
                        "content": "So true"
                    },
                    {
                        "username": "heg816",
                        "content": "Please change title to \"Find Resultant Array After Removing Consecutive Anagrams\" or include example testcase that demonstates this-- it seems easy to miss this detail."
                    },
                    {
                        "username": "Ber40",
                        "content": "words =[\"ab\",\"bc\",\"cb\",\"ab\",\"bc\"]\\nOutput = [\"ab\",\"bc\"]\\nExpected = [\"ab\",\"bc\",\"ab\",\"bc\"]\\n\\nTestcase 195 is wrong. "
                    },
                    {
                        "username": "user2285TI",
                        "content": "Problem statement specifies that when two adjacent words are anagrams, the later one in the list should be deleted. What you are doing here is deleting all later cases of anagrams and not just from adjacent pairs.  "
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Tip :\\nFor every index i, find the largest index j < i such that words[j] will be present in the final answer.\\nCheck if words[i] and words[j] are anagrams. If they are, then it can be confirmed that words[i] will not be present in the final answer.\\n"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "For those whose test case fails at : \\nwords = [\"a\", \"b\", \"a\"]\\nOutput = [\"a\", \"b\"]\\nExpected = [\"a\", \"b\", \"a\"]\\nRead question statement carefully, we have to delete adjacent anagrams, not all possible anagrams from vector.\\n\\nIn one operation, select any index i such that 0 < i < words.length and words[i - 1] and words[i] are anagrams, and delete words[i] from words."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "````\\n[\"z\",\"z\",\"z\",\"gsw\",\"wsg\",\"gsw\",\"krptu\"]\\noutput - [\"gsw\",\"krptu\",\"z\"]\\nexpected - [\"z\",\"gsw\",\"krptu\"]\\n````\\nWhy my ans is wrong?"
                    },
                    {
                        "username": "sarthak6596",
                        "content": "what should be the ouput for this one:\\ninput:\\n[\"az\",\"azz\"]\\noutput:\\n[\"az\"]\\nexpected:\\n[\"az\",\"azz\"]"
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "\"azz\" and \"az\" are not anagrams since they dont have the same number of alphabets in the first place. \"za\" is an anagram for \"az\" or \"zaz\" is an anagram for \"azz\" but the two arent anagrams to each other "
                    },
                    {
                        "username": "topswe",
                        "content": "You want the first unique anagrams in some consecutive sequence of anagrams."
                    }
                ]
            },
            {
                "id": 1714798,
                "content": [
                    {
                        "username": "Sudha_S",
                        "content": "words = [\"a\", \"b\", \"a\"]\\nOutput  = [\"a\", \"b\"]\\nExpected = [\"a\", \"b\", \"a\"]\\n\\nTestcase 167 is wrong. Please look into it. "
                    },
                    {
                        "username": "wyldbill",
                        "content": "Actually, I\\'m going to revise my statement. The problem statement says:\\n\"In one operation, select any index i such that 0 < i < words.length and words[i - 1] and words[i] are anagrams, and delete words[i] from words\"\\n\\nEssentially we are supposed to remove _consecutive_ anagrams, not all anagrams present. It\\'d be nice if the problem was stated and/or named that way. If that is correct, then this test case is correct."
                    },
                    {
                        "username": "wyldbill",
                        "content": "Yup. \\nActually got a passing submission until I read this comment, then re-implemented exactly as specified in the problem statement....."
                    },
                    {
                        "username": "speeep",
                        "content": "So true"
                    },
                    {
                        "username": "heg816",
                        "content": "Please change title to \"Find Resultant Array After Removing Consecutive Anagrams\" or include example testcase that demonstates this-- it seems easy to miss this detail."
                    },
                    {
                        "username": "Ber40",
                        "content": "words =[\"ab\",\"bc\",\"cb\",\"ab\",\"bc\"]\\nOutput = [\"ab\",\"bc\"]\\nExpected = [\"ab\",\"bc\",\"ab\",\"bc\"]\\n\\nTestcase 195 is wrong. "
                    },
                    {
                        "username": "user2285TI",
                        "content": "Problem statement specifies that when two adjacent words are anagrams, the later one in the list should be deleted. What you are doing here is deleting all later cases of anagrams and not just from adjacent pairs.  "
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Tip :\\nFor every index i, find the largest index j < i such that words[j] will be present in the final answer.\\nCheck if words[i] and words[j] are anagrams. If they are, then it can be confirmed that words[i] will not be present in the final answer.\\n"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "For those whose test case fails at : \\nwords = [\"a\", \"b\", \"a\"]\\nOutput = [\"a\", \"b\"]\\nExpected = [\"a\", \"b\", \"a\"]\\nRead question statement carefully, we have to delete adjacent anagrams, not all possible anagrams from vector.\\n\\nIn one operation, select any index i such that 0 < i < words.length and words[i - 1] and words[i] are anagrams, and delete words[i] from words."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "````\\n[\"z\",\"z\",\"z\",\"gsw\",\"wsg\",\"gsw\",\"krptu\"]\\noutput - [\"gsw\",\"krptu\",\"z\"]\\nexpected - [\"z\",\"gsw\",\"krptu\"]\\n````\\nWhy my ans is wrong?"
                    },
                    {
                        "username": "sarthak6596",
                        "content": "what should be the ouput for this one:\\ninput:\\n[\"az\",\"azz\"]\\noutput:\\n[\"az\"]\\nexpected:\\n[\"az\",\"azz\"]"
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "\"azz\" and \"az\" are not anagrams since they dont have the same number of alphabets in the first place. \"za\" is an anagram for \"az\" or \"zaz\" is an anagram for \"azz\" but the two arent anagrams to each other "
                    },
                    {
                        "username": "topswe",
                        "content": "You want the first unique anagrams in some consecutive sequence of anagrams."
                    }
                ]
            },
            {
                "id": 2036581,
                "content": [
                    {
                        "username": "Sudha_S",
                        "content": "words = [\"a\", \"b\", \"a\"]\\nOutput  = [\"a\", \"b\"]\\nExpected = [\"a\", \"b\", \"a\"]\\n\\nTestcase 167 is wrong. Please look into it. "
                    },
                    {
                        "username": "wyldbill",
                        "content": "Actually, I\\'m going to revise my statement. The problem statement says:\\n\"In one operation, select any index i such that 0 < i < words.length and words[i - 1] and words[i] are anagrams, and delete words[i] from words\"\\n\\nEssentially we are supposed to remove _consecutive_ anagrams, not all anagrams present. It\\'d be nice if the problem was stated and/or named that way. If that is correct, then this test case is correct."
                    },
                    {
                        "username": "wyldbill",
                        "content": "Yup. \\nActually got a passing submission until I read this comment, then re-implemented exactly as specified in the problem statement....."
                    },
                    {
                        "username": "speeep",
                        "content": "So true"
                    },
                    {
                        "username": "heg816",
                        "content": "Please change title to \"Find Resultant Array After Removing Consecutive Anagrams\" or include example testcase that demonstates this-- it seems easy to miss this detail."
                    },
                    {
                        "username": "Ber40",
                        "content": "words =[\"ab\",\"bc\",\"cb\",\"ab\",\"bc\"]\\nOutput = [\"ab\",\"bc\"]\\nExpected = [\"ab\",\"bc\",\"ab\",\"bc\"]\\n\\nTestcase 195 is wrong. "
                    },
                    {
                        "username": "user2285TI",
                        "content": "Problem statement specifies that when two adjacent words are anagrams, the later one in the list should be deleted. What you are doing here is deleting all later cases of anagrams and not just from adjacent pairs.  "
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Tip :\\nFor every index i, find the largest index j < i such that words[j] will be present in the final answer.\\nCheck if words[i] and words[j] are anagrams. If they are, then it can be confirmed that words[i] will not be present in the final answer.\\n"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "For those whose test case fails at : \\nwords = [\"a\", \"b\", \"a\"]\\nOutput = [\"a\", \"b\"]\\nExpected = [\"a\", \"b\", \"a\"]\\nRead question statement carefully, we have to delete adjacent anagrams, not all possible anagrams from vector.\\n\\nIn one operation, select any index i such that 0 < i < words.length and words[i - 1] and words[i] are anagrams, and delete words[i] from words."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "````\\n[\"z\",\"z\",\"z\",\"gsw\",\"wsg\",\"gsw\",\"krptu\"]\\noutput - [\"gsw\",\"krptu\",\"z\"]\\nexpected - [\"z\",\"gsw\",\"krptu\"]\\n````\\nWhy my ans is wrong?"
                    },
                    {
                        "username": "sarthak6596",
                        "content": "what should be the ouput for this one:\\ninput:\\n[\"az\",\"azz\"]\\noutput:\\n[\"az\"]\\nexpected:\\n[\"az\",\"azz\"]"
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "\"azz\" and \"az\" are not anagrams since they dont have the same number of alphabets in the first place. \"za\" is an anagram for \"az\" or \"zaz\" is an anagram for \"azz\" but the two arent anagrams to each other "
                    },
                    {
                        "username": "topswe",
                        "content": "You want the first unique anagrams in some consecutive sequence of anagrams."
                    }
                ]
            },
            {
                "id": 2016048,
                "content": [
                    {
                        "username": "Sudha_S",
                        "content": "words = [\"a\", \"b\", \"a\"]\\nOutput  = [\"a\", \"b\"]\\nExpected = [\"a\", \"b\", \"a\"]\\n\\nTestcase 167 is wrong. Please look into it. "
                    },
                    {
                        "username": "wyldbill",
                        "content": "Actually, I\\'m going to revise my statement. The problem statement says:\\n\"In one operation, select any index i such that 0 < i < words.length and words[i - 1] and words[i] are anagrams, and delete words[i] from words\"\\n\\nEssentially we are supposed to remove _consecutive_ anagrams, not all anagrams present. It\\'d be nice if the problem was stated and/or named that way. If that is correct, then this test case is correct."
                    },
                    {
                        "username": "wyldbill",
                        "content": "Yup. \\nActually got a passing submission until I read this comment, then re-implemented exactly as specified in the problem statement....."
                    },
                    {
                        "username": "speeep",
                        "content": "So true"
                    },
                    {
                        "username": "heg816",
                        "content": "Please change title to \"Find Resultant Array After Removing Consecutive Anagrams\" or include example testcase that demonstates this-- it seems easy to miss this detail."
                    },
                    {
                        "username": "Ber40",
                        "content": "words =[\"ab\",\"bc\",\"cb\",\"ab\",\"bc\"]\\nOutput = [\"ab\",\"bc\"]\\nExpected = [\"ab\",\"bc\",\"ab\",\"bc\"]\\n\\nTestcase 195 is wrong. "
                    },
                    {
                        "username": "user2285TI",
                        "content": "Problem statement specifies that when two adjacent words are anagrams, the later one in the list should be deleted. What you are doing here is deleting all later cases of anagrams and not just from adjacent pairs.  "
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Tip :\\nFor every index i, find the largest index j < i such that words[j] will be present in the final answer.\\nCheck if words[i] and words[j] are anagrams. If they are, then it can be confirmed that words[i] will not be present in the final answer.\\n"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "For those whose test case fails at : \\nwords = [\"a\", \"b\", \"a\"]\\nOutput = [\"a\", \"b\"]\\nExpected = [\"a\", \"b\", \"a\"]\\nRead question statement carefully, we have to delete adjacent anagrams, not all possible anagrams from vector.\\n\\nIn one operation, select any index i such that 0 < i < words.length and words[i - 1] and words[i] are anagrams, and delete words[i] from words."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "````\\n[\"z\",\"z\",\"z\",\"gsw\",\"wsg\",\"gsw\",\"krptu\"]\\noutput - [\"gsw\",\"krptu\",\"z\"]\\nexpected - [\"z\",\"gsw\",\"krptu\"]\\n````\\nWhy my ans is wrong?"
                    },
                    {
                        "username": "sarthak6596",
                        "content": "what should be the ouput for this one:\\ninput:\\n[\"az\",\"azz\"]\\noutput:\\n[\"az\"]\\nexpected:\\n[\"az\",\"azz\"]"
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "\"azz\" and \"az\" are not anagrams since they dont have the same number of alphabets in the first place. \"za\" is an anagram for \"az\" or \"zaz\" is an anagram for \"azz\" but the two arent anagrams to each other "
                    },
                    {
                        "username": "topswe",
                        "content": "You want the first unique anagrams in some consecutive sequence of anagrams."
                    }
                ]
            },
            {
                "id": 2005525,
                "content": [
                    {
                        "username": "Sudha_S",
                        "content": "words = [\"a\", \"b\", \"a\"]\\nOutput  = [\"a\", \"b\"]\\nExpected = [\"a\", \"b\", \"a\"]\\n\\nTestcase 167 is wrong. Please look into it. "
                    },
                    {
                        "username": "wyldbill",
                        "content": "Actually, I\\'m going to revise my statement. The problem statement says:\\n\"In one operation, select any index i such that 0 < i < words.length and words[i - 1] and words[i] are anagrams, and delete words[i] from words\"\\n\\nEssentially we are supposed to remove _consecutive_ anagrams, not all anagrams present. It\\'d be nice if the problem was stated and/or named that way. If that is correct, then this test case is correct."
                    },
                    {
                        "username": "wyldbill",
                        "content": "Yup. \\nActually got a passing submission until I read this comment, then re-implemented exactly as specified in the problem statement....."
                    },
                    {
                        "username": "speeep",
                        "content": "So true"
                    },
                    {
                        "username": "heg816",
                        "content": "Please change title to \"Find Resultant Array After Removing Consecutive Anagrams\" or include example testcase that demonstates this-- it seems easy to miss this detail."
                    },
                    {
                        "username": "Ber40",
                        "content": "words =[\"ab\",\"bc\",\"cb\",\"ab\",\"bc\"]\\nOutput = [\"ab\",\"bc\"]\\nExpected = [\"ab\",\"bc\",\"ab\",\"bc\"]\\n\\nTestcase 195 is wrong. "
                    },
                    {
                        "username": "user2285TI",
                        "content": "Problem statement specifies that when two adjacent words are anagrams, the later one in the list should be deleted. What you are doing here is deleting all later cases of anagrams and not just from adjacent pairs.  "
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Tip :\\nFor every index i, find the largest index j < i such that words[j] will be present in the final answer.\\nCheck if words[i] and words[j] are anagrams. If they are, then it can be confirmed that words[i] will not be present in the final answer.\\n"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "For those whose test case fails at : \\nwords = [\"a\", \"b\", \"a\"]\\nOutput = [\"a\", \"b\"]\\nExpected = [\"a\", \"b\", \"a\"]\\nRead question statement carefully, we have to delete adjacent anagrams, not all possible anagrams from vector.\\n\\nIn one operation, select any index i such that 0 < i < words.length and words[i - 1] and words[i] are anagrams, and delete words[i] from words."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "````\\n[\"z\",\"z\",\"z\",\"gsw\",\"wsg\",\"gsw\",\"krptu\"]\\noutput - [\"gsw\",\"krptu\",\"z\"]\\nexpected - [\"z\",\"gsw\",\"krptu\"]\\n````\\nWhy my ans is wrong?"
                    },
                    {
                        "username": "sarthak6596",
                        "content": "what should be the ouput for this one:\\ninput:\\n[\"az\",\"azz\"]\\noutput:\\n[\"az\"]\\nexpected:\\n[\"az\",\"azz\"]"
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "\"azz\" and \"az\" are not anagrams since they dont have the same number of alphabets in the first place. \"za\" is an anagram for \"az\" or \"zaz\" is an anagram for \"azz\" but the two arent anagrams to each other "
                    },
                    {
                        "username": "topswe",
                        "content": "You want the first unique anagrams in some consecutive sequence of anagrams."
                    }
                ]
            },
            {
                "id": 1828179,
                "content": [
                    {
                        "username": "Sudha_S",
                        "content": "words = [\"a\", \"b\", \"a\"]\\nOutput  = [\"a\", \"b\"]\\nExpected = [\"a\", \"b\", \"a\"]\\n\\nTestcase 167 is wrong. Please look into it. "
                    },
                    {
                        "username": "wyldbill",
                        "content": "Actually, I\\'m going to revise my statement. The problem statement says:\\n\"In one operation, select any index i such that 0 < i < words.length and words[i - 1] and words[i] are anagrams, and delete words[i] from words\"\\n\\nEssentially we are supposed to remove _consecutive_ anagrams, not all anagrams present. It\\'d be nice if the problem was stated and/or named that way. If that is correct, then this test case is correct."
                    },
                    {
                        "username": "wyldbill",
                        "content": "Yup. \\nActually got a passing submission until I read this comment, then re-implemented exactly as specified in the problem statement....."
                    },
                    {
                        "username": "speeep",
                        "content": "So true"
                    },
                    {
                        "username": "heg816",
                        "content": "Please change title to \"Find Resultant Array After Removing Consecutive Anagrams\" or include example testcase that demonstates this-- it seems easy to miss this detail."
                    },
                    {
                        "username": "Ber40",
                        "content": "words =[\"ab\",\"bc\",\"cb\",\"ab\",\"bc\"]\\nOutput = [\"ab\",\"bc\"]\\nExpected = [\"ab\",\"bc\",\"ab\",\"bc\"]\\n\\nTestcase 195 is wrong. "
                    },
                    {
                        "username": "user2285TI",
                        "content": "Problem statement specifies that when two adjacent words are anagrams, the later one in the list should be deleted. What you are doing here is deleting all later cases of anagrams and not just from adjacent pairs.  "
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Tip :\\nFor every index i, find the largest index j < i such that words[j] will be present in the final answer.\\nCheck if words[i] and words[j] are anagrams. If they are, then it can be confirmed that words[i] will not be present in the final answer.\\n"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "For those whose test case fails at : \\nwords = [\"a\", \"b\", \"a\"]\\nOutput = [\"a\", \"b\"]\\nExpected = [\"a\", \"b\", \"a\"]\\nRead question statement carefully, we have to delete adjacent anagrams, not all possible anagrams from vector.\\n\\nIn one operation, select any index i such that 0 < i < words.length and words[i - 1] and words[i] are anagrams, and delete words[i] from words."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "````\\n[\"z\",\"z\",\"z\",\"gsw\",\"wsg\",\"gsw\",\"krptu\"]\\noutput - [\"gsw\",\"krptu\",\"z\"]\\nexpected - [\"z\",\"gsw\",\"krptu\"]\\n````\\nWhy my ans is wrong?"
                    },
                    {
                        "username": "sarthak6596",
                        "content": "what should be the ouput for this one:\\ninput:\\n[\"az\",\"azz\"]\\noutput:\\n[\"az\"]\\nexpected:\\n[\"az\",\"azz\"]"
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "\"azz\" and \"az\" are not anagrams since they dont have the same number of alphabets in the first place. \"za\" is an anagram for \"az\" or \"zaz\" is an anagram for \"azz\" but the two arent anagrams to each other "
                    },
                    {
                        "username": "topswe",
                        "content": "You want the first unique anagrams in some consecutive sequence of anagrams."
                    }
                ]
            },
            {
                "id": 1721292,
                "content": [
                    {
                        "username": "Sudha_S",
                        "content": "words = [\"a\", \"b\", \"a\"]\\nOutput  = [\"a\", \"b\"]\\nExpected = [\"a\", \"b\", \"a\"]\\n\\nTestcase 167 is wrong. Please look into it. "
                    },
                    {
                        "username": "wyldbill",
                        "content": "Actually, I\\'m going to revise my statement. The problem statement says:\\n\"In one operation, select any index i such that 0 < i < words.length and words[i - 1] and words[i] are anagrams, and delete words[i] from words\"\\n\\nEssentially we are supposed to remove _consecutive_ anagrams, not all anagrams present. It\\'d be nice if the problem was stated and/or named that way. If that is correct, then this test case is correct."
                    },
                    {
                        "username": "wyldbill",
                        "content": "Yup. \\nActually got a passing submission until I read this comment, then re-implemented exactly as specified in the problem statement....."
                    },
                    {
                        "username": "speeep",
                        "content": "So true"
                    },
                    {
                        "username": "heg816",
                        "content": "Please change title to \"Find Resultant Array After Removing Consecutive Anagrams\" or include example testcase that demonstates this-- it seems easy to miss this detail."
                    },
                    {
                        "username": "Ber40",
                        "content": "words =[\"ab\",\"bc\",\"cb\",\"ab\",\"bc\"]\\nOutput = [\"ab\",\"bc\"]\\nExpected = [\"ab\",\"bc\",\"ab\",\"bc\"]\\n\\nTestcase 195 is wrong. "
                    },
                    {
                        "username": "user2285TI",
                        "content": "Problem statement specifies that when two adjacent words are anagrams, the later one in the list should be deleted. What you are doing here is deleting all later cases of anagrams and not just from adjacent pairs.  "
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Tip :\\nFor every index i, find the largest index j < i such that words[j] will be present in the final answer.\\nCheck if words[i] and words[j] are anagrams. If they are, then it can be confirmed that words[i] will not be present in the final answer.\\n"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "For those whose test case fails at : \\nwords = [\"a\", \"b\", \"a\"]\\nOutput = [\"a\", \"b\"]\\nExpected = [\"a\", \"b\", \"a\"]\\nRead question statement carefully, we have to delete adjacent anagrams, not all possible anagrams from vector.\\n\\nIn one operation, select any index i such that 0 < i < words.length and words[i - 1] and words[i] are anagrams, and delete words[i] from words."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "````\\n[\"z\",\"z\",\"z\",\"gsw\",\"wsg\",\"gsw\",\"krptu\"]\\noutput - [\"gsw\",\"krptu\",\"z\"]\\nexpected - [\"z\",\"gsw\",\"krptu\"]\\n````\\nWhy my ans is wrong?"
                    },
                    {
                        "username": "sarthak6596",
                        "content": "what should be the ouput for this one:\\ninput:\\n[\"az\",\"azz\"]\\noutput:\\n[\"az\"]\\nexpected:\\n[\"az\",\"azz\"]"
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "\"azz\" and \"az\" are not anagrams since they dont have the same number of alphabets in the first place. \"za\" is an anagram for \"az\" or \"zaz\" is an anagram for \"azz\" but the two arent anagrams to each other "
                    },
                    {
                        "username": "topswe",
                        "content": "You want the first unique anagrams in some consecutive sequence of anagrams."
                    }
                ]
            }
        ]
    },
    {
        "title": "Partition Array Such That Maximum Difference Is K",
        "question_content": "<p>You are given an integer array <code>nums</code> and an integer <code>k</code>. You may partition <code>nums</code> into one or more <strong>subsequences</strong> such that each element in <code>nums</code> appears in <strong>exactly</strong> one of the subsequences.</p>\n\n<p>Return <em>the <strong>minimum </strong>number of subsequences needed such that the difference between the maximum and minimum values in each subsequence is <strong>at most</strong> </em><code>k</code><em>.</em></p>\n\n<p>A <strong>subsequence</strong> is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [3,6,1,2,5], k = 2\n<strong>Output:</strong> 2\n<strong>Explanation:</strong>\nWe can partition nums into the two subsequences [3,1,2] and [6,5].\nThe difference between the maximum and minimum value in the first subsequence is 3 - 1 = 2.\nThe difference between the maximum and minimum value in the second subsequence is 6 - 5 = 1.\nSince two subsequences were created, we return 2. It can be shown that 2 is the minimum number of subsequences needed.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3], k = 1\n<strong>Output:</strong> 2\n<strong>Explanation:</strong>\nWe can partition nums into the two subsequences [1,2] and [3].\nThe difference between the maximum and minimum value in the first subsequence is 2 - 1 = 1.\nThe difference between the maximum and minimum value in the second subsequence is 3 - 3 = 0.\nSince two subsequences were created, we return 2. Note that another optimal solution is to partition nums into the two subsequences [1] and [2,3].\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,2,4,5], k = 0\n<strong>Output:</strong> 3\n<strong>Explanation:</strong>\nWe can partition nums into the three subsequences [2,2], [4], and [5].\nThe difference between the maximum and minimum value in the first subsequences is 2 - 2 = 0.\nThe difference between the maximum and minimum value in the second subsequences is 4 - 4 = 0.\nThe difference between the maximum and minimum value in the third subsequences is 5 - 5 = 0.\nSince three subsequences were created, we return 3. It can be shown that 3 is the minimum number of subsequences needed.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= k &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 2112243,
                "title": "java-c-python-sort-greedy",
                "content": "# **Explanation**\\n`mn` means the minimum number in the current sequence.\\n`mx` means the maximum number in the current sequence.\\n\\nIterate each element `A[i]` in the input array,\\nand we try to add it into the current subsequence.\\n\\nWe need to check if the differnce is still good.\\nSo we firstly update the value of  `mn` and `mx`\\n`mn = min(mn, a)`\\n`mx = max(mx, a)`.\\n\\n\\nIf `mx - mn > k`,\\nthis means the difference between the maximum and minimum values,\\nis bigger than `k`  in current subsequence,\\n\\n`A[i]` cannot be added to the subsequence,\\nso we start a new subsequence with `A[i]` as the first element,\\nthus increment `res` and update `mn = mx = a`.\\n\\nWe continue doing this process and finally return result `res`.\\n\\nThen I notice it\\'s subsequences instead of subarray,\\nI added a sort at the beginning.....\\n<br>\\n\\n# **Complexity**\\nTime `O(sort)`\\nSpace `O(sort)`\\n<br>\\n\\n**Java**\\n```java\\n    public int partitionArray(int[] A, int k) {\\n        Arrays.sort(A);\\n        int res = 1, mn = A[0], mx = A[0];\\n        for (int a: A) {\\n            mn = Math.min(mn, a);\\n            mx = Math.max(mx, a);\\n            if (mx - mn > k) {\\n                res++;\\n                mn = mx = a;\\n            }\\n        }\\n        return res;\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    int partitionArray(vector<int>& A, int k) {\\n        sort(A.begin(), A.end());\\n        int res = 1, mn = A[0], mx = A[0];\\n        for (int& a: A) {\\n            mn = min(mn, a);\\n            mx = max(mx, a);\\n            if (mx - mn > k) {\\n                res++;\\n                mn = mx = a;\\n            }\\n        }\\n        return res;\\n    }\\n```\\n\\n**Python**\\n```py\\n    def partitionArray(self, A, k):\\n        A.sort()\\n        res = 1\\n        mn = mx = A[0]\\n        for a in A:\\n            mn = min(mn, a)\\n            mx = max(mx, a)\\n            if mx - mn > k:\\n                res += 1\\n                mn = mx = a\\n        return res\\n```\\n\\n# Solution II\\n**Java**\\n```java\\n    public int partitionArray(int[] A, int k) {\\n        Arrays.sort(A);\\n        int res = 1, n = A.length, j = 0;\\n        for (int i = 1; i < n; ++i) {\\n            if (A[i] - A[j] > k) {\\n                res++;\\n                j = i;\\n            }\\n        }\\n        return res;\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    int partitionArray(vector<int>& A, int k) {\\n        sort(A.begin(), A.end());\\n        int res = 1, n = A.size(), j = 0;\\n        for (int i = 1; i < n; ++i) {\\n            if (A[i] - A[j] > k) {\\n                res++;\\n                j = i;\\n            }\\n        }\\n        return res;\\n    }\\n```\\n**Python**\\n```py\\n    def partitionArray(self, A, k):\\n        A.sort()\\n        res, j = 1, 0\\n        for i in range(len(A)):\\n             if A[i] - A[j] > k:\\n                res += 1\\n                j = i\\n        return res\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public int partitionArray(int[] A, int k) {\\n        Arrays.sort(A);\\n        int res = 1, mn = A[0], mx = A[0];\\n        for (int a: A) {\\n            mn = Math.min(mn, a);\\n            mx = Math.max(mx, a);\\n            if (mx - mn > k) {\\n                res++;\\n                mn = mx = a;\\n            }\\n        }\\n        return res;\\n    }\\n```\n```cpp\\n    int partitionArray(vector<int>& A, int k) {\\n        sort(A.begin(), A.end());\\n        int res = 1, mn = A[0], mx = A[0];\\n        for (int& a: A) {\\n            mn = min(mn, a);\\n            mx = max(mx, a);\\n            if (mx - mn > k) {\\n                res++;\\n                mn = mx = a;\\n            }\\n        }\\n        return res;\\n    }\\n```\n```py\\n    def partitionArray(self, A, k):\\n        A.sort()\\n        res = 1\\n        mn = mx = A[0]\\n        for a in A:\\n            mn = min(mn, a)\\n            mx = max(mx, a)\\n            if mx - mn > k:\\n                res += 1\\n                mn = mx = a\\n        return res\\n```\n```java\\n    public int partitionArray(int[] A, int k) {\\n        Arrays.sort(A);\\n        int res = 1, n = A.length, j = 0;\\n        for (int i = 1; i < n; ++i) {\\n            if (A[i] - A[j] > k) {\\n                res++;\\n                j = i;\\n            }\\n        }\\n        return res;\\n    }\\n```\n```cpp\\n    int partitionArray(vector<int>& A, int k) {\\n        sort(A.begin(), A.end());\\n        int res = 1, n = A.size(), j = 0;\\n        for (int i = 1; i < n; ++i) {\\n            if (A[i] - A[j] > k) {\\n                res++;\\n                j = i;\\n            }\\n        }\\n        return res;\\n    }\\n```\n```py\\n    def partitionArray(self, A, k):\\n        A.sort()\\n        res, j = 1, 0\\n        for i in range(len(A)):\\n             if A[i] - A[j] > k:\\n                res += 1\\n                j = i\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2111862,
                "title": "sort-and-select",
                "content": "* Sort the array \\n* And select maximum gap of max element - min element\\n* If difference >= k then only increase answer and make start of another subsequence as ith element.\\n\\nTime - O(sort)\\n```\\nclass Solution {\\n\\n    public int partitionArray(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int c = 1, prev = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] - nums[prev] <= k) continue;\\n            c++; prev = i;\\n        }\\n        return c;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int partitionArray(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int c = 1, prev = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] - nums[prev] <= k) continue;\\n            c++; prev = i;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2111923,
                "title": "python-easy-solution-using-sorting",
                "content": "### Explanation:\\n\\nInitially I did think it as a DP problem because of the word \"**subsequence**\" and \"**minimum**\". But after analysing the array and output I realized we are more concerned about \"**at most difference should be K**\", and the at most difference is of min element and max element of subsequence, so what\\'s better than sorting? Sorting gives min and max element.\\n\\nYes, we are changing the order of elements but it wouldnt matter because we dont need to return the exact subsequences, we need to return the count of subsequences.\\n\\n**Example:**\\n\\n*before sort:*\\nnums -> [3, 6, 1, 2, 5]\\nsubsequences -> [3, 1, 2], [6, 5]\\noutput -> 2\\n\\n*after sort:*\\nnums -> [1, 2, 3, 5, 6]\\nsubsequences -> [1, 2, 3], [5, 6]\\noutput -> 2\\n\\nSo the order of elements would change but the elements inside each subsequence would remain same.\\n\\n\\n```\\nclass Solution:\\n    def partitionArray(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        ans = 1\\n\\t\\t# To keep track of starting element of each subsequence\\n        start = nums[0]\\n        \\n        for i in range(1, len(nums)):\\n            diff = nums[i] - start\\n            if diff > k:\\n\\t\\t\\t\\t# If difference of starting and current element of subsequence is greater\\n\\t\\t\\t\\t# than K, then only start new subsequence\\n                ans += 1\\n                start = nums[i]\\n        \\n        return ans",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "### Explanation:\\n\\nInitially I did think it as a DP problem because of the word \"**subsequence**\" and \"**minimum**\". But after analysing the array and output I realized we are more concerned about \"**at most difference should be K**\", and the at most difference is of min element and max element of subsequence, so what\\'s better than sorting? Sorting gives min and max element.\\n\\nYes, we are changing the order of elements but it wouldnt matter because we dont need to return the exact subsequences, we need to return the count of subsequences.\\n\\n**Example:**\\n\\n*before sort:*\\nnums -> [3, 6, 1, 2, 5]\\nsubsequences -> [3, 1, 2], [6, 5]\\noutput -> 2\\n\\n*after sort:*\\nnums -> [1, 2, 3, 5, 6]\\nsubsequences -> [1, 2, 3], [5, 6]\\noutput -> 2\\n\\nSo the order of elements would change but the elements inside each subsequence would remain same.\\n\\n\\n```\\nclass Solution:\\n    def partitionArray(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        ans = 1\\n\\t\\t# To keep track of starting element of each subsequence\\n        start = nums[0]\\n        \\n        for i in range(1, len(nums)):\\n            diff = nums[i] - start\\n            if diff > k:\\n\\t\\t\\t\\t# If difference of starting and current element of subsequence is greater\\n\\t\\t\\t\\t# than K, then only start new subsequence\\n                ans += 1\\n                start = nums[i]\\n        \\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 2112127,
                "title": "easy",
                "content": "**Here we only have to tell the number of subsequences and we can use an element only once that\\'s why we can sort the array.**\\n\\n```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        \\n        int n(size(nums)), res(0);\\n        sort(begin(nums), end(nums));\\n    \\n        for (int start=0, next=0; start<n;) {\\n            while (next<n and nums[next]-nums[start] <= k) next++;            \\n            start = next;\\n            res++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        \\n        int n(size(nums)), res(0);\\n        sort(begin(nums), end(nums));\\n    \\n        for (int start=0, next=0; start<n;) {\\n            while (next<n and nums[next]-nums[start] <= k) next++;            \\n            start = next;\\n            res++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112706,
                "title": "two-pointers",
                "content": "Sort, then use two pointers to track the current valid subsequence. Start a new subsequence if `nums[i]` cannot be added to the current one.\\n\\nAs the second pointer, we use the last element of the `subs` array. This could be handy if we need to identify subarrays in the end, for some reason.\\n\\n**C++**\\n```cpp\\nint partitionArray(vector<int>& nums, int k) {\\n    sort(begin(nums), end(nums));\\n    vector<int> subs{nums[0]};\\n    for (int i = 1; i < nums.size(); ++i)\\n        if (nums[i] - subs.back() > k)\\n            subs.push_back(nums[i]);\\n    return subs.size();\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint partitionArray(vector<int>& nums, int k) {\\n    sort(begin(nums), end(nums));\\n    vector<int> subs{nums[0]};\\n    for (int i = 1; i < nums.size(); ++i)\\n        if (nums[i] - subs.back() > k)\\n            subs.push_back(nums[i]);\\n    return subs.size();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2112218,
                "title": "java-python-3-sort-and-count-w-brief-explanation-and-analysis",
                "content": "Greedy algorithm.\\n\\n----\\n\\n**method 1: two pointers**\\n1. Sort `nums`, starting from 1st two elements, `nums[0]` and `nums[1]`, as the values that two pointers `prev` and `cur` initially point to; Initialize a counter `partitions` as `1` since we at lease have `1` partition;\\n2. if `nums[cur] - nums[prev] > k`, increase the counter by `1` and update `prev` and `cur` accordingly;\\n3. Repeat 2 till the end of `nums`.\\n```java\\n    public int partitionArray(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int partitions = 1;\\n        for (int cur = 1, prev = 0; cur < nums.length; ++cur) {\\n            if (nums[cur] - nums[prev] > k) {\\n                ++partitions; \\n                prev = cur;\\n            }\\n        }\\n        return partitions;\\n    }\\n```\\n```python\\n    def partitionArray(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        prev, partitions, n = 0, 1, len(nums)\\n        for cur in range(1, n):\\n            if nums[cur] - nums[prev] > k:\\n                partitions += 1\\n                prev = cur\\n        return partitions\\n```\\n\\n----\\n\\nWe can use binary search after sorting, which is of course only a minor optimiztaton.\\n\\n**Method 2: binary search**\\n\\n1. Sort `nums`, starting from 1st element, `nums[0]`, binary search the index of the ceil of `nums[0] + k`, `nums[0] + 2 * k`, ...`nums[0] + i * k`,.., respectively, till reach the last element of `nums`;\\n2. Increase the partitions by `1` whenever find each during the binary search in 1.\\n```java\\n    public int partitionArray(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int key = nums[0] + k, partitions = 1;\\n        while (binarySearch(nums, key) < nums.length) {\\n            ++partitions;\\n            key = nums[binarySearch(nums, key)] + k;\\n        }\\n        return partitions;\\n    }\\n    private int binarySearch(int[] nums, int key) {\\n        int lo = 0, hi = nums.length;\\n        while (lo < hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            if (nums[mid] <= key) {\\n                lo = mid + 1;\\n            }else {\\n                hi = mid;\\n            }\\n        }\\n        return lo;\\n    }\\n```\\n```python\\n    def partitionArray(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        partitions = 1\\n        cur = nums[0]\\n        while (idx := bisect.bisect(nums, cur + k)) < len(nums):\\n            partitions += 1\\n            cur = nums[idx]\\n        return partitions    \\n```\\n\\n**Analysis:**\\n\\nTime: `O(nlogn)`, space: `O(n)` - including sorting space, where `n = nums.length`.",
                "solutionTags": [],
                "code": "```java\\n    public int partitionArray(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int partitions = 1;\\n        for (int cur = 1, prev = 0; cur < nums.length; ++cur) {\\n            if (nums[cur] - nums[prev] > k) {\\n                ++partitions; \\n                prev = cur;\\n            }\\n        }\\n        return partitions;\\n    }\\n```\n```python\\n    def partitionArray(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        prev, partitions, n = 0, 1, len(nums)\\n        for cur in range(1, n):\\n            if nums[cur] - nums[prev] > k:\\n                partitions += 1\\n                prev = cur\\n        return partitions\\n```\n```java\\n    public int partitionArray(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int key = nums[0] + k, partitions = 1;\\n        while (binarySearch(nums, key) < nums.length) {\\n            ++partitions;\\n            key = nums[binarySearch(nums, key)] + k;\\n        }\\n        return partitions;\\n    }\\n    private int binarySearch(int[] nums, int key) {\\n        int lo = 0, hi = nums.length;\\n        while (lo < hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            if (nums[mid] <= key) {\\n                lo = mid + 1;\\n            }else {\\n                hi = mid;\\n            }\\n        }\\n        return lo;\\n    }\\n```\n```python\\n    def partitionArray(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        partitions = 1\\n        cur = nums[0]\\n        while (idx := bisect.bisect(nums, cur + k)) < len(nums):\\n            partitions += 1\\n            cur = nums[idx]\\n        return partitions    \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2111948,
                "title": "c-python-java-sort-short-and-clean",
                "content": "**CPP**\\n\\n```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& v, int k,int ans=0,int idx=0) {\\n        sort(v.begin(),v.end());\\n        for(int i=0;i<v.size();i++){\\n            if(v[i]-v[idx]>k)ans++,idx=i;\\n        }\\n        return ans+1;\\n    }\\n};\\n```\\n\\n**PYTHON**\\n\\n```\\nclass Solution:\\n    def partitionArray(self, v: List[int], k: int,idx=0 ,ans=0) -> int:\\n        v.sort()\\n        for i in range(len(v)):\\n            if v[i] - v[idx]>k:\\n                ans+=1\\n                idx=i\\n        return ans+1\\n        \\n```\\n\\n**JAVA**\\n\\n```\\nclass Solution {\\n    public int partitionArray(int[] v, int k) {\\n        Arrays.sort(v);\\n        int ans=0,idx=0;\\n        for(int i=0;i<v.length;i++){\\n            if(v[i]-v[idx]>k){\\n                ans++;idx=i;\\n            }\\n        }\\n        return ans+1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& v, int k,int ans=0,int idx=0) {\\n        sort(v.begin(),v.end());\\n        for(int i=0;i<v.size();i++){\\n            if(v[i]-v[idx]>k)ans++,idx=i;\\n        }\\n        return ans+1;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def partitionArray(self, v: List[int], k: int,idx=0 ,ans=0) -> int:\\n        v.sort()\\n        for i in range(len(v)):\\n            if v[i] - v[idx]>k:\\n                ans+=1\\n                idx=i\\n        return ans+1\\n        \\n```\n```\\nclass Solution {\\n    public int partitionArray(int[] v, int k) {\\n        Arrays.sort(v);\\n        int ans=0,idx=0;\\n        for(int i=0;i<v.length;i++){\\n            if(v[i]-v[idx]>k){\\n                ans++;idx=i;\\n            }\\n        }\\n        return ans+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112342,
                "title": "java-o-n-turns-out-bucket-is-faster-in-this-solution-7ms-beats-100",
                "content": "After you put nums into buckets, scan it, if it appeared, then jump k steps.\\nTo shorten time, it could check only from smallest to biggest in buckets.\\n```\\nclass Solution {\\n    public int partitionArray(int[] nums, int k) {\\n        int[] buckets=new int[(int)(Math.pow(10,5)+1)];\\n        int max=0;\\n        for(int num:nums){\\n            buckets[num]++;\\n            max=Math.max(max,num);\\n        }\\n        int result=0;\\n        for(int i=0;i<=max;i++){\\n            if(buckets[i]>0){\\n                result++;\\n                i+=k;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int partitionArray(int[] nums, int k) {\\n        int[] buckets=new int[(int)(Math.pow(10,5)+1)];\\n        int max=0;\\n        for(int num:nums){\\n            buckets[num]++;\\n            max=Math.max(max,num);\\n        }\\n        int result=0;\\n        for(int i=0;i<=max;i++){\\n            if(buckets[i]>0){\\n                result++;\\n                i+=k;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112025,
                "title": "max-heap-priority-queue-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        priority_queue<int> pq;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            pq.push(nums[i]);\\n        }\\n        int last=-1;\\n        int count=0;\\n        while(pq.size()>0)\\n        {\\n            int t=pq.top();\\n            pq.pop();\\n            if(last!=-1)\\n            {\\n                if(last-t<=k)\\n                {\\n                    continue;\\n                }\\n                else\\n                {\\n                    last=t;\\n                    count++;\\n                }\\n            }\\n            else\\n            { count++;\\n                last=t;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\n**Like it? Please Upvote ;-)**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        priority_queue<int> pq;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            pq.push(nums[i]);\\n        }\\n        int last=-1;\\n        int count=0;\\n        while(pq.size()>0)\\n        {\\n            int t=pq.top();\\n            pq.pop();\\n            if(last!=-1)\\n            {\\n                if(last-t<=k)\\n                {\\n                    continue;\\n                }\\n                else\\n                {\\n                    last=t;\\n                    count++;\\n                }\\n            }\\n            else\\n            { count++;\\n                last=t;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2851294,
                "title": "cpp-solution-better-than-100-o-nlogn-time-complexity",
                "content": "# Approach\\n-> The idea is to sort the array in decending order and then apply two pointers the first pointer will point to the first element of any partition and second pointer will traverse and find the last element of the partition \\n\\n-> The job of second pointer is find to the element whose difference with the element (first pointer is pointing) is greater than the value k, and when we find that element simply increase the value of partition variable (this variable is counting the number of partions we require) \\n\\n-> The answer of the query is value of partition variable + 1 (because we need to return number of subsequences or partition)\\n\\n```\\nGiven nums = [3,6,1,2,5], k = 2\\n             part = 0\\n->           nums = 6  5  3  2  1  // After Sorting in Descending order\\n                    |  |\\n                    i  j           // Pointers\\n    n[i]-n[j] = 1 < 2          //ignore and increment value of j\\n\\n\\n->            nums = 6  5  3  2  1\\n                     |     |\\n                     i     j\\n    n[i]-n[j] = 3 > 2   // increment partition variable\\'s value by 1 and do i=j\\n\\n\\n-> Now,        nums = 6  5 | 3  2  1\\n                             |  |\\n                             i  j\\n    n[i]-n[j] = 1 < 2  // ignore and increment value of j\\n\\n\\n           nums = 6  5 | 3  2  1\\n                         |     |\\n                         i     j  \\n    n[i]-n[j] = 2 == 2 //ignore and increment value of j\\n\\n\\n j == n.size() therefore terminate the loop \\n\\n```\\n\\n```\\nPLease Like if find the code interesting\\uD83D\\uDE01\\uD83D\\uDE01\\uD83D\\uDE0A\\uD83D\\uDE0A\\n```\\n\\n# Complexity\\n- Time complexity: O(nlogn + n) ,better than 100% Cpp online Submissions\\n\\n- Space complexity: O(1), better than 52% Cpp online Submissions\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& n, int k) {\\n        int part=0;\\n        sort(n.begin(),n.end(),greater<int>());\\n        int i=0,j=1;\\n        while(i<n.size() && j<n.size())\\n        {\\n            if(n[i]-n[j]>k)\\n            {\\n                part++;\\n                i=j;\\n            }\\n            j++;\\n        }\\n  return part+1;  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nGiven nums = [3,6,1,2,5], k = 2\\n             part = 0\\n->           nums = 6  5  3  2  1  // After Sorting in Descending order\\n                    |  |\\n                    i  j           // Pointers\\n    n[i]-n[j] = 1 < 2          //ignore and increment value of j\\n\\n\\n->            nums = 6  5  3  2  1\\n                     |     |\\n                     i     j\\n    n[i]-n[j] = 3 > 2   // increment partition variable\\'s value by 1 and do i=j\\n\\n\\n-> Now,        nums = 6  5 | 3  2  1\\n                             |  |\\n                             i  j\\n    n[i]-n[j] = 1 < 2  // ignore and increment value of j\\n\\n\\n           nums = 6  5 | 3  2  1\\n                         |     |\\n                         i     j  \\n    n[i]-n[j] = 2 == 2 //ignore and increment value of j\\n\\n\\n j == n.size() therefore terminate the loop \\n\\n```\n```\\nPLease Like if find the code interesting\\uD83D\\uDE01\\uD83D\\uDE01\\uD83D\\uDE0A\\uD83D\\uDE0A\\n```\n```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& n, int k) {\\n        int part=0;\\n        sort(n.begin(),n.end(),greater<int>());\\n        int i=0,j=1;\\n        while(i<n.size() && j<n.size())\\n        {\\n            if(n[i]-n[j]>k)\\n            {\\n                part++;\\n                i=j;\\n            }\\n            j++;\\n        }\\n  return part+1;  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112182,
                "title": "fully-explained",
                "content": "\\'\\'\\'\\nclass Solution {\\n    public int partitionArray(int[] nums, int k) {\\n        \\n        // sorted array - so that we can simply traverse for min and max elements\\n        \\n        Arrays.sort(nums);\\n        \\n        int min = nums[0];  //obvious\\n        int max;\\n        \\n        int result = 1; //intially our whole array is a subsequence for us\\n        \\n        for(int i=0;i<nums.length;i++)\\n        {\\n            // we have to traverse ahead till the min and the max difference is smaller than that of k\\n            // so that we can get the max of our first subsequence and thereon further subsequences\\n            \\n            max = nums[i];\\n            \\n            if((max - min) > k)     // if it exceeds - we will have to make a new subsequence\\n            {\\n                result++;\\n                \\n                // and when getting to another subsequence, we will also have to update our min value\\n                \\n               min = nums[i];\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n\\'\\'\\'",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int partitionArray(int[] nums, int k) {\\n        \\n        // sorted array - so that we can simply traverse for min and max elements\\n        \\n        Arrays.sort(nums);\\n        \\n        int min = nums[0];  //obvious\\n        int max;\\n        \\n        int result = 1; //intially our whole array is a subsequence for us\\n        \\n        for(int i=0;i<nums.length;i++)\\n        {\\n            // we have to traverse ahead till the min and the max difference is smaller than that of k\\n            // so that we can get the max of our first subsequence and thereon further subsequences\\n            \\n            max = nums[i];\\n            \\n            if((max - min) > k)     // if it exceeds - we will have to make a new subsequence\\n            {\\n                result++;\\n                \\n                // and when getting to another subsequence, we will also have to update our min value\\n                \\n               min = nums[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3347962,
                "title": "very-easy-java-solution",
                "content": "Please **UPVOTE** if you like my solution!\\n\\n```\\nclass Solution {\\n    public int partitionArray(int[] nums, int k) {\\n        if(nums.length == 1){\\n            return 1;\\n        }\\n        Arrays.sort(nums);\\n        int count = 0;\\n        for(int i = 1,j = 0;i<nums.length;i++){\\n            if(nums[i] - nums[j] <= k){\\n                continue;\\n            }\\n            else{\\n                count++;\\n                j = i;\\n            }\\n        }\\n        return count+1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int partitionArray(int[] nums, int k) {\\n        if(nums.length == 1){\\n            return 1;\\n        }\\n        Arrays.sort(nums);\\n        int count = 0;\\n        for(int i = 1,j = 0;i<nums.length;i++){\\n            if(nums[i] - nums[j] <= k){\\n                continue;\\n            }\\n            else{\\n                count++;\\n                j = i;\\n            }\\n        }\\n        return count+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2128692,
                "title": "c-108ms-o-n-83-mb-o-n-100-86-counting-sort-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        int rt=0,ma=0,mi=100000;\\n        bool ct[100005]={0};\\n        for(int i=0;i<nums.size();++i){\\n            ma=max(ma,nums[i]);\\n            mi=min(mi,nums[i]);\\n            ct[nums[i]]=1;\\n        }\\n\\t\\tif(k>=ma-mi)\\n            return 1;\\n        for(int i=mi;i<=ma;++i){\\n            if(ct[i]){\\n                ++rt;\\n                i+=k;\\n            }\\n        }\\n        return rt;\\n    }\\n};\\n```\\n1.we don\\'t need to count the times of each number because it is equivalence between [2] and [2,2,2] **->** use boolean array to reduce memory use.\\n2.we don\\'t need to traverse each number after counting sort **->** when a single number x  apper in nums, x ~ x+k is the best way to partition (greedy).\\n3.we don\\'t need to traverse from 0 to 10000 for every test case **->** recording the min/max value of nums and iterating over them.\\n4.if (k >= max-min) and (the size of nums > 0) **->** the answer is 1.",
                "solutionTags": [
                    "Greedy",
                    "Counting Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        int rt=0,ma=0,mi=100000;\\n        bool ct[100005]={0};\\n        for(int i=0;i<nums.size();++i){\\n            ma=max(ma,nums[i]);\\n            mi=min(mi,nums[i]);\\n            ct[nums[i]]=1;\\n        }\\n\\t\\tif(k>=ma-mi)\\n            return 1;\\n        for(int i=mi;i<=ma;++i){\\n            if(ct[i]){\\n                ++rt;\\n                i+=k;\\n            }\\n        }\\n        return rt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2119674,
                "title": "c-smooth-solution-clearly-explained",
                "content": "**dry run with steps:**\\nnums = [3 6 1 2 5], k= 2\\n**step-1:** sort in decreasing order\\n6 5 3 2 1\\n**Step-2:** count sub-sequences (if the difference between elements (nums[j]- nums[i] > k) book a new subsequence).\\n6-5 = 1         |   j = 0,  ans = 1\\n6-3 = 3> k    |  j = 2,   ans = 2\\n3-2 = 1         |  j = 2,   ans = 2\\n3-1 = 2         |  j = 2,   ans = 2\\n\\n\\n**Code:**\\n```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        int j = 0;\\n        int ans = 1;    //complete array is 1 subsequence in itself\\n        \\n        //sort in decreasing fashion\\n        sort(nums.begin(), nums.end(), greater<int>());\\n        \\n        //if the difference between elements (nums[j]- nums[i] > k) book a new subsequence\\n        for(int i=1; i<nums.size(); i++){\\n            if(nums[j]- nums[i] > k){\\n                ans++;\\n                j = i;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n**Please do upvote if you like the solution:)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        int j = 0;\\n        int ans = 1;    //complete array is 1 subsequence in itself\\n        \\n        //sort in decreasing fashion\\n        sort(nums.begin(), nums.end(), greater<int>());\\n        \\n        //if the difference between elements (nums[j]- nums[i] > k) book a new subsequence\\n        for(int i=1; i<nums.size(); i++){\\n            if(nums[j]- nums[i] > k){\\n                ans++;\\n                j = i;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2111994,
                "title": "c-sorting-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end(),greater<int>());\\n        int s=nums[0];\\n        int cnt=0;\\n        for(int i=1;i<n;i++){\\n            if(s-nums[i]>k){\\n                s=nums[i];\\n                cnt++;\\n            }\\n        }\\n        cnt++;\\n        return cnt;\\n    }\\n};\\n```\\n**Don\\'t forget to upvote this post if it has helped you!!!**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end(),greater<int>());\\n        int s=nums[0];\\n        int cnt=0;\\n        for(int i=1;i<n;i++){\\n            if(s-nums[i]>k){\\n                s=nums[i];\\n                cnt++;\\n            }\\n        }\\n        cnt++;\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2111928,
                "title": "simple-cpp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        if(n==1)\\n            return 1;\\n        sort(nums.begin(),nums.end());\\n        int i=0;\\n        int j=i+1;\\n        int ans=0;\\n        while(j<n && i<n){\\n            if(k>=nums[j]-nums[i]){\\n                j++;\\n            }\\n            else{\\n                ans++;\\n                i=j;\\n                j=i+1;\\n            }\\n        }\\n        ans++;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        if(n==1)\\n            return 1;\\n        sort(nums.begin(),nums.end());\\n        int i=0;\\n        int j=i+1;\\n        int ans=0;\\n        while(j<n && i<n){\\n            if(k>=nums[j]-nums[i]){\\n                j++;\\n            }\\n            else{\\n                ans++;\\n                i=j;\\n                j=i+1;\\n            }\\n        }\\n        ans++;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112569,
                "title": "c-sort-two-pointer-most-simple-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int i,j=0, cnt=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]-nums[j]>k){\\n                cnt++;\\n                j=i;\\n            }\\n        }\\n        return cnt+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int i,j=0, cnt=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]-nums[j]>k){\\n                cnt++;\\n                j=i;\\n            }\\n        }\\n        return cnt+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112393,
                "title": "c-use-sorting-and-flag-explanation-through-comments",
                "content": "**Please upvote if you find this solution helpful:)\\nTC: O(NlogN), SC: O(1)**\\n\\n**Code:**\\n```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) \\n    {\\n        //sort nums to get all values in ascending order  \\n        sort(nums.begin(), nums.end());\\n        int n=nums.size(), count=0, flag=0, mini=INT_MAX;\\n        \\n    \\n        //iterate through the nums\\n        for(int j=0; j<n; j++)\\n        {\\n            //when flag is 0 \\n            if(!flag)\\n            {\\n                flag=1; //mark flag=1 which shows new subsequence started\\n                mini = nums[j];  //since nums is in ascending order, mini will be at first index of new subsequence\\n                count++;\\n            }\\n\\n            //when difference is greater than k we need to start new subsequence\\n            if(abs(nums[j]-mini) > k)\\n            {\\n                //re-assign flag=0, mini, and decrement j, to consider it in new subsequence\\n                flag=0; \\n                mini = INT_MAX; \\n                j--;\\n            }\\n        }\\n            \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) \\n    {\\n        //sort nums to get all values in ascending order  \\n        sort(nums.begin(), nums.end());\\n        int n=nums.size(), count=0, flag=0, mini=INT_MAX;\\n        \\n    \\n        //iterate through the nums\\n        for(int j=0; j<n; j++)\\n        {\\n            //when flag is 0 \\n            if(!flag)\\n            {\\n                flag=1; //mark flag=1 which shows new subsequence started\\n                mini = nums[j];  //since nums is in ascending order, mini will be at first index of new subsequence\\n                count++;\\n            }\\n\\n            //when difference is greater than k we need to start new subsequence\\n            if(abs(nums[j]-mini) > k)\\n            {\\n                //re-assign flag=0, mini, and decrement j, to consider it in new subsequence\\n                flag=0; \\n                mini = INT_MAX; \\n                j--;\\n            }\\n        }\\n            \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112209,
                "title": "4-liner-sort-two-pointer",
                "content": "**Point to be Noted :** *There should be minimum one Partition Always.*\\n\\t\\n\\t\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint partitionArray(vector<int>& nums, int k) {\\n\\t\\t\\tint start = 0,end = 0,ans = 1;\\n\\t\\t\\tsort(nums.begin(),nums.end());\\n\\t\\t\\twhile(end != nums.size()){\\n\\t\\t\\t\\tif(nums[end] - nums[start] <= k) end++;\\n\\t\\t\\t\\telse ans++, start = end;\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\n\\t\\n**Time Complexity :** *O(nlogn)*\\n**Space Complexity :** *O(1)*",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint partitionArray(vector<int>& nums, int k) {\\n\\t\\t\\tint start = 0,end = 0,ans = 1;\\n\\t\\t\\tsort(nums.begin(),nums.end());\\n\\t\\t\\twhile(end != nums.size()){\\n\\t\\t\\t\\tif(nums[end] - nums[start] <= k) end++;\\n\\t\\t\\t\\telse ans++, start = end;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2112114,
                "title": "greedy-using-treeset",
                "content": "```\\nclass Solution {\\n    public int partitionArray(int[] nums, int k) {\\n        TreeSet<Integer> ts = new TreeSet<>();\\n        for(int num: nums){\\n           ts.add(num);\\n        }\\n\\n        Integer start = ts.first();\\n        int count = 0;\\n        while(start!=null && ts.ceiling(start)!=null){\\n            int end = start+k;\\n            count++;\\n            if(ts.ceiling(end+1)==null)\\n                return count;\\n            if(ts.contains(end+1))\\n            start = end+1;\\n            else\\n            start = ts.ceiling(end+1);  \\n        }\\n        return count;\\n    }\\n}\\n",
                "solutionTags": [],
                "code": "class Solution {\\n    public int partitionArray(int[] nums, int k) {\\n        TreeSet<Integer> ts = new TreeSet<>();\\n        for(int num: nums){\\n           ts.add(num);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3810227,
                "title": "python-3-sort-greedy-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(NlogN)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def partitionArray(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        j = 0\\n        res = 1\\n        for i, num in enumerate(nums):\\n            if num - nums[j] > k:\\n                res += 1\\n                j = i\\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def partitionArray(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        j = 0\\n        res = 1\\n        for i, num in enumerate(nums):\\n            if num - nums[j] > k:\\n                res += 1\\n                j = i\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3510637,
                "title": "3-solutions-for-partition-array-such-that-maximum-difference-is-k-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# 1. Approach\\n<!-- Describe your approach to solving the problem. -->\\n*BRUTE FORCE -> SORTING*\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        int i, j, min, count=1;\\n        sort(nums.begin(), nums.end());\\n        min = nums[0];\\n        for(i=1 ; i<nums.size() ; i++)\\n        {\\n            if(nums[i]-min>k)\\n            {\\n                count++;\\n                min = nums[i];\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\n# 2. Approach\\n<!-- Describe your approach to solving the problem. -->\\n*USING HASHMAP*\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        int i, min=-1, count=1;\\n        map<int, int> mp;\\n        for(i=0 ; i<nums.size() ; i++)\\n        {\\n            mp[nums[i]]++;\\n        }\\n        for(auto it:mp)\\n        {\\n            if(min==-1)\\n            {\\n                min = it.first;\\n            }\\n            else if(it.first-min>k)\\n            {\\n                min = it.first;\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\n# 3. Approach\\n<!-- Describe your approach to solving the problem. -->\\n*USING SET*\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        int i, min=-1, count=1;\\n        set<int> s(nums.begin(), nums.end());\\n        for(auto it:s)\\n        {\\n            if(min==-1)\\n            {\\n                min = it;\\n            }\\n            else if(it-min>k)\\n            {\\n                min = it;\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/a8c0d5e9-c618-4854-90e8-a0d852a12a8d_1683773556.702196.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        int i, j, min, count=1;\\n        sort(nums.begin(), nums.end());\\n        min = nums[0];\\n        for(i=1 ; i<nums.size() ; i++)\\n        {\\n            if(nums[i]-min>k)\\n            {\\n                count++;\\n                min = nums[i];\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        int i, min=-1, count=1;\\n        map<int, int> mp;\\n        for(i=0 ; i<nums.size() ; i++)\\n        {\\n            mp[nums[i]]++;\\n        }\\n        for(auto it:mp)\\n        {\\n            if(min==-1)\\n            {\\n                min = it.first;\\n            }\\n            else if(it.first-min>k)\\n            {\\n                min = it.first;\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        int i, min=-1, count=1;\\n        set<int> s(nums.begin(), nums.end());\\n        for(auto it:s)\\n        {\\n            if(min==-1)\\n            {\\n                min = it;\\n            }\\n            else if(it-min>k)\\n            {\\n                min = it;\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2736428,
                "title": "two-pointers",
                "content": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) \\n{\\n    sort(nums.begin(),nums.end());\\n    // 3 6 1 2 5--> 1 2 3 5 6         \\n    int count=0;\\n    int start=0;\\n    int end=0;\\n    \\n    while(end<nums.size())\\n    {\\n    \\twhile(end<nums.size() and (nums[end]-nums[start])<=k)\\n    \\t{\\n    \\t\\tend++;\\n\\t\\t}\\n\\t\\tstart=end;\\n\\t\\tcount++;\\n\\t}\\n\\treturn count;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) \\n{\\n    sort(nums.begin(),nums.end());\\n    // 3 6 1 2 5--> 1 2 3 5 6         \\n    int count=0;\\n    int start=0;\\n    int end=0;\\n    \\n    while(end<nums.size())\\n    {\\n    \\twhile(end<nums.size() and (nums[end]-nums[start])<=k)\\n    \\t{\\n    \\t\\tend++;\\n\\t\\t}\\n\\t\\tstart=end;\\n\\t\\tcount++;\\n\\t}\\n\\treturn count;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2141430,
                "title": "sort-cpp-very-easy",
                "content": "class Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        \\n        \\n        sort(nums.begin(),nums.end(),greater<int>());\\n        int l=0;\\n        int ans=0;\\n        // 6 5 3 2 1 0\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[l]-nums[i]>k){\\n                ans++;\\n                l=i;\\n            }\\n        }\\n        return ans+1;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        \\n        \\n        sort(nums.begin(),nums.end(),greater<int>());\\n        int l=0;\\n        int ans=0;\\n        // 6 5 3 2 1 0\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[l]-nums[i]>k){\\n                ans++;\\n                l=i;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2119165,
                "title": "c-easy-code",
                "content": "**Please Upvote If It Helps**\\n\\n```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) \\n    {\\n        sort(nums.begin(),nums.end());\\n        int cnt = 0;\\n        int flag = 1;\\n        int n = nums.size();\\n        int mn = INT_MAX;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            // if our flag is 1 it means we are ready with new subsequence\\n            if(flag==1)\\n            {\\n                flag = 0;\\n                mn = nums[i];\\n                cnt++;\\n            }\\n            \\n            // if our consecutive diff is greater than k then we need to start new subsequence\\n            if(nums[i]-mn > k)\\n            {\\n                flag = 1;               // made flag 1 to start the new subsequence\\n                mn = INT_MAX;           // make again mn as max\\n                i--;                    // move curr pointer , 1 step behind\\n            }\\n        }\\n        return cnt;\\n        \\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) \\n    {\\n        sort(nums.begin(),nums.end());\\n        int cnt = 0;\\n        int flag = 1;\\n        int n = nums.size();\\n        int mn = INT_MAX;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            // if our flag is 1 it means we are ready with new subsequence\\n            if(flag==1)\\n            {\\n                flag = 0;\\n                mn = nums[i];\\n                cnt++;\\n            }\\n            \\n            // if our consecutive diff is greater than k then we need to start new subsequence\\n            if(nums[i]-mn > k)\\n            {\\n                flag = 1;               // made flag 1 to start the new subsequence\\n                mn = INT_MAX;           // make again mn as max\\n                i--;                    // move curr pointer , 1 step behind\\n            }\\n        }\\n        return cnt;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2114621,
                "title": "array-with-maximum-k-difference-sort-simple-boolean",
                "content": "Hi,\\n\\nInitially I went through the thought process of figuring out the solution, Since the differenece is the main factor of grouping the items its better to sort the given array in the first step itself.\\n\\nTo make sure the items are tracked and added I kept a boolean array to keep track of the elements. This will make sure the items are added to the resultant list.\\n\\nNext we can itrate through the given array, this is the crutial step which has multiple conditions to be handled.\\n\\nI maintained a current value which will store the differance at any point in time. If the value is greater than K then \\n\\t1. If the difference is greater than the given value k -> increment the result\\n\\t2. Increment the index everytime, because one element can\\'t be shared \\n\\t3. One last step is to make the flag as true once element is added and check at last if the element is not added then increment the result and add to the list.\\n\\nHere is the my code implementing the same, Kindly upvote if it helps.. Happy learning :)\\n\\n```\\n   public int partitionArray(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int res=0;\\n        int curr=0, i=0;\\n        boolean flag[] = new boolean[nums.length];\\n        while(i<nums.length-1){\\n        \\tcurr = curr+nums[i+1]-nums[i];\\n        \\tif(curr>k){\\n        \\t\\tflag[i]=true;\\n        \\t\\tcurr=0;\\n        \\t\\tres++;\\n        \\t}\\n        \\ti++;\\n        }\\n        if(!flag[nums.length-1])\\n        \\tres++;\\n        return res;\\n    }",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "Hi,\\n\\nInitially I went through the thought process of figuring out the solution, Since the differenece is the main factor of grouping the items its better to sort the given array in the first step itself.\\n\\nTo make sure the items are tracked and added I kept a boolean array to keep track of the elements. This will make sure the items are added to the resultant list.\\n\\nNext we can itrate through the given array, this is the crutial step which has multiple conditions to be handled.\\n\\nI maintained a current value which will store the differance at any point in time. If the value is greater than K then \\n\\t1. If the difference is greater than the given value k -> increment the result\\n\\t2. Increment the index everytime, because one element can\\'t be shared \\n\\t3. One last step is to make the flag as true once element is added and check at last if the element is not added then increment the result and add to the list.\\n\\nHere is the my code implementing the same, Kindly upvote if it helps.. Happy learning :)\\n\\n```\\n   public int partitionArray(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int res=0;\\n        int curr=0, i=0;\\n        boolean flag[] = new boolean[nums.length];\\n        while(i<nums.length-1){\\n        \\tcurr = curr+nums[i+1]-nums[i];\\n        \\tif(curr>k){\\n        \\t\\tflag[i]=true;\\n        \\t\\tcurr=0;\\n        \\t\\tres++;\\n        \\t}\\n        \\ti++;\\n        }\\n        if(!flag[nums.length-1])\\n        \\tres++;\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2113854,
                "title": "python3-heap",
                "content": "The idea is to iteratively build subsequences from nums using heap while maintaining the property that each element appears in exactly one subsequence.\\nWe initialize a variable **start** to store the first element of the current subsequence and **count** to store the number of subsequences required and set it to 1. While there are still elements left in the **heap**, we pop the smallest element from the heap using the heappop() and assign it to **num**. If the difference between **num** and **start** is greater than **k**, it means that the current subsequence has exceeded the allowed difference of k. Therefore, we update start to be equal to num and increment the count variable to indicate a new subsequence. After popping all elements from the heap, we return **count** variable which stores the minimum number of subsequences.\\n```\\nclass Solution:\\n    def partitionArray(self, nums: List[int], k: int) -> int:\\n        heapify(nums)\\n        count = 1\\n        \\n        start = heappop(nums)\\n        \\n        while nums:\\n            num = heappop(nums)\\n            \\n            if num - start > k:\\n                start = num\\n                count += 1\\n                \\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def partitionArray(self, nums: List[int], k: int) -> int:\\n        heapify(nums)\\n        count = 1\\n        \\n        start = heappop(nums)\\n        \\n        while nums:\\n            num = heappop(nums)\\n            \\n            if num - start > k:\\n                start = num\\n                count += 1\\n                \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2111894,
                "title": "c-sort",
                "content": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        if(size(nums) == 1) return 1;\\n        sort(begin(nums),end(nums));\\n        int i=1,cnt = 0;\\n        int minEle = nums[0];\\n        while(i < size(nums)){\\n            if(abs(minEle - nums[i]) > k){ // when the condition is not satisfied just update the min element and increase the count .\\n                minEle = nums[i];\\n                cnt++;\\n            }\\n            i++;\\n        }\\n        return cnt+1; // + 1 for the last subsequence .\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        if(size(nums) == 1) return 1;\\n        sort(begin(nums),end(nums));\\n        int i=1,cnt = 0;\\n        int minEle = nums[0];\\n        while(i < size(nums)){\\n            if(abs(minEle - nums[i]) > k){ // when the condition is not satisfied just update the min element and increase the count .\\n                minEle = nums[i];\\n                cnt++;\\n            }\\n            i++;\\n        }\\n        return cnt+1; // + 1 for the last subsequence .\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3386016,
                "title": "partition-array-such-that-maximum-difference-is-k-fast-super-easy",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) \\n    {\\n        sort(nums.begin(),nums.end());\\n        int ans = 1;\\n        int i = 0;\\n        int a = 0;\\n        int b = nums[0];\\n        while(i<nums.size())\\n        {\\n            a = nums[i];\\n            if(a>(b+k))\\n            {\\n                ans++;\\n                a = nums[i];\\n                b = nums[i];\\n            }\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) \\n    {\\n        sort(nums.begin(),nums.end());\\n        int ans = 1;\\n        int i = 0;\\n        int a = 0;\\n        int b = nums[0];\\n        while(i<nums.size())\\n        {\\n            a = nums[i];\\n            if(a>(b+k))\\n            {\\n                ans++;\\n                a = nums[i];\\n                b = nums[i];\\n            }\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3255456,
                "title": "simple-python-solution",
                "content": "# Intuition\\nSort Your given array. Why? Because we need to find subsequence so order isnt define for them.\\nWe are asked to return minimum number of subsequence we need to form so our aim is to add as many number as possible in one array with limit(k).\\n`How limit is defined? largest ele - Smallest ele`\\nAs we sorted our array so for each subsequence the first element will be smallest and just check if by adding curr element if we are still in our limit. (The problem is reduced in finding subarrays within limit)\\n`If yes -> add the element\\nIf not -> add the by far collected ans in res and reset your ans as empty to start finding new subarray.`\\nRes carries all the possible subsequnces thus, return its length as the min no of subsequences required.\\n\\n# Code\\n```\\nclass Solution:\\n    def partitionArray(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        \\n        # Base Case\\n        if nums[-1] - nums[0] <= k:\\n            return 1\\n\\n        ans = []\\n        ans.append(nums[0])\\n        res = []\\n        for i in range(len(nums)-1):\\n            if nums[i + 1] - ans[0] <= k:\\n                ans.append(nums[i + 1])\\n            else:\\n                res.append(ans)\\n                ans = []\\n                ans.append(nums[i + 1])\\n        res.append(ans)\\n        # print(res)\\n        return len(res)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def partitionArray(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        \\n        # Base Case\\n        if nums[-1] - nums[0] <= k:\\n            return 1\\n\\n        ans = []\\n        ans.append(nums[0])\\n        res = []\\n        for i in range(len(nums)-1):\\n            if nums[i + 1] - ans[0] <= k:\\n                ans.append(nums[i + 1])\\n            else:\\n                res.append(ans)\\n                ans = []\\n                ans.append(nums[i + 1])\\n        res.append(ans)\\n        # print(res)\\n        return len(res)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3130005,
                "title": "c-very-simple-optimized",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        int c=1,mini=INT_MAX;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            mini=min(mini,nums[i]);\\n            if(nums[i]-mini>k)\\n            {\\n                c++;\\n                mini=nums[i];\\n            }\\n        }return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        int c=1,mini=INT_MAX;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            mini=min(mini,nums[i]);\\n            if(nums[i]-mini>k)\\n            {\\n                c++;\\n                mini=nums[i];\\n            }\\n        }return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2635340,
                "title": "java-easy-to-understand-answer",
                "content": "```\\nclass Solution {\\n    public int partitionArray(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int count =1;\\n        int start =0;\\n        for(int i=1;i<nums.length;i++)\\n        {\\n            if(nums[i]-nums[start]>k)\\n            {\\n                count++;\\n                start =i;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int partitionArray(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int count =1;\\n        int start =0;\\n        for(int i=1;i<nums.length;i++)\\n        {\\n            if(nums[i]-nums[start]>k)\\n            {\\n                count++;\\n                start =i;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2120216,
                "title": "java-javascript-simple-fast-solution-faster-than-100",
                "content": "Java code:\\n```\\n    public int partitionArray(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        var list = new ArrayList<Integer>();\\n        list.add(nums[0]);\\n        var count = 0;\\n        for (int i = 1; i < nums.length; i++) {\\n            if (nums[i]-list.get(0)>k) {\\n                count++;\\n                list = new ArrayList<>();\\n            }\\n            list.add(nums[i]);\\n        }\\n        if (!list.isEmpty()) {\\n            count++;\\n        }\\n        return count;\\n    }\\n```\\n\\nJavaScript code:\\n```\\nvar partitionArray = function(nums, k) {\\n    let sorted = nums.sort((a, b) => a-b)\\n    let list = []\\n    let count = 0\\n    list.push(sorted[0])\\n    for (i = 1; i < sorted.length; i++) {\\n        let num = sorted[i]\\n        if (num-list[0]>k) {\\n            count++\\n            list = []\\n        }\\n        list.push(num)\\n    } if (list.length) count++\\n    return count\\n\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "JavaScript",
                    "Sorting"
                ],
                "code": "```\\n    public int partitionArray(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        var list = new ArrayList<Integer>();\\n        list.add(nums[0]);\\n        var count = 0;\\n        for (int i = 1; i < nums.length; i++) {\\n            if (nums[i]-list.get(0)>k) {\\n                count++;\\n                list = new ArrayList<>();\\n            }\\n            list.add(nums[i]);\\n        }\\n        if (!list.isEmpty()) {\\n            count++;\\n        }\\n        return count;\\n    }\\n```\n```\\nvar partitionArray = function(nums, k) {\\n    let sorted = nums.sort((a, b) => a-b)\\n    let list = []\\n    let count = 0\\n    list.push(sorted[0])\\n    for (i = 1; i < sorted.length; i++) {\\n        let num = sorted[i]\\n        if (num-list[0]>k) {\\n            count++\\n            list = []\\n        }\\n        list.push(num)\\n    } if (list.length) count++\\n    return count\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2115256,
                "title": "javascript-easy-understanding",
                "content": "```\\nvar partitionArray = function(nums, k) {\\n      nums.sort((a,b)=>a-b)\\n  var start = 0;\\n  var end = 0;\\n  var count = 0;\\n  \\n  while(start<nums.length){\\n    var diff = nums[end]-nums[start]\\n    if(diff<=k){\\n      end++;\\n    }\\n    else {\\n      count++;\\n      start = end;\\n    }\\n  } return count\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar partitionArray = function(nums, k) {\\n      nums.sort((a,b)=>a-b)\\n  var start = 0;\\n  var end = 0;\\n  var count = 0;\\n  \\n  while(start<nums.length){\\n    var diff = nums[end]-nums[start]\\n    if(diff<=k){\\n      end++;\\n    }\\n    else {\\n      count++;\\n      start = end;\\n    }\\n  } return count\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2113942,
                "title": "c-easy-and-simplest-solution-using-sorting",
                "content": "Step 1: We will sort the array in non-decreasing order.\\nStep 2: Mark the starting position and iterate through array and whenever the diference of starting index and cuurent index exceeds k this means we have to start a new subsequence.\\nStep 3: Returning the number of subsequences in which we have to split.\\n```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int count=1;\\n        int start=0;\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]-nums[start]>k){\\n                start=i;\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int count=1;\\n        int start=0;\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]-nums[start]>k){\\n                start=i;\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2113584,
                "title": "100-faster-solution-using-sort-and-upper-bound",
                "content": "Upper bound function return iterator of just greater element of searching element. \\nso first of all sort the given vector and using **it - nums.begin()** calculate the next element that can be part of subsequence and do untill upper bound return **nums.end()** \\nand use a counter that will count our answer and simply return it whenever its completed \\n\\n```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        sort(nums.begin(), nums.end());\\n        \\n        \\n        int ans=0;\\n        int i=0,temp=nums[0]+k;\\n        while(i<nums.size()){\\n            auto it=upper_bound(nums.begin(),nums.end(),temp);\\n            i=it-nums.begin();\\n            ans++;\\n            if(it==nums.end())return ans;\\n            temp=nums[i]+k;\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};****\\n```\\n\\n**please... Upvote :)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        sort(nums.begin(), nums.end());\\n        \\n        \\n        int ans=0;\\n        int i=0,temp=nums[0]+k;\\n        while(i<nums.size()){\\n            auto it=upper_bound(nums.begin(),nums.end(),temp);\\n            i=it-nums.begin();\\n            ans++;\\n            if(it==nums.end())return ans;\\n            temp=nums[i]+k;\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};****\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2113361,
                "title": "c-easy-to-understand-clean-code-with-comments",
                "content": "It has been asked that we need to partition the array such that the difference of the maximum and the minimum values of the individual partition do not exceed a certain value `k `. \\n\\nIt is clear that we need to keep track of the **minimum** and **maximum** value of the partition. But if we **sort** the array beforehand, the first value would be the minimum and last value would be maximum. \\n\\nThen we loop through the array, checking at each step that we take that if the difference of maximum and minimum exceeds k, if it does, a new partion is formed with present element as the new minimum.\\n\\n```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        int i,j,count=1; // initially the whole array is a single partition, hence count=1\\n        sort(nums.begin(), nums.end()); // sort the whole array\\n\\t\\t\\n        for(i=0; i<nums.size();){\\n            for(j=i; j<nums.size(); j++){\\n\\t\\t\\t\\t// i is the index of present minimum, j is the index of present maximum\\n                if(nums[j]-nums[i] > k){ \\n                    count++;\\n                    break;\\n                }\\n            }\\n            i=j; // present element becomes the new minimum\\n        }\\n\\t\\t\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        int i,j,count=1; // initially the whole array is a single partition, hence count=1\\n        sort(nums.begin(), nums.end()); // sort the whole array\\n\\t\\t\\n        for(i=0; i<nums.size();){\\n            for(j=i; j<nums.size(); j++){\\n\\t\\t\\t\\t// i is the index of present minimum, j is the index of present maximum\\n                if(nums[j]-nums[i] > k){ \\n                    count++;\\n                    break;\\n                }\\n            }\\n            i=j; // present element becomes the new minimum\\n        }\\n\\t\\t\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112756,
                "title": "go-lang-solution",
                "content": "```go\\nfunc partitionArray(nums []int, k int) int {\\n    // remember you\\'re trying to minimize difference \\n    // k is the ceiling\\n    // sort to group higher values together (to minimize difference)\\n    \\n    // then keep expanding till difference larger than k \\n    // create new sequence(increment) in that case\\n    \\n    sort.Ints(nums)\\n    \\n    ans := 1\\n    \\n    \\n    min := nums[0]\\n    max := nums[0]\\n    \\n    for i := 0; i < len(nums); i++ {\\n        max = nums[i]\\n        \\n        if (max - min) > k {\\n            ans++\\n            \\n            min = nums[i]\\n        }\\n    }\\n    \\n    return ans\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc partitionArray(nums []int, k int) int {\\n    // remember you\\'re trying to minimize difference \\n    // k is the ceiling\\n    // sort to group higher values together (to minimize difference)\\n    \\n    // then keep expanding till difference larger than k \\n    // create new sequence(increment) in that case\\n    \\n    sort.Ints(nums)\\n    \\n    ans := 1\\n    \\n    \\n    min := nums[0]\\n    max := nums[0]\\n    \\n    for i := 0; i < len(nums); i++ {\\n        max = nums[i]\\n        \\n        if (max - min) > k {\\n            ans++\\n            \\n            min = nums[i]\\n        }\\n    }\\n    \\n    return ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2112702,
                "title": "sort-array-java-o-nlogn-time",
                "content": "- The idea is to sort the array.\\n- If the array is sorted, we know that the smallest element would be at left end and largest at the right end of the sorted array.\\n - Thus, to get the difference between minimum and maximum element, we can just find the difference between the first and last element of the sorted array.\\n   \\n The algorithm can be described as,\\n - Find the sum of first and last element of sorted array,\\n\\t   1. If the difference is less than or equal to k, we no longer need to divide the subarray further.\\n\\t   2. If the difference is greater than k, we will have to divide the current array into subarrays. \\n\\t   The trick is that, we have to divide the current array such that the difference between largest and smallest element is less than the current difference. We can do this by pickup up next smaller element.\\n\\n```\\nclass Solution {\\n    public int partitionArray(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int result = 1;\\n        int end = nums.length - 1;\\n        int lastPartition = 0;\\n        \\n        for(int left = 0;left<nums.length;left++){\\n            int difference = nums[end] - nums[left];\\n            if(difference <=  k)\\n                return result;\\n            if(nums[left] - nums[lastPartition] > k || lastPartition == left){\\n                result += 1;\\n                lastPartition = left;\\n            }    \\n        }\\n        return result;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int partitionArray(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int result = 1;\\n        int end = nums.length - 1;\\n        int lastPartition = 0;\\n        \\n        for(int left = 0;left<nums.length;left++){\\n            int difference = nums[end] - nums[left];\\n            if(difference <=  k)\\n                return result;\\n            if(nums[left] - nums[lastPartition] > k || lastPartition == left){\\n                result += 1;\\n                lastPartition = left;\\n            }    \\n        }\\n        return result;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112602,
                "title": "java-sort-sliding-window-with-explanation",
                "content": "### Steps\\n1. sort the array\\n2. for each element:\\n2.1.  update the min & max\\n2.2.  if max - min > k, counter++ and reset the min & max\\n3. counter++ for the last one sequence\\n\\n### Complexity\\ntime: `O(nlogn)`\\nspace: `O(logn or n)` depends on the sorting algorithm\\n\\n### Java\\n```java\\npublic int partitionArray(int[] A, int k) {\\n    int n = A.length, res = 0, min = A[0], max = A[0];\\n    Arrays.sort(A);\\n\\n    for (int i = 0; i < n; i++) {\\n        min = Math.min(min, A[i]);\\n        max = Math.max(max, A[i]);\\n\\n        if (max - min > k) {\\n            res++;\\n            min = max = A[i];\\n        }\\n    }\\n    return res + 1;\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\npublic int partitionArray(int[] A, int k) {\\n    int n = A.length, res = 0, min = A[0], max = A[0];\\n    Arrays.sort(A);\\n\\n    for (int i = 0; i < n; i++) {\\n        min = Math.min(min, A[i]);\\n        max = Math.max(max, A[i]);\\n\\n        if (max - min > k) {\\n            res++;\\n            min = max = A[i];\\n        }\\n    }\\n    return res + 1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2112514,
                "title": "python-easy-understanding",
                "content": "Here the most basic idea is to first sort the array , coz then it will become an easy ques as comapred to medium coz now u only have to traverse through the list at once which will only take O(n) time complexity coz then we just have to compare the min value of the curent list with the current value and if we get that difference greater than k , then we just create a new list and keep on working on this concept and we will always get minimum no of lists only.\\n```\\nclass Solution:\\n    def partitionArray(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        l=[[nums[0]]]\\n        for i in range(1,len(nums)):\\n            if nums[i]-l[-1][0]<=k:\\n                l[-1].append(nums[i])\\n            \\n            else:\\n                l.append([nums[i]])\\n                \\n        return len(l)\\n```\\nIf u understood the code then plz.......UPVOTE.......Thnx in adv",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def partitionArray(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        l=[[nums[0]]]\\n        for i in range(1,len(nums)):\\n            if nums[i]-l[-1][0]<=k:\\n                l[-1].append(nums[i])\\n            \\n            else:\\n                l.append([nums[i]])\\n                \\n        return len(l)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112460,
                "title": "javascript",
                "content": "- Sort the array\\n- Select maximum diff of max element - min element\\nIf difference > k then only increase count and make start of another subsequence as ith element.\\n```\\n\\nlet Partition_Array_Such_That_Maximum_Difference_Is_K = function (nums, k) {\\n  nums.sort((a, b) => a - b);\\n  let minV = nums[0];\\n  let count = 1;\\n  for (let i = 1; i < nums.length; i++) {\\n    let diff = nums[i] - minV;\\n    if (diff > k) {\\n      count++;\\n      minV = nums[i];\\n    }\\n  }\\n  return count;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nlet Partition_Array_Such_That_Maximum_Difference_Is_K = function (nums, k) {\\n  nums.sort((a, b) => a - b);\\n  let minV = nums[0];\\n  let count = 1;\\n  for (let i = 1; i < nums.length; i++) {\\n    let diff = nums[i] - minV;\\n    if (diff > k) {\\n      count++;\\n      minV = nums[i];\\n    }\\n  }\\n  return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2111939,
                "title": "c-solution-using-sorting",
                "content": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) \\n    {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        int count=1;\\n        int mn=nums[0];\\n        int mx=nums[0];\\n        for(int i=1;i<n;i++)\\n        {\\n            mn=min(nums[i],mn);\\n            mx=max(nums[i],mx);\\n            if(mx-mn<=k)\\n            {\\n                continue;\\n            }\\n            else\\n            {\\n                count++;\\n                mn=nums[i];\\n                mx=nums[i];\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) \\n    {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        int count=1;\\n        int mn=nums[0];\\n        int mx=nums[0];\\n        for(int i=1;i<n;i++)\\n        {\\n            mn=min(nums[i],mn);\\n            mx=max(nums[i],mx);\\n            if(mx-mn<=k)\\n            {\\n                continue;\\n            }\\n            else\\n            {\\n                count++;\\n                mn=nums[i];\\n                mx=nums[i];\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2111899,
                "title": "sorting-java",
                "content": "```\\nclass Solution\\n{\\n    public int partitionArray(int[] nums, int k)\\n    {\\n        int count = 1;\\n        int min = 100001, max = -1;\\n        Arrays.sort(nums);\\n        for(int i = 0 ;i < nums.length; i++)\\n        {\\n            max = Math.max(max,nums[i]);\\n            min = Math.min(min,nums[i]);\\n            if(max - min > k)\\n            {\\n                count++;\\n                min = max; // The new substring has just one element which is max and min both\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution\\n{\\n    public int partitionArray(int[] nums, int k)\\n    {\\n        int count = 1;\\n        int min = 100001, max = -1;\\n        Arrays.sort(nums);\\n        for(int i = 0 ;i < nums.length; i++)\\n        {\\n            max = Math.max(max,nums[i]);\\n            min = Math.min(min,nums[i]);\\n            if(max - min > k)\\n            {\\n                count++;\\n                min = max; // The new substring has just one element which is max and min both\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4057560,
                "title": "c-o-1-space-complexity",
                "content": "# Complexity\\n- Time complexity: O(N logN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int mini = nums[0], cnt = 0;\\n        for(int it: nums){\\n            if(it-mini > k){\\n                cnt++;  mini = it;\\n            }\\n        }\\n        return cnt+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int mini = nums[0], cnt = 0;\\n        for(int it: nums){\\n            if(it-mini > k){\\n                cnt++;  mini = it;\\n            }\\n        }\\n        return cnt+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3997463,
                "title": "first-binary-search-solution-on-leetcode",
                "content": "# Approach\\nJust think of minimization problem of binary search.\\n# Complexity\\n- Time complexity:\\nO(n*logn) ->n*log(n) due to sorting\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // int partitionArray(vector<int>& nums, int k) {\\n       int chck(vector<int>&v1,int k,int md)\\n    {\\n        int cnt=1,n=v1.size(),maxi=INT_MIN,mini=INT_MAX;\\n        for(int i=0;i<n;i++)\\n        {\\n            maxi=max(maxi,v1[i]);\\n            mini=min(mini,v1[i]);\\n            if((maxi-mini)>k)\\n            {\\n                maxi=v1[i],mini=v1[i];\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n\\n    }\\n\\n    int partitionArray(vector<int>& v1, int k) {\\n    sort(v1.begin(),v1.end());\\n    \\n    int l=1,h=1e9,ans=INT_MAX;\\n\\n    while(l<=h)\\n    {\\n        \\n        int md=(l+h)/2;\\n        if(ans>=chck(v1,k,md))\\n        {\\n            ans=chck(v1,k,md);\\n        }\\n        else\\n        break;\\n        \\n        h=md-1;\\n    }\\n    \\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // int partitionArray(vector<int>& nums, int k) {\\n       int chck(vector<int>&v1,int k,int md)\\n    {\\n        int cnt=1,n=v1.size(),maxi=INT_MIN,mini=INT_MAX;\\n        for(int i=0;i<n;i++)\\n        {\\n            maxi=max(maxi,v1[i]);\\n            mini=min(mini,v1[i]);\\n            if((maxi-mini)>k)\\n            {\\n                maxi=v1[i],mini=v1[i];\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n\\n    }\\n\\n    int partitionArray(vector<int>& v1, int k) {\\n    sort(v1.begin(),v1.end());\\n    \\n    int l=1,h=1e9,ans=INT_MAX;\\n\\n    while(l<=h)\\n    {\\n        \\n        int md=(l+h)/2;\\n        if(ans>=chck(v1,k,md))\\n        {\\n            ans=chck(v1,k,md);\\n        }\\n        else\\n        break;\\n        \\n        h=md-1;\\n    }\\n    \\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3772968,
                "title": "greedy-approach",
                "content": "# Intuition\\nsorting and two pointer\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- o(n);\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- o(1);\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        int i =0, j=0;\\n        int count = 1;\\n          while( j<n){\\n           int z =  nums[j]- nums[i];\\n           if(z<=k){\\n               j++;\\n           }\\n           else{\\n               i =j;\\n               count++;\\n           }\\n          }\\n          return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        int i =0, j=0;\\n        int count = 1;\\n          while( j<n){\\n           int z =  nums[j]- nums[i];\\n           if(z<=k){\\n               j++;\\n           }\\n           else{\\n               i =j;\\n               count++;\\n           }\\n          }\\n          return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3645038,
                "title": "c-easy-to-understand-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        int ans = 1; //There will be atleast one such partition\\n        //start denotes the starting point of the partition\\n        //end denotes the ending point\\n        int start = 0, end = 0;\\n        \\n        //Sort and start traversing\\n        sort(nums.begin(),nums.end());\\n        while(end < nums.size()){\\n            if(nums[end]-nums[start] <= k){\\n                //If valid check for the next index\\n                end++;\\n            }\\n            else{\\n                //If invalid then move start to this index\\n                start = end;\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        int ans = 1; //There will be atleast one such partition\\n        //start denotes the starting point of the partition\\n        //end denotes the ending point\\n        int start = 0, end = 0;\\n        \\n        //Sort and start traversing\\n        sort(nums.begin(),nums.end());\\n        while(end < nums.size()){\\n            if(nums[end]-nums[start] <= k){\\n                //If valid check for the next index\\n                end++;\\n            }\\n            else{\\n                //If invalid then move start to this index\\n                start = end;\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3567057,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSort the array and apply this approach,  **how many elements can be push between minimum and maximum.**\\n\\n# Complexity\\n- Time complexity: O(N*logN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& arr, int k) {\\n        sort(arr.begin(),arr.end());\\n\\n        int n  = arr.size();\\n\\n        int mn  = arr[0];\\n        int mx  = arr[0];\\n\\n        int ans = 1;\\n\\n        for(int i = 0;i<n;i++)\\n        {\\n          mx = arr[i];\\n          if(mx-mn>k)\\n          {\\n          mn = arr[i];\\n          ans++;\\n          }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& arr, int k) {\\n        sort(arr.begin(),arr.end());\\n\\n        int n  = arr.size();\\n\\n        int mn  = arr[0];\\n        int mx  = arr[0];\\n\\n        int ans = 1;\\n\\n        for(int i = 0;i<n;i++)\\n        {\\n          mx = arr[i];\\n          if(mx-mn>k)\\n          {\\n          mn = arr[i];\\n          ans++;\\n          }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3552092,
                "title": "c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int count =0;\\n        int i=0; int j=0;\\n        while(j<nums.size()){\\n            if(abs(nums[i]-nums[j])<=k){\\n                j++;\\n            }\\n            else{\\n                count++;\\n                i=j;\\n            }\\n        }\\n\\n        return count+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int count =0;\\n        int i=0; int j=0;\\n        while(j<nums.size()){\\n            if(abs(nums[i]-nums[j])<=k){\\n                j++;\\n            }\\n            else{\\n                count++;\\n                i=j;\\n            }\\n        }\\n\\n        return count+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3507622,
                "title": "java-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int partitionArray(int[] nums, int k) {\\n         Arrays.sort(nums);\\n        int ans=1;\\n        int i=0, j=0;\\n        while(j<nums.length){\\n            if(i==j){\\n                j++;\\n                continue;\\n            }\\n            if(nums[j]-nums[i]<=k){\\n                j++;\\n            }\\n            else{\\n                ans++;\\n                i=j;\\n            }\\n        }\\nreturn ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int partitionArray(int[] nums, int k) {\\n         Arrays.sort(nums);\\n        int ans=1;\\n        int i=0, j=0;\\n        while(j<nums.length){\\n            if(i==j){\\n                j++;\\n                continue;\\n            }\\n            if(nums[j]-nums[i]<=k){\\n                j++;\\n            }\\n            else{\\n                ans++;\\n                i=j;\\n            }\\n        }\\nreturn ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367586,
                "title": "two-pointer-solution-cpp-o-1-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int count=0;\\n        int min=0;\\n        int max=0;\\n        while(max<nums.size())\\n        {\\n            if(abs(nums[max]-nums[min])<=k)\\n            {\\n                max++;\\n            }\\n            else\\n            {\\n                count++;\\n                min=max;\\n            }\\n        }\\n        return count+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int count=0;\\n        int min=0;\\n        int max=0;\\n        while(max<nums.size())\\n        {\\n            if(abs(nums[max]-nums[min])<=k)\\n            {\\n                max++;\\n            }\\n            else\\n            {\\n                count++;\\n                min=max;\\n            }\\n        }\\n        return count+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3355915,
                "title": "2294-simple-multiple-solutions-with-explanation-beats-96",
                "content": "\\n# Approach\\n- Two pointer + Greedy\\nSince we want the seperations to as minimum as possible we will use greedy and check with first and last and moves on to the right when a possible seperation is met the counter is updated and index of right is changed to starting index of previous seperation - 1 and left is set to 0 and approach goes on till right reaches 0.\\nBut sadly there are many worst case test cases so this doesn\\'t work properly the next code has the same time complexity irrespective of best or worst case \\n\\n# Complexity\\n- For this code the \\n Best case : O(1)\\nworst case may even go exponentially O(N^2)\\n\\n# Code - 1\\n```\\nclass Solution:\\n    def partitionArray(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        n = len(nums)\\n        left, right = 0, n - 1\\n        count = 0\\n        if k == 0:\\n            new = len(set(nums))\\n            return new\\n        while right >= 0 and left <= right:\\n            first, second = nums[left], nums[right]\\n            if left == right:\\n                count += 1\\n                right -= 1\\n                left = 0\\n                continue\\n            if second - first <= k:\\n                count += 1\\n                left, right = 0, left - 1\\n            else: left += 1\\n        return count\\n```\\n# Complexity\\n- TIme Complexity : O(N + Log(N))\\n# Code - 2\\n```\\nclass Solution:\\n    def partitionArray(self, nums: List[int], k: int) -> int:\\n        cnt = 1\\n        nums.sort()\\n        start = nums[0]\\n        for i in range(1,len(nums)):\\n            if nums[i]-start <= k:\\n                continue\\n            else:\\n                start = nums[i]\\n                cnt+= 1\\n        return cnt\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def partitionArray(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        n = len(nums)\\n        left, right = 0, n - 1\\n        count = 0\\n        if k == 0:\\n            new = len(set(nums))\\n            return new\\n        while right >= 0 and left <= right:\\n            first, second = nums[left], nums[right]\\n            if left == right:\\n                count += 1\\n                right -= 1\\n                left = 0\\n                continue\\n            if second - first <= k:\\n                count += 1\\n                left, right = 0, left - 1\\n            else: left += 1\\n        return count\\n```\n```\\nclass Solution:\\n    def partitionArray(self, nums: List[int], k: int) -> int:\\n        cnt = 1\\n        nums.sort()\\n        start = nums[0]\\n        for i in range(1,len(nums)):\\n            if nums[i]-start <= k:\\n                continue\\n            else:\\n                start = nums[i]\\n                cnt+= 1\\n        return cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3324535,
                "title": "php-100-faster-in-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    /**\\n     * @param Integer[] $nums\\n     * @param Integer $k\\n     * @return Integer\\n     */\\n    function partitionArray($nums, $k) {\\n        $result = 0;\\n        if ($k === 0 && count(array_count_values($nums)) === count($nums)) {\\n            return count($nums);\\n        }\\n        while (!empty($nums)) {\\n            $max = max($nums);\\n            $arr = array_filter($nums, function($val) use ($max, $k) {\\n                return $val >= $max - $k;\\n            });\\n            $nums = array_diff($nums, $arr);\\n            $result++;\\n        }\\n        return $result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nclass Solution {\\n\\n    /**\\n     * @param Integer[] $nums\\n     * @param Integer $k\\n     * @return Integer\\n     */\\n    function partitionArray($nums, $k) {\\n        $result = 0;\\n        if ($k === 0 && count(array_count_values($nums)) === count($nums)) {\\n            return count($nums);\\n        }\\n        while (!empty($nums)) {\\n            $max = max($nums);\\n            $arr = array_filter($nums, function($val) use ($max, $k) {\\n                return $val >= $max - $k;\\n            });\\n            $nums = array_diff($nums, $arr);\\n            $result++;\\n        }\\n        return $result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3132990,
                "title": "simple-and-easy-sorting-and-greedy-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int st = 0;\\n        int count =0;\\n        for(int i = 0;i<nums.size();i++)\\n        {\\n            if(nums[i]-nums[st]<=k)\\n            {\\n                if(i == nums.size()-1)\\n                {\\n                    count++;\\n                }\\n                continue;\\n            }\\n            else\\n            {\\n                    count++;\\n                    st = i;\\n                    i--;\\n            }\\n\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int st = 0;\\n        int count =0;\\n        for(int i = 0;i<nums.size();i++)\\n        {\\n            if(nums[i]-nums[st]<=k)\\n            {\\n                if(i == nums.size()-1)\\n                {\\n                    count++;\\n                }\\n                continue;\\n            }\\n            else\\n            {\\n                    count++;\\n                    st = i;\\n                    i--;\\n            }\\n\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2893027,
                "title": "c-200ms-faster-than-90-easy-approach-clean-concise-code",
                "content": "\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n\\n    int partitionArray(vector<int>& nums, int k) {\\n        \\n        sort(nums.begin(),nums.end());\\n\\n        int res = 1; n = nums.size(), mini = nums[0];\\n\\n        for(int i = 0; i < n; ++i)\\n        {\\n           if((nums[i] - mini) > k)\\n           {\\n               res++;\\n               mini = nums[i];\\n           }\\n        }\\n\\n        return res;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n\\n    int partitionArray(vector<int>& nums, int k) {\\n        \\n        sort(nums.begin(),nums.end());\\n\\n        int res = 1; n = nums.size(), mini = nums[0];\\n\\n        for(int i = 0; i < n; ++i)\\n        {\\n           if((nums[i] - mini) > k)\\n           {\\n               res++;\\n               mini = nums[i];\\n           }\\n        }\\n\\n        return res;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2862111,
                "title": "c-solution-using-sorting-and-map",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int partitionArray(vector<int>& nums, int k) \\n    {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        map<int,int> m;\\n        for(int x=0; x<n; x++) m[nums[x]]=x;\\n        int division=0;\\n        int i=0;\\n        while(i<n)\\n        {\\n            for(int x=nums[i]+k; x>=nums[i]; x--)\\n            {\\n                if(m.find(x)!=m.end()) \\n                {\\n                    division++;\\n                    i=m[x]+1;\\n                    break;\\n                }\\n            }\\n        }\\n        return division;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int partitionArray(vector<int>& nums, int k) \\n    {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        map<int,int> m;\\n        for(int x=0; x<n; x++) m[nums[x]]=x;\\n        int division=0;\\n        int i=0;\\n        while(i<n)\\n        {\\n            for(int x=nums[i]+k; x>=nums[i]; x--)\\n            {\\n                if(m.find(x)!=m.end()) \\n                {\\n                    division++;\\n                    i=m[x]+1;\\n                    break;\\n                }\\n            }\\n        }\\n        return division;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2817978,
                "title": "c-easy-to-understand-5-6-line-code",
                "content": "class Solution {\\npublic:\\n\\n    int partitionArray(vector<int>& nums, int k) {\\n        \\n        int j = 0;\\n        int ans = 1;    \\n        \\n       \\n        sort(nums.begin(), nums.end(), greater<int>());\\n        \\n       \\n        for(int i=1; i<nums.size(); i++){\\n            \\n            if(nums[j]- nums[i] > k){\\n                ans++;\\n                j = i;\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int partitionArray(vector<int>& nums, int k) {\\n        \\n        int j = 0;\\n        int ans = 1;    \\n        \\n       \\n        sort(nums.begin(), nums.end(), greater<int>());\\n        \\n       \\n        for(int i=1; i<nums.size(); i++){\\n            \\n            if(nums[j]- nums[i] > k){\\n                ans++;\\n                j = i;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2814393,
                "title": "java-easy-solution-on-sorting",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int partitionArray(int[] nums, int k) {\\n       Arrays.sort(nums);\\n        int res = 1, mn = nums[0], mx = nums[0];\\n        for (int a : nums) {\\n            mn = Math.min(mn, a);\\n            mx = Math.max(mx, a);\\n            if (mx - mn > k) {\\n                res ++;\\n                mn = mx = a;\\n            }\\n        }\\n        return res; \\n    }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int partitionArray(int[] nums, int k) {\\n       Arrays.sort(nums);\\n        int res = 1, mn = nums[0], mx = nums[0];\\n        for (int a : nums) {\\n            mn = Math.min(mn, a);\\n            mx = Math.max(mx, a);\\n            if (mx - mn > k) {\\n                res ++;\\n                mn = mx = a;\\n            }\\n        }\\n        return res; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2814047,
                "title": "c-easy-solution-sorting",
                "content": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int cnt=0;\\n        int j=0;\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            if(nums[i]-nums[j]>k){\\n                cnt++;\\n                j=i;\\n            }\\n        }\\n        cnt++;\\n        return cnt;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int cnt=0;\\n        int j=0;\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            if(nums[i]-nums[j]>k){\\n                cnt++;\\n                j=i;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2643689,
                "title": "java-brute-force-easy-solution-o-nlogn",
                "content": "# Code\\n```\\nclass Solution {\\n    public int partitionArray(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int count = 1;\\n        int start=nums[0];\\n        for(int i=0;i<nums.length;i++){\\n           if(nums[i]-start>k){\\n               start=nums[i];\\n                count++;\\n           } \\n        }return count;\\n    }\\n}   \\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int partitionArray(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int count = 1;\\n        int start=nums[0];\\n        for(int i=0;i<nums.length;i++){\\n           if(nums[i]-start>k){\\n               start=nums[i];\\n                count++;\\n           } \\n        }return count;\\n    }\\n}   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2612394,
                "title": "java-sort-clean-solution",
                "content": "```\\nclass Solution {\\n    public int partitionArray(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int res = 0;\\n        int range = -1;\\n        for(int i =0;i<nums.length;i++){\\n            if(nums[i]<=range) continue;\\n            else{\\n                range = nums[i]+k;\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int partitionArray(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int res = 0;\\n        int range = -1;\\n        for(int i =0;i<nums.length;i++){\\n            if(nums[i]<=range) continue;\\n            else{\\n                range = nums[i]+k;\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2574773,
                "title": "c-sorting-binary-search-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n       \\n        sort(nums.begin(),nums.end());\\n       \\n        int ans=0;\\n        int j=0;\\n        while(j<nums.size())\\n        {\\n           auto i=upper_bound(nums.begin(),nums.end(),nums[j]+k);\\n           int index=int(i-nums.begin());\\n            \\n           ans++;\\n           j=index;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n       \\n        sort(nums.begin(),nums.end());\\n       \\n        int ans=0;\\n        int j=0;\\n        while(j<nums.size())\\n        {\\n           auto i=upper_bound(nums.begin(),nums.end(),nums[j]+k);\\n           int index=int(i-nums.begin());\\n            \\n           ans++;\\n           j=index;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2569752,
                "title": "java-simple-and-short-solution-88-memory-with-explanation",
                "content": "\\n```\\nclass Solution {\\n    public int partitionArray(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int count = 1;\\n        int start = nums[0];\\n\\t\\t//for each iteration I find difference between first element of subsequence\\n\\t\\t//and current element. If difference is > than k, then I just increment subsequence count\\n\\t\\t//and make current element as start element for the next subsequence\\n        for (int i = 1; i < nums.length; i++) {\\n            if (nums[i] - start > k) {\\n                count++;\\n                start = nums[i];\\n            }\\n        }\\n        return count;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int partitionArray(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int count = 1;\\n        int start = nums[0];\\n\\t\\t//for each iteration I find difference between first element of subsequence\\n\\t\\t//and current element. If difference is > than k, then I just increment subsequence count\\n\\t\\t//and make current element as start element for the next subsequence\\n        for (int i = 1; i < nums.length; i++) {\\n            if (nums[i] - start > k) {\\n                count++;\\n                start = nums[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2519425,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end()); \\n        int maxi= INT_MIN; int mini= INT_MAX; int count=0; int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            mini= min(mini,nums[i]);\\n            maxi=max(maxi, nums[i]);\\n            if(maxi-mini <=k)\\n                continue;\\n            else\\n            {\\n                count++;\\n                maxi=INT_MIN;\\n                mini= INT_MAX;\\n                i--;\\n            }  \\n        }\\n        return count+1;\\n    }\\n};",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end()); \\n        int maxi= INT_MIN; int mini= INT_MAX; int count=0; int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            mini= min(mini,nums[i]);\\n            maxi=max(maxi, nums[i]);\\n            if(maxi-mini <=k)\\n                continue;\\n            else\\n            {\\n                count++;\\n                maxi=INT_MIN;\\n                mini= INT_MAX;\\n                i--;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2399329,
                "title": "sorting-easy-2-pointer",
                "content": "class Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int cnt=1;\\n        int i=0,j=1;\\n        while(j<nums.size())\\n        {\\n            if (nums[j]-nums[i]<=k)\\n            {\\n                j++;\\n            }\\n            else\\n            {\\n                cnt++;\\n                i=j;\\n            }\\n            \\n            \\n        }\\n        return cnt;\\n    }\\n};",
                "solutionTags": [
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int cnt=1;\\n        int i=0,j=1;\\n        while(j<nums.size())\\n        {\\n            if (nums[j]-nums[i]<=k)\\n            {\\n                j++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2297034,
                "title": "java-explained-two-approach-use-one-loop",
                "content": "```\\n\\n```class Solution {\\n    public int partitionArray(int[] nums, int k) {\\n        Arrays.sort(nums); // we sort the array so it will be easy for us to track \\n        int count=1;\\n        int start=0;//for the smallest number\\n        for(int i=0;i<nums.length;i++){\\n            \\n            //basically if the diff b/w smallest and larget number is greater \\n            //than k then we do change the minimum and  \\n            //shift the numbwe into new subsequence and +1 the count;\\n            if(nums[i]-nums[start]>k){\\n                start=i;\\n                count++;\\n            }\\n            // if(nums[i]-nums[start]<=k){\\n            // continue;\\n            // }else{\\n            //     start=i;\\n            //     count++;\\n            // }\\n        }\\n        return count;\\n    }\\n}\\n//kindly upvote if you find it helpful",
                "solutionTags": [],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2287274,
                "title": "python3-o-n-min-max-blocks-counts",
                "content": "```\\nclass Solution:\\n    def partitionArray(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        res=1\\n        minm=nums[0]\\n        maxm=nums[0]\\n        for x in nums:\\n            if abs(x-minm)>k or abs(x-maxm)>k:\\n                res+=1\\n                minm=x\\n                maxm=x\\n            else:\\n                minm=min(minm,x)\\n                maxm=max(maxm,x)\\n        return res\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def partitionArray(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        res=1\\n        minm=nums[0]\\n        maxm=nums[0]\\n        for x in nums:\\n            if abs(x-minm)>k or abs(x-maxm)>k:\\n                res+=1\\n                minm=x\\n                maxm=x\\n            else:\\n                minm=min(minm,x)\\n                maxm=max(maxm,x)\\n        return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2282069,
                "title": "60-tc-and-78-sc-easy-python-solution-using-binary-search",
                "content": "```\\ndef partitionArray(self, nums: List[int], k: int) -> int:\\n\\tans = 0\\n\\tnums.sort()\\n\\ti = 0\\n\\twhile(i < len(nums)):\\n\\t\\ti = bisect_right(nums, nums[i]+k, i)\\n\\t\\tans += 1\\n\\treturn ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy",
                    "Binary Tree"
                ],
                "code": "```\\ndef partitionArray(self, nums: List[int], k: int) -> int:\\n\\tans = 0\\n\\tnums.sort()\\n\\ti = 0\\n\\twhile(i < len(nums)):\\n\\t\\ti = bisect_right(nums, nums[i]+k, i)\\n\\t\\tans += 1\\n\\treturn ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2253700,
                "title": "brute-force-to-optimized-c",
                "content": "# Brute force (TLE)\\n*Time complexity: worst case - O(n ^ 2)*\\n```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        sort(nums.begin(), nums.end());\\n        \\n        int i = 0, j = nums.size() - 1, ans = 0;\\n        \\n        while(i < nums.size()) {\\n            if(nums[j] - nums[i] <= k) ans++, i = j + 1, j = nums.size() - 1;\\n            else j--;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n# Optimized\\n```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        sort(nums.begin(), nums.end());\\n        \\n        int mn = INT_MAX, mx = INT_MIN, ans = 1;\\n        for(int i : nums) {\\n            mn = min(mn, i);\\n            mx = max(mx, i);\\n            \\n            if(mx - mn > k) ans++, mn = mx = i;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        sort(nums.begin(), nums.end());\\n        \\n        int i = 0, j = nums.size() - 1, ans = 0;\\n        \\n        while(i < nums.size()) {\\n            if(nums[j] - nums[i] <= k) ans++, i = j + 1, j = nums.size() - 1;\\n            else j--;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        sort(nums.begin(), nums.end());\\n        \\n        int mn = INT_MAX, mx = INT_MIN, ans = 1;\\n        for(int i : nums) {\\n            mn = min(mn, i);\\n            mx = max(mx, i);\\n            \\n            if(mx - mn > k) ans++, mn = mx = i;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2201487,
                "title": "java-sort-binary-search-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int partitionArray(int[] nums, int k) \\n    {\\n        Arrays.sort(nums);\\n        \\n        int ans=0;\\n        int i=0;\\n        \\n        while(i<nums.length)\\n        {\\n           int curr=nums[i];\\n           ans++; \\n           int pos=binarySearch(nums,i,nums[i]+k+1);\\n           i=pos;\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    public int binarySearch(int nums[],int start,int target)\\n    {\\n        int n=nums.length;\\n        int end=n-1;int ans=n;\\n        \\n        while(start<=end)\\n        {\\n            int mid=start+(end-start)/2;\\n            \\n            if(nums[mid]>=target)\\n            {\\n                ans=mid;\\n                end=mid-1;\\n            }\\n            \\n            else\\n            start=mid+1;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int partitionArray(int[] nums, int k) \\n    {\\n        Arrays.sort(nums);\\n        \\n        int ans=0;\\n        int i=0;\\n        \\n        while(i<nums.length)\\n        {\\n           int curr=nums[i];\\n           ans++; \\n           int pos=binarySearch(nums,i,nums[i]+k+1);\\n           i=pos;\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    public int binarySearch(int nums[],int start,int target)\\n    {\\n        int n=nums.length;\\n        int end=n-1;int ans=n;\\n        \\n        while(start<=end)\\n        {\\n            int mid=start+(end-start)/2;\\n            \\n            if(nums[mid]>=target)\\n            {\\n                ans=mid;\\n                end=mid-1;\\n            }\\n            \\n            else\\n            start=mid+1;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2173730,
                "title": "java-easy-to-understand-o-nlogn-sorting-beginner-friendly-simple-approach",
                "content": "class Solution {\\n    public int partitionArray(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int start = 0;\\n        int count=1;\\n        for(int i=1;i<nums.length;i++){\\n            if((nums[i]-nums[start])>k){\\n                start = i;\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n\\n// Note :- Please upvote if you find it helpful ... Thank you ..!",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Sorting"
                ],
                "code": "class Solution {\\n    public int partitionArray(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int start = 0;\\n        int count=1;\\n        for(int i=1;i<nums.length;i++){\\n            if((nums[i]-nums[start])>k){\\n                start = i;\\n                count++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2165764,
                "title": "java-sort-and-compare",
                "content": "```\\nclass Solution {\\n    public int partitionArray(int[] nums, int k) \\n    {\\n        Arrays.sort(nums);\\n        \\n        int i =1;\\n        int prev_val = nums[0];\\n        int result =1;\\n        \\n        while(i < nums.length)\\n        {\\n            if(nums[i] - prev_val > k)\\n            {\\n                result++;\\n                prev_val = nums[i];\\n            }\\n            i++;\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int partitionArray(int[] nums, int k) \\n    {\\n        Arrays.sort(nums);\\n        \\n        int i =1;\\n        int prev_val = nums[0];\\n        int result =1;\\n        \\n        while(i < nums.length)\\n        {\\n            if(nums[i] - prev_val > k)\\n            {\\n                result++;\\n                prev_val = nums[i];\\n            }\\n            i++;\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2161908,
                "title": "c-simple-soution-using-sorting",
                "content": "```\\nint partitionArray(vector<int>& nums, int k) {\\n        \\n        sort(nums.begin(),nums.end());\\n        \\n        int res = 0 , i = 0 , j = 0 , n = nums.size();\\n      \\n        while(j<n){\\n            if(nums[j]-nums[i] > k){                \\n                res++;\\n                i = j;  \\n            }\\n            j++;\\n        }\\n        ++res;\\n        \\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nint partitionArray(vector<int>& nums, int k) {\\n        \\n        sort(nums.begin(),nums.end());\\n        \\n        int res = 0 , i = 0 , j = 0 , n = nums.size();\\n      \\n        while(j<n){\\n            if(nums[j]-nums[i] > k){                \\n                res++;\\n                i = j;  \\n            }\\n            j++;\\n        }\\n        ++res;\\n        \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2141591,
                "title": "c-6-lines-sort-2-pointer-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int cnt = 1,low = 0,i=0;\\n\\t\\t//low points to min element and i points to max \\n\\t\\t//whenever their difference exceeds k we update low index and increment counter\\n       while(i<nums.size())\\n       {\\n            if(nums[i]-nums[low] <= k) i++;\\n            else low = i,cnt++;\\n       }\\n        return cnt;             \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int cnt = 1,low = 0,i=0;\\n\\t\\t//low points to min element and i points to max \\n\\t\\t//whenever their difference exceeds k we update low index and increment counter\\n       while(i<nums.size())\\n       {\\n            if(nums[i]-nums[low] <= k) i++;\\n            else low = i,cnt++;\\n       }\\n        return cnt;             \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2139697,
                "title": "o-n-solution-c-88ms-beats-100-and-java-11ms-beats-99-73",
                "content": "C++:\\n```\\nconst int ZERO = []() {\\n    ios_base::sync_with_stdio(false);\\n    cin.tie(nullptr);\\n    return 0;\\n}();\\n\\nclass Solution {\\npublic:\\n    bool a[100005];\\n    \\n    int partitionArray(vector<int>& nums, int k) {\\n        int mx = -1;\\n        for(int num: nums){\\n            a[num] = 1;\\n            mx = max(num, mx);\\n        }\\n        \\n        int ans = 0;\\n        int l = 0;\\n        while(l <= mx){\\n            while(l <= mx && !a[l]) l++;\\n            l += k + 1;\\n            while(l <= mx && !a[l]) l++;\\n            ans++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n\\nJava:\\n```\\nclass Solution {\\n    boolean a[] = new boolean[100004];\\n    \\n    public int partitionArray(int[] nums, int k) {\\n        int mx = -1;\\n        for(int num: nums){\\n            a[num] = true;\\n            mx = Math.max(num, mx);\\n        }\\n        \\n        int ans = 0;\\n        int l = 0;\\n        while(l <= mx){\\n            while(l <= mx && !a[l]) l++;\\n            l += k + 1;\\n            while(l <= mx && !a[l]) l++;\\n            ans++;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nconst int ZERO = []() {\\n    ios_base::sync_with_stdio(false);\\n    cin.tie(nullptr);\\n    return 0;\\n}();\\n\\nclass Solution {\\npublic:\\n    bool a[100005];\\n    \\n    int partitionArray(vector<int>& nums, int k) {\\n        int mx = -1;\\n        for(int num: nums){\\n            a[num] = 1;\\n            mx = max(num, mx);\\n        }\\n        \\n        int ans = 0;\\n        int l = 0;\\n        while(l <= mx){\\n            while(l <= mx && !a[l]) l++;\\n            l += k + 1;\\n            while(l <= mx && !a[l]) l++;\\n            ans++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    boolean a[] = new boolean[100004];\\n    \\n    public int partitionArray(int[] nums, int k) {\\n        int mx = -1;\\n        for(int num: nums){\\n            a[num] = true;\\n            mx = Math.max(num, mx);\\n        }\\n        \\n        int ans = 0;\\n        int l = 0;\\n        while(l <= mx){\\n            while(l <= mx && !a[l]) l++;\\n            l += k + 1;\\n            while(l <= mx && !a[l]) l++;\\n            ans++;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2137517,
                "title": "scala-solution",
                "content": "```\\n\\n  def partitionArray(nums: Array[Int], k: Int): Int = {\\n    nums.sorted.foldLeft((1, nums.min))((acc, cur) =>{\\n      cur - acc._2 > k match {\\n        case true => (acc._1 + 1, cur)\\n        case _ => acc\\n      }\\n    })._1\\n  }\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\n\\n  def partitionArray(nums: Array[Int], k: Int): Int = {\\n    nums.sorted.foldLeft((1, nums.min))((acc, cur) =>{\\n      cur - acc._2 > k match {\\n        case true => (acc._1 + 1, cur)\\n        case _ => acc\\n      }\\n    })._1\\n  }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2125842,
                "title": "2-pointers-c",
                "content": "class Solution {\\npublic:\\n\\n    int partitionArray(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int i=0,j=0,ans=0;\\n        while(i<nums.size()&&j<nums.size()){\\n            if(nums[j]-nums[i]<=k)j++;\\n            else {\\n                i=j;\\n                ans++;\\n            }\\n        }\\n        return ans+1;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    int partitionArray(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int i=0,j=0,ans=0;\\n        while(i<nums.size()&&j<nums.size()){\\n            if(nums[j]-nums[i]<=k)j++;\\n            else {\\n                i=j;\\n                ans++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2123140,
                "title": "c",
                "content": "\\tPartition Array Such That Maximum Difference Is K\\nclass Solution {\\npublic:\\n         \\n        int i=0,j=i+1,count=1;\\n        int length=nums.size();\\n        sort(nums.begin(),nums.end());\\n        while(j<length)\\n        {\\n            if(nums[j]-nums[i]>k)\\n            {\\n                count++;\\n                i=j;\\n            }\\n            j++;\\n        }\\n        return count;\\n    }\\n};",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "class Solution {\\npublic:\\n         \\n        int i=0,j=i+1,count=1;\\n        int length=nums.size();\\n        sort(nums.begin(),nums.end());\\n        while(j<length)\\n        {\\n            if(nums[j]-nums[i]>k)\\n            {\\n                count++;\\n                i=j;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2116566,
                "title": "queue-sorting-approach-in-partition-array",
                "content": "Priority Queue TC:- O(n log n)\\n```\\nclass Solution {\\n     public int partitionArray(int[] nums, int k) {\\n        return usePriorityQueue(nums, k);\\n    }\\n    \\n    public int usePriorityQueue(int[] nums, int k) {\\n     PriorityQueue<Integer> p = new PriorityQueue<>();\\n     for(int num : nums){\\n         p.offer(num);\\n     }\\n        int ans = 0;\\n        while(!p.isEmpty()){\\n            ans++;\\n            int val = p.poll();\\n            while(!p.isEmpty() && p.peek() - val <= k){\\n                p.poll();\\n            }\\n        }\\n        return ans ; \\n    }\\n}\\n```\\nvia Sorting  \\n```\\nclass Solution {\\n    public int partitionArray(int[] nums, int k) {\\n         Arrays.sort(nums);\\n    \\n    int ans=1,j=0;\\n    for(int i=1;i<nums.length;i++)\\n    {\\n       \\n        if(nums[i]-nums[j]>k)\\n        {\\n            ans++;\\n            j=i;\\n        }\\n        else\\n        {\\n            continue;\\n        }\\n            \\n    }\\n    return ans;\\n    }\\n}\\n```\\n\\nTime complexity = O(n log n)",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n     public int partitionArray(int[] nums, int k) {\\n        return usePriorityQueue(nums, k);\\n    }\\n    \\n    public int usePriorityQueue(int[] nums, int k) {\\n     PriorityQueue<Integer> p = new PriorityQueue<>();\\n     for(int num : nums){\\n         p.offer(num);\\n     }\\n        int ans = 0;\\n        while(!p.isEmpty()){\\n            ans++;\\n            int val = p.poll();\\n            while(!p.isEmpty() && p.peek() - val <= k){\\n                p.poll();\\n            }\\n        }\\n        return ans ; \\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int partitionArray(int[] nums, int k) {\\n         Arrays.sort(nums);\\n    \\n    int ans=1,j=0;\\n    for(int i=1;i<nums.length;i++)\\n    {\\n       \\n        if(nums[i]-nums[j]>k)\\n        {\\n            ans++;\\n            j=i;\\n        }\\n        else\\n        {\\n            continue;\\n        }\\n            \\n    }\\n    return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2116251,
                "title": "python",
                "content": "```python\\n        nums.sort()\\n        left = res = 0\\n        for right in range(len(nums)):\\n            if nums[right] - nums[left] > k:\\n                res += 1\\n                left = right\\n        return res + 1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\n        nums.sort()\\n        left = res = 0\\n        for right in range(len(nums)):\\n            if nums[right] - nums[left] > k:\\n                res += 1\\n                left = right\\n        return res + 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2114688,
                "title": "java-solution-by-sorting-the-array",
                "content": "```\\nclass Solution {\\n    public int partitionArray(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int partition=0;\\n        int start=0;\\n        for(int i=0;i<nums.length;++i)\\n        {\\n            if(nums[i]-nums[start]<=k)\\n            {\\n                if(i==nums.length-1)\\n                {\\n                    ++partition;\\n                }\\n            }\\n            else\\n            {\\n                start=i;\\n                ++partition;\\n                --i;\\n            }\\n        }\\n        return partition;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int partitionArray(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int partition=0;\\n        int start=0;\\n        for(int i=0;i<nums.length;++i)\\n        {\\n            if(nums[i]-nums[start]<=k)\\n            {\\n                if(i==nums.length-1)\\n                {\\n                    ++partition;\\n                }\\n            }\\n            else\\n            {\\n                start=i;\\n                ++partition;\\n                --i;\\n            }\\n        }\\n        return partition;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2114451,
                "title": "c-sorting-greedy",
                "content": "**Approach** :\\nIn problem statement, it states that min and max of every subsequence should have difference of at most k. First thing that comes to mind is to collect all elements that are in each other\\'s vicinity. Since here vicinity is matter of difference, best way to collect these elements is sorting. \\n\\nNow, for minimizing number of subsequences, we\\'ll try to make each subsequence as long as possible. Therefore, we\\'ll keep on picking up elements as long as difference is at most k. By this way, we are keeping bounds of each subsequence as tight as possible so that next subsequence to be added won\\'t get affected with this.\\n\\n**Code** :\\n```\\nint partitionArray(vector<int>& nums, int k) {\\n        int ans = 1;\\n        int n = nums.size();\\n        sort(nums.begin(),nums.end());\\n        int min_num = nums[0];\\n        for(int i = 1; i < n; i++)\\n        {\\n            if(nums[i] - min_num > k)\\n            {\\n                ans++;\\n                min_num = nums[i];\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nint partitionArray(vector<int>& nums, int k) {\\n        int ans = 1;\\n        int n = nums.size();\\n        sort(nums.begin(),nums.end());\\n        int min_num = nums[0];\\n        for(int i = 1; i < n; i++)\\n        {\\n            if(nums[i] - min_num > k)\\n            {\\n                ans++;\\n                min_num = nums[i];\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2114260,
                "title": "c-sorting-binary-search",
                "content": "```\\nint binarySearch(int low,int high,vector<int>&nums, int k,int left){\\n       int ans;\\n        while(low<=high){\\n            int mid = (low+high)/2;\\n            if(nums[mid]-left<=k){\\n                ans = mid;\\n                low=mid+1;\\n            }\\n            else{\\n                high=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n    int partitionArray(vector<int>& nums, int k) {\\n        int left=0, right = nums.size()-1;\\n        sort(nums.begin(),nums.end());\\n        int count=1;\\n        while(left<=right){\\n            if(nums[right]-nums[left]<=k){\\n                break;\\n            }\\n            else{\\n                int idx = binarySearch(left,right,nums,k,nums[left]);\\n                count++;\\n                left=idx+1;\\n            }\\n        }\\n        return count;\\n    }",
                "solutionTags": [],
                "code": "```\\nint binarySearch(int low,int high,vector<int>&nums, int k,int left){\\n       int ans;\\n        while(low<=high){\\n            int mid = (low+high)/2;\\n            if(nums[mid]-left<=k){\\n                ans = mid;\\n                low=mid+1;\\n            }\\n            else{\\n                high=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n    int partitionArray(vector<int>& nums, int k) {\\n        int left=0, right = nums.size()-1;\\n        sort(nums.begin(),nums.end());\\n        int count=1;\\n        while(left<=right){\\n            if(nums[right]-nums[left]<=k){\\n                break;\\n            }\\n            else{\\n                int idx = binarySearch(left,right,nums,k,nums[left]);\\n                count++;\\n                left=idx+1;\\n            }\\n        }\\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2114252,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public int partitionArray(int[] nums, int k) {\\n        if(nums== null || nums.length==0) return 0;\\n        Arrays.sort(nums);\\n        int count=1;\\n        int min= Integer.MAX_VALUE;\\n        int max= Integer.MIN_VALUE;\\n        for(int val: nums){\\n            min= Math.min(val, min);\\n            max= Math.max(val, max);\\n            if(max-min> k){\\n                count++;\\n                min= max;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int partitionArray(int[] nums, int k) {\\n        if(nums== null || nums.length==0) return 0;\\n        Arrays.sort(nums);\\n        int count=1;\\n        int min= Integer.MAX_VALUE;\\n        int max= Integer.MIN_VALUE;\\n        for(int val: nums){\\n            min= Math.min(val, min);\\n            max= Math.max(val, max);\\n            if(max-min> k){\\n                count++;\\n                min= max;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2113580,
                "title": "c-faster-than-100-easy-understanding",
                "content": "**As they asked for only number of subsequences, we should\\'nt worry about the order of the elements, thus we can sort the nums array.**\\n\\nnow we take 2 variables, start and next, initially both are set to 0\\nnow we loop until start < n, else it\\'ll be out of bounds\\n\\nwe keep on increasing the next pointer, if \\n1. it is less than n\\n2. nums[next] - nums[start] <= k\\n\\nonce it fails the condition, i.e the start element and the last element (next) difference crossed k, we break out and increment the count of ans.\\n\\n***we dont consider the last element (next) as it didnt meet the condition, and now we set the start to last element (next) as we start a new subsequnce.***\\n\\n```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        int ans = 0;\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        int start = 0;\\n        int next = 0;\\n        while(start < n){\\n            while(next < n and nums[next] - nums[start] <= k){\\n                next++;\\n            }\\n            ans++;\\n            start = next;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        int ans = 0;\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        int start = 0;\\n        int next = 0;\\n        while(start < n){\\n            while(next < n and nums[next] - nums[start] <= k){\\n                next++;\\n            }\\n            ans++;\\n            start = next;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2113457,
                "title": "o-n-c-sort-select-easy-understanding-full-explained",
                "content": "Just sort the given array and keep track of the minimum and maximum element. When the minimum element changes, you make an extra subsequence. The minimum element is changed the moment when nums[i]-min > k\\n\\n```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        sort(begin(nums),end(nums));\\n        int n = nums.size();\\n        int ans = 0;\\n        int cmin = nums[0];\\n        for(int i = 1;i<n;i++){\\n            if(nums[i]-cmin > k){\\n                cmin = nums[i];\\n                \\n                ans++;\\n            }\\n        }\\n        return ans+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        sort(begin(nums),end(nums));\\n        int n = nums.size();\\n        int ans = 0;\\n        int cmin = nums[0];\\n        for(int i = 1;i<n;i++){\\n            if(nums[i]-cmin > k){\\n                cmin = nums[i];\\n                \\n                ans++;\\n            }\\n        }\\n        return ans+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2113442,
                "title": "simple-5-line-code-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int ans=0,j=0;\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]-nums[j]>k){\\n                ans++;\\n                j=i;\\n            }\\n        }\\n        return ans+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int ans=0,j=0;\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]-nums[j]>k){\\n                ans++;\\n                j=i;\\n            }\\n        }\\n        return ans+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2113263,
                "title": "c-greedy",
                "content": "We need to find subsequence so we can sort the array and use sliding window to keep check for max - min, whenever it exceeds we increment cnt by 1 and change the lo pointer\\n```\\nclass Solution {\\npublic:\\n\\tint partitionArray(vector<int>& nums, int k) {\\n\\t\\tsort(nums.begin(), nums.end());\\n\\t\\tint cnt = 1, n = nums.size(), lo = 0;\\n\\t\\tfor (int i = 1; i < n; ++i) {\\n\\t\\t\\tif (nums[i] - nums[lo] > k) {\\n\\t\\t\\t\\tcnt++;\\n\\t\\t\\t\\tlo = i;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn cnt;\\n\\t}\\n};",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Sliding Window"
                ],
                "code": "class Solution {\\npublic:\\n\\tint partitionArray(vector<int>& nums, int k) {\\n\\t\\tsort(nums.begin(), nums.end());\\n\\t\\tint cnt = 1, n = nums.size(), lo = 0;\\n\\t\\tfor (int i = 1; i < n; ++i) {\\n\\t\\t\\tif (nums[i] - nums[lo] > k) {\\n\\t\\t\\t\\tcnt++;\\n\\t\\t\\t\\tlo = i;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2113191,
                "title": "c-easy-sorting-full-explanation-intution",
                "content": "**Task:**\\n\\nReturn\\xA0the\\xA0minimum\\xA0number of subsequences needed such that the difference between the maximum and minimum values in each subsequence is\\xA0at most\\xA0k.\\n\\n**Constraints:**\\n\\nlength<=10^5\\nSo (10^5)^2 = 10^10 is not possible i.e O(n^2) fails.\\nWe need to think in O(nlogn) or O(logn) or O(n)\\ni.e sorting/logrithmic/linear\\n\\n**Approach:**\\n\\nWe only care about the count of subsequences where (max-min)<=k\\n\\nConsider,\\n\\n[3,6,1,2,5] k=2\\n\\nHere we see\\nmax-min <=k\\n\\n3-1=2<=k\\n6-5=1<=k\\n2-2=0<=k\\n\\nSo subsequences are  [3,1] [6,5] ,[2]\\nBut we need minimum no. of subsequences \\nSo we include 2 in [3,1] which doesn\\'t change diff of max and min and 3-1=2<=k still holds true\\n\\nso new subseqnces are [3,1,2] and [6,5]\\n\\nSo we observed we included 2 in the range of min and max to minimise no. of subsequences\\n\\nThus we get the idea that we should consider only max and min and any other numbers that lie in this range should lie in the same subsequence for count to be min.\\n\\nThus if we sort the array\\nleft part would be min and right part will be maximum\\n\\n[1,2,3,5,6]\\n\\nWe can check the following considering absolute difference abs(min-max)<=k\\n\\n1-2=1<=k\\n1-3=2<=k\\n1-5=4>k condition breaks means we have found one subsequence [1,2,3] here, so cnt++\\n\\nNow move to 5\\n5-6=1<=k , cnt++ \\n\\nThus cnt=2 we found 2 subsequences [1,2,3] and [5,6]\\n\\n**>>Edge case:**\\n\\nConsider\\n[1,2,3] k=1\\n\\n1-2=1<=k\\n1-3=2>k condition breaks here cnt++\\nEnd of array\\n\\ncnt =1\\n\\nBut wait we should have 2 subsequences \\n[1,2] and [3] alone\\n\\nwe only found out [1,2]\\n\\nSo whenever condition breaks we do i--\\nSo that the abs diff of element itself is checked\\nsince single element can be a subsequence\\n\\nThus\\n1-2=1<=k\\n1-3=2>k cnt++ ,  i--\\n3-3=0<=k cnt++\\nThus cnt=2\\n\\nAlso we see sorting makes us consider each element in only one subsequence as mentioned in the question as we traverse linearly only once.\\n\\nAlso if we have just one element(max==min) in array ans will be always 1 independent of k since max-min will be 0.\\n\\n**Time Complexity:**\\n\\nSorting + linear\\nO(nlogn)+O(n) = O(nlogn) \\n\\n**Code:**\\n\\n```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        int n=nums.size();\\n\\t\\tif(n==1) return 1;\\n\\t\\t\\n        sort(nums.begin(),nums.end());\\n        int cnt=0;\\n        int idx=0;\\n        int diff;\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            diff= abs(nums[idx] - nums[i]);\\n            if(diff>k){\\n                cnt++;\\n                idx = i;\\n                i--;\\n             }\\n\\n       }\\n       if(diff<=k) cnt++;\\n        \\n        return cnt;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        int n=nums.size();\\n\\t\\tif(n==1) return 1;\\n\\t\\t\\n        sort(nums.begin(),nums.end());\\n        int cnt=0;\\n        int idx=0;\\n        int diff;\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            diff= abs(nums[idx] - nums[i]);\\n            if(diff>k){\\n                cnt++;\\n                idx = i;\\n                i--;\\n             }\\n\\n       }\\n       if(diff<=k) cnt++;\\n        \\n        return cnt;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112669,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using Sorting***\\n\\n* ***Time Complexity : O(NlogN)***\\n\\n* ***Space Complexity : O(1)***\\n\\n```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& arr, int k) {\\n        \\n        sort(arr.begin(), arr.end());\\n        \\n        int left = 0;\\n        \\n        int right = 0;\\n        \\n        int count = 1;\\n        \\n        while(right < arr.size())\\n        {\\n            while(right < arr.size() && (arr[right] - arr[left]) <= k)\\n            {\\n                right++; \\n            }\\n            \\n            if(right < arr.size())\\n            {\\n                count++;\\n            \\n                left = right;\\n            }  \\n        }\\n        \\n        return count; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& arr, int k) {\\n        \\n        sort(arr.begin(), arr.end());\\n        \\n        int left = 0;\\n        \\n        int right = 0;\\n        \\n        int count = 1;\\n        \\n        while(right < arr.size())\\n        {\\n            while(right < arr.size() && (arr[right] - arr[left]) <= k)\\n            {\\n                right++; \\n            }\\n            \\n            if(right < arr.size())\\n            {\\n                count++;\\n            \\n                left = right;\\n            }  \\n        }\\n        \\n        return count; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112642,
                "title": "javascript-simple-and-easy",
                "content": "If you like please upvote :)\\n\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar partitionArray = function(nums, k) {\\n  \\n    nums.sort((a,b) =>{ return a-b})\\n    \\n    let n = nums.length ,ans=0\\n    \\n    for(let i=0 ; i<n; i++){\\n        let ele = nums[i]\\n        while(i<n && nums[i]-ele<=k) i++\\n        i--\\n        ans++\\n    }\\n    return ans\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar partitionArray = function(nums, k) {\\n  \\n    nums.sort((a,b) =>{ return a-b})\\n    \\n    let n = nums.length ,ans=0\\n    \\n    for(let i=0 ; i<n; i++){\\n        let ele = nums[i]\\n        while(i<n && nums[i]-ele<=k) i++\\n        i--\\n        ans++\\n    }\\n    return ans\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2112567,
                "title": "c-294-ms",
                "content": "\\n```\\n    public int PartitionArray(int[] nums, int k) {\\n        \\n        Array.Sort(nums);\\n        \\n        int count = 1;\\n        int maxSubsequence = nums[0] + k;\\n        \\n        for(int i = 1; i < nums.Length; i++){\\n            if(nums[i] > maxSubsequence){\\n                count++;\\n                maxSubsequence = nums[i] + k;\\n            }\\n        }\\n        \\n        return count;\\n        \\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    public int PartitionArray(int[] nums, int k) {\\n        \\n        Array.Sort(nums);\\n        \\n        int count = 1;\\n        int maxSubsequence = nums[0] + k;\\n        \\n        for(int i = 1; i < nums.Length; i++){\\n            if(nums[i] > maxSubsequence){\\n                count++;\\n                maxSubsequence = nums[i] + k;\\n            }\\n        }\\n        \\n        return count;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2112414,
                "title": "python3-easy-intuitive-method-sliding-window",
                "content": "```\\nclass Solution:\\n    def partitionArray(self, nums: List[int], k: int) -> int:\\n        nums.sort(reverse = True)\\n        # print(nums)\\n        initial = nums[0]\\n        count = 0\\n        for i in range(1, len(nums)):\\n            if initial - nums[i] > k:\\n                initial = nums[i]\\n                count += 1\\n        count += 1\\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sliding Window",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def partitionArray(self, nums: List[int], k: int) -> int:\\n        nums.sort(reverse = True)\\n        # print(nums)\\n        initial = nums[0]\\n        count = 0\\n        for i in range(1, len(nums)):\\n            if initial - nums[i] > k:\\n                initial = nums[i]\\n                count += 1\\n        count += 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112348,
                "title": "sort-and-binary-search",
                "content": "Since we are asked about subsequences and required to calculate the min and max of each subsequence , the **order of the elements does not matter** and hence we can sort the array.\\n\\nOnce the array is sorted we just have to count number of blocks having *max-min element <= k*, which we can do by using binary search ( bisect_right gives the index of the rightmost occurance of the number minSeq + k )\\n\\n```\\n nums.sort()\\n        n = len(nums)\\n        count = 0\\n        i = 0\\n        while i <n:\\n            i = bisect_right(nums,nums[i] +k)\\n            count+=1\\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Search"
                ],
                "code": "```\\n nums.sort()\\n        n = len(nums)\\n        count = 0\\n        i = 0\\n        while i <n:\\n            i = bisect_right(nums,nums[i] +k)\\n            count+=1\\n        return count\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2112276,
                "title": "javascript-greedy-sort-397ms",
                "content": "Main idea: greedily pick elements for subsequence, always increasing pick (from min -> max) to make more elements to be picked up for current collection\\n```\\nconst partitionArray = (a, k) => {\\n    a.sort((x, y) => x - y);\\n    let res = 0, pre = a[0]\\n    for (let i = 1; i < a.length; i++) {\\n        if (a[i] - pre > k) {\\n            res++;\\n            pre = a[i];\\n        }\\n    }\\n    return res + 1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nconst partitionArray = (a, k) => {\\n    a.sort((x, y) => x - y);\\n    let res = 0, pre = a[0]\\n    for (let i = 1; i < a.length; i++) {\\n        if (a[i] - pre > k) {\\n            res++;\\n            pre = a[i];\\n        }\\n    }\\n    return res + 1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2112257,
                "title": "just-sort-and-do-the-rest",
                "content": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        int mnn = INT_MAX;\\n        sort(begin(nums),end(nums));\\n        int res = 0;\\n        int n = nums.size();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(abs(mnn-nums[i])<=k)\\n            {\\n                mnn = min(mnn,nums[i]);\\n            }else \\n                res++,mnn = nums[i];\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        int mnn = INT_MAX;\\n        sort(begin(nums),end(nums));\\n        int res = 0;\\n        int n = nums.size();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(abs(mnn-nums[i])<=k)\\n            {\\n                mnn = min(mnn,nums[i]);\\n            }else \\n                res++,mnn = nums[i];\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112237,
                "title": "python-easy-understanding-solution",
                "content": "```\\nclass Solution:\\n    def partitionArray(self, nums: List[int], k: int) -> int:\\n        ans = 1\\n\\n        nums = list(set(nums))\\n        nums.sort()\\n\\n        newNums = []\\n        newNums.append(nums[0])\\n        nums.pop(0)\\n        i = 1\\n\\n        while len(nums) >= 1:\\n            if nums[0] <= newNums[ans - 1] + k:\\n                nums.pop(0)\\n            else:\\n                ans += 1\\n                newNums.append(nums[0])\\n                nums.pop(0)\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def partitionArray(self, nums: List[int], k: int) -> int:\\n        ans = 1\\n\\n        nums = list(set(nums))\\n        nums.sort()\\n\\n        newNums = []\\n        newNums.append(nums[0])\\n        nums.pop(0)\\n        i = 1\\n\\n        while len(nums) >= 1:\\n            if nums[0] <= newNums[ans - 1] + k:\\n                nums.pop(0)\\n            else:\\n                ans += 1\\n                newNums.append(nums[0])\\n                nums.pop(0)\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112187,
                "title": "c-sort-the-array-and-then-compare",
                "content": "Don\\'t get confused by subsequence. we can re-arrange things as we just need to group numbers where diff between min and max should be less than or equal to k.\\n\\nHence we can sort the numbers.\\n\\n```\\npublic int PartitionArray(int[] nums, int k) {\\n        Array.Sort(nums);\\n        int count = 1;\\n        int min = nums[0];\\n        for(int i = 1; i < nums.Length; i++){\\n            if(nums[i]-min <= k){\\n                continue;\\n            }\\n            else{\\n                count++;\\n                min = nums[i];\\n            }\\n        }\\n        \\n        return count;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int PartitionArray(int[] nums, int k) {\\n        Array.Sort(nums);\\n        int count = 1;\\n        int min = nums[0];\\n        for(int i = 1; i < nums.Length; i++){\\n            if(nums[i]-min <= k){\\n                continue;\\n            }\\n            else{\\n                count++;\\n                min = nums[i];\\n            }\\n        }\\n        \\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2112170,
                "title": "using-binary-search-cpp-o-n-log-n-time",
                "content": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        \\n        \\n        sort(nums.begin(),nums.end());\\n        int i=0,s=nums.size()-1;\\n        int cnt=0;\\n        while(i<nums.size()){\\n        \\n            int mid;\\n            int start=i,end=s;\\n            int res;\\n            \\n            while(start<=end){\\n                mid=start+(end-start)/2;\\n                \\n                if(nums[mid]-nums[i]==k){\\n                    res=mid;\\n                    start=mid+1;\\n                }\\n                else if(nums[mid]-nums[i]<k){\\n                    res=mid;\\n                    start=mid+1;\\n                }\\n                \\n                else{\\n                    end=mid-1;\\n                }\\n            }\\n            \\n            i=res+1;\\n            cnt++;\\n            \\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        \\n        \\n        sort(nums.begin(),nums.end());\\n        int i=0,s=nums.size()-1;\\n        int cnt=0;\\n        while(i<nums.size()){\\n        \\n            int mid;\\n            int start=i,end=s;\\n            int res;\\n            \\n            while(start<=end){\\n                mid=start+(end-start)/2;\\n                \\n                if(nums[mid]-nums[i]==k){\\n                    res=mid;\\n                    start=mid+1;\\n                }\\n                else if(nums[mid]-nums[i]<k){\\n                    res=mid;\\n                    start=mid+1;\\n                }\\n                \\n                else{\\n                    end=mid-1;\\n                }\\n            }\\n            \\n            i=res+1;\\n            cnt++;\\n            \\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112161,
                "title": "c-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        if(nums.size()==1)\\n            return 1;\\n        sort(nums.begin(),nums.end());\\n        int ans=1;\\n        int i=1;\\n        int mn=nums[0];\\n        while(i<nums.size())\\n        {\\n            if(abs(mn-nums[i])>k)\\n            {\\n                ans++;\\n                mn=nums[i];\\n            }\\n            i++;\\n        }\\n        \\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        if(nums.size()==1)\\n            return 1;\\n        sort(nums.begin(),nums.end());\\n        int ans=1;\\n        int i=1;\\n        int mn=nums[0];\\n        while(i<nums.size())\\n        {\\n            if(abs(mn-nums[i])>k)\\n            {\\n                ans++;\\n                mn=nums[i];\\n            }\\n            i++;\\n        }\\n        \\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112157,
                "title": "this-was-good-to-be-the-2nd-problem-in-contest-interesting-solution",
                "content": "int partitionArray(vector<int>& nums, int k) {\\n        \\n        sort(nums.begin(),nums.end());\\n        int count=1,start=0,end;\\n        \\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            if(nums[i+1]-nums[start]>k)\\n            {\\n                end=i;\\n                start=i+1;\\n                count++;\\n            }\\n                \\n        }\\n        return count;\\n        \\n    }",
                "solutionTags": [],
                "code": "int partitionArray(vector<int>& nums, int k) {\\n        \\n        sort(nums.begin(),nums.end());\\n        int count=1,start=0,end;\\n        \\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            if(nums[i+1]-nums[start]>k)\\n            {\\n                end=i;\\n                start=i+1;\\n                count++;\\n            }\\n                \\n        }\\n        return count;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2112145,
                "title": "c-with-logic",
                "content": "```\\n// 1- first sort the array \\n// 2- traverse the array and take the mininum so far and if the difference become greater than k increment the count and update the minimum as nums[i].\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        int cnt=1;\\n        sort(nums.begin(),nums.end());\\n        int mn=nums[0],mx=nums[0];\\n        for(int i=0;i<n;i++)\\n        {\\n           if(nums[i]-mn>k)\\n           {\\n               mn=nums[i];\\n               cnt++;\\n           }\\n            else\\n                mn=min(mn,nums[i]);\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\n// 1- first sort the array \\n// 2- traverse the array and take the mininum so far and if the difference become greater than k increment the count and update the minimum as nums[i].\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        int cnt=1;\\n        sort(nums.begin(),nums.end());\\n        int mn=nums[0],mx=nums[0];\\n        for(int i=0;i<n;i++)\\n        {\\n           if(nums[i]-mn>k)\\n           {\\n               mn=nums[i];\\n               cnt++;\\n           }\\n            else\\n                mn=min(mn,nums[i]);\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112055,
                "title": "c-easiest-solution-upper-bound-concept",
                "content": "class Solution {\\npublic:\\n    \\n\\tint partitionArray(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        sort(nums.begin(),nums.end());\\n        int c = 0;\\n        for(int i=0;i<n;i++){\\n            int ind = upper_bound(nums.begin(),nums.end(),nums[i]+k)-nums.begin();\\n            c++;\\n            i = ind-1;\\n        }\\n        return c;\\n    }\\n};\\n// plz Upvote if you like !!!",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    \\n\\tint partitionArray(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        sort(nums.begin(),nums.end());\\n        int c = 0;\\n        for(int i=0;i<n;i++){\\n            int ind = upper_bound(nums.begin(),nums.end(),nums[i]+k)-nums.begin();\\n            c++;\\n            i = ind-1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2112039,
                "title": "easy-solution",
                "content": "class Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end(),greater<int>());//sort the array dec order\\n        int c=0;int s=nums[0];\\n        for(int i=1;i<nums.size();++i){\\n            if(s-nums[i]>k){\\n                s=nums[i];\\n                c++;\\n            }\\n        }\\n        c++;\\n        return c;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end(),greater<int>());//sort the array dec order\\n        int c=0;int s=nums[0];\\n        for(int i=1;i<nums.size();++i){\\n            if(s-nums[i]>k){\\n                s=nums[i];\\n                c++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2112024,
                "title": "sort-and-twopointer-approach-to-keep-track-of-subsequence-size",
                "content": "```\\nclass Solution {\\n    public int partitionArray(int[] nums, int k) {\\n        \\n        Arrays.sort(nums);\\n        \\n        int i = 0;\\n        int j = 1;\\n        \\n        int count = 1;\\n        \\n        while(j < nums.length)\\n        {\\n            if(nums[j] - nums[i] > k)\\n            {\\n                count++;\\n                i = j;\\n            }\\n            \\n            j++;\\n        }\\n        \\n        return count;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int partitionArray(int[] nums, int k) {\\n        \\n        Arrays.sort(nums);\\n        \\n        int i = 0;\\n        int j = 1;\\n        \\n        int count = 1;\\n        \\n        while(j < nums.length)\\n        {\\n            if(nums[j] - nums[i] > k)\\n            {\\n                count++;\\n                i = j;\\n            }\\n            \\n            j++;\\n        }\\n        \\n        return count;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112023,
                "title": "what-is-the-time-complexity-requirment-o-nlog-n",
                "content": "```\\n    public int partitionArray(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        int ct = 0;\\n        for(int i = 0;i < n;){\\n            \\n            int j = i;\\n            while(i < n && nums[i] - nums[j] <= k)i++;\\n            ct++;\\n        }\\n        return ct;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int partitionArray(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        int ct = 0;\\n        for(int i = 0;i < n;){\\n            \\n            int j = i;\\n            while(i < n && nums[i] - nums[j] <= k)i++;\\n            ct++;\\n        }\\n        return ct;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2111999,
                "title": "java-sort",
                "content": "class Solution {\\n    public int partitionArray(int[] nums, int k) {\\n        \\n        Arrays.sort(nums);\\n        int current=nums[0],c=1;\\n        for(int i=1;i<nums.length;i++)\\n        {\\n            if(nums[i]>current+k)\\n            {\\n                c++;\\n                current =nums[i];\\n            }\\n        }\\n        \\n        return c;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int partitionArray(int[] nums, int k) {\\n        \\n        Arrays.sort(nums);\\n        int current=nums[0],c=1;\\n        for(int i=1;i<nums.length;i++)\\n        {\\n            if(nums[i]>current+k)\\n            {\\n                c++;\\n                current =nums[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2111985,
                "title": "javascript-binary-search",
                "content": "```js\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nconst partitionArray = function (nums, k) {\\n  nums.sort((a, b) => a - b)\\n  let result = 0\\n  if (nums[nums.length - 1] - nums[0] <= k) {\\n    return result + 1\\n  }\\n  // console.log(nums)\\n  const find = (start = 0) => {\\n    let left = start\\n    let right = nums.length - 1\\n    let next = -1\\n    while (left <= right) {\\n      const middle = Math.floor((left + right) / 2)\\n\\n      if (nums[middle] - nums[start] > k) {\\n        next = middle\\n        right = middle - 1\\n      } else {\\n        left = middle + 1\\n      }\\n    }\\n    if (next !== -1) {\\n      result += 1\\n      find(next)\\n    }\\n  }\\n  find(0)\\n  return result + 1\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```js\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nconst partitionArray = function (nums, k) {\\n  nums.sort((a, b) => a - b)\\n  let result = 0\\n  if (nums[nums.length - 1] - nums[0] <= k) {\\n    return result + 1\\n  }\\n  // console.log(nums)\\n  const find = (start = 0) => {\\n    let left = start\\n    let right = nums.length - 1\\n    let next = -1\\n    while (left <= right) {\\n      const middle = Math.floor((left + right) / 2)\\n\\n      if (nums[middle] - nums[start] > k) {\\n        next = middle\\n        right = middle - 1\\n      } else {\\n        left = middle + 1\\n      }\\n    }\\n    if (next !== -1) {\\n      result += 1\\n      find(next)\\n    }\\n  }\\n  find(0)\\n  return result + 1\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2111905,
                "title": "java-sorting",
                "content": "```\\nclass Solution {\\n    public int partitionArray(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        \\n        int n = nums.length;\\n        int i=1;\\n        int min=nums[0];\\n        int count=1;\\n        while(i<n){\\n            if(nums[i]-min>k){\\n                min=nums[i];\\n                count++;\\n            }\\n            i++;\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int partitionArray(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        \\n        int n = nums.length;\\n        int i=1;\\n        int min=nums[0];\\n        int count=1;\\n        while(i<n){\\n            if(nums[i]-min>k){\\n                min=nums[i];\\n                count++;\\n            }\\n            i++;\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2111892,
                "title": "c-sort-and-count",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint partitionArray(vector<int>& nums, int k) {\\n\\t\\t\\tsort(begin(nums),end(nums),greater<int>());\\n\\t\\t\\tint res = 1,prev = nums[0];\\n\\t\\t\\tfor(int i=1;i<size(nums);i++){\\n\\t\\t\\t\\tif(prev-nums[i]>k){\\n\\t\\t\\t\\t\\tprev = nums[i];\\n\\t\\t\\t\\t\\tres++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint partitionArray(vector<int>& nums, int k) {\\n\\t\\t\\tsort(begin(nums),end(nums),greater<int>());\\n\\t\\t\\tint res = 1,prev = nums[0];\\n\\t\\t\\tfor(int i=1;i<size(nums);i++){\\n\\t\\t\\t\\tif(prev-nums[i]>k){\\n\\t\\t\\t\\t\\tprev = nums[i];\\n\\t\\t\\t\\t\\tres++;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 4091237,
                "title": "optimal-partitioning-minimize-subarray-differences",
                "content": "# Intuition\\nThe problem requires us to partition an array into subarrays such that the difference between consecutive elements in each subarray is less than or equal to a given value \\'k\\'. In other words, we need to find the minimum number of partitions required to satisfy this condition. To do this efficiently, we can sort the array and identify points where a new partition should begin.\\n\\n# Approach\\n1. Sort the input array \\'nums\\' in ascending order. Sorting is essential as it helps identify the points where a new partition is needed.\\n\\n2. Initialize \\'answer\\' to 1 since, at a minimum, we\\'ll have one partition.\\n\\n3. Initialize \\'mini\\' to the first element of the sorted array. This variable keeps track of the minimum value within the current partition.\\n\\n4. Loop through each element in the sorted array:\\n   - Check if the difference between the current element and \\'mini\\' is greater than \\'k\\'. If it is, this means we need to start a new partition.\\n   - Update \\'mini\\' with the current element\\'s value to start a new partition.\\n   - Increment \\'answer\\' to keep track of the number of partitions.\\n\\n5. Return the \\'answer,\\' which represents the minimum number of partitions required to satisfy the given condition.\\n\\n# Complexity\\n- Time complexity:\\n    - The most time-consuming operation is sorting the \\'nums\\' array, which takes O(NlogN) time, where N is the number of elements in \\'nums.\\'\\n    - The subsequent loop through \\'nums\\' takes O(N) time since we examine each element once.\\n    Therefore, the overall time complexity is O(NlogN).\\n\\n- Space complexity:\\n    - The algorithm uses a constant amount of extra space for variables \\'answer\\' and \\'mini.\\'\\n    - Thus, the space complexity is O(1), indicating that the space used by the algorithm is independent of the input size.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // Function to partition an array into subarrays where the difference\\n    // between consecutive elements is less than or equal to \\'k\\'.\\n    int partitionArray(vector<int>& nums, int k) {\\n        // Sort the input \\'nums\\' array in ascending order.\\n        sort(nums.begin(), nums.end());\\n\\n        // Initialize \\'answer\\' to 1 since we\\'ll have at least one partition.\\n        int answer = 1;\\n\\n        // Initialize \\'mini\\' to the first element of the sorted array.\\n        int mini = nums[0];\\n\\n        // Loop through each element in the sorted array.\\n        for (int i = 0; i < nums.size(); i++) {\\n            // If the difference between the current element and \\'mini\\' is greater than \\'k\\',\\n            // it means we need to start a new partition, so we update \\'mini\\' and increment \\'answer\\'.\\n            if (nums[i] - mini > k) {\\n                mini = nums[i];\\n                ++answer;\\n            }\\n        }\\n\\n        // Return the total number of partitions.\\n        return answer;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Function to partition an array into subarrays where the difference\\n    // between consecutive elements is less than or equal to \\'k\\'.\\n    int partitionArray(vector<int>& nums, int k) {\\n        // Sort the input \\'nums\\' array in ascending order.\\n        sort(nums.begin(), nums.end());\\n\\n        // Initialize \\'answer\\' to 1 since we\\'ll have at least one partition.\\n        int answer = 1;\\n\\n        // Initialize \\'mini\\' to the first element of the sorted array.\\n        int mini = nums[0];\\n\\n        // Loop through each element in the sorted array.\\n        for (int i = 0; i < nums.size(); i++) {\\n            // If the difference between the current element and \\'mini\\' is greater than \\'k\\',\\n            // it means we need to start a new partition, so we update \\'mini\\' and increment \\'answer\\'.\\n            if (nums[i] - mini > k) {\\n                mini = nums[i];\\n                ++answer;\\n            }\\n        }\\n\\n        // Return the total number of partitions.\\n        return answer;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4070186,
                "title": "greedy",
                "content": "Using Greedy technique\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(logn)\\n# Code\\n```\\nclass Solution {\\n    fun partitionArray(nums: IntArray, k: Int): Int {\\n        nums.sort()\\n        var result = 1\\n        var x = nums[0]\\n\\n        for(i in 1 until nums.size){\\n            if(nums[i] - x > k){\\n                x = nums[i]\\n                result++\\n            }\\n        }\\n\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun partitionArray(nums: IntArray, k: Int): Int {\\n        nums.sort()\\n        var result = 1\\n        var x = nums[0]\\n\\n        for(i in 1 until nums.size){\\n            if(nums[i] - x > k){\\n                x = nums[i]\\n                result++\\n            }\\n        }\\n\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4045109,
                "title": "c-simplest-easiest-optimal-solution-using-sorting",
                "content": "# Complexity\\n- Time complexity:\\nO(n log(n))\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n\\n      sort(nums.begin(), nums.end());\\n\\n      int Min = nums[0];\\n\\n      int ans = 1;\\n\\n      for(int i=1; i<nums.size(); i++) {\\n        if(nums[i] - Min > k) {\\n          Min = nums[i];\\n          ans++;\\n        }\\n      }\\n\\n      return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n\\n      sort(nums.begin(), nums.end());\\n\\n      int Min = nums[0];\\n\\n      int ans = 1;\\n\\n      for(int i=1; i<nums.size(); i++) {\\n        if(nums[i] - Min > k) {\\n          Min = nums[i];\\n          ans++;\\n        }\\n      }\\n\\n      return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4045086,
                "title": "c-simplest-solution-using-sorting-clean-and-concise-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(n log(n))\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n\\n      sort(nums.begin(), nums.end());\\n\\n      int Min = nums[0];\\n\\n      int ans = 1;\\n\\n      for(int i=1; i<nums.size(); i++) {\\n        if(nums[i] - Min > k) {\\n          Min = nums[i];\\n          ans++;\\n        }\\n      }\\n\\n      return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n\\n      sort(nums.begin(), nums.end());\\n\\n      int Min = nums[0];\\n\\n      int ans = 1;\\n\\n      for(int i=1; i<nums.size(); i++) {\\n        if(nums[i] - Min > k) {\\n          Min = nums[i];\\n          ans++;\\n        }\\n      }\\n\\n      return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4038952,
                "title": "easy-explanation-with-comments-and-approach-binary-search-optimised-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n We have to find minimun number of partition ,so we have to  \\n    include maximum valid element in our partition and we have \\n    to just focus on getting the minimum and maximum element in \\n    the partition\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n * log(n) )\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n/*\\n\\n    We have to find minimun number of partition ,so we have to  \\n    include maximum valid element in our partition and we have \\n    to just focus on getting the minimum and maximum element in \\n    the partition\\n\\n*/\\n    int partitionArray(vector<int>& nums, int k) {\\n        \\n        int n=nums.size();\\n        int i=0;\\n        int cnt=0;\\n        //So that duplicates element can come together and we can easily include them in our partition\\n        sort(nums.begin(),nums.end());\\n\\n        while(i<n){\\n            \\n            //Since we have sorted the array we just need to find the greatest valid element in the array and we will get our partition\\n            int target=k+nums[i];\\n\\n            //Upper bound to get the last index of target(if array have duplicates element)\\n            int idx=upper_bound(nums.begin(),nums.end(),target)-nums.begin();\\n\\n            //If target is there in array we have got out partition so our new possible partition can start from next index\\n            if(idx<n && nums[idx]==target){\\n                idx++;\\n            }\\n\\n            //If target not found then upper bound will automaically give us index of next element so we dont need to do idx++\\n            i=idx;\\n            cnt++;\\n        }\\n        \\n        return cnt;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n/*\\n\\n    We have to find minimun number of partition ,so we have to  \\n    include maximum valid element in our partition and we have \\n    to just focus on getting the minimum and maximum element in \\n    the partition\\n\\n*/\\n    int partitionArray(vector<int>& nums, int k) {\\n        \\n        int n=nums.size();\\n        int i=0;\\n        int cnt=0;\\n        //So that duplicates element can come together and we can easily include them in our partition\\n        sort(nums.begin(),nums.end());\\n\\n        while(i<n){\\n            \\n            //Since we have sorted the array we just need to find the greatest valid element in the array and we will get our partition\\n            int target=k+nums[i];\\n\\n            //Upper bound to get the last index of target(if array have duplicates element)\\n            int idx=upper_bound(nums.begin(),nums.end(),target)-nums.begin();\\n\\n            //If target is there in array we have got out partition so our new possible partition can start from next index\\n            if(idx<n && nums[idx]==target){\\n                idx++;\\n            }\\n\\n            //If target not found then upper bound will automaically give us index of next element so we dont need to do idx++\\n            i=idx;\\n            cnt++;\\n        }\\n        \\n        return cnt;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4033734,
                "title": "java-30ms-beats-96-98-sort-nums-then-use-greedy-strategy",
                "content": "Importantly, we don\\'t keep track of which numbers go in each subsequence, since we don\\'t care. We just need how many subsequences there will be. This is an analysis, not a simulation.\\n\\n\\n# Code\\n```\\n// 30ms Beats 96.98%\\n\\nclass Solution {\\n    public int partitionArray(int[] nums, int k) {\\n\\n        // strategy: sort array, then use a greedy approach to counting subsequences\\n\\n        Arrays.sort(nums);\\n        int numSS = 1;  // SS == subsequences; what we\\'ll return\\n\\n        int leastNumInCurSS = nums[0];\\n        for (int n : nums) {\\n            if (n - leastNumInCurSS <= k) {\\n                // add `n` to current SS\\n            } else {\\n                // close out current SS and start a new SS\\n                ++numSS;\\n                leastNumInCurSS = n;\\n            }\\n        }\\n\\n        if (nums[nums.length - 1] - leastNumInCurSS > k) {  // last number needs its own subsequence\\n            return 1 + numSS;\\n        } else {  // last number belongs in the last subsequence already counted\\n            return numSS;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// 30ms Beats 96.98%\\n\\nclass Solution {\\n    public int partitionArray(int[] nums, int k) {\\n\\n        // strategy: sort array, then use a greedy approach to counting subsequences\\n\\n        Arrays.sort(nums);\\n        int numSS = 1;  // SS == subsequences; what we\\'ll return\\n\\n        int leastNumInCurSS = nums[0];\\n        for (int n : nums) {\\n            if (n - leastNumInCurSS <= k) {\\n                // add `n` to current SS\\n            } else {\\n                // close out current SS and start a new SS\\n                ++numSS;\\n                leastNumInCurSS = n;\\n            }\\n        }\\n\\n        if (nums[nums.length - 1] - leastNumInCurSS > k) {  // last number needs its own subsequence\\n            return 1 + numSS;\\n        } else {  // last number belongs in the last subsequence already counted\\n            return numSS;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4019495,
                "title": "easy-python-solution-using-greedy-beats-92-18-in-runtime-and-memory",
                "content": "# Approach\\nSort the nums and define `counter`, `minVal`. Greedily check if `currentVal - minVal <= k`. Else increment the `counter` and update `minVal`.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```py\\nclass Solution:\\n    def partitionArray(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        counter, minVal = 0, -1\\n        for num in nums : \\n            if minVal == -1 : \\n                counter, minVal = counter + 1, num\\n            elif num - minVal > k : \\n                counter, minVal = counter + 1, num\\n                    \\n        return counter \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```py\\nclass Solution:\\n    def partitionArray(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        counter, minVal = 0, -1\\n        for num in nums : \\n            if minVal == -1 : \\n                counter, minVal = counter + 1, num\\n            elif num - minVal > k : \\n                counter, minVal = counter + 1, num\\n                    \\n        return counter \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4018627,
                "title": "easy-solution-using-one-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int res=1,mn=nums[0],mx=nums[0];\\n        for(int a: nums){\\n            mn=min(mn,a);\\n            mx=max(mx,a);\\n            if(mx-mn > k){\\n                res++;mn=mx=a;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int res=1,mn=nums[0],mx=nums[0];\\n        for(int a: nums){\\n            mn=min(mn,a);\\n            mx=max(mx,a);\\n            if(mx-mn > k){\\n                res++;mn=mx=a;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4018601,
                "title": "sliding-window-on-subsequence",
                "content": "\\n```\\nclass Solution\\n{\\n    public:\\n        int partitionArray(vector<int> &nums, int k)\\n        {\\n            int n = nums.size();\\n            sort(nums.begin(), nums.end());\\n            int head = 1, tail = 0;\\n            int diff, cnt = 1;\\n            while (head < n)\\n            {\\n                diff = nums[head] - nums[tail];\\n                if (diff > k)\\n                {\\n                    cnt++;\\n                    tail = head;\\n                }\\n                head++;\\n            }\\n            return cnt;\\n        }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        int partitionArray(vector<int> &nums, int k)\\n        {\\n            int n = nums.size();\\n            sort(nums.begin(), nums.end());\\n            int head = 1, tail = 0;\\n            int diff, cnt = 1;\\n            while (head < n)\\n            {\\n                diff = nums[head] - nums[tail];\\n                if (diff > k)\\n                {\\n                    cnt++;\\n                    tail = head;\\n                }\\n                head++;\\n            }\\n            return cnt;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3999023,
                "title": "simple-intuitive-python-solution-with-detailed-explanation",
                "content": "# Intuition\\nWhen I first read the problem and noticed the word subsequence, I immediately though no sorting then. But as I start penning down ideas, it occured to me we only need to track min and max of any partition. Once you sort the input answer comes to you.\\n\\nLearning - dont rule out sorting just because problem statement mentions subsequence\\n\\n# Approach\\nSort the array.\\n\\nFor example, [3, 6, 1, 2, 5] becomes [1, 2, 5, 3, 6]\\n\\nNow we have to be greedy as we need minimum number of partitions. Then I thought of sliding window technique - \\n\\nAs we start our first window will be [1] - this will always fullfil the window as minimum value of k is 0 from problem statement contraints\\n\\nIncrease the window size till window is valid \\n\\npartition[min] - partiion[max] <= k \\ntransalates into \\nwindow[left] - window[right] <= k (as elements are sorted)\\n\\nbreak when the condition is violated and create a new window (left set to right)\\n\\n# Complexity\\n- Time complexity:\\nO(nlgn)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def partitionArray(self, nums: List[int], k: int) -> int:\\n        # sliding window but first we sort\\n\\n        nums.sort()\\n\\n        left = 0\\n        min_partition = 0\\n\\n        for right in range(len(nums)):\\n            # new partition starts as current window becomes invalid\\n            if (nums[right] - nums[left]) > k:\\n                left = right\\n                min_partition += 1\\n\\n        # we will have to add 1 as we need to count the last window\\n        return min_partition + 1\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Greedy",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def partitionArray(self, nums: List[int], k: int) -> int:\\n        # sliding window but first we sort\\n\\n        nums.sort()\\n\\n        left = 0\\n        min_partition = 0\\n\\n        for right in range(len(nums)):\\n            # new partition starts as current window becomes invalid\\n            if (nums[right] - nums[left]) > k:\\n                left = right\\n                min_partition += 1\\n\\n        # we will have to add 1 as we need to count the last window\\n        return min_partition + 1\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3997491,
                "title": "99-5-optimal-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>&n , int k){\\n        sort(n.begin(),n.end());\\n        int c=0 , mn=n[0] , i=0;\\n        while(i<n.size()){\\n            if(n[i]-mn<=k){\\n                i++;\\n            }\\n            else{\\n                c++;\\n                mn=n[i];\\n            }\\n        }\\n        return c+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>&n , int k){\\n        sort(n.begin(),n.end());\\n        int c=0 , mn=n[0] , i=0;\\n        while(i<n.size()){\\n            if(n[i]-mn<=k){\\n                i++;\\n            }\\n            else{\\n                c++;\\n                mn=n[i];\\n            }\\n        }\\n        return c+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3989317,
                "title": "easy-sorting-solution-for-beginners",
                "content": "# Intuition\\nKeeping track of diffrences and the lowest number is the ley to this solution.\\n\\n# Approach\\nI sorted the vector in ascending order and then kept track of the difference and when it exceeded teh difference it was time to update counter and the value of the lowest of the next partition.\\n\\nKindly upvote the solution if you found it easy, precise and concise!\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) \\n    {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        int c=1;\\n        int low=nums[0];\\n        for(int i=1;i<n;i++)\\n        {\\n            int diff=nums[i]-low;\\n            if(diff>k)\\n            {\\n                c++;\\n                low=nums[i];\\n            }\\n        }\\n        return c;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) \\n    {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        int c=1;\\n        int low=nums[0];\\n        for(int i=1;i<n;i++)\\n        {\\n            int diff=nums[i]-low;\\n            if(diff>k)\\n            {\\n                c++;\\n                low=nums[i];\\n            }\\n        }\\n        return c;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3987953,
                "title": "java-greedy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem says hey u can pick any element in  `nums` and u  need to make some groups where difference between minimum value and maximum value of any  group should be less than or equal to `k`.Now tell me how many groups u can form in an efiiecient manner .\\n\\nWhat i learned ? \\n\\nThe trick behind this problem is noticing that order of elements i n subsequence will change if we sort the array but the minimum and maximum part of the subsequence can and will  remain same irrespective of the order of element in an subsequence . \\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int partitionArray(int[] nums, int k) {\\n        // you can pick up any element u want !\\n        // easier way is sort the element and choose greedily\\n        Arrays.sort(nums);\\n        int res=  0 ,  min  = nums[0]  , max =  nums[0];\\n        for( var el :nums){\\n            min = Math.min(el , min);\\n            max = Math.max(el  ,max);\\n            if( max - min > k){\\n                res++;\\n                min = el ; max = el; \\n            }\\n        }\\n        return res+1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int partitionArray(int[] nums, int k) {\\n        // you can pick up any element u want !\\n        // easier way is sort the element and choose greedily\\n        Arrays.sort(nums);\\n        int res=  0 ,  min  = nums[0]  , max =  nums[0];\\n        for( var el :nums){\\n            min = Math.min(el , min);\\n            max = Math.max(el  ,max);\\n            if( max - min > k){\\n                res++;\\n                min = el ; max = el; \\n            }\\n        }\\n        return res+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3984165,
                "title": "simple-and-easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int partitionArray(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        if(nums.length == 1) return 1;\\n        int start = nums[0], ans =1;;\\n        for(int i=1;i<nums.length;i++){\\n            if((nums[i] - start) > k){\\n                start = nums[i];\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int partitionArray(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        if(nums.length == 1) return 1;\\n        int start = nums[0], ans =1;;\\n        for(int i=1;i<nums.length;i++){\\n            if((nums[i] - start) > k){\\n                start = nums[i];\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3980003,
                "title": "sorting-greedy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        sort(nums.begin(), nums.end());\\n\\n        int mini = nums[0];\\n        int i = 1;\\n        int count = 1;\\n        while (i < nums.size()) {\\n            if (nums[i] - mini > k) {\\n                count++;\\n                mini = nums[i];\\n            }\\n            i++;\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        sort(nums.begin(), nums.end());\\n\\n        int mini = nums[0];\\n        int i = 1;\\n        int count = 1;\\n        while (i < nums.size()) {\\n            if (nums[i] - mini > k) {\\n                count++;\\n                mini = nums[i];\\n            }\\n            i++;\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3965722,
                "title": "java-simple-sorting-pointer-manipulation",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int partitionArray(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int start = 0, count = 1;\\n        for(int i = start+1;i<nums.length;i++){\\n            if(nums[i] - nums[start] > k){\\n                count++;\\n                start = i;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int partitionArray(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int start = 0, count = 1;\\n        for(int i = start+1;i<nums.length;i++){\\n            if(nums[i] - nums[start] > k){\\n                count++;\\n                start = i;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3961524,
                "title": "simple-sol",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int mini=INT32_MIN,count=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]-k>mini)\\n            {\\n                mini=nums[i];\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int mini=INT32_MIN,count=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]-k>mini)\\n            {\\n                mini=nums[i];\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3943671,
                "title": "using-pointers-only",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def partitionArray(self, nums: List[int], k: int) -> int:\\n        count=0\\n        nums.sort()\\n        print(nums)\\n        i,j=0,1\\n        if len(nums)==1:\\n            return 1\\n        while(i<len(nums)):\\n            if j==len(nums)-1 and nums[j]-nums[i]<=k:\\n                count=count+1\\n                return count\\n            elif j==len(nums)-1 and nums[j]-nums[i]>k:\\n                count=count+2\\n                return count\\n            elif nums[j]-nums[i]<=k:\\n                j=j+1\\n            else:\\n                i=j\\n                j=j+1\\n                count=count+1\\n            print(count,i,j)\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C"
                ],
                "code": "```\\nclass Solution:\\n    def partitionArray(self, nums: List[int], k: int) -> int:\\n        count=0\\n        nums.sort()\\n        print(nums)\\n        i,j=0,1\\n        if len(nums)==1:\\n            return 1\\n        while(i<len(nums)):\\n            if j==len(nums)-1 and nums[j]-nums[i]<=k:\\n                count=count+1\\n                return count\\n            elif j==len(nums)-1 and nums[j]-nums[i]>k:\\n                count=count+2\\n                return count\\n            elif nums[j]-nums[i]<=k:\\n                j=j+1\\n            else:\\n                i=j\\n                j=j+1\\n                count=count+1\\n            print(count,i,j)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3916430,
                "title": "without-greedy-easiest-solution-using-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int partitionArray(int[] nums, int k) {\\n        Stack<Integer> st=new Stack<>();\\n        int count=1;\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length;i++){\\n            if(st.size()==0){\\n                st.push(nums[i]);\\n\\n            }\\n            else if((int)Math.abs(st.peek()-nums[i])>k){\\n                st.clear();\\n                st.push(nums[i]);\\n                count=count+1;\\n\\n            }\\n            \\n        }\\n        int resul=count;\\n        return resul;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int partitionArray(int[] nums, int k) {\\n        Stack<Integer> st=new Stack<>();\\n        int count=1;\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length;i++){\\n            if(st.size()==0){\\n                st.push(nums[i]);\\n\\n            }\\n            else if((int)Math.abs(st.peek()-nums[i])>k){\\n                st.clear();\\n                st.push(nums[i]);\\n                count=count+1;\\n\\n            }\\n            \\n        }\\n        int resul=count;\\n        return resul;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3903249,
                "title": "c-easy-solution-o-n-time-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTwo pointer technique\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        int start=0;\\n        int end=0;\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        int min_val=INT_MAX;\\n        int max_val=INT_MIN;\\n        int count=1;\\n        while(end<n){\\n            min_val=min(min_val,nums[end]);\\n            max_val=max(max_val,nums[end]);\\n            if(max_val-min_val<=k){\\n                end++;\\n            }\\n            else{\\n                count++;\\n                start=end;\\n                min_val=INT_MAX;\\n                max_val=INT_MIN;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        int start=0;\\n        int end=0;\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        int min_val=INT_MAX;\\n        int max_val=INT_MIN;\\n        int count=1;\\n        while(end<n){\\n            min_val=min(min_val,nums[end]);\\n            max_val=max(max_val,nums[end]);\\n            if(max_val-min_val<=k){\\n                end++;\\n            }\\n            else{\\n                count++;\\n                start=end;\\n                min_val=INT_MAX;\\n                max_val=INT_MIN;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3892777,
                "title": "golang-133ms-100-8-3m-73-simple-2-solutions-comb",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nChoose solution with len(nums)\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nstd pdq_sort -> count sort\\n# Complexity\\n- Time complexity: O(nlogn) -> O(??)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1) -> O(??)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc partitionArray(nums []int, k int) int {\\n    if len(nums) < 5000 {\\n        return sortResolution(nums, k)\\n    }\\n\\n    arr := make([]bool, 100001)\\n    for _, v := range nums {\\n        arr[v] = true\\n    }\\n\\n    var (\\n        result int\\n        pre  = -k - 1\\n    )\\n\\n    for i := 0; i < len(arr); i++ {\\n        if !arr[i] || i - pre <= k {\\n            continue\\n        }\\n\\n        pre = i\\n        result++\\n    }\\n    return result\\n}\\n\\nfunc sortResolution(nums []int, k int) int {\\n    sort.Ints(nums)\\n\\n    var (\\n        result = 1\\n        pre  = nums[0]\\n    )\\n\\n    for i := 1; i < len(nums); i++ {\\n        if nums[i] - pre <= k {\\n            continue\\n        }\\n\\n        pre = nums[i]\\n        result++\\n    }\\n    return result\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc partitionArray(nums []int, k int) int {\\n    if len(nums) < 5000 {\\n        return sortResolution(nums, k)\\n    }\\n\\n    arr := make([]bool, 100001)\\n    for _, v := range nums {\\n        arr[v] = true\\n    }\\n\\n    var (\\n        result int\\n        pre  = -k - 1\\n    )\\n\\n    for i := 0; i < len(arr); i++ {\\n        if !arr[i] || i - pre <= k {\\n            continue\\n        }\\n\\n        pre = i\\n        result++\\n    }\\n    return result\\n}\\n\\nfunc sortResolution(nums []int, k int) int {\\n    sort.Ints(nums)\\n\\n    var (\\n        result = 1\\n        pre  = nums[0]\\n    )\\n\\n    for i := 1; i < len(nums); i++ {\\n        if nums[i] - pre <= k {\\n            continue\\n        }\\n\\n        pre = nums[i]\\n        result++\\n    }\\n    return result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3879640,
                "title": "python-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def partitionArray(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        ans = 1\\n        curr = nums[0]\\n        for i in range(1, len(nums)):\\n            if nums[i] - curr > k:\\n                curr = nums[i]\\n                ans += 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def partitionArray(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        ans = 1\\n        curr = nums[0]\\n        for i in range(1, len(nums)):\\n            if nums[i] - curr > k:\\n                curr = nums[i]\\n                ans += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3856900,
                "title": "sort-sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe goal is to divide the array into partitions such that the maximum difference between elements in each partition is at most k. Sorting the array helps ensure smaller differences between adjacent elements. Using a sliding window approach, maintain a window where the difference between the maximum and minimum elements is at most k. When this condition is violated, increment the output counter, indicating a new partition. Slide the window by updating the start and end pointers. Continue until the end of the array. The output counter will give the minimum number of partitions required.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSort the array to facilitate smaller differences.\\nInitialize a sliding window with start and end pointers.\\nExtend the window as long as the difference between nums[end] and nums[start] is within k.\\nIf the difference condition is violated, increment output and move start to end.\\nContinue sliding the window until the end of the array.\\nThe output counter represents the minimum number of partitions needed.\\n\\n# Complexity\\n- Time complexity: O(N*logN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        int output = 0;\\n        sort(nums.begin() , nums.end());\\n\\n        // sliding window\\n        int start = 0;\\n        int end = 0;\\n        while(end < nums.size()){\\n            // we can extend this window\\n            if(nums[end] - nums[start] <= k){\\n                end++;\\n            }\\n            // we cannot extend this window as doing so will give us a subsequence with range greater than k\\n            else{\\n                output++;\\n                start = end;\\n            }\\n        }\\n        // don\\'t miss the last output\\n        output++;\\n\\n        return output;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        int output = 0;\\n        sort(nums.begin() , nums.end());\\n\\n        // sliding window\\n        int start = 0;\\n        int end = 0;\\n        while(end < nums.size()){\\n            // we can extend this window\\n            if(nums[end] - nums[start] <= k){\\n                end++;\\n            }\\n            // we cannot extend this window as doing so will give us a subsequence with range greater than k\\n            else{\\n                output++;\\n                start = end;\\n            }\\n        }\\n        // don\\'t miss the last output\\n        output++;\\n\\n        return output;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3844406,
                "title": "c-greedy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int PartitionArray(int[] nums, int k) {\\n        Array.Sort(nums);\\n        int partition = 1;\\n        \\n        for (int end = 1, start = 0; end < nums.Length; end++)\\n        {\\n            if (nums[end] - nums[start] > k)\\n            {\\n                start = end;\\n                partition++;\\n            }\\n        }\\n\\n        return partition;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int PartitionArray(int[] nums, int k) {\\n        Array.Sort(nums);\\n        int partition = 1;\\n        \\n        for (int end = 1, start = 0; end < nums.Length; end++)\\n        {\\n            if (nums[end] - nums[start] > k)\\n            {\\n                start = end;\\n                partition++;\\n            }\\n        }\\n\\n        return partition;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3837849,
                "title": "c-sorting-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int i=0,j=0;\\n        int ans=0;\\n        while(j<nums.size()){\\n            if(nums[j]-nums[i]<=k){\\n                j++;\\n            }\\n            else{\\n                ans++;\\n                i=j;\\n            }\\n        }\\n        return ans+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int i=0,j=0;\\n        int ans=0;\\n        while(j<nums.size()){\\n            if(nums[j]-nums[i]<=k){\\n                j++;\\n            }\\n            else{\\n                ans++;\\n                i=j;\\n            }\\n        }\\n        return ans+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3834683,
                "title": "python3-very-easy-solution",
                "content": "# Intuition\\n![please upvote.jpg](https://assets.leetcode.com/users/images/3264e373-3e9f-448e-923c-7850de0c6a94_1690650158.6361108.jpeg)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(n log n)\\n\\n- Space complexity:\\n    o(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def partitionArray(self, nums: List[int], k: int) -> int:\\n        ans = 0\\n        nums.sort()\\n        prev = float(\"-inf\")\\n        for i in nums:\\n            if i - prev > k:\\n                ans+=1\\n                prev = i\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def partitionArray(self, nums: List[int], k: int) -> int:\\n        ans = 0\\n        nums.sort()\\n        prev = float(\"-inf\")\\n        for i in nums:\\n            if i - prev > k:\\n                ans+=1\\n                prev = i\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3830041,
                "title": "greedy-beats-100-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        sort(nums.begin(), nums.end());\\n        int count = 0;\\n        int n = nums.size();\\n        int i=0;\\n        while(i<n){\\n            int curr = nums[i];\\n            while(i<n && nums[i] - curr <= k){\\n                i++;\\n            }\\n            count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        sort(nums.begin(), nums.end());\\n        int count = 0;\\n        int n = nums.size();\\n        int i=0;\\n        while(i<n){\\n            int curr = nums[i];\\n            while(i<n && nums[i] - curr <= k){\\n                i++;\\n            }\\n            count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3828633,
                "title": "easy-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n      int i=0;\\n      int j=0;\\n      int ans=0;\\n      while(i<n&&j<n){\\n           while(i<n&&nums[i]-nums[j]<=k){\\n             i++;\\n           }\\n           ans++;\\n           j=i;\\n      }    \\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n      int i=0;\\n      int j=0;\\n      int ans=0;\\n      while(i<n&&j<n){\\n           while(i<n&&nums[i]-nums[j]<=k){\\n             i++;\\n           }\\n           ans++;\\n           j=i;\\n      }    \\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3810743,
                "title": "easy-sorting-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst sort the elements and find the max number for which the diff between them is not greater than the k.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI have used sorting and then upper bound function to find the greater element for element.\\nlike int the case 3,6,1,2,5 the sorted one is 1,2,3,5,6 and k is 2 so the upeer bound of a[0](1)+k(2) will be 5 ane then we will decrease the pos by 1 for equal or less elements which is needed.\\nand then we will increase the cnt and set the i=pos.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& a, int k) {\\n        int n=a.size();\\n        int cnt=0;\\n        sort(a.begin(),a.end());\\n        for(int i=0;i<n;i++)\\n        {\\n            int pos=upper_bound(a.begin(),a.end(),a[i]+k)-a.begin();\\n            pos--;\\n            i=pos;\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& a, int k) {\\n        int n=a.size();\\n        int cnt=0;\\n        sort(a.begin(),a.end());\\n        for(int i=0;i<n;i++)\\n        {\\n            int pos=upper_bound(a.begin(),a.end(),a[i]+k)-a.begin();\\n            pos--;\\n            i=pos;\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3807908,
                "title": "c-two-pointer-approch-on-sorted-array",
                "content": "# Approach\\nTo solve this problem, we can follow the following steps:\\n1. Sort the input array `nums` in ascending order.\\n2. Initialize two pointers, `i` and `j`, both pointing to the start of the sorted array.\\n3. Initialize a variable `result` to keep track of the minimum number of subsequences needed. Set it to 1 initially.\\n4. Traverse the sorted array with the `j` pointer while checking the difference between `nums[j]` and `nums[i]`. If the difference exceeds `k`, we increment the `result` variable by 1 and move the `i` pointer to `j`. Otherwise, we increment the `j` pointer to keep checking the next elements.\\n5. Continue this process until the `j` pointer reaches the end of the array.\\n6. After the loop ends, return the `result` variable, which represents the minimum number of subsequences needed to satisfy the conditions.\\n\\n# Complexity\\n- Time complexity: The sorting step takes O(n log n), and the while loop runs in O(n) time. Thus, the overall time complexity is O(n log n).\\n- Space complexity: The sorting step takes O(n) additional space. Hence, the space complexity is O(n).\\n\\n# Code\\n```cpp\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        sort(nums.begin(), nums.end());\\n        int result = 1, i = 0, j = 0;\\n\\n        while (j < nums.size()) {\\n            if (nums[j] - nums[i] > k) {\\n                result++;\\n                i = j;\\n            } else {\\n                j++;\\n            }\\n        }\\n\\n        return result;\\n    }\\n};\\n```\\n\\n# Example Walkthroughs\\n## Example 1\\nGiven input: `nums = [3, 6, 1, 2, 5]`, `k = 2`.\\n- After sorting: `[1, 2, 3, 5, 6]`\\n- Initialize `i = 0`, `j = 0`, and `result = 1`.\\n    - Check `nums[j] - nums[i] = 1 - 1 = 0 <= k`, increment `j`.\\n    - Check `nums[j] - nums[i] = 2 - 1 = 1 <= k`, increment `j`.\\n    - Check `nums[j] - nums[i] = 3 - 1 = 2 <= k`, increment `j`.\\n    - Check `nums[j] - nums[i] = 5 - 1 = 4 > k`, increment `result` and set `i = j = 3`.\\n    - Check `nums[j] - nums[i] = 6 - 5 = 1 <= k`, increment `j`.\\n    - `j` reaches the end of the array, terminate the loop.\\n- Return `result = 2`.\\n\\n## Example 2\\nGiven input: `nums = [1, 2, 3]`, `k = 1`.\\n- After sorting: `[1, 2, 3]`\\n- Initialize `i = 0`, `j = 0`, and `result = 1`.\\n    - Check `nums[j] - nums[i] = 1 - 1 = 0 <= k`, increment `j`.\\n    - Check `nums[j] - nums[i] = 2 - 1 = 1 <= k`, increment `j`.\\n    - Check `nums[j] - nums[i] = 3 - 1 = 2 > k`, increment `result` and set `i = j = 2`.\\n    - `j` reaches the end of the array, terminate the loop.\\n- Return `result = 2`.\\n\\n## Example 3\\nGiven input: `nums = [2, 2, 4, 5]`, `k = 0`.\\n- After sorting: `[2, 2, 4, 5]`\\n- Initialize `i = 0`, `j = 0`, and `result = 1`.\\n    - Check `nums[j] - nums[i] = 2 - 2 = 0 <= k`, increment `j`.\\n    - Check `nums[j] - nums[i] = 2 - 2 = 0 <= k`, increment `j`.\\n    - Check `nums[j] - nums[i] = 4 - 2 = 2 > k`, increment `result` and set `i = j = 2`.\\n    - Check `nums[j] - nums[i] = 5 - 4 = 1 <= k`, increment `j`.\\n    - `j` reaches the end of the array, terminate the loop.\\n- Return `result = 3`.",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        sort(nums.begin(), nums.end());\\n        int result = 1, i = 0, j = 0;\\n\\n        while (j < nums.size()) {\\n            if (nums[j] - nums[i] > k) {\\n                result++;\\n                i = j;\\n            } else {\\n                j++;\\n            }\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3780830,
                "title": "c-greedy-solution-time-complexity-o-n-with-explanation",
                "content": "# Intuition\\nThe intuition is to put as many elements in a single group as long as the difference between the maximum and the minimum element in the group is at most `k`. After sorting the given vector, the minimum element is `nums[0]`. Iterate over the sorted vector and check the elements if they satisfy the property. If yes, just go to the next element. If no, then you need to form a new group and also update the minimum element of the new group.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        sort(nums.begin(),nums.end());\\n        int res = 1;\\n        int mn = nums[0];\\n        for(int i = 1; i < n; i++)\\n        {\\n            if(nums[i] - mn <= k)\\n                continue;\\n            mn = nums[i];\\n            res++;\\n        }\\n        return res;\\n    }\\n};\\n```\\nPlease upvote if the solution is help to you :)",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        sort(nums.begin(),nums.end());\\n        int res = 1;\\n        int mn = nums[0];\\n        for(int i = 1; i < n; i++)\\n        {\\n            if(nums[i] - mn <= k)\\n                continue;\\n            mn = nums[i];\\n            res++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3777743,
                "title": "4-lines-simple-and-concise",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int c=0,mn=nums[0],mx;\\n         for(int i=0;i<nums.size();i++){\\n           if(nums[i]-mn>k){\\n               c++;\\n               mn=nums[i];\\n           }\\n         }\\n         return c+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int c=0,mn=nums[0],mx;\\n         for(int i=0;i<nums.size();i++){\\n           if(nums[i]-mn>k){\\n               c++;\\n               mn=nums[i];\\n           }\\n         }\\n         return c+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3767305,
                "title": "qsort-and-check",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nqsort and check return\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlog(n))\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n1\\n# Code\\n```\\nint comp (const  void * elem1, const void *elem2){\\n    int f = *((int*)elem1);\\n    int s = *((int*)elem2);\\n    if (f>s) return 1;\\n    if (f<s) return -1;\\n    return 0;\\n}\\nint partitionArray(int* nums, int numsSize, int k){\\n    qsort(nums, numsSize, sizeof(int), comp);\\n    int ret=1;\\n    int j=0;\\n    for(int i=0;i<numsSize;i++){\\n        if(nums[i]-nums[j]>k){\\n            ret++;\\n            j=i;\\n        }\\n    }\\n    return ret;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint comp (const  void * elem1, const void *elem2){\\n    int f = *((int*)elem1);\\n    int s = *((int*)elem2);\\n    if (f>s) return 1;\\n    if (f<s) return -1;\\n    return 0;\\n}\\nint partitionArray(int* nums, int numsSize, int k){\\n    qsort(nums, numsSize, sizeof(int), comp);\\n    int ret=1;\\n    int j=0;\\n    for(int i=0;i<numsSize;i++){\\n        if(nums[i]-nums[j]>k){\\n            ret++;\\n            j=i;\\n        }\\n    }\\n    return ret;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3755758,
                "title": "beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        int count=1;\\n        ios::sync_with_stdio(0);\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        int f=nums[0];\\n        for(int i=0;i<n;i++)\\n        {\\n            if(k<(nums[i]-f))\\n            {\\n                count++;\\n                f=nums[i];\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        int count=1;\\n        ios::sync_with_stdio(0);\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        int f=nums[0];\\n        for(int i=0;i<n;i++)\\n        {\\n            if(k<(nums[i]-f))\\n            {\\n                count++;\\n                f=nums[i];\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3744722,
                "title": "simple-cpp-solution-in-4statements",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int count=1;\\n        int past=nums[0];\\n        for(int i=1;i<nums.size();i++)\\n            if(nums[i]-past>k){count++;past=nums[i];}\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int count=1;\\n        int past=nums[0];\\n        for(int i=1;i<nums.size();i++)\\n            if(nums[i]-past>k){count++;past=nums[i];}\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3716375,
                "title": "simple-code-using-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int i = 0,j = 0;\\n        int n = nums.size();\\n        int ans = 0;\\n        while(i<n){\\n            while(i<n and nums[i]-nums[j]<=k)i++;\\n            ans++;\\n            j = i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int i = 0,j = 0;\\n        int n = nums.size();\\n        int ans = 0;\\n        while(i<n){\\n            while(i<n and nums[i]-nums[j]<=k)i++;\\n            ans++;\\n            j = i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3710598,
                "title": "java-solution-simple-solution-easy",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int partitionArray(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int min = nums[0];\\n        int count = 1;\\n\\n        for(int i = 1; i < nums.length; i++)\\n            if(nums[i] - min > k){\\n                count++;\\n                min = nums[i];\\n            }\\n\\n        return count;\\n    }\\n}\\n// UP-VOTE IF HELPFUL\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int partitionArray(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int min = nums[0];\\n        int count = 1;\\n\\n        for(int i = 1; i < nums.length; i++)\\n            if(nums[i] - min > k){\\n                count++;\\n                min = nums[i];\\n            }\\n\\n        return count;\\n    }\\n}\\n// UP-VOTE IF HELPFUL\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3685968,
                "title": "sort-python",
                "content": "# Intuition\\nsort it and check the diff\\n\\n# Approach\\nif diff >k, increase the counter\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)\\n\\n- Space complexity:\\n$$O(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def partitionArray(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        # print(nums)\\n        c=0\\n        start= nums[0]\\n\\n        for i in range(1, len(nums)):\\n            if nums[i]-start>k:\\n                c=c+1\\n                start= nums[i]\\n        return (c+1)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def partitionArray(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        # print(nums)\\n        c=0\\n        start= nums[0]\\n\\n        for i in range(1, len(nums)):\\n            if nums[i]-start>k:\\n                c=c+1\\n                start= nums[i]\\n        return (c+1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3661955,
                "title": "only-use-one-for-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        sort (nums.begin(), nums.end());   \\n        int i=0,ans=1;\\n        \\n        for(int j=1;j<nums.size();j++){\\n            if (nums[j] > nums[i]+k) {\\n                i=j;\\n                ans++;        \\n            }         \\n        } \\n        return ans; \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        sort (nums.begin(), nums.end());   \\n        int i=0,ans=1;\\n        \\n        for(int j=1;j<nums.size();j++){\\n            if (nums[j] > nums[i]+k) {\\n                i=j;\\n                ans++;        \\n            }         \\n        } \\n        return ans; \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1717549,
                "content": [
                    {
                        "username": "user3238Gj",
                        "content": "what a weird question , probably you would need to ask interviewer many clarifying questions"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "`hint` Sorting then traversing "
                    },
                    {
                        "username": "swecpp",
                        "content": "I think two pointers technique can be added for this question"
                    },
                    {
                        "username": "vizzy205",
                        "content": "wow I am the only one who used deque ;-;"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "Sort the array  "
                    },
                    {
                        "username": "shouvik32",
                        "content": "class Solution {\\n    public int partitionArray(int[] nums, int k) {\\n        Arrays.sort(nums);\\n\\t\\tint count=1;\\n\\t\\tint start=0;\\n\\t\\tfor(int i=1; i<nums.length; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(nums[i]-nums[start]>k)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\tstart=i;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\treturn count;\\n    }\\n}"
                    },
                    {
                        "username": "Grishound",
                        "content": "Come on man read the first rule of Discussion."
                    }
                ]
            },
            {
                "id": 1802881,
                "content": [
                    {
                        "username": "user3238Gj",
                        "content": "what a weird question , probably you would need to ask interviewer many clarifying questions"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "`hint` Sorting then traversing "
                    },
                    {
                        "username": "swecpp",
                        "content": "I think two pointers technique can be added for this question"
                    },
                    {
                        "username": "vizzy205",
                        "content": "wow I am the only one who used deque ;-;"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "Sort the array  "
                    },
                    {
                        "username": "shouvik32",
                        "content": "class Solution {\\n    public int partitionArray(int[] nums, int k) {\\n        Arrays.sort(nums);\\n\\t\\tint count=1;\\n\\t\\tint start=0;\\n\\t\\tfor(int i=1; i<nums.length; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(nums[i]-nums[start]>k)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\tstart=i;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\treturn count;\\n    }\\n}"
                    },
                    {
                        "username": "Grishound",
                        "content": "Come on man read the first rule of Discussion."
                    }
                ]
            },
            {
                "id": 2048444,
                "content": [
                    {
                        "username": "user3238Gj",
                        "content": "what a weird question , probably you would need to ask interviewer many clarifying questions"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "`hint` Sorting then traversing "
                    },
                    {
                        "username": "swecpp",
                        "content": "I think two pointers technique can be added for this question"
                    },
                    {
                        "username": "vizzy205",
                        "content": "wow I am the only one who used deque ;-;"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "Sort the array  "
                    },
                    {
                        "username": "shouvik32",
                        "content": "class Solution {\\n    public int partitionArray(int[] nums, int k) {\\n        Arrays.sort(nums);\\n\\t\\tint count=1;\\n\\t\\tint start=0;\\n\\t\\tfor(int i=1; i<nums.length; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(nums[i]-nums[start]>k)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\tstart=i;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\treturn count;\\n    }\\n}"
                    },
                    {
                        "username": "Grishound",
                        "content": "Come on man read the first rule of Discussion."
                    }
                ]
            },
            {
                "id": 1821080,
                "content": [
                    {
                        "username": "user3238Gj",
                        "content": "what a weird question , probably you would need to ask interviewer many clarifying questions"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "`hint` Sorting then traversing "
                    },
                    {
                        "username": "swecpp",
                        "content": "I think two pointers technique can be added for this question"
                    },
                    {
                        "username": "vizzy205",
                        "content": "wow I am the only one who used deque ;-;"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "Sort the array  "
                    },
                    {
                        "username": "shouvik32",
                        "content": "class Solution {\\n    public int partitionArray(int[] nums, int k) {\\n        Arrays.sort(nums);\\n\\t\\tint count=1;\\n\\t\\tint start=0;\\n\\t\\tfor(int i=1; i<nums.length; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(nums[i]-nums[start]>k)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\tstart=i;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\treturn count;\\n    }\\n}"
                    },
                    {
                        "username": "Grishound",
                        "content": "Come on man read the first rule of Discussion."
                    }
                ]
            },
            {
                "id": 1789326,
                "content": [
                    {
                        "username": "user3238Gj",
                        "content": "what a weird question , probably you would need to ask interviewer many clarifying questions"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "`hint` Sorting then traversing "
                    },
                    {
                        "username": "swecpp",
                        "content": "I think two pointers technique can be added for this question"
                    },
                    {
                        "username": "vizzy205",
                        "content": "wow I am the only one who used deque ;-;"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "Sort the array  "
                    },
                    {
                        "username": "shouvik32",
                        "content": "class Solution {\\n    public int partitionArray(int[] nums, int k) {\\n        Arrays.sort(nums);\\n\\t\\tint count=1;\\n\\t\\tint start=0;\\n\\t\\tfor(int i=1; i<nums.length; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(nums[i]-nums[start]>k)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\tstart=i;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\treturn count;\\n    }\\n}"
                    },
                    {
                        "username": "Grishound",
                        "content": "Come on man read the first rule of Discussion."
                    }
                ]
            },
            {
                "id": 1778894,
                "content": [
                    {
                        "username": "user3238Gj",
                        "content": "what a weird question , probably you would need to ask interviewer many clarifying questions"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "`hint` Sorting then traversing "
                    },
                    {
                        "username": "swecpp",
                        "content": "I think two pointers technique can be added for this question"
                    },
                    {
                        "username": "vizzy205",
                        "content": "wow I am the only one who used deque ;-;"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "Sort the array  "
                    },
                    {
                        "username": "shouvik32",
                        "content": "class Solution {\\n    public int partitionArray(int[] nums, int k) {\\n        Arrays.sort(nums);\\n\\t\\tint count=1;\\n\\t\\tint start=0;\\n\\t\\tfor(int i=1; i<nums.length; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(nums[i]-nums[start]>k)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\tstart=i;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\treturn count;\\n    }\\n}"
                    },
                    {
                        "username": "Grishound",
                        "content": "Come on man read the first rule of Discussion."
                    }
                ]
            }
        ]
    },
    {
        "title": "Arrange Table by Gender",
        "question_content": null,
        "solutions": [],
        "discussions": []
    },
    {
        "title": "Check if Matrix Is X-Matrix",
        "question_content": "<p>A square matrix is said to be an <strong>X-Matrix</strong> if <strong>both</strong> of the following conditions hold:</p>\n\n<ol>\n\t<li>All the elements in the diagonals of the matrix are <strong>non-zero</strong>.</li>\n\t<li>All other elements are 0.</li>\n</ol>\n\n<p>Given a 2D integer array <code>grid</code> of size <code>n x n</code> representing a square matrix, return <code>true</code><em> if </em><code>grid</code><em> is an X-Matrix</em>. Otherwise, return <code>false</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/05/03/ex1.jpg\" style=\"width: 311px; height: 320px;\" />\n<pre>\n<strong>Input:</strong> grid = [[2,0,0,1],[0,3,1,0],[0,5,2,0],[4,0,0,2]]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> Refer to the diagram above. \nAn X-Matrix should have the green elements (diagonals) be non-zero and the red elements be 0.\nThus, grid is an X-Matrix.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/05/03/ex2.jpg\" style=\"width: 238px; height: 246px;\" />\n<pre>\n<strong>Input:</strong> grid = [[5,7,0],[0,3,1],[0,5,0]]\n<strong>Output:</strong> false\n<strong>Explanation:</strong> Refer to the diagram above.\nAn X-Matrix should have the green elements (diagonals) be non-zero and the red elements be 0.\nThus, grid is not an X-Matrix.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == grid.length == grid[i].length</code></li>\n\t<li><code>3 &lt;= n &lt;= 100</code></li>\n\t<li><code>0 &lt;= grid[i][j] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 2198187,
                "title": "one-pass",
                "content": "**C++**\\n```cpp\\nbool checkXMatrix(vector<vector<int>>& g) {\\n    for (int i = 0; i < g.size(); ++i)\\n        for (int j = 0; j < g[i].size(); ++j) {\\n            if (i == j || i + j == g.size() - 1) {\\n                if (g[i][j] == 0)\\n                    return false;\\n            }\\n            else if (g[i][j] > 0)\\n                return false;\\n        }\\n    return true;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nbool checkXMatrix(vector<vector<int>>& g) {\\n    for (int i = 0; i < g.size(); ++i)\\n        for (int j = 0; j < g[i].size(); ++j) {\\n            if (i == j || i + j == g.size() - 1) {\\n                if (g[i][j] == 0)\\n                    return false;\\n            }\\n            else if (g[i][j] > 0)\\n                return false;\\n        }\\n    return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2198123,
                "title": "python-java-c",
                "content": "**Python**\\n```\\nclass Solution:\\n    def checkXMatrix(self, grid: List[List[int]]) -> bool:\\n        n = len(grid)\\n        for i in range(n):\\n            for j in range(n):\\n                if i==j or (i+j) ==n-1:\\n                    if grid[i][j] == 0:\\n                        return False\\n                elif grid[i][j] != 0: \\n                    return False\\n        return True;\\n```\\n\\n**Java**\\n```\\nclass Solution {\\n    public boolean checkXMatrix(int[][] grid) {\\n        int n = grid.length;\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++ ){\\n                if ( i == j  || i + j == n - 1 ) {\\n                    if ( grid[i][j] == 0 ) return false;                    \\n                }\\n\\t\\t\\t\\telse if ( grid[i][j] != 0 ) return false;                                    \\n            }\\n        }       \\n       return true;\\n    }\\n}\\n```\\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    bool checkXMatrix(vector<vector<int>>& v1) {\\n        int n = v1.size();\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                if(i==j || (i+j) == n-1){\\n                    if(v1[i][j]==0)     return false;\\n                }\\n\\t\\t\\t\\telse if(v1[i][j]!=0)     return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution:\\n    def checkXMatrix(self, grid: List[List[int]]) -> bool:\\n        n = len(grid)\\n        for i in range(n):\\n            for j in range(n):\\n                if i==j or (i+j) ==n-1:\\n                    if grid[i][j] == 0:\\n                        return False\\n                elif grid[i][j] != 0: \\n                    return False\\n        return True;\\n```\n```\\nclass Solution {\\n    public boolean checkXMatrix(int[][] grid) {\\n        int n = grid.length;\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++ ){\\n                if ( i == j  || i + j == n - 1 ) {\\n                    if ( grid[i][j] == 0 ) return false;                    \\n                }\\n\\t\\t\\t\\telse if ( grid[i][j] != 0 ) return false;                                    \\n            }\\n        }       \\n       return true;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    bool checkXMatrix(vector<vector<int>>& v1) {\\n        int n = v1.size();\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                if(i==j || (i+j) == n-1){\\n                    if(v1[i][j]==0)     return false;\\n                }\\n\\t\\t\\t\\telse if(v1[i][j]!=0)     return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2198175,
                "title": "check-if-matrix-is-x-matrix-java-solution",
                "content": "```\\nclass Solution {\\n    public boolean checkXMatrix(int[][] grid) {\\n        for(int i=0;i<grid.length;i++)\\n        {\\n            for(int j=0;j<grid[0].length;j++)\\n            {\\n                if((i == j) || (i+j)==(grid.length-1))\\n                {\\n                    if(grid[i][j] == 0)\\n                        return false;\\n                }\\n                else\\n                {\\n                    if(grid[i][j] !=0)\\n                        return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkXMatrix(int[][] grid) {\\n        for(int i=0;i<grid.length;i++)\\n        {\\n            for(int j=0;j<grid[0].length;j++)\\n            {\\n                if((i == j) || (i+j)==(grid.length-1))\\n                {\\n                    if(grid[i][j] == 0)\\n                        return false;\\n                }\\n                else\\n                {\\n                    if(grid[i][j] !=0)\\n                        return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2198127,
                "title": "c-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkXMatrix(vector<vector<int>>& a) {\\n        int n = a.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if((i==j )or(i+j)==(n-1))\\n                {\\n                    if(a[i][j]==0)\\n                        return false;\\n                }\\n                else\\n                {   if(a[i][j]!=0)\\n                        return false;\\n                }\\n            }\\n        }\\n        return true;;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkXMatrix(vector<vector<int>>& a) {\\n        int n = a.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if((i==j )or(i+j)==(n-1))\\n                {\\n                    if(a[i][j]==0)\\n                        return false;\\n                }\\n                else\\n                {   if(a[i][j]!=0)\\n                        return false;\\n                }\\n            }\\n        }\\n        return true;;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2260192,
                "title": "go-python-c-one-pass-w-comments",
                "content": "<iframe src=\"https://leetcode.com/playground/j49mCxmw/shared\" frameBorder=\"0\" width=\"800\" height=\"500\"></iframe>",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Python3",
                    "C",
                    "Go"
                ],
                "code": "<iframe src=\"https://leetcode.com/playground/j49mCxmw/shared\" frameBorder=\"0\" width=\"800\" height=\"500\"></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 2198349,
                "title": "very-easy-java-solution",
                "content": "In a row left diagnoal element will be at where **i and j are same** and right diagnoal will be at j elements from the right most column **i.e. (N-1)-j** and we need to take absolute value of this as after N/2 rows at some point j will become a bigger value than N-1.   \\n```\\nclass Solution {\\n    public boolean checkXMatrix(int[][] grid) {\\n        int n = grid.length;\\n        \\n        // Check Diagnonals\\n        for(int i =0; i < n ; i++){\\n            if(grid[i][i] == 0 || grid[i][Math.abs(n-i-1)] == 0){\\n                return false;\\n            }\\n            \\n        }\\n       \\n        \\n        // check rest of the block\\n        for(int i = 0; i < n ;i++){\\n            for(int j = 0; j < n ; j++){\\n                if(j == i || j == Math.abs(n-i-1)){\\n                    continue;\\n                }else if(grid[i][j] != 0){\\n                    return false;\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkXMatrix(int[][] grid) {\\n        int n = grid.length;\\n        \\n        // Check Diagnonals\\n        for(int i =0; i < n ; i++){\\n            if(grid[i][i] == 0 || grid[i][Math.abs(n-i-1)] == 0){\\n                return false;\\n            }\\n            \\n        }\\n       \\n        \\n        // check rest of the block\\n        for(int i = 0; i < n ;i++){\\n            for(int j = 0; j < n ; j++){\\n                if(j == i || j == Math.abs(n-i-1)){\\n                    continue;\\n                }else if(grid[i][j] != 0){\\n                    return false;\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3228736,
                "title": "100-runtime-replace-with-row-grid-i-for-good-reading",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[][]} grid\\n * @return {boolean}\\n */\\nvar checkXMatrix = function(grid) {\\n    for (let i = 0; i < grid.length; i++) {\\n        if (grid[i][i] === 0 || grid[i][grid[i].length - i - 1] === 0) {\\n            return false;\\n        }\\n        for (let j = 0; j < grid[i].length; j++) {\\n            if (grid[i][j] !== 0 && j !== i && j !== (grid[i].length - i - 1)) {\\n                return false;\\n            }\\n        }\\n    }\\n    return true;\\n\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} grid\\n * @return {boolean}\\n */\\nvar checkXMatrix = function(grid) {\\n    for (let i = 0; i < grid.length; i++) {\\n        if (grid[i][i] === 0 || grid[i][grid[i].length - i - 1] === 0) {\\n            return false;\\n        }\\n        for (let j = 0; j < grid[i].length; j++) {\\n            if (grid[i][j] !== 0 && j !== i && j !== (grid[i].length - i - 1)) {\\n                return false;\\n            }\\n        }\\n    }\\n    return true;\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2216375,
                "title": "java-easy-simple-3ms",
                "content": "```\\nclass Solution {\\n\\tpublic boolean checkXMatrix(int[][] grid) {\\n\\t\\tint i = 0, j = 0;\\n\\t\\tint n = grid.length;\\n\\t\\tfor (i = 0; i < n; i++) {\\n\\t\\t\\tfor (j = 0; j < grid[i].length; j++) {\\n\\t\\t\\t\\tif (i == j || i + j == n - 1) {\\n\\t\\t\\t\\t\\tif (grid[i][j] == 0)\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tif (grid[i][j] != 0)\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n}\\n```\\n***Pls upvote if you find it helpful***",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n\\tpublic boolean checkXMatrix(int[][] grid) {\\n\\t\\tint i = 0, j = 0;\\n\\t\\tint n = grid.length;\\n\\t\\tfor (i = 0; i < n; i++) {\\n\\t\\t\\tfor (j = 0; j < grid[i].length; j++) {\\n\\t\\t\\t\\tif (i == j || i + j == n - 1) {\\n\\t\\t\\t\\t\\tif (grid[i][j] == 0)\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tif (grid[i][j] != 0)\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2201750,
                "title": "different-approach-diagonal-sum-total-sum",
                "content": "**Step 1:** Calculating diagonal sum, `dSum`\\n**Step 2:** Calculating total sum of all elements in matrix, `total`\\nif `totalSum == diagonalSum` , return `true` else `false`\\n\\n```\\nbool checkXMatrix(vector<vector<int>>& grid) {\\n\\tint n=grid.size();\\n\\n\\t//Calculating diagonal Sum \\n\\tint dSum=0;\\n\\tfor(int i = 0; i < n; i++){\\n\\t\\tif(grid[i][i]==0 || grid[i][n-1-i]==0) // if diagonals contains non-zero elements, return false\\n\\t\\t\\treturn false;\\n\\t\\tdSum+=grid[i][i]+grid[i][n-1-i]; \\n\\t} \\n\\tdSum = (n%2==1)? dSum-grid[n/2][n/2] : dSum;\\n\\n\\t//Calculating total sum of all elements in matrix\\n\\tint total=0;\\n\\tfor(int i = 0; i < n; i++)\\n\\t\\tfor(int j = 0; j < n; j++)\\n\\t\\t\\t total+=grid[i][j];\\n\\t\\t\\t \\n\\t//total sum == diagonal sum , return true else false\\n\\treturn total == dSum ? true : false; \\n}\\n```\\n\\n**If you like it, Please Upvote!!!**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nbool checkXMatrix(vector<vector<int>>& grid) {\\n\\tint n=grid.size();\\n\\n\\t//Calculating diagonal Sum \\n\\tint dSum=0;\\n\\tfor(int i = 0; i < n; i++){\\n\\t\\tif(grid[i][i]==0 || grid[i][n-1-i]==0) // if diagonals contains non-zero elements, return false\\n\\t\\t\\treturn false;\\n\\t\\tdSum+=grid[i][i]+grid[i][n-1-i]; \\n\\t} \\n\\tdSum = (n%2==1)? dSum-grid[n/2][n/2] : dSum;\\n\\n\\t//Calculating total sum of all elements in matrix\\n\\tint total=0;\\n\\tfor(int i = 0; i < n; i++)\\n\\t\\tfor(int j = 0; j < n; j++)\\n\\t\\t\\t total+=grid[i][j];\\n\\t\\t\\t \\n\\t//total sum == diagonal sum , return true else false\\n\\treturn total == dSum ? true : false; \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2198343,
                "title": "simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkXMatrix(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n; j++){\\n                if(i == j or i == n - j - 1){\\n                    if(!grid[i][j])\\n                        return false;\\n                }else if(grid[i][j])\\n                    return false;    \\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkXMatrix(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n; j++){\\n                if(i == j or i == n - j - 1){\\n                    if(!grid[i][j])\\n                        return false;\\n                }else if(grid[i][j])\\n                    return false;    \\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3499458,
                "title": "python3-easiest-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**Traverse Diagonal and then whole matrix**\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- traverse matrix by primary and secondary diagonal\\n- check if any of diagonal element are 0 if yes then return False.\\n- else make them zero.\\n- now after doing this travse all elements and add them.\\n- now at last if answer is 0 then return True otherwise False, because if answer is 0 then we have our \\'X\\' Matrix else not.\\n\\n# Complexity\\n- Time complexity: O(N+N*2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def checkXMatrix(self, grid: List[List[int]]) -> bool:\\n        i, k, j, N = 0, len(grid) - 1, 0, len(grid)\\n\\n        def isValid(r, c): # to check validity of co-ordinates\\n            return r in range(0, N) and c in range(0, N)\\n        \\n        while isValid(i,j): # traverse primary and secondary diagonal\\n            if grid[i][j] == 0: return 0 # checking \\'X\\' Condition\\n            if grid[k][j] == 0: return 0 # checking \\'X\\' Condition\\n            grid[i][j] = 0 # Falgging them 0\\n            grid[k][j] = 0 # Falgging them 0\\n            i += 1 # moving to next primary diagonal\\n            j += 1 # Common column factor\\n            k -= 1 # moving to next Secondary diagonal\\n        \\n        ans = 0\\n# travsersing all the elements\\n        for r in range(N): \\n            for c in range(N): \\n                ans += grid[r][c] # adding to cherck \\'X\\' Condition at last\\n        return not ans # as said return \"1 if 0\" or \"0 if otherwise\"\\n```\\n# Please like and comment below :-)",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def checkXMatrix(self, grid: List[List[int]]) -> bool:\\n        i, k, j, N = 0, len(grid) - 1, 0, len(grid)\\n\\n        def isValid(r, c): # to check validity of co-ordinates\\n            return r in range(0, N) and c in range(0, N)\\n        \\n        while isValid(i,j): # traverse primary and secondary diagonal\\n            if grid[i][j] == 0: return 0 # checking \\'X\\' Condition\\n            if grid[k][j] == 0: return 0 # checking \\'X\\' Condition\\n            grid[i][j] = 0 # Falgging them 0\\n            grid[k][j] = 0 # Falgging them 0\\n            i += 1 # moving to next primary diagonal\\n            j += 1 # Common column factor\\n            k -= 1 # moving to next Secondary diagonal\\n        \\n        ans = 0\\n# travsersing all the elements\\n        for r in range(N): \\n            for c in range(N): \\n                ans += grid[r][c] # adding to cherck \\'X\\' Condition at last\\n        return not ans # as said return \"1 if 0\" or \"0 if otherwise\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2943419,
                "title": "easier-and-faster-c-solution",
                "content": "# Approach\\nThe approach is very simple , traverse the matrix and check that the diagonal elements are non-zero and non-diagonal elements are 0.\\n\\n*For Primary Diagonal of a Matrix* : **i==j**\\n*For Secondary Diagonal of a Matrix* : **i+j+1==grid.size()**\\n\\n![matrix.png](https://assets.leetcode.com/users/images/5b49cb1b-1025-4e86-b313-e2a447e01e7d_1671824193.943293.png)\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkXMatrix(vector<vector<int>>& grid) {\\n        \\n        //traversing the Matrix\\n        for(int i=0;i<grid.size();++i){\\n            for(int j=0;j<grid[i].size();++j){\\n\\n                //Checking both primary and secondary diagonals if all the elements are non-zero \\n                if(i==j || i+j+1==grid.size()){\\n                    if(grid[i][j]==0) return false;\\n                } \\n\\n                //Checking the non-diagonal elements if all of them are 0\\n                else if(i!=j || i+j+1!=grid.size()){\\n                    if(grid[i][j]!=0) return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkXMatrix(vector<vector<int>>& grid) {\\n        \\n        //traversing the Matrix\\n        for(int i=0;i<grid.size();++i){\\n            for(int j=0;j<grid[i].size();++j){\\n\\n                //Checking both primary and secondary diagonals if all the elements are non-zero \\n                if(i==j || i+j+1==grid.size()){\\n                    if(grid[i][j]==0) return false;\\n                } \\n\\n                //Checking the non-diagonal elements if all of them are 0\\n                else if(i!=j || i+j+1!=grid.size()){\\n                    if(grid[i][j]!=0) return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2776373,
                "title": "java-most-trivial-solution",
                "content": "# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean checkXMatrix(int[][] grid) {\\n      int n = grid.length;\\n      for(int i = 0; i < n; i ++) {\\n          for(int j = 0; j < n; j ++) {\\n              if(i == j || i + j == n - 1) {\\n              if(grid[i][j] == 0) return false;\\n              }\\n              else if(grid[i][j] != 0) return false;\\n          }\\n      } \\n      return true; \\n    }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkXMatrix(int[][] grid) {\\n      int n = grid.length;\\n      for(int i = 0; i < n; i ++) {\\n          for(int j = 0; j < n; j ++) {\\n              if(i == j || i + j == n - 1) {\\n              if(grid[i][j] == 0) return false;\\n              }\\n              else if(grid[i][j] != 0) return false;\\n          }\\n      } \\n      return true; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2738494,
                "title": "java-99-70-faster-very-simple-aprroach",
                "content": "```\\n// If finding any difficulty to understand the approach you can ping me \\n// sahil2001bassan@gmail.com\\nclass Solution {\\n    public boolean checkXMatrix(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n//         Traversing throgh both diagnols\\n        for(int row=0; row<m; row++){\\n            for(int col=row , col2 = m-1-row; col<row+1 && col2<m-row; col++,col2++){\\n                if(grid[row][col] == 0){\\n                    return false;\\n                }else{\\n                    grid[row][col] = 0;\\n                }\\n//                 If it is a odd length matrix that time both diagnols will have\\n//                 one same element that is middle that time we should skip next check\\n                if(col == col2) continue;\\n                if(grid[row][col2] == 0){\\n                    return false;\\n                }else{\\n                    grid[row][col2] = 0;\\n                }\\n            }\\n        }\\n//         Traversing rest of elements\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(grid[i][j] != 0){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// If finding any difficulty to understand the approach you can ping me \\n// sahil2001bassan@gmail.com\\nclass Solution {\\n    public boolean checkXMatrix(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n//         Traversing throgh both diagnols\\n        for(int row=0; row<m; row++){\\n            for(int col=row , col2 = m-1-row; col<row+1 && col2<m-row; col++,col2++){\\n                if(grid[row][col] == 0){\\n                    return false;\\n                }else{\\n                    grid[row][col] = 0;\\n                }\\n//                 If it is a odd length matrix that time both diagnols will have\\n//                 one same element that is middle that time we should skip next check\\n                if(col == col2) continue;\\n                if(grid[row][col2] == 0){\\n                    return false;\\n                }else{\\n                    grid[row][col2] = 0;\\n                }\\n            }\\n        }\\n//         Traversing rest of elements\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(grid[i][j] != 0){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2665632,
                "title": "simple-java-solution-easy-to-understand",
                "content": "Upvote if you liked the solution\\n```\\nclass Solution {\\n    public boolean checkXMatrix(int[][] grid) {\\n        \\n\\n        int n=grid.length;\\n        for(int i=0;i<grid.length;i++)\\n        {\\n            for(int j=0;j<grid[0].length;j++)\\n            {\\n                if(i==j || i+j+1==n) \\n                {\\n                    if(grid[i][j]==0) return false;\\n                }\\n                else\\n                {\\n                    if(grid[i][j]!=0) return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C",
                    "Matrix"
                ],
                "code": "class Solution {\\n    public boolean checkXMatrix(int[][] grid) {\\n        \\n\\n        int n=grid.length;\\n        for(int i=0;i<grid.length;i++)\\n        {\\n            for(int j=0;j<grid[0].length;j++)\\n            {\\n                if(i==j || i+j+1==n) \\n                {\\n                    if(grid[i][j]==0) return false;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2432829,
                "title": "96-faster-one-pass-easy-to-understand-c-cpp",
                "content": "```\\nbool checkXMatrix(vector<vector<int>>& grid) {\\n        int p=0,q=grid[0].size()-1;\\n        \\n        for(int i=0;i<grid.size();++i){\\n            for(int j=0;j<grid[0].size();++j){\\n                if(i==j||(i==p&&j==q)){\\n                    //diagonal elements\\n                    if(grid[i][j]==0)\\n                        return false;\\n                }\\n                else{\\n                    //non diagonal elements\\n                    if(grid[i][j]!=0)\\n                        return false;\\n                }\\n            }\\n            p++;\\n            q--;\\n        }\\n        \\n        return true;\\n    }",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nbool checkXMatrix(vector<vector<int>>& grid) {\\n        int p=0,q=grid[0].size()-1;\\n        \\n        for(int i=0;i<grid.size();++i){\\n            for(int j=0;j<grid[0].size();++j){\\n                if(i==j||(i==p&&j==q)){\\n                    //diagonal elements\\n                    if(grid[i][j]==0)\\n                        return false;\\n                }\\n                else{\\n                    //non diagonal elements\\n                    if(grid[i][j]!=0)\\n                        return false;\\n                }\\n            }\\n            p++;\\n            q--;\\n        }\\n        \\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2282112,
                "title": "c-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkXMatrix(vector<vector<int>>& nums) {\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(i==j || j==n-1-i){\\n                    if(!nums[i][j])    // if diagonal elements contain zero \\n                        return false;\\n                }else if(nums[i][j])  // non diagonal elements contain non-zero\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkXMatrix(vector<vector<int>>& nums) {\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(i==j || j==n-1-i){\\n                    if(!nums[i][j])    // if diagonal elements contain zero \\n                        return false;\\n                }else if(nums[i][j])  // non diagonal elements contain non-zero\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2198162,
                "title": "java-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public boolean checkXMatrix(int[][] grid) {\\n        int n = grid.length-1;\\n        //Making a boolean matrix of same dimensions as of the grid to check whether we have visited that element or not\\n        boolean[][] isVisited = new boolean[grid.length][ grid.length];\\n\\n        for (int i = 0; i < grid.length; i++) {\\n            //For primary diagonal\\n            if (grid[i][i]==0){\\n                //We have found one breakage to the rule as diagonal is zero, so returning false\\n                return false;\\n            }else{\\n                isVisited[i][i] = true;\\n                //Else the diagonal matrix is 0, and we have visited that element\\n            }\\n            //For secondary diagonal\\n            if (grid[i][n]==0){\\n                //We have found one breakage to the rule as diagonal is zero, so returning false\\n                return false;\\n            }else {\\n\\t\\t\\t// When the columns are equal to  n, we have right to left diagonal and we are decreasing the value of n after every pass\\n                //Else we have visited this element\\n                isVisited[i][n--] = true;\\n                //Decreasing n for the next iteration to get secondary diagonal\\n            }\\n        }\\n        //Now, checking for the remaining grid and as we have already marked the diagonals as visited,\\n        // we will only check for the remaining elements\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid.length; j++) {\\n                if (!isVisited[i][j]){\\n                    //All the elements except those present in diagonals now can be differentiated\\n                    if (grid[i][j]!= 0){\\n                        //If they are not equal to zero, then the condition does not hold, and we return the ans\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n        //Else if we have traversed entirely and no condition has broken, it means that the ans is true\\n        return true;\\n    }\\n}\\n```\\nDo upvote the solution and comment for any doubts :)",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkXMatrix(int[][] grid) {\\n        int n = grid.length-1;\\n        //Making a boolean matrix of same dimensions as of the grid to check whether we have visited that element or not\\n        boolean[][] isVisited = new boolean[grid.length][ grid.length];\\n\\n        for (int i = 0; i < grid.length; i++) {\\n            //For primary diagonal\\n            if (grid[i][i]==0){\\n                //We have found one breakage to the rule as diagonal is zero, so returning false\\n                return false;\\n            }else{\\n                isVisited[i][i] = true;\\n                //Else the diagonal matrix is 0, and we have visited that element\\n            }\\n            //For secondary diagonal\\n            if (grid[i][n]==0){\\n                //We have found one breakage to the rule as diagonal is zero, so returning false\\n                return false;\\n            }else {\\n\\t\\t\\t// When the columns are equal to  n, we have right to left diagonal and we are decreasing the value of n after every pass\\n                //Else we have visited this element\\n                isVisited[i][n--] = true;\\n                //Decreasing n for the next iteration to get secondary diagonal\\n            }\\n        }\\n        //Now, checking for the remaining grid and as we have already marked the diagonals as visited,\\n        // we will only check for the remaining elements\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid.length; j++) {\\n                if (!isVisited[i][j]){\\n                    //All the elements except those present in diagonals now can be differentiated\\n                    if (grid[i][j]!= 0){\\n                        //If they are not equal to zero, then the condition does not hold, and we return the ans\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n        //Else if we have traversed entirely and no condition has broken, it means that the ans is true\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4064700,
                "title": "typescript-solution",
                "content": "\\n\\n# Code\\n```\\nfunction checkXMatrix(grid: number[][]): boolean {\\n\\tconst size = grid.length;\\n\\tfor (let i = 0; i < size; i++) {\\n\\t\\tfor (let j = 0; j < size; j++) {\\n            \\n\\t\\t\\tconst isDiagonal = j === i || j === size - i - 1;\\n\\t\\t\\tconst currentElement = grid[i][j];\\n\\n\\t\\t\\tif (isDiagonal ? currentElement === 0 : currentElement !== 0) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn true;\\n}\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Matrix"
                ],
                "code": "```\\nfunction checkXMatrix(grid: number[][]): boolean {\\n\\tconst size = grid.length;\\n\\tfor (let i = 0; i < size; i++) {\\n\\t\\tfor (let j = 0; j < size; j++) {\\n            \\n\\t\\t\\tconst isDiagonal = j === i || j === size - i - 1;\\n\\t\\t\\tconst currentElement = grid[i][j];\\n\\n\\t\\t\\tif (isDiagonal ? currentElement === 0 : currentElement !== 0) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn true;\\n}\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3447560,
                "title": "beginners-solution-explained",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n        check forward and backward element must not be zero    \\n        and others must be 0\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean checkXMatrix(int[][] grid) {\\n\\n        for(int i=0;i<grid.length;i++){\\n            // if(grid[i][i]==0 || grid[i][grid.length-i-1]==0) return false;\\n            for(int j=0; j<grid.length;j++){\\n                if(i==j || j==grid.length-i-1){\\n                    if(grid[i][j] ==0) return false;\\n                } else {\\n                    if(grid[i][j] !=0) return false;\\n                }\\n               \\n            }\\n\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkXMatrix(int[][] grid) {\\n\\n        for(int i=0;i<grid.length;i++){\\n            // if(grid[i][i]==0 || grid[i][grid.length-i-1]==0) return false;\\n            for(int j=0; j<grid.length;j++){\\n                if(i==j || j==grid.length-i-1){\\n                    if(grid[i][j] ==0) return false;\\n                } else {\\n                    if(grid[i][j] !=0) return false;\\n                }\\n               \\n            }\\n\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3035401,
                "title": "easy-cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkXMatrix(vector<vector<int>>& grid) {\\n       int n=grid.size();\\n       for(int i=0;i<n;i++){\\n           for(int j=0;j<n;j++){\\n               if((i==j or i+j==n-1) and grid[i][j]==0) return 0;\\n               if(i!=j and i+j!=n-1 and grid[i][j]!=0) return 0;\\n           }\\n       }\\n       return 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkXMatrix(vector<vector<int>>& grid) {\\n       int n=grid.size();\\n       for(int i=0;i<n;i++){\\n           for(int j=0;j<n;j++){\\n               if((i==j or i+j==n-1) and grid[i][j]==0) return 0;\\n               if(i!=j and i+j!=n-1 and grid[i][j]!=0) return 0;\\n           }\\n       }\\n       return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3000472,
                "title": "java-simple-approach-brute-force-approach",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- First check diagonal \\n- Check all the remaining cases\\n\\n# Complexity\\n- Time complexity: O(N2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean checkXMatrix(int[][] grid) {\\n        int[][] array=grid;\\n         boolean bool=false;\\n         for(int i=0; i<grid.length; i++){\\n             if(!(grid[i][i]!=0)) return false;\\n          \\n             if(!(grid.length%2!=0 && ((grid.length/2))==i)) grid[i][i]=0;\\n         }\\n       \\n         int count=0;\\n         for(int i=grid.length-1;i>=0; i--){\\n             if(!(grid[i][count]!=0)) return false;\\n             grid[i][count]=0;\\n             count++;\\n         }\\n       \\n        for(int[] a:grid){\\n            for(int ele:a){\\n                if(ele!=0) return false;\\n            }\\n        }\\n        return true;\\n\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkXMatrix(int[][] grid) {\\n        int[][] array=grid;\\n         boolean bool=false;\\n         for(int i=0; i<grid.length; i++){\\n             if(!(grid[i][i]!=0)) return false;\\n          \\n             if(!(grid.length%2!=0 && ((grid.length/2))==i)) grid[i][i]=0;\\n         }\\n       \\n         int count=0;\\n         for(int i=grid.length-1;i>=0; i--){\\n             if(!(grid[i][count]!=0)) return false;\\n             grid[i][count]=0;\\n             count++;\\n         }\\n       \\n        for(int[] a:grid){\\n            for(int ele:a){\\n                if(ele!=0) return false;\\n            }\\n        }\\n        return true;\\n\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2967455,
                "title": "one-line-100-99",
                "content": "i = rows, j = colums\\n```\\n//          IF SOME OF THIS TRUE THEN THROW FALSE\\n//                                                           if not diagonal\\n//         if diagonal                        and equal 0     and not equal 0 \\n//              |                                 |              |\\n//              V                                 V              V\\n(i === j || i === grid.length - 1 - j) ? grid[i][j] === 0 : grid[i][j] !== 0)\\n```\\n\\n# Code\\n```\\n/**\\n * @param {number[][]} grid\\n * @return {boolean}\\n */\\nvar checkXMatrix = function(grid) {\\n    return !grid.some((_, i) => grid[i].some((_, j) => (i === j || i === grid.length - 1 - j) ? grid[i][j] === 0 : grid[i][j] !== 0));\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n//          IF SOME OF THIS TRUE THEN THROW FALSE\\n//                                                           if not diagonal\\n//         if diagonal                        and equal 0     and not equal 0 \\n//              |                                 |              |\\n//              V                                 V              V\\n(i === j || i === grid.length - 1 - j) ? grid[i][j] === 0 : grid[i][j] !== 0)\\n```\n```\\n/**\\n * @param {number[][]} grid\\n * @return {boolean}\\n */\\nvar checkXMatrix = function(grid) {\\n    return !grid.some((_, i) => grid[i].some((_, j) => (i === j || i === grid.length - 1 - j) ? grid[i][j] === 0 : grid[i][j] !== 0));\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2850956,
                "title": "easy-cplusplus-solution-just-2-conditions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkXMatrix(vector<vector<int>>& grid) {\\n        // int n = grid.size();\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid.size();j++){\\n                if(i==j && grid[i][j]==0) return false;\\n                else if(grid.size()-j-1==i && grid[i][j]==0) return false;\\n                else if((i!=j && grid[i][j]!=0)&&(grid.size()-j-1!=i && grid[i][j]!=0)) return false;\\n                // if(i==j){\\n                //     if(grid[i][j]==0) return false;\\n                // }\\n                // if(grid.size()-j-1==i){\\n                //     if(grid[i][j]==0) return false;\\n                // }\\n                // if(i!=j && grid.size()-j-1!=i){\\n                //     if(grid[i][j]!=0) return false;\\n                // }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkXMatrix(vector<vector<int>>& grid) {\\n        // int n = grid.size();\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid.size();j++){\\n                if(i==j && grid[i][j]==0) return false;\\n                else if(grid.size()-j-1==i && grid[i][j]==0) return false;\\n                else if((i!=j && grid[i][j]!=0)&&(grid.size()-j-1!=i && grid[i][j]!=0)) return false;\\n                // if(i==j){\\n                //     if(grid[i][j]==0) return false;\\n                // }\\n                // if(grid.size()-j-1==i){\\n                //     if(grid[i][j]==0) return false;\\n                // }\\n                // if(i!=j && grid.size()-j-1!=i){\\n                //     if(grid[i][j]!=0) return false;\\n                // }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2411392,
                "title": "easy-to-understand-java-simple-approach-with-comments",
                "content": "```\\nclass Solution {\\n    public boolean checkXMatrix(int[][] grid) {\\n        \\n        // for(i==j) I am checking the primary diagonal...\\n        // for((i+1)+(j+1)==n) I am checking the secondary diagonal...\\n        // else I am checking the rest values of the matrix...\\n        \\n        int n = grid.length+1;\\n        for(int i=0 ; i<grid.length ; i++){\\n            for(int j=0 ; j<grid.length ; j++){\\n                if(i==j && grid[i][j]==0){\\n                    return false;\\n                }\\n                else if((i+1)+(j+1)==n && grid[i][j]==0){\\n                    return false;\\n                }\\n                else if((i!=j) && ((i+1)+(j+1)!=n) && grid[i][j]!=0){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n        \\n        // Time Complexity : O(n^2)\\n        // Space Complexity : O(n^2)\\n        \\n\\t\\t\\n\\t\\t// Kindly upvote if you like so that I get motivated to post more and more solutions...\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkXMatrix(int[][] grid) {\\n        \\n        // for(i==j) I am checking the primary diagonal...\\n        // for((i+1)+(j+1)==n) I am checking the secondary diagonal...\\n        // else I am checking the rest values of the matrix...\\n        \\n        int n = grid.length+1;\\n        for(int i=0 ; i<grid.length ; i++){\\n            for(int j=0 ; j<grid.length ; j++){\\n                if(i==j && grid[i][j]==0){\\n                    return false;\\n                }\\n                else if((i+1)+(j+1)==n && grid[i][j]==0){\\n                    return false;\\n                }\\n                else if((i!=j) && ((i+1)+(j+1)!=n) && grid[i][j]!=0){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n        \\n        // Time Complexity : O(n^2)\\n        // Space Complexity : O(n^2)\\n        \\n\\t\\t\\n\\t\\t// Kindly upvote if you like so that I get motivated to post more and more solutions...\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2399428,
                "title": "easy-python",
                "content": "```\\ndef checkXMatrix(self, grid: List[List[int]]) -> bool:\\n        for i in range(len(grid)):\\n            for j in range(len(grid)):\\n                if (i == j or i == len(grid) - j - 1) and grid[i][j] != 0:\\n                    continue\\n                elif i != j and i != len(grid) - j - 1 and grid[i][j] != 0:\\n                    return False\\n                elif  (i == j or i == len(grid) - j - 1) and grid[i][j] == 0:\\n                    return False\\n                \\n                \\n        return True",
                "solutionTags": [],
                "code": "```\\ndef checkXMatrix(self, grid: List[List[int]]) -> bool:\\n        for i in range(len(grid)):\\n            for j in range(len(grid)):\\n                if (i == j or i == len(grid) - j - 1) and grid[i][j] != 0:\\n                    continue\\n                elif i != j and i != len(grid) - j - 1 and grid[i][j] != 0:\\n                    return False\\n                elif  (i == j or i == len(grid) - j - 1) and grid[i][j] == 0:\\n                    return False\\n                \\n                \\n        return True",
                "codeTag": "Python3"
            },
            {
                "id": 2219858,
                "title": "easy-javascript-typescript-solution",
                "content": "Simple JavaScript/TypeScript solution:\\n```\\nfunction checkXMatrix(grid: number[][]): boolean {\\n    const n = grid.length;\\n    for (let i = 0; i < n; i++) {\\n        for (let j = 0; j < n; j++) {\\n            if (i === j && grid[i][j] === 0) return false;\\n            if (i === n - j - 1 && grid[i][j] === 0) return false;\\n            if (i !== j && i !== n - j - 1 && grid[i][j] !== 0) return false;\\n        }\\n    }\\n    return true;\\n};\\n```\\n\\nThe best result:\\nRuntime:\\xA072 ms, faster than\\xA0100.00%\\xA0of\\xA0TypeScript\\xA0online submissions for\\xA0Check if Matrix Is X-Matrix.\\nMemory Usage:\\xA045 MB, less than\\xA081.82%\\xA0of\\xA0TypeScript\\xA0online submissions for\\xA0Check if Matrix Is X-Matrix.\\n",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction checkXMatrix(grid: number[][]): boolean {\\n    const n = grid.length;\\n    for (let i = 0; i < n; i++) {\\n        for (let j = 0; j < n; j++) {\\n            if (i === j && grid[i][j] === 0) return false;\\n            if (i === n - j - 1 && grid[i][j] === 0) return false;\\n            if (i !== j && i !== n - j - 1 && grid[i][j] !== 0) return false;\\n        }\\n    }\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2212482,
                "title": "java-simple-6-statements-plus-super-fast-recursive",
                "content": "**Simple:**  This first code example is the simple code.  It scans all the cells of the grid, using XOR to check for \"is it an X cell\" XOR \"is it non-zero\".  If of these tests are true, or both of these tests are false, then it is NOT an X-Matrix.  \\nRuntime is usually 2ms or 3ms.\\n```\\nclass Solution {\\n    public boolean checkXMatrix(int[][] grid) {\\n        int n = grid.length - 1;\\n        for (int row = n; row >= 0; row--)\\n            for (int col = n; col >= 0; col--)\\n                if ((row == col || row == n - col) ^ (grid[row][col] != 0))\\n                    return false;\\n        return true;\\n    }\\n}\\n```\\n**Fast:**  The following code recursively checks the cells of the grid.  The recursion processes first tests the cells around the border of the grid.  Then recurses to test the border of a smaller square within the grid.  This repeats with the border of smaller and smaller nested squares, until reaching the center of the grid.\\nRuntime is usually 0ms or 1ms.\\n```\\nclass Solution {\\n    public boolean checkXMatrix(int[][] grid) {\\n        return checkRect(grid, 0, grid.length - 1);\\n    }\\n    \\n    boolean checkRect(int[][] grid, int first, int last) {\\n        if (grid[first][first] == 0 || grid[first][last] == 0 ||\\n            grid[last][first] == 0 || grid[last][last] == 0)  return false;\\n        for (int i = first + 1; i < last; i++) \\n            if (grid[first][i] != 0 || grid[last][i] != 0 || \\n               grid[i][first] != 0 || grid[i][last] != 0)  return false;\\n        if (first + 1 >= last)  return true;\\n        return checkRect(grid, first + 1, last - 1);\\n    }\\n}\\n```\\n**Middle:**  The code below has a runtime between the two code examples above.  The code below first tests the \"X\" part of the grid for any zero values, and sets all \"X\" values to zero.  Then the entire grid is tested for any non-zero values, including the \"X\" part of the grid which had previously be set to all zeroes.\\nRuntime is usually 1ms or 2ms.\\n```\\nclass Solution {\\n    public boolean checkXMatrix(int[][] grid) {\\n        int n = grid.length - 1;\\n        for (int i = n; i >= 0; i--) {\\n            if (grid[i][i] == 0 || grid[i][n - i] == 0)  return false;\\n            grid[i][i] = 0;\\n            grid[i][n - i] = 0;\\n        }\\n        for (int row = n; row >= 0; row--) {\\n            int[] curRow = grid[row];\\n            for (int col = n; col >= 0; col--)\\n                if (curRow[col] != 0)\\n                    return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkXMatrix(int[][] grid) {\\n        int n = grid.length - 1;\\n        for (int row = n; row >= 0; row--)\\n            for (int col = n; col >= 0; col--)\\n                if ((row == col || row == n - col) ^ (grid[row][col] != 0))\\n                    return false;\\n        return true;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean checkXMatrix(int[][] grid) {\\n        return checkRect(grid, 0, grid.length - 1);\\n    }\\n    \\n    boolean checkRect(int[][] grid, int first, int last) {\\n        if (grid[first][first] == 0 || grid[first][last] == 0 ||\\n            grid[last][first] == 0 || grid[last][last] == 0)  return false;\\n        for (int i = first + 1; i < last; i++) \\n            if (grid[first][i] != 0 || grid[last][i] != 0 || \\n               grid[i][first] != 0 || grid[i][last] != 0)  return false;\\n        if (first + 1 >= last)  return true;\\n        return checkRect(grid, first + 1, last - 1);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean checkXMatrix(int[][] grid) {\\n        int n = grid.length - 1;\\n        for (int i = n; i >= 0; i--) {\\n            if (grid[i][i] == 0 || grid[i][n - i] == 0)  return false;\\n            grid[i][i] = 0;\\n            grid[i][n - i] = 0;\\n        }\\n        for (int row = n; row >= 0; row--) {\\n            int[] curRow = grid[row];\\n            for (int col = n; col >= 0; col--)\\n                if (curRow[col] != 0)\\n                    return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2209009,
                "title": "c-simple-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool checkXMatrix(vector<vector<int>>& grid) {\\n\\t\\t\\tint n = grid.size();\\n\\t\\t\\tfor(int i = 0; i < n; i++){\\n\\t\\t\\t\\tfor(int j = 0; j < n; j++){\\n\\t\\t\\t\\t\\tif((i == j) or (i + j == n - 1)){\\n\\t\\t\\t\\t\\t\\tif(grid[i][j] == 0){\\n\\t\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\t\\tif(grid[i][j] != 0){\\n\\t\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tbool checkXMatrix(vector<vector<int>>& grid) {\\n\\t\\t\\tint n = grid.size();\\n\\t\\t\\tfor(int i = 0; i < n; i++){\\n\\t\\t\\t\\tfor(int j = 0; j < n; j++){\\n\\t\\t\\t\\t\\tif((i == j) or (i + j == n - 1)){\\n\\t\\t\\t\\t\\t\\tif(grid[i][j] == 0){\\n\\t\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2202606,
                "title": "javascript-early-return-solution",
                "content": "```\\n/**\\n * @param {number[][]} grid\\n * @return {boolean}\\n */\\nconst checkXMatrix = grid => {\\n    for (let i = 0; i < grid.length; i += 1) {\\n        for (let j = 0; j < grid.length; j += 1) {\\n            const isDiagonal = i === j || i + j === grid.length - 1;\\n\\n            if ((isDiagonal && grid[i][j] === 0) || (!isDiagonal && grid[i][j] !== 0)) {\\n                return false;\\n            }\\n        }\\n    }\\n    \\n    return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} grid\\n * @return {boolean}\\n */\\nconst checkXMatrix = grid => {\\n    for (let i = 0; i < grid.length; i += 1) {\\n        for (let j = 0; j < grid.length; j += 1) {\\n            const isDiagonal = i === j || i + j === grid.length - 1;\\n\\n            if ((isDiagonal && grid[i][j] === 0) || (!isDiagonal && grid[i][j] !== 0)) {\\n                return false;\\n            }\\n        }\\n    }\\n    \\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2202542,
                "title": "simple-easy-kotlin-solution-faster-than-100",
                "content": "Kotlin code:\\n```\\n    fun checkXMatrix(grid: Array<IntArray>): Boolean {\\n        var i = 0\\n        var j = 0\\n        val matrix = mutableListOf<MutableList<Boolean>>()\\n        for (k in grid.indices) {\\n            val g = mutableListOf<Boolean>()\\n            for (l in grid[k].indices) g.add(false)\\n            matrix.add(g)\\n        }\\n        while (i<grid.size) {\\n            if (grid[i][j]==0) return false\\n            matrix[i][j] = true\\n            i++\\n            j++\\n        }\\n        j = grid.size-1\\n        i=0\\n        while (j>=0) {\\n            if (grid[i][j]==0) return false\\n            matrix[i][j] = true\\n            i++\\n            j--\\n        }\\n\\n        for (k in matrix.indices) {\\n            for (l in matrix[k].indices) {\\n                if (!matrix[k][l]) {\\n                    if (grid[k][l]!=0) return false\\n                }\\n            }\\n        }\\n        return true\\n    }\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Matrix"
                ],
                "code": "```\\n    fun checkXMatrix(grid: Array<IntArray>): Boolean {\\n        var i = 0\\n        var j = 0\\n        val matrix = mutableListOf<MutableList<Boolean>>()\\n        for (k in grid.indices) {\\n            val g = mutableListOf<Boolean>()\\n            for (l in grid[k].indices) g.add(false)\\n            matrix.add(g)\\n        }\\n        while (i<grid.size) {\\n            if (grid[i][j]==0) return false\\n            matrix[i][j] = true\\n            i++\\n            j++\\n        }\\n        j = grid.size-1\\n        i=0\\n        while (j>=0) {\\n            if (grid[i][j]==0) return false\\n            matrix[i][j] = true\\n            i++\\n            j--\\n        }\\n\\n        for (k in matrix.indices) {\\n            for (l in matrix[k].indices) {\\n                if (!matrix[k][l]) {\\n                    if (grid[k][l]!=0) return false\\n                }\\n            }\\n        }\\n        return true\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2200568,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    pub fn check_x_matrix(grid: Vec<Vec<i32>>) -> bool {\\n        let n = grid.len();\\n        grid.iter().enumerate().all(|(i, row)| {\\n            row.iter()\\n                .enumerate()\\n                .all(|(j, &x)| match i == j || i == (n - j - 1) {\\n                    true => x > 0,\\n                    false => x == 0,\\n                })\\n        })\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn check_x_matrix(grid: Vec<Vec<i32>>) -> bool {\\n        let n = grid.len();\\n        grid.iter().enumerate().all(|(i, row)| {\\n            row.iter()\\n                .enumerate()\\n                .all(|(j, &x)| match i == j || i == (n - j - 1) {\\n                    true => x > 0,\\n                    false => x == 0,\\n                })\\n        })\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2198558,
                "title": "kotlin-one-pass",
                "content": "```\\nclass Solution {\\n    fun checkXMatrix(grid: Array<IntArray>): Boolean {\\n        val n = grid.size\\n        grid.forEachIndexed { i, row ->\\n            row.forEachIndexed { j, cur ->\\n                when {\\n                    i == j || j == n - i - 1 -> if (cur == 0) return false\\n                    cur != 0 -> return false\\n                }\\n            }\\n        }\\n        return true\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun checkXMatrix(grid: Array<IntArray>): Boolean {\\n        val n = grid.size\\n        grid.forEachIndexed { i, row ->\\n            row.forEachIndexed { j, cur ->\\n                when {\\n                    i == j || j == n - i - 1 -> if (cur == 0) return false\\n                    cur != 0 -> return false\\n                }\\n            }\\n        }\\n        return true\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2198487,
                "title": "o-n2-single-pass-solution-with-explanation",
                "content": "Intuition :\\nDiagonal 1: i=j\\n```\\nfor i=0,j=0\\nfor i=1,j=1\\n...\\nfor i=n-1,j=n-1\\n```\\nDiagnol 2: j==n-i-1\\n```\\nfor i=0,j=n-1\\nfor i=1,j=n-2\\n...\\nfor i=n-1,j=0\\n```\\nAll the other elements are non diagonal elements.\\n```\\nbool checkXMatrix(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(i==j||j==n-i-1){\\n                    if(grid[i][j]==0)return false;\\n                }\\n                else if(grid[i][j]!=0)return false;\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nfor i=0,j=0\\nfor i=1,j=1\\n...\\nfor i=n-1,j=n-1\\n```\n```\\nfor i=0,j=n-1\\nfor i=1,j=n-2\\n...\\nfor i=n-1,j=0\\n```\n```\\nbool checkXMatrix(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(i==j||j==n-i-1){\\n                    if(grid[i][j]==0)return false;\\n                }\\n                else if(grid[i][j]!=0)return false;\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2198366,
                "title": "easy-single-pass-solution-with-explanation-and-pictures",
                "content": "#### Rationale\\n* It could be observed that the left diagonal elements exist where both the indices are equal and the right diagonal elements exist where they add up to `n - 1`\\n* We could return early with a falsy value if:\\n\\t* the current element is a diagonal element and is not zero\\n\\t* the current element is not a diagonal element and is zero\\n\\n![image](https://assets.leetcode.com/users/images/41b52b74-13c8-4f62-9c48-e77d5f025223_1656217749.707465.png)\\n\\n\\n\\n\\n\\n#### Complexities\\n* Time: `O(n^2)`\\n* Space: `O(1)`\\n\\n```\\nclass Solution:\\n    def checkXMatrix(self, grid: List[List[int]]) -> bool:\\n        n = len(grid)\\n        \\n        for i in range(n):\\n            for j in range(n):\\n\\t\\t\\t\\tis_left_diagonal = i == j\\n\\t\\t\\t\\tis_right_diagonal = i + j == n - 1\\n\\t\\t\\t\\t\\n                if is_left_diagonal or is_right_diagonal:\\n                    if grid[i][j] == 0:\\n                        return False\\n                elif grid[i][j] != 0:\\n                    return False\\n                \\n        return True\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def checkXMatrix(self, grid: List[List[int]]) -> bool:\\n        n = len(grid)\\n        \\n        for i in range(n):\\n            for j in range(n):\\n\\t\\t\\t\\tis_left_diagonal = i == j\\n\\t\\t\\t\\tis_right_diagonal = i + j == n - 1\\n\\t\\t\\t\\t\\n                if is_left_diagonal or is_right_diagonal:\\n                    if grid[i][j] == 0:\\n                        return False\\n                elif grid[i][j] != 0:\\n                    return False\\n                \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2198331,
                "title": "java-full-approach-clean-code-commented-code",
                "content": "**Approach:** 1)\\tWe will traverse the complete matrix.\\n2)\\tWe will do a few checks, we make sure that the elements on the diagonal are no zero and elements which are not on the diagonal are zero.\\n3)\\tFirst check: Diagonal 1 \\u2013 If (i==j), then it is diagonal 1, we will return false if the element on this diagonal is zero, we will return false.\\n4)\\tSecond check: Diagonal 2 \\u2013 If (i+j==grid.length-1) then it is diagonal 2, we will return false if the element on this diagonal is zero, we will return false.\\n5)\\tThird Check: If the element is not on diagonal 1 and diagonal, we will return false if the element is non-zero.\\n6)\\tIn the end after we have traversed the complete matrix, and if we didn\\u2019t satisfy any of the conditions the program would have returned false, so it means that it has satisfied all the conditions so now we will return true in the end.\\n\\n**Time Complexity:** O(N^2)\\n**Space Complexity:** O(1)\\n\\n\\n```\\nclass Solution {\\n    public boolean checkXMatrix(int[][] grid) {\\n        for(int i=0;i<grid.length;i++)\\n        {\\n            for(int j=0;j<grid[0].length;j++)\\n            {\\n                if(i==j) // If it is diagonal 1\\n                {\\n                    if(grid[i][j]==0) // If the element inside this diagonal is zero, we will return false.\\n                        return false;\\n                }\\n                \\n                else if(i+j==grid.length-1) // If it is diagonal 2\\n                {\\n                    if(grid[i][j]==0) // If the element inside this diagonal is zero, we will return false.\\n                        return false;\\n                }\\n                \\n                else // If it is neither diagonal 1 or diagonal 2\\n                {\\n                    if(grid[i][j]!=0) // If the element inside is non-zero, we will return false.\\n                        return false;\\n                }\\n            }\\n        }\\n    \\n        return true; // Since we were able to traverse the complete matrix this means, all the conditions were satisfied so we return true\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkXMatrix(int[][] grid) {\\n        for(int i=0;i<grid.length;i++)\\n        {\\n            for(int j=0;j<grid[0].length;j++)\\n            {\\n                if(i==j) // If it is diagonal 1\\n                {\\n                    if(grid[i][j]==0) // If the element inside this diagonal is zero, we will return false.\\n                        return false;\\n                }\\n                \\n                else if(i+j==grid.length-1) // If it is diagonal 2\\n                {\\n                    if(grid[i][j]==0) // If the element inside this diagonal is zero, we will return false.\\n                        return false;\\n                }\\n                \\n                else // If it is neither diagonal 1 or diagonal 2\\n                {\\n                    if(grid[i][j]!=0) // If the element inside is non-zero, we will return false.\\n                        return false;\\n                }\\n            }\\n        }\\n    \\n        return true; // Since we were able to traverse the complete matrix this means, all the conditions were satisfied so we return true\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2198326,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public boolean checkXMatrix(int[][] g) {\\n        int n=g.length;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(g[i][i]==0||g[i][g.length-1-i]==0)\\n                return false;\\n        }\\n        int m=n-1;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i==j||(i+j)==m)\\n                {\\n                    continue;\\n                }\\n                else\\n                {\\n                    if(g[i][j]!=0)\\n                    {\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public boolean checkXMatrix(int[][] g) {\\n        int n=g.length;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(g[i][i]==0||g[i][g.length-1-i]==0)\\n                return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3697344,
                "title": "java-simple-easy-solution-beats-99",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nGive it a DRY run. You\\'ll get it.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean checkXMatrix(int[][] grid) {\\n        int n = grid.length;\\n        for(int i = 0;i<n;i++)\\n        {\\n            for(int j =0;j<n;j++)\\n            {\\n                if(j==i || j==n-i-1)\\n                {\\n                    if(grid[i][j]==0) return false;\\n                }\\n\\n                else\\n                {\\n                    if(grid[i][j]!=0) return false;\\n                }\\n                \\n            }\\n        }\\n        return true;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkXMatrix(int[][] grid) {\\n        int n = grid.length;\\n        for(int i = 0;i<n;i++)\\n        {\\n            for(int j =0;j<n;j++)\\n            {\\n                if(j==i || j==n-i-1)\\n                {\\n                    if(grid[i][j]==0) return false;\\n                }\\n\\n                else\\n                {\\n                    if(grid[i][j]!=0) return false;\\n                }\\n                \\n            }\\n        }\\n        return true;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3501034,
                "title": "a-good-way-to-learn-how-to-solve-problems-regarding-diagonals-of-matrices-og-solution",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    bool checkXMatrix(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        for(int i=0;i<n;i++){\\n            if(grid[i][i]==0 or grid[i][n-i-1]==0) //no need of 2 loops to check for both diagonals\\n                return false;\\n            for(int j=0;j<n;j++){\\n                if(j!=i and j!=n-i-1 and grid[i][j]!=0)\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkXMatrix(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        for(int i=0;i<n;i++){\\n            if(grid[i][i]==0 or grid[i][n-i-1]==0) //no need of 2 loops to check for both diagonals\\n                return false;\\n            for(int j=0;j<n;j++){\\n                if(j!=i and j!=n-i-1 and grid[i][j]!=0)\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3338915,
                "title": "simple-python-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def checkXMatrix(self, grid: List[List[int]]) -> bool:\\n        n=len(grid)\\n        for i in range(n):\\n            for j in range(n):\\n                if((i!=j and i+j!=n-1) and grid[i][j]!=0):\\n                    return 0\\n                elif((i==j or i+j==n-1) and grid[i][j]==0):\\n                    return 0\\n        return 1\\n\\n\\n```\\nLike? hit that button",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkXMatrix(self, grid: List[List[int]]) -> bool:\\n        n=len(grid)\\n        for i in range(n):\\n            for j in range(n):\\n                if((i!=j and i+j!=n-1) and grid[i][j]!=0):\\n                    return 0\\n                elif((i==j or i+j==n-1) and grid[i][j]==0):\\n                    return 0\\n        return 1\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3329563,
                "title": "easy-c-matrix-traversal",
                "content": "# Intuition\\nDiagonal elements are the elements where i==j or i+j==grid.size()-1\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkXMatrix(vector<vector<int>> &grid)\\n{\\n    for (int i = 0; i < grid.size(); i++)\\n    {\\n        for (int j = 0; j < grid[i].size(); j++)\\n        {\\n            if(i==j || i+j == grid.size()-1){\\n                if(grid[i][j]!=0){\\n                    //do nothing\\n                }\\n                else return false;\\n            }\\n            else{\\n                if(grid[i][j]==0){\\n                    //do nothing\\n                }\\n                else return false;\\n            }\\n        }\\n        \\n    }\\n    return true;\\n    \\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkXMatrix(vector<vector<int>> &grid)\\n{\\n    for (int i = 0; i < grid.size(); i++)\\n    {\\n        for (int j = 0; j < grid[i].size(); j++)\\n        {\\n            if(i==j || i+j == grid.size()-1){\\n                if(grid[i][j]!=0){\\n                    //do nothing\\n                }\\n                else return false;\\n            }\\n            else{\\n                if(grid[i][j]==0){\\n                    //do nothing\\n                }\\n                else return false;\\n            }\\n        }\\n        \\n    }\\n    return true;\\n    \\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3248863,
                "title": "python-3-beat-94-263ms-two-pointer",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def checkXMatrix(self, grid: List[List[int]]) -> bool:\\n        i, j = 0, len(grid) - 1\\n        a, b = [], []\\n        while i < len(grid):\\n            if i != j and grid[i].count(0) != len(grid) - 2:\\n                return False\\n            if  grid[i][i] and grid[i][j] != 0:\\n                a.append(grid[i][i])\\n                a.append(grid[i][j])\\n            i += 1\\n            j -= 1\\n        print(a, b)\\n        return len(a) ==  len(grid) * 2 \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkXMatrix(self, grid: List[List[int]]) -> bool:\\n        i, j = 0, len(grid) - 1\\n        a, b = [], []\\n        while i < len(grid):\\n            if i != j and grid[i].count(0) != len(grid) - 2:\\n                return False\\n            if  grid[i][i] and grid[i][j] != 0:\\n                a.append(grid[i][i])\\n                a.append(grid[i][j])\\n            i += 1\\n            j -= 1\\n        print(a, b)\\n        return len(a) ==  len(grid) * 2 \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3228972,
                "title": "python-8-lines-of-the-simple-code",
                "content": "# Complexity\\n- Time complexity:\\n96.88%\\n\\n- Space complexity:\\n52.83%\\n\\n# Problems\\nThis solution has a side-effect. You can\\'t use your matrix after calling this function.\\n\\n# Code\\n```\\nclass Solution:\\n    def checkXMatrix(self, grid: List[List[int]]) -> bool:\\n        size = len(grid)\\n        last = size - 1\\n\\n        for i in range(size):\\n            if grid[i][i] == 0 or grid[i][last - i] == 0:\\n                return False\\n\\n            grid[i][i] = 0\\n            grid[i][last - i] = 0\\n\\n        return sum((item for sublist in grid for item in sublist)) == 0\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkXMatrix(self, grid: List[List[int]]) -> bool:\\n        size = len(grid)\\n        last = size - 1\\n\\n        for i in range(size):\\n            if grid[i][i] == 0 or grid[i][last - i] == 0:\\n                return False\\n\\n            grid[i][i] = 0\\n            grid[i][last - i] = 0\\n\\n        return sum((item for sublist in grid for item in sublist)) == 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3120031,
                "title": "c-easy-and-simple-solution",
                "content": "***Guy\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE. By doing that it motivate\\'s me to create more better post like this \\u270D\\uFE0F***\\n\\n# Complexity\\n- Time complexity:\\nO(N*N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkXMatrix(vector<vector<int>>& grid) {\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                if(i==j || i+j==grid.size()-1){\\n                    if(grid[i][j]==0) return false;\\n                }else {\\n                    if(grid[i][j]!=0) return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\\n***Guy\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE. By doing that it motivate\\'s me to create more better post like this \\u270D\\uFE0F***",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkXMatrix(vector<vector<int>>& grid) {\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                if(i==j || i+j==grid.size()-1){\\n                    if(grid[i][j]==0) return false;\\n                }else {\\n                    if(grid[i][j]!=0) return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3039687,
                "title": "easy-python-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def checkXMatrix(self, grid: List[List[int]]) -> bool:\\n        n=len(grid)\\n        sum=0\\n        c=0\\n        for x in range(n):\\n            for y in range(n):\\n                if not(x==y) and not(x==n-y-1):\\n                    sum+=grid[x][y]\\n                elif (x==y) or (x==n-y-1):\\n                    if grid[x][y]!=0:\\n                        c+=1\\n        if sum==0:\\n            if (n%2==0 and c==n*2) or (n%2!=0 and c==(n*2)-1):\\n                return True\\n        else:\\n            return False\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def checkXMatrix(self, grid: List[List[int]]) -> bool:\\n        n=len(grid)\\n        sum=0\\n        c=0\\n        for x in range(n):\\n            for y in range(n):\\n                if not(x==y) and not(x==n-y-1):\\n                    sum+=grid[x][y]\\n                elif (x==y) or (x==n-y-1):\\n                    if grid[x][y]!=0:\\n                        c+=1\\n        if sum==0:\\n            if (n%2==0 and c==n*2) or (n%2!=0 and c==(n*2)-1):\\n                return True\\n        else:\\n            return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3019754,
                "title": "python-short-clean-two-line-one-pass",
                "content": "# Code\\n```\\nfrom itertools import product\\nfrom typing import List\\n\\n\\nclass Solution:\\n    def checkXMatrix(self, grid: List[List[int]]) -> bool:\\n        n1 = len(grid) - 1\\n        return all(\\n            bool(grid[i][j] == 0) ^ bool(i == j or i + j == n1)\\n            for i, j in product(range(n1 + 1), repeat=2)\\n        )\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom itertools import product\\nfrom typing import List\\n\\n\\nclass Solution:\\n    def checkXMatrix(self, grid: List[List[int]]) -> bool:\\n        n1 = len(grid) - 1\\n        return all(\\n            bool(grid[i][j] == 0) ^ bool(i == j or i + j == n1)\\n            for i, j in product(range(n1 + 1), repeat=2)\\n        )\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2813352,
                "title": "java-check-if-matrix-is-x-matrix-3ms-quadratic-tc",
                "content": "```\\nclass Solution {\\n    public boolean checkXMatrix(int[][] grid) {\\n        int n = grid.length;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(i==j && grid[i][j]==0)        return false;   //left diagonal\\n            else if((i+j==n-1) && grid[i][j]==0) return false;   // right diagonal\\n            else if( (i!=j) && (i+j!=n-1) && grid[i][j]!=0) return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\\n![image](https://assets.leetcode.com/users/images/a1d53b91-20bb-4a45-a493-708735f8d17f_1668417029.797294.png)\\n",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkXMatrix(int[][] grid) {\\n        int n = grid.length;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(i==j && grid[i][j]==0)        return false;   //left diagonal\\n            else if((i+j==n-1) && grid[i][j]==0) return false;   // right diagonal\\n            else if( (i!=j) && (i+j!=n-1) && grid[i][j]!=0) return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2808956,
                "title": "simple-python-solution",
                "content": "```\\nclass Solution:\\n    def checkXMatrix(self, grid: List[List[int]]) -> bool:\\n        r = len(grid)\\n        c = len(grid[0])\\n        for m in range(r):\\n            for n in range(c):\\n                if (m==n and grid[m][n]==0) or (m==((r-1)-n) and grid[m][n]==0):return False\\n                elif not(m==n or m==((r-1)-n)) and grid[m][n]!=0:return False\\n        return True\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkXMatrix(self, grid: List[List[int]]) -> bool:\\n        r = len(grid)\\n        c = len(grid[0])\\n        for m in range(r):\\n            for n in range(c):\\n                if (m==n and grid[m][n]==0) or (m==((r-1)-n) and grid[m][n]==0):return False\\n                elif not(m==n or m==((r-1)-n)) and grid[m][n]!=0:return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2672418,
                "title": "java-solution-easy",
                "content": "### Please Upvote :D\\n```\\nclass Solution {\\n    public boolean checkXMatrix(int[][] grid) {\\n        int n = grid.length;\\n\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (i == j || i + j + 1 == n) {\\n                    if (grid[i][j] == 0) return false;\\n                }\\n                else {\\n                    if (grid[i][j] != 0) return false;\\n                }\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n\\n// TC: O(n * n)\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkXMatrix(int[][] grid) {\\n        int n = grid.length;\\n\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (i == j || i + j + 1 == n) {\\n                    if (grid[i][j] == 0) return false;\\n                }\\n                else {\\n                    if (grid[i][j] != 0) return false;\\n                }\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n\\n// TC: O(n * n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2514216,
                "title": "java-solution-2ms-runtime-90-70-faster-easy-to-understand-brute-force",
                "content": "```\\nclass Solution {\\n    public boolean checkXMatrix(int[][] arr) {\\n        if (checkX(arr)) {\\n            if (othersNotZero(arr)) {\\n                return true;\\n            }\\n            return false;\\n        }\\n        return false;\\n    }\\n\\n    private static boolean othersNotZero(int[][] arr) {\\n        for (int i = 0; i < arr.length; i++) {\\n            for (int j = 0; j < arr[i].length; j++) {\\n                if (arr[i][j] == -1) continue;\\n                else if (arr[i][j] != 0) return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    private static boolean checkX(int[][] arr) {\\n        for (int i = 0; i < arr.length; i++) {\\n            if (arr[i][i] == 0){\\n                return false;\\n            }\\n            else arr[i][i] = -1;\\n        }\\n        int x = arr.length - 1;\\n        for (int i = 0; i < arr.length; i++) {\\n            if (arr[i][x--] == 0) {\\n                return false;\\n            }\\n            else arr[i][x+1] = -1;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkXMatrix(int[][] arr) {\\n        if (checkX(arr)) {\\n            if (othersNotZero(arr)) {\\n                return true;\\n            }\\n            return false;\\n        }\\n        return false;\\n    }\\n\\n    private static boolean othersNotZero(int[][] arr) {\\n        for (int i = 0; i < arr.length; i++) {\\n            for (int j = 0; j < arr[i].length; j++) {\\n                if (arr[i][j] == -1) continue;\\n                else if (arr[i][j] != 0) return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    private static boolean checkX(int[][] arr) {\\n        for (int i = 0; i < arr.length; i++) {\\n            if (arr[i][i] == 0){\\n                return false;\\n            }\\n            else arr[i][i] = -1;\\n        }\\n        int x = arr.length - 1;\\n        for (int i = 0; i < arr.length; i++) {\\n            if (arr[i][x--] == 0) {\\n                return false;\\n            }\\n            else arr[i][x+1] = -1;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2476855,
                "title": "explained-java-o-n-solution-100-faster",
                "content": "So, I go over matrix only once.\\n\\nWhen I took a pen and a paper and started thinking, I found out that diagonal cells coordinates are of a two kinds:\\n- first: a diagonal from left top to right bottom has cells with coordinates (0,0), (1,1), (2,2)... So, which **i == j** in the code below. \\n- second: a diagonal from left bottom to right top has cells with coordinates (8,0), (7,1), (6,2)...(0,8). This applies for a matrix with x (side) == 9. Thus, here **i + j == x - 1**.\\n\\nAs you can see, if **i and j** satisfy one of those conditions, then we check if value of that cell: if it is equal to 0, then return false, since it does not satisfy the problem.\\n\\nIf i and j do not satisfy diagonal cell\\'s conditions then we check if the value of a cell is more than 0. And if yes, then return false, since it is not correct according to problem.\\n\\nIf we successfully finish the loop, that means all the cells meet the corresponding conditions.\\n\\n```\\nclass Solution {\\n    public boolean checkXMatrix(int[][] grid) {\\n        int x = grid.length;\\n        for (int i = 0; i < x; i++) {\\n            for (int j = 0; j < x; j++) {\\n                if (i + j == x - 1 || i == j) { //coordinates of diagonal cells\\n                    if (grid[i][j] == 0) {\\n                        return false;\\n                    }\\n                    continue;\\n                } else if (grid[i][j] > 0) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean checkXMatrix(int[][] grid) {\\n        int x = grid.length;\\n        for (int i = 0; i < x; i++) {\\n            for (int j = 0; j < x; j++) {\\n                if (i + j == x - 1 || i == j) { //coordinates of diagonal cells\\n                    if (grid[i][j] == 0) {\\n                        return false;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 2446512,
                "title": "java-3ms-simple-and-explained-solution",
                "content": "```\\n  //the trick is that we will find the total sum of all the elements of the matrix and then\\n//we will see if it is equall to the diognal sum it will be a x matrix if the sum is equall ;\\n      int sum = 0 ; int dgsum = 0 ;\\n        //we took 2 variables ;\\n        \\n        //used for loop for iterating over the matrix ;\\n            for(int i = 0 ; i < grid.length ; i++ ){\\n                for(int j = 0 ; j < grid[i].length ; j++){\\n                    sum = sum + grid[i][j];//adding every value in the variable sum ;\\n                    \\n                     if(i == j || i == grid.length-1-j ){\\n                        //adding diognal value in the variable dgsum ;\\n                        dgsum = grid[i][j] + dgsum ;\\n                        if( grid[i][j] <= 0){\\n//if any diognal element is found 0 this will return false ;\\n                    return false ;\\n                    }\\n                }\\n                    \\n                }\\n            }\\n            //n ow we will compare the sum and dgsum ;\\n        // it will return true for sum = = dgsum ;\\n            if(sum == dgsum){\\n                return true ;\\n            }else{\\n                return false ;\\n            }",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "```\\n  //the trick is that we will find the total sum of all the elements of the matrix and then\\n//we will see if it is equall to the diognal sum it will be a x matrix if the sum is equall ;\\n      int sum = 0 ; int dgsum = 0 ;\\n        //we took 2 variables ;\\n        \\n        //used for loop for iterating over the matrix ;\\n            for(int i = 0 ; i < grid.length ; i++ ){\\n                for(int j = 0 ; j < grid[i].length ; j++){\\n                    sum = sum + grid[i][j];//adding every value in the variable sum ;\\n                    \\n                     if(i == j || i == grid.length-1-j ){\\n                        //adding diognal value in the variable dgsum ;\\n                        dgsum = grid[i][j] + dgsum ;\\n                        if( grid[i][j] <= 0){\\n//if any diognal element is found 0 this will return false ;\\n                    return false ;\\n                    }\\n                }\\n                    \\n                }\\n            }\\n            //n ow we will compare the sum and dgsum ;\\n        // it will return true for sum = = dgsum ;\\n            if(sum == dgsum){\\n                return true ;\\n            }else{\\n                return false ;\\n            }",
                "codeTag": "Unknown"
            },
            {
                "id": 2446508,
                "title": "c-easy-and-short-faster-than-89-explained-code",
                "content": "An X matrix is a matrix which only has non zero diagonal elements. So in this code we calculate the sum of diagonal elemnts of matrix and the sum of whole matrix. If the matrix contains all the other elements zero except the diagonal elements then both the sums should be equal.\\n```\\n int sum = 0, n = grid.size(), diag_sum = 0;\\n            // traverse through the matrix\\n        for(int i = 0; i < n;  i ++) {\\n            \\n            for(int j = 0; j < n; j ++) {\\n                \\n                sum = sum + grid[i][j]; \\n                // the condition for diagonal elements \\n                if (i == j || i == n-1-j) {\\n                    if (grid[i][j] == 0)         // if any diagonal element is zero return false\\n                        return false;\\n                    else                            // else calculate the sum of diagonal elements\\n                        diag_sum = grid[i][j] + diag_sum;\\n               }\\n            }\\n        }\\n        \\n        if (sum == diag_sum) {        // if sum of diagonal elements is equal to sum of all elements \\n            return true;                     // this means all the elements outside diagonals are zero in the matrix\\n        }\\n        else                                    // else we return false\\n            return false;",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "An X matrix is a matrix which only has non zero diagonal elements. So in this code we calculate the sum of diagonal elemnts of matrix and the sum of whole matrix. If the matrix contains all the other elements zero except the diagonal elements then both the sums should be equal.\\n```\\n int sum = 0, n = grid.size(), diag_sum = 0;\\n            // traverse through the matrix\\n        for(int i = 0; i < n;  i ++) {\\n            \\n            for(int j = 0; j < n; j ++) {\\n                \\n                sum = sum + grid[i][j]; \\n                // the condition for diagonal elements \\n                if (i == j || i == n-1-j) {\\n                    if (grid[i][j] == 0)         // if any diagonal element is zero return false\\n                        return false;\\n                    else                            // else calculate the sum of diagonal elements\\n                        diag_sum = grid[i][j] + diag_sum;\\n               }\\n            }\\n        }\\n        \\n        if (sum == diag_sum) {        // if sum of diagonal elements is equal to sum of all elements \\n            return true;                     // this means all the elements outside diagonals are zero in the matrix\\n        }\\n        else                                    // else we return false\\n            return false;",
                "codeTag": "Unknown"
            },
            {
                "id": 2411285,
                "title": "easy-to-understand-c",
                "content": "\\'\\'\\'\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool checkXMatrix(vector<vector<int>>& grid) {\\n\\t\\t\\tint n = grid.size();\\n\\t\\t\\tfor(int i=0; i<n; i++){\\n\\t\\t\\t\\tfor(int j=0; j<n; j++){\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t//to check  the diagonal are zero or not if zero return false\\n\\t\\t\\t\\t\\tif(grid[i][j] == 0 && (i == j || j == n-i-1))\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t//to check the rest of the elements are zero or not .If not zero return false\\n\\t\\t\\t\\t\\tif(grid[i][j] != 0 && (i != j && j != n-i-1) )\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t};\\n\\'\\'\\'\\nIf it is helpful, you are smart enough what to do \\uD83D\\uDC4D: )",
                "solutionTags": [
                    "C",
                    "Matrix"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tbool checkXMatrix(vector<vector<int>>& grid) {\\n\\t\\t\\tint n = grid.size();\\n\\t\\t\\tfor(int i=0; i<n; i++){\\n\\t\\t\\t\\tfor(int j=0; j<n; j++){\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t//to check  the diagonal are zero or not if zero return false\\n\\t\\t\\t\\t\\tif(grid[i][j] == 0 && (i == j || j == n-i-1))\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t//to check the rest of the elements are zero or not .If not zero return false\\n\\t\\t\\t\\t\\tif(grid[i][j] != 0 && (i != j && j != n-i-1) )\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2410736,
                "title": "python-easy-and-faster-solution",
                "content": "```\\ndef checkXMatrix(self, grid: List[List[int]]) -> bool:\\n        left = -1\\n        right = len(grid)\\n        \\n        for row in grid:\\n            \\n            left += 1\\n            right -= 1\\n            \\n            for i in range(len(row)):\\n                if row[left] == 0 or row[right] == 0:\\n                    return False\\n                \\n                if i != left and i != right:\\n                    if row[i] != 0:\\n                        print(row[i], i, left)\\n                        return False\\n                    \\n        return True\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef checkXMatrix(self, grid: List[List[int]]) -> bool:\\n        left = -1\\n        right = len(grid)\\n        \\n        for row in grid:\\n            \\n            left += 1\\n            right -= 1\\n            \\n            for i in range(len(row)):\\n                if row[left] == 0 or row[right] == 0:\\n                    return False\\n                \\n                if i != left and i != right:\\n                    if row[i] != 0:\\n                        print(row[i], i, left)\\n                        return False\\n                    \\n        return True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2368873,
                "title": "easiest-python-solution-you-will-find-single-loop",
                "content": "\\n```class Solution:\\n    def checkXMatrix(self, grid: List[List[int]]) -> bool:\\n        lst=[]\\n        a=0\\n        j=len(grid)-1\\n        for i in range(0,len(grid)):\\n            if grid[i][i]==0:\\n                return False\\n            if grid[i][j]==0:\\n                return False\\n            if i!=j:\\n                a=grid[i][i]+grid[i][j]\\n                lst.append(a)\\n            elif i==j:\\n                a=grid[i][i]\\n                lst.append(a)\\n            j-=1\\n        for i in range(0,len(grid)):\\n            if sum(grid[i])!=lst[i]:\\n                return False\\n        \\n            \\n        return True\\n```\\nAfter optimising.\\n```\\nclass Solution:\\n    def checkXMatrix(self, grid: List[List[int]]) -> bool:\\n        a=0\\n        j=len(grid)-1\\n        for i in range(0,len(grid)):\\n            if grid[i][i]==0 or grid[i][j]==0:\\n                return False\\n            else:\\n                if i!=j:\\n                    a=grid[i][i]+grid[i][j]\\n                elif i==j:\\n                    a=grid[i][i]\\n            if a!=sum(grid[i]):\\n                return False\\n            j-=1\\n        return True\\n            \\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```class Solution:\\n    def checkXMatrix(self, grid: List[List[int]]) -> bool:\\n        lst=[]\\n        a=0\\n        j=len(grid)-1\\n        for i in range(0,len(grid)):\\n            if grid[i][i]==0:\\n                return False\\n            if grid[i][j]==0:\\n                return False\\n            if i!=j:\\n                a=grid[i][i]+grid[i][j]\\n                lst.append(a)\\n            elif i==j:\\n                a=grid[i][i]\\n                lst.append(a)\\n            j-=1\\n        for i in range(0,len(grid)):\\n            if sum(grid[i])!=lst[i]:\\n                return False\\n        \\n            \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2351225,
                "title": "fastest-java-solution",
                "content": "```\\nclass Solution {\\n    public boolean checkXMatrix(int[][] grid) {\\n        int row = grid.length;\\n        for(int i=0;i<row;i++)\\n        {\\n            for(int j=0;j<row;j++)\\n            {\\n                if(i==j || i+j == row-1){\\n                    if(grid[i][j]==0)\\n                        return false;\\n                }\\n                else{ \\n                    if(grid[i][j]!=0)\\n                        return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public boolean checkXMatrix(int[][] grid) {\\n        int row = grid.length;\\n        for(int i=0;i<row;i++)\\n        {\\n            for(int j=0;j<row;j++)\\n            {\\n                if(i==j || i+j == row-1){\\n                    if(grid[i][j]==0)\\n                        return false;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2344400,
                "title": "simple-python-faster-than-99",
                "content": "![image](https://assets.leetcode.com/users/images/2dfd83dd-12bb-4899-9284-e2ebe9b3ab03_1658989550.8461027.png)\\n\\n```\\nclass Solution:\\n    def checkXMatrix(self, grid: List[List[int]]) -> bool:\\n        m, n = 0, len(grid) - 1\\n        for row in grid:\\n            for count, num in enumerate(row):\\n                if count == m or count == n:\\n                    if num == 0:\\n                        return False\\n                else:\\n                    if num != 0:\\n                        return False\\n            m += 1\\n            n -= 1\\n        return True\\n```\\nVery simple solution. Hopefully it is readable enough that no explanation is required.\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def checkXMatrix(self, grid: List[List[int]]) -> bool:\\n        m, n = 0, len(grid) - 1\\n        for row in grid:\\n            for count, num in enumerate(row):\\n                if count == m or count == n:\\n                    if num == 0:\\n                        return False\\n                else:\\n                    if num != 0:\\n                        return False\\n            m += 1\\n            n -= 1\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2327739,
                "title": "c-easy-solution-with-proper-explanation",
                "content": "```\\nn = 5        //size of matrix\\n5 6 7 8 9\\n1 2 3 4 5\\n6 3 2 8 1\\n5 4 3 2 1\\n7 8 4 3 9\\n\\nPrimary Diagonal : 5 -> 2 -> 2 -> 2 -> 9\\nSecondary Diagonal : 9 -> 4 -> 2 -> 4 -> 7\\n\\nA00 A01 A02 A03 A04\\nA10 A11 A12 A13 A14\\nA20 A21 A22 A23 A24\\nA30 A31 A32 A33 A34\\nA40 A41 A42 A43 A44\\n\\nso taking the example of 5*5 matrix\\n\\nPrimary Diagonal will be : A00 -> A11 -> A22 -> A33 -> A44\\nand\\nSecondary Diagonal will be : A04 -> A13 -> A22 -> A31 -> A40\\n\\nCondition for Primary diagonal is: row == column\\nand\\nCondition for Secondary diagonal is: (row + column) == n-1\\n\\nYou can find the code below.\\n```\\n```\\nclass Solution {\\npublic:\\n    bool checkXMatrix(vector<vector<int>>& grid) {\\n        \\n        int n = grid.size();\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n; j++){\\n                if(i==j){\\n                    if(grid[i][j] == 0) {\\n                        return false;\\n                    }\\n                }\\n                else if((i+j) == n-1){\\n                    if(grid[i][j] == 0){\\n                        return false;\\n                    }\\n                }\\n                else if(grid[i][j] != 0){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nn = 5        //size of matrix\\n5 6 7 8 9\\n1 2 3 4 5\\n6 3 2 8 1\\n5 4 3 2 1\\n7 8 4 3 9\\n\\nPrimary Diagonal : 5 -> 2 -> 2 -> 2 -> 9\\nSecondary Diagonal : 9 -> 4 -> 2 -> 4 -> 7\\n\\nA00 A01 A02 A03 A04\\nA10 A11 A12 A13 A14\\nA20 A21 A22 A23 A24\\nA30 A31 A32 A33 A34\\nA40 A41 A42 A43 A44\\n\\nso taking the example of 5*5 matrix\\n\\nPrimary Diagonal will be : A00 -> A11 -> A22 -> A33 -> A44\\nand\\nSecondary Diagonal will be : A04 -> A13 -> A22 -> A31 -> A40\\n\\nCondition for Primary diagonal is: row == column\\nand\\nCondition for Secondary diagonal is: (row + column) == n-1\\n\\nYou can find the code below.\\n```\n```\\nclass Solution {\\npublic:\\n    bool checkXMatrix(vector<vector<int>>& grid) {\\n        \\n        int n = grid.size();\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n; j++){\\n                if(i==j){\\n                    if(grid[i][j] == 0) {\\n                        return false;\\n                    }\\n                }\\n                else if((i+j) == n-1){\\n                    if(grid[i][j] == 0){\\n                        return false;\\n                    }\\n                }\\n                else if(grid[i][j] != 0){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2312808,
                "title": "c-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkXMatrix(vector<vector<int>>& grid) {\\n        int n = grid.size(); //length of side\\n        int i = 0; // index of the elements of the primary diagonal\\n        int j = n-1; // index of the elements of the secondary diagonal\\n        int sum = 0; // total\\n        int u = 0; // index of row\\n        int center = 0; // in case if n is odd, cause we have to subtract the center from the final total(we counted the center twice)\\n        int total = 0;\\n        while(j != -1) {\\n            if(i == j) {\\n                center = grid[u][i]; // find the center\\n            }\\n            if(grid[u][i] == 0 || grid[u][j] == 0) return false; // check if the all elements in the diagonals are non-zero\\n            sum += grid[u][i]+grid[u][j];\\n            u++;\\n            i++;\\n            j--; \\n        }\\n        if(n % 2 != 0) sum -= center;\\n        \\n        for(i = 0; i < n; i++) {\\n            for(j = 0; j < n; j++) {\\n                total += grid[i][j];\\n            }\\n        }\\n        return total != sum ? false : true; // check if the non-diagonal elements are zero\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkXMatrix(vector<vector<int>>& grid) {\\n        int n = grid.size(); //length of side\\n        int i = 0; // index of the elements of the primary diagonal\\n        int j = n-1; // index of the elements of the secondary diagonal\\n        int sum = 0; // total\\n        int u = 0; // index of row\\n        int center = 0; // in case if n is odd, cause we have to subtract the center from the final total(we counted the center twice)\\n        int total = 0;\\n        while(j != -1) {\\n            if(i == j) {\\n                center = grid[u][i]; // find the center\\n            }\\n            if(grid[u][i] == 0 || grid[u][j] == 0) return false; // check if the all elements in the diagonals are non-zero\\n            sum += grid[u][i]+grid[u][j];\\n            u++;\\n            i++;\\n            j--; \\n        }\\n        if(n % 2 != 0) sum -= center;\\n        \\n        for(i = 0; i < n; i++) {\\n            for(j = 0; j < n; j++) {\\n                total += grid[i][j];\\n            }\\n        }\\n        return total != sum ? false : true; // check if the non-diagonal elements are zero\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2246753,
                "title": "java-beginners-friendly-easy-to-understand",
                "content": "Three seperate loops for three conditions, although they can be merged together into a single loop.\\n```\\nclass Solution {\\n    public boolean checkXMatrix(int[][] grid) {\\n        int n = grid.length;\\n        \\n        // principal diagonal\\n        for (int i = 0; i < n; i++) {\\n           if (grid[i][i] == 0) return false; \\n        }\\n        \\n        // checking for other diagonal\\n        for (int i = 0; i < n; i++) {\\n            if (grid[i][n-i-1] == 0) return false;    \\n        }\\n        \\n        // checking for remaining\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (i != j && j != n-i-1) {\\n                    if (grid[i][j] != 0) return false;\\n                }\\n            }   \\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkXMatrix(int[][] grid) {\\n        int n = grid.length;\\n        \\n        // principal diagonal\\n        for (int i = 0; i < n; i++) {\\n           if (grid[i][i] == 0) return false; \\n        }\\n        \\n        // checking for other diagonal\\n        for (int i = 0; i < n; i++) {\\n            if (grid[i][n-i-1] == 0) return false;    \\n        }\\n        \\n        // checking for remaining\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (i != j && j != n-i-1) {\\n                    if (grid[i][j] != 0) return false;\\n                }\\n            }   \\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2223386,
                "title": "python-only-one-loop",
                "content": "```\\nclass Solution(object):\\n    def checkXMatrix(self, grid):\\n        count_zero=0\\n        for i in range(len(grid[0])):\\n            if grid[i][i]==0 or grid[i][len(grid[0])-i-1]==0:return False\\n            count_zero+=grid[i].count(0)\\n        return count_zero==len(grid[0])*len(grid[0])-2*len(grid[0])+len(grid[0])%2\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def checkXMatrix(self, grid):\\n        count_zero=0\\n        for i in range(len(grid[0])):\\n            if grid[i][i]==0 or grid[i][len(grid[0])-i-1]==0:return False\\n            count_zero+=grid[i].count(0)\\n        return count_zero==len(grid[0])*len(grid[0])-2*len(grid[0])+len(grid[0])%2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2220172,
                "title": "ruby-solution",
                "content": "```\\ndef check_x_matrix(grid)\\n    size = grid.size\\n    size.times do |i|\\n        if grid[i][i] == 0 || grid[i][size - 1 -i] == 0\\n            return false\\n        else\\n            grid[i][i] = nil\\n            grid[i][size - 1 -i] = nil\\n        end\\n    end\\n    grid.flatten.compact.all?(0) ? true : false\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef check_x_matrix(grid)\\n    size = grid.size\\n    size.times do |i|\\n        if grid[i][i] == 0 || grid[i][size - 1 -i] == 0\\n            return false\\n        else\\n            grid[i][i] = nil\\n            grid[i][size - 1 -i] = nil\\n        end\\n    end\\n    grid.flatten.compact.all?(0) ? true : false\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2218457,
                "title": "php",
                "content": "![image](https://assets.leetcode.com/users/images/c6dcd62b-b4cb-4bc9-bbe8-a968c0eb3110_1656594561.3662379.png)\\n```\\nclass Solution\\n{\\n\\n  /**\\n   * @param Integer[][] $grid\\n   * @return Boolean\\n   */\\n  function checkXMatrix($grid)\\n  {\\n\\n    // Check from top right diagnol to bottom right.\\n    $left_right_diagnol = [];\\n    $right_left_diagnol = [];\\n    $col_and_row_length = count($grid[0]) - 1;\\n    $odd_row_skip = false;\\n\\n    if ((($col_and_row_length + 1) % 2 !== 0)) {\\n      $odd_row_skip =  ($col_and_row_length / 2) + 1;\\n      $odd_row_skip--;\\n    }\\n    $total_array_sum = 0;\\n    foreach ($grid as $row_num => $row) {\\n\\n      $total_array_sum += array_sum($row);\\n\\n      // Non negative diagnol check\\n      $right_left_val = $row[$col_and_row_length - $row_num];\\n      $left_right_val = $row[$row_num];\\n      if ($right_left_val === 0 || $left_right_val === 0) {\\n        return false;\\n      }\\n      if ($odd_row_skip && $row_num == $odd_row_skip) {\\n\\n        $left_right_diagnol[] = $left_right_val;\\n      } else {\\n        $left_right_diagnol[] = $left_right_val;\\n        $right_left_diagnol[] = $right_left_val;\\n      }\\n    }\\n\\n\\n    // check that all other values are zero\\n    $sum_of_all_diagnols = array_sum($left_right_diagnol) + array_sum($right_left_diagnol);\\n    if ($sum_of_all_diagnols !== $total_array_sum) {\\n      return false;\\n    }\\n\\n    return true;\\n  }\\n}",
                "solutionTags": [
                    "PHP"
                ],
                "code": "class Solution\\n{\\n\\n  /**\\n   * @param Integer[][] $grid\\n   * @return Boolean\\n   */\\n  function checkXMatrix($grid)\\n  {\\n\\n    // Check from top right diagnol to bottom right.\\n    $left_right_diagnol = [];\\n    $right_left_diagnol = [];\\n    $col_and_row_length = count($grid[0]) - 1;\\n    $odd_row_skip = false;\\n\\n    if ((($col_and_row_length + 1) % 2 !== 0)) {\\n      $odd_row_skip =  ($col_and_row_length / 2) + 1;\\n      $odd_row_skip--;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2211546,
                "title": "python-simple-solution",
                "content": "```\\nclass Solution:\\n    def checkXMatrix(self, grid: List[List[int]]) -> bool:\\n        n = len(grid)\\n        for i in range(n):\\n            for j in range(n):\\n                if i == j or i + j == n-1:\\n                    if grid[i][j] == 0:\\n                        return False\\n                else:\\n                    if grid[i][j] != 0:\\n                        return False\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkXMatrix(self, grid: List[List[int]]) -> bool:\\n        n = len(grid)\\n        for i in range(n):\\n            for j in range(n):\\n                if i == j or i + j == n-1:\\n                    if grid[i][j] == 0:\\n                        return False\\n                else:\\n                    if grid[i][j] != 0:\\n                        return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2203599,
                "title": "easiest-problem-ever-c",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    bool checkXMatrix(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        for(int i=0; i<m; ++i){\\n            for(int j=0; j<m; ++j){\\n                if(i==j || i+j == m-1){\\n                    if(grid[i][j] == 0) return false;\\n                }\\n                else{\\n                    if(grid[i][j] != 0) return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    bool checkXMatrix(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        for(int i=0; i<m; ++i){\\n            for(int j=0; j<m; ++j){\\n                if(i==j || i+j == m-1){\\n                    if(grid[i][j] == 0) return false;\\n                }\\n                else{\\n                    if(grid[i][j] != 0) return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2203272,
                "title": "simple-c-solution-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkXMatrix(vector<vector<int>>& grid) {\\n        for(int i=0;i<grid.size();i++)\\n            for(int j=0;j<grid[0].size();j++)\\n                if((i==j || i==grid.size()-j-1) && grid[i][j]==0)return false;\\n                else if((i!=j && i!=grid.size()-j-1) && grid[i][j]!=0)return false;\\n        return true;\\n    }\\n};\\n```\\nSomeone do comment why removing brackets reduces runtime :)\\n![image](https://assets.leetcode.com/users/images/81644d64-ee62-4eff-a830-1cb98331d459_1656303596.1359963.png)\\n",
                "solutionTags": [
                    "C",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkXMatrix(vector<vector<int>>& grid) {\\n        for(int i=0;i<grid.size();i++)\\n            for(int j=0;j<grid[0].size();j++)\\n                if((i==j || i==grid.size()-j-1) && grid[i][j]==0)return false;\\n                else if((i!=j && i!=grid.size()-j-1) && grid[i][j]!=0)return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2200221,
                "title": "brute-force-logical-intuitive-c",
                "content": "**C++**\\n\\n     bool checkXMatrix(vector<vector<int>>& grid) {\\n        int row=grid.size();\\n        int col=grid[0].size();\\n        for(int i=0;i<row;i++){\\n            if(grid[i][i]==0)return false;\\n            if(grid[i][col-1-i]==0)return false;\\n        }\\n        for(int i=0;i<row;i++){\\n            for(int j=0;j<col;j++){\\n                if(i==j || j==col-1-i)continue;\\n                   else{\\n                   if(grid[i][j]!=0)return false;}\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "**C++**\\n\\n     bool checkXMatrix(vector<vector<int>>& grid) {\\n        int row=grid.size();\\n        int col=grid[0].size();\\n        for(int i=0;i<row;i++){\\n            if(grid[i][i]==0)return false;\\n            if(grid[i][col-1-i]==0)return false;\\n        }\\n        for(int i=0;i<row;i++){\\n            for(int j=0;j<col;j++){\\n                if(i==j || j==col-1-i)continue;\\n                   else{\\n                   if(grid[i][j]!=0)return false;}\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2200171,
                "title": "python-o-m-n",
                "content": "````\\nclass Solution:\\n    def checkXMatrix(self, grid: List[List[int]]) -> bool:\\n        \\n        N = len(grid)\\n        \\n        for i in range(N):\\n            for j in range(N):\\n                if i == j or j == N-i-1:\\n                    if grid[i][j] == 0: return False\\n                elif not grid[i][j] == 0: return False\\n                \\n        return True\\n\\n````",
                "solutionTags": [
                    "Python"
                ],
                "code": "````\\nclass Solution:\\n    def checkXMatrix(self, grid: List[List[int]]) -> bool:\\n        \\n        N = len(grid)\\n        \\n        for i in range(N):\\n            for j in range(N):\\n                if i == j or j == N-i-1:\\n                    if grid[i][j] == 0: return False\\n                elif not grid[i][j] == 0: return False\\n                \\n        return True\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2198531,
                "title": "check-if-matrix-is-x-matrix-c-solution-1-ms",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    bool checkXMatrix(vector<vector<int>>& grid) {\\n       for (int i = 0; i < grid.size(); i++) \\n       {\\n          for (int j = 0; j < grid[0].size(); j++) \\n          {\\n                if (i == j || i + j == grid.size() - 1) \\n                {\\n                    if (grid[i][j] == 0)\\n                        return false;\\n                }\\n                else if (grid[i][j] > 0)\\n                    return false;\\n        }\\n       }\\n        return true;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    bool checkXMatrix(vector<vector<int>>& grid) {\\n       for (int i = 0; i < grid.size(); i++) \\n       {\\n          for (int j = 0; j < grid[0].size(); j++) \\n          {\\n                if (i == j || i + j == grid.size() - 1) \\n                {\\n                    if (grid[i][j] == 0)\\n                        return false;\\n                }\\n                else if (grid[i][j] > 0)\\n                    return false;\\n        }\\n       }\\n        return true;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2198245,
                "title": "java-solution-explained",
                "content": "If we have rows == columns, we have left to right diagonal and if we have columns == n-row-1, we have right to left diagonal\\n```\\nclass Solution {\\n    public boolean checkXMatrix(int[][] grid) {\\n        int n = grid.length;\\n        for(int row = 0; row < n ; row++){\\n            for(int column = 0; column < n ;column++){\\n\\t\\t\\t\\n// If we are in the left to right diagonal and value is 0 , it means condition is voilated.\\n                if(row== column && grid[row][column] == 0 ){\\n                    return false;\\n\\t\\t\\t\\t\\t\\n// If we are in the right to left diagonal and value is 0 , it means condition is voilated.\\n                }else if(column == n-row-1 && grid[row][column] == 0){\\n                    return false;\\n                }\\n\\t\\t\\t\\t\\n// If we are at any other position and value is not 0 , it means condition is voilated.\\n\\t\\t\\t\\telse if(row != column && column != n-row-1 && grid[row][column] != 0){\\n                    return false;\\n                }\\n    }\\n}\\n\\n// If none of the condition is voilated, we will return true;\\n        return true;\\n                      }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkXMatrix(int[][] grid) {\\n        int n = grid.length;\\n        for(int row = 0; row < n ; row++){\\n            for(int column = 0; column < n ;column++){\\n\\t\\t\\t\\n// If we are in the left to right diagonal and value is 0 , it means condition is voilated.\\n                if(row== column && grid[row][column] == 0 ){\\n                    return false;\\n\\t\\t\\t\\t\\t\\n// If we are in the right to left diagonal and value is 0 , it means condition is voilated.\\n                }else if(column == n-row-1 && grid[row][column] == 0){\\n                    return false;\\n                }\\n\\t\\t\\t\\t\\n// If we are at any other position and value is not 0 , it means condition is voilated.\\n\\t\\t\\t\\telse if(row != column && column != n-row-1 && grid[row][column] != 0){\\n                    return false;\\n                }\\n    }\\n}\\n\\n// If none of the condition is voilated, we will return true;\\n        return true;\\n                      }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2198209,
                "title": "java-one-pass-100-faster-1ms-solution",
                "content": "\\n\\t    class Solution {\\n    public boolean checkXMatrix(int[][] grid) {\\n\\t\\n    for (int i = 0; i < grid.length; i++)\\n        for (int j = 0; j < grid[0].length; j++) {\\n            if (i == j || i == grid.length - j  - 1) {\\n                if (grid[i][j] == 0)\\n                    return false;\\n            }\\n            else if (grid[i][j] > 0)\\n                return false;\\n        }\\n    return true;\\n\\t}\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public boolean checkXMatrix(int[][] grid) {\\n\\t\\n    for (int i = 0; i < grid.length; i++)\\n        for (int j = 0; j < grid[0].length; j++) {\\n            if (i == j || i == grid.length - j  - 1) {\\n                if (grid[i][j] == 0)\\n                    return false;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2198142,
                "title": "rust-matrix-manipulation",
                "content": "Solution - [github](https://github.com/An7One/lc_soln_rust_leon/tree/main/src/leetcode/lvl1/lc2319)\\n\\n<b>Problem List</b>\\n#MatrixDiagonal - [github](https://github.com/An7One/leetcode-problems-by-tag-an7one/blob/main/txt/by_data_structure/array/by_topic/array_or_matrix_manipulation/matrix/maindiagnoal_vs_antidiagnoal.txt)\\n#MatrixManipulation - [github](https://github.com/An7One/leetcode-problems-by-tag-an7one/tree/main/txt/by_data_structure/array/by_topic/array_or_matrix_manipulation/matrix)\\n\\n```\\n/// @author: Leon\\n/// https://leetcode.com/problems/check-if-matrix-is-x-matrix/\\n/// Time Complexity:    O(`len_n`)\\n/// Space Complexity:   O(1)\\nimpl Solution {\\n    pub fn check_x_matrix(grid: Vec<Vec<i32>>) -> bool {\\n        let len_n: usize = grid.len();\\n        for r in 0..len_n {\\n            for c in 0..len_n {\\n                if Self::is_any_diagonal(r, c, len_n) {\\n                    if grid[r][c] == 0 {\\n                        return false;\\n                    }\\n                } else {\\n                    if grid[r][c] != 0 {\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n        true\\n    }\\n    fn is_any_diagonal(r: usize, c: usize, len_n: usize) -> bool {\\n        (r == c) || (r + c == len_n - 1)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\n/// @author: Leon\\n/// https://leetcode.com/problems/check-if-matrix-is-x-matrix/\\n/// Time Complexity:    O(`len_n`)\\n/// Space Complexity:   O(1)\\nimpl Solution {\\n    pub fn check_x_matrix(grid: Vec<Vec<i32>>) -> bool {\\n        let len_n: usize = grid.len();\\n        for r in 0..len_n {\\n            for c in 0..len_n {\\n                if Self::is_any_diagonal(r, c, len_n) {\\n                    if grid[r][c] == 0 {\\n                        return false;\\n                    }\\n                } else {\\n                    if grid[r][c] != 0 {\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n        true\\n    }\\n    fn is_any_diagonal(r: usize, c: usize, len_n: usize) -> bool {\\n        (r == c) || (r + c == len_n - 1)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4085719,
                "title": "discuss",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n^2)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean checkXMatrix(int[][] grid) {\\n        final int n = grid.length;\\n\\n    for (int i = 0; i < n; ++i)\\n      for (int j = 0; j < n; ++j)\\n        if (i == j || i + j == n - 1) { // In diagonal\\n          if (grid[i][j] == 0)\\n            return false;\\n        } else if (grid[i][j] > 0) { // Not in diagonal\\n          return false;\\n        }\\n\\n    return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkXMatrix(int[][] grid) {\\n        final int n = grid.length;\\n\\n    for (int i = 0; i < n; ++i)\\n      for (int j = 0; j < n; ++j)\\n        if (i == j || i + j == n - 1) { // In diagonal\\n          if (grid[i][j] == 0)\\n            return false;\\n        } else if (grid[i][j] > 0) { // Not in diagonal\\n          return false;\\n        }\\n\\n    return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4082746,
                "title": "x-matrix-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean checkXMatrix(int[][] grid) {\\n      for(int i=0;i<grid.length;i++){\\n          if(grid[i][i]==0||grid[i][grid.length-i-1]==0){\\n              return false;\\n          }\\n      }\\n      for(int i=0;i<grid.length;i++){\\n          for(int j=0;j<grid.length;j++){\\n              if(i==j||j==(grid.length-i-1)){\\n                  continue;\\n              }else if(grid[i][j]!=0){\\n                  return false;\\n              }\\n          }\\n      }\\n      return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkXMatrix(int[][] grid) {\\n      for(int i=0;i<grid.length;i++){\\n          if(grid[i][i]==0||grid[i][grid.length-i-1]==0){\\n              return false;\\n          }\\n      }\\n      for(int i=0;i<grid.length;i++){\\n          for(int j=0;j<grid.length;j++){\\n              if(i==j||j==(grid.length-i-1)){\\n                  continue;\\n              }else if(grid[i][j]!=0){\\n                  return false;\\n              }\\n          }\\n      }\\n      return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4080406,
                "title": "easy-code-c-solution-quadratic-time-o-n-2-beginners-friendly-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkXMatrix(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[i].size();j++){\\n                if(((i==j || i+j==n-1) && grid[i][j]==0))\\n                    return false;\\n                if((i!=j && i+j!=n-1 && grid[i][j]!=0)){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkXMatrix(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[i].size();j++){\\n                if(((i==j || i+j==n-1) && grid[i][j]==0))\\n                    return false;\\n                if((i!=j && i+j!=n-1 && grid[i][j]!=0)){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4068499,
                "title": "very-simple-intiution",
                "content": "# Intuition\\nDont check the whole matrix, just go for the diagonal if any of th ediagonal element is zero then it is not a X matrix\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean checkXMatrix(int[][] grid) {\\n       for(int i = 0; i < grid.length; i++){\\n           for(int j = 0; j < grid[0].length; j++){\\n               if ((grid[i][j] == 0) == (i == j || i + j == grid.length - 1)) {\\n                   return false;\\n                }\\n           }\\n       } \\n       return true;\\n       // Very simple if the element on the diagonal will be zero\\n       // then it will not be a X matrix\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkXMatrix(int[][] grid) {\\n       for(int i = 0; i < grid.length; i++){\\n           for(int j = 0; j < grid[0].length; j++){\\n               if ((grid[i][j] == 0) == (i == j || i + j == grid.length - 1)) {\\n                   return false;\\n                }\\n           }\\n       } \\n       return true;\\n       // Very simple if the element on the diagonal will be zero\\n       // then it will not be a X matrix\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4043956,
                "title": "check-if-matrix-is-x-matrix-python-solution-easyy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def checkXMatrix(self, grid: List[List[int]]) -> bool:\\n        n = len(grid)\\n        start = 0\\n        end = n-1\\n        for i in range(n):\\n            row = grid[i]\\n            if row[start]==0 or row[end]==0:\\n                return False\\n            for j in range(n):\\n                if j != start and j != end and row[j]!= 0:\\n                    return False\\n            start +=1\\n            end-=1\\n        return True\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def checkXMatrix(self, grid: List[List[int]]) -> bool:\\n        n = len(grid)\\n        start = 0\\n        end = n-1\\n        for i in range(n):\\n            row = grid[i]\\n            if row[start]==0 or row[end]==0:\\n                return False\\n            for j in range(n):\\n                if j != start and j != end and row[j]!= 0:\\n                    return False\\n            start +=1\\n            end-=1\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4035238,
                "title": "simple-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def checkXMatrix(self, grid: List[List[int]]) -> bool:\\n        for i,l in zip(range(len(grid)),range(len(grid)-1,-1,-1)):\\n            if grid[i][i]==0 or grid[i][l]==0 :return False\\n            for j in range(len(grid)):\\n                if i!=j and l!=j and grid[i][j]!=0:return False\\n        return True\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkXMatrix(self, grid: List[List[int]]) -> bool:\\n        for i,l in zip(range(len(grid)),range(len(grid)-1,-1,-1)):\\n            if grid[i][i]==0 or grid[i][l]==0 :return False\\n            for j in range(len(grid)):\\n                if i!=j and l!=j and grid[i][j]!=0:return False\\n        return True\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4024835,
                "title": "easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public static boolean checkXMatrix(int[][] grid) {\\n\\t\\t if(FirstCondition(grid)==true && count0(grid)==true) {\\n\\t\\t\\t return true;\\n\\t\\t }\\n\\t\\t return false;\\n\\t }\\n\\t// check diagonals of the matrix are non-zero.\\n\\t public static boolean FirstCondition(int[][] arr) {\\n\\t\\tint n = arr.length;\\n\\t\\tfor (int i = 0; i < arr.length; i++) {\\n\\t\\t\\t\\tif(arr[i][i]==0 || arr[i][n-1-i]==0) {\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n\\t// All other elements are 0\\n\\tpublic static boolean count0(int[][] arr) {\\n        //count 0 from all matrix\\n\\t\\tint n = arr.length;\\n\\t\\tint count = 0;\\n\\t\\tfor (int i = 0; i < arr.length; i++) {\\n\\t\\t\\tfor (int j = 0; j < arr.length; j++) {\\n\\t\\t\\t\\tif(arr[i][j]==0) {\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(n%2==0) {\\n\\t\\t\\t//for even matrix\\n\\t\\t\\tint totalNumber = n*n;\\n\\t\\t\\tint numberOfDiagonal = n*2;\\n\\t\\t\\tint ans = totalNumber-numberOfDiagonal;\\n\\t\\t\\tif(count==ans) {\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t}else {\\n\\t\\t\\t//for odd matrix\\n\\t\\t\\tint totalNumber = n*n;\\n\\t\\t\\tint numberOfDiagonal = n*2-1;\\n\\t\\t\\tint ans = totalNumber-numberOfDiagonal;\\n\\t\\t\\tif(count==ans) {\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public static boolean checkXMatrix(int[][] grid) {\\n\\t\\t if(FirstCondition(grid)==true && count0(grid)==true) {\\n\\t\\t\\t return true;\\n\\t\\t }\\n\\t\\t return false;\\n\\t }\\n\\t// check diagonals of the matrix are non-zero.\\n\\t public static boolean FirstCondition(int[][] arr) {\\n\\t\\tint n = arr.length;\\n\\t\\tfor (int i = 0; i < arr.length; i++) {\\n\\t\\t\\t\\tif(arr[i][i]==0 || arr[i][n-1-i]==0) {\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n\\t// All other elements are 0\\n\\tpublic static boolean count0(int[][] arr) {\\n        //count 0 from all matrix\\n\\t\\tint n = arr.length;\\n\\t\\tint count = 0;\\n\\t\\tfor (int i = 0; i < arr.length; i++) {\\n\\t\\t\\tfor (int j = 0; j < arr.length; j++) {\\n\\t\\t\\t\\tif(arr[i][j]==0) {\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(n%2==0) {\\n\\t\\t\\t//for even matrix\\n\\t\\t\\tint totalNumber = n*n;\\n\\t\\t\\tint numberOfDiagonal = n*2;\\n\\t\\t\\tint ans = totalNumber-numberOfDiagonal;\\n\\t\\t\\tif(count==ans) {\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t}else {\\n\\t\\t\\t//for odd matrix\\n\\t\\t\\tint totalNumber = n*n;\\n\\t\\t\\tint numberOfDiagonal = n*2-1;\\n\\t\\t\\tint ans = totalNumber-numberOfDiagonal;\\n\\t\\t\\tif(count==ans) {\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4006509,
                "title": "check-if-a-matrix-is-x-matrix-in-java",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public boolean checkXMatrix(int[][] grid) {\\n        int n=grid.length;\\n        int count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if ((i == j || i + j == n - 1) && grid[i][j] != 0)\\n                count++;\\n                else if(i != j && i + j != n - 1 && grid[i][j]==0)\\n                count++;\\n            }\\n        }\\n        return (count==n*n);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkXMatrix(int[][] grid) {\\n        int n=grid.length;\\n        int count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if ((i == j || i + j == n - 1) && grid[i][j] != 0)\\n                count++;\\n                else if(i != j && i + j != n - 1 && grid[i][j]==0)\\n                count++;\\n            }\\n        }\\n        return (count==n*n);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3995878,
                "title": "x-matrix-easy-solution-for-loops-beats-90-solutions-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def checkXMatrix(self, grid):\\n        n = len(grid)\\n        for i in range(n):\\n            for j in range(n):\\n                #Diagonal Elements\\n                if (i==j) or (i+j == n-1):\\n                    if grid[i][j] == 0:\\n                        return False\\n                #Other than diagonal elements\\n                else :\\n                    if grid[i][j] != 0:\\n                        return False\\n        return True\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def checkXMatrix(self, grid):\\n        n = len(grid)\\n        for i in range(n):\\n            for j in range(n):\\n                #Diagonal Elements\\n                if (i==j) or (i+j == n-1):\\n                    if grid[i][j] == 0:\\n                        return False\\n                #Other than diagonal elements\\n                else :\\n                    if grid[i][j] != 0:\\n                        return False\\n        return True\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3990267,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n public:\\n  bool checkXMatrix(vector<vector<int>>& grid) {\\n    const int n = grid.size();\\n\\n    for (int i = 0; i < n; ++i)\\n      for (int j = 0; j < n; ++j)\\n        if (i == j || i + j == n - 1) {  // In diagonal\\n          if (grid[i][j] == 0)\\n            return false;\\n        } else if (grid[i][j]) {  // Not in diagonal\\n          return false;\\n        }\\n\\n    return true;\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  bool checkXMatrix(vector<vector<int>>& grid) {\\n    const int n = grid.size();\\n\\n    for (int i = 0; i < n; ++i)\\n      for (int j = 0; j < n; ++j)\\n        if (i == j || i + j == n - 1) {  // In diagonal\\n          if (grid[i][j] == 0)\\n            return false;\\n        } else if (grid[i][j]) {  // Not in diagonal\\n          return false;\\n        }\\n\\n    return true;\\n  }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3989327,
                "title": "python-1-pass-1-if-with-line-sum-x-elements-sum",
                "content": "- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n```\\nclass Solution(object):\\n    def checkXMatrix(self, grid):\\n        n=len(grid)\\n        for i in range(n):\\n            if grid[i][i]==0 or grid[i][n-i-1]==0 or grid[i][i] + (n-1!=2*i) * grid[i][n-i-1] != sum(grid[i]):\\n                return False\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def checkXMatrix(self, grid):\\n        n=len(grid)\\n        for i in range(n):\\n            if grid[i][i]==0 or grid[i][n-i-1]==0 or grid[i][i] + (n-1!=2*i) * grid[i][n-i-1] != sum(grid[i]):\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3987293,
                "title": "cpp-easy-solution-using-basics-concept",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkXMatrix(vector<vector<int>>& grid) {\\n        int n=grid.size(),c=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i==j)\\n                {\\n                    if(grid[i][j]!=0)\\n                    {\\n                        c++;\\n                    }\\n                }\\n                else if(i+j==n-1)\\n                {\\n                    if(grid[i][j]!=0)\\n                    {\\n                        c++;\\n                    }\\n                }\\n                else\\n                {\\n                    if(grid[i][j]==0)\\n                    {\\n                        c++;\\n                    }\\n                }\\n            }\\n        }\\n        if (c==n*n)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkXMatrix(vector<vector<int>>& grid) {\\n        int n=grid.size(),c=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i==j)\\n                {\\n                    if(grid[i][j]!=0)\\n                    {\\n                        c++;\\n                    }\\n                }\\n                else if(i+j==n-1)\\n                {\\n                    if(grid[i][j]!=0)\\n                    {\\n                        c++;\\n                    }\\n                }\\n                else\\n                {\\n                    if(grid[i][j]==0)\\n                    {\\n                        c++;\\n                    }\\n                }\\n            }\\n        }\\n        if (c==n*n)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3978088,
                "title": "check-if-matrix-is-x-matrix",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. First check diagonal elements are non Zero.\\n2. Second check all other elements are Zero\\n\\n# Complexity\\n- Time complexity: O(N*M)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean checkXMatrix(int[][] grid) {\\n        \\n        int n = grid.length;\\n        int m = grid[0].length;\\n\\n\\n        for(int i = 0; i<n; i++)\\n        {\\n            for(int j = 0; j<m; j++)\\n            {\\n                if(i==j || i+j== n-1)\\n                {\\n                    if(grid[i][j] == 0)\\n                        return false;\\n                }\\n                else\\n                {\\n                    if(grid[i][j] != 0)\\n                        return false;\\n                }\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkXMatrix(int[][] grid) {\\n        \\n        int n = grid.length;\\n        int m = grid[0].length;\\n\\n\\n        for(int i = 0; i<n; i++)\\n        {\\n            for(int j = 0; j<m; j++)\\n            {\\n                if(i==j || i+j== n-1)\\n                {\\n                    if(grid[i][j] == 0)\\n                        return false;\\n                }\\n                else\\n                {\\n                    if(grid[i][j] != 0)\\n                        return false;\\n                }\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3977263,
                "title": "2ms-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean checkXMatrix(int[][] grid) {\\n        for(int i=0;i<grid.length;i++)\\n        {\\n            if(grid[i][i]==0)\\n            {\\n                return false;\\n            }\\n                grid[i][i]=-1;\\n        }\\n\\n        int x=0;\\n        for(int j=grid[0].length-1;j>=0;j--)\\n        {\\n            if(grid[x][j]==0)\\n            {\\n                return false;\\n            }\\n            grid[x++][j]=-1;\\n        }\\n\\n        for(int i=0;i<grid.length;i++)\\n        {\\n            for(int j=0;j<grid[0].length;j++)\\n            {\\n                if(grid[i][j]!=-1)\\n                {\\n                    if(grid[i][j]!=0)\\n                    {\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkXMatrix(int[][] grid) {\\n        for(int i=0;i<grid.length;i++)\\n        {\\n            if(grid[i][i]==0)\\n            {\\n                return false;\\n            }\\n                grid[i][i]=-1;\\n        }\\n\\n        int x=0;\\n        for(int j=grid[0].length-1;j>=0;j--)\\n        {\\n            if(grid[x][j]==0)\\n            {\\n                return false;\\n            }\\n            grid[x++][j]=-1;\\n        }\\n\\n        for(int i=0;i<grid.length;i++)\\n        {\\n            for(int j=0;j<grid[0].length;j++)\\n            {\\n                if(grid[i][j]!=-1)\\n                {\\n                    if(grid[i][j]!=0)\\n                    {\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3971022,
                "title": "check-if-matrix-is-x-matrix",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def checkXMatrix(self, grid: List[List[int]]) -> bool:\\n        n=len(grid)\\n        for i in range(n):\\n            for j in range(n):\\n                if i==j or i==n-j-1:\\n                    if grid[i][j]==0:\\n                        return False \\n\\n                else:\\n                    if grid[i][j]!=0:\\n                        return False\\n        return True\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkXMatrix(self, grid: List[List[int]]) -> bool:\\n        n=len(grid)\\n        for i in range(n):\\n            for j in range(n):\\n                if i==j or i==n-j-1:\\n                    if grid[i][j]==0:\\n                        return False \\n\\n                else:\\n                    if grid[i][j]!=0:\\n                        return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3967651,
                "title": "beats-97-92-of-users-with-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[][]} grid\\n * @return {boolean}\\n */\\nvar checkXMatrix = function(grid) {\\n    if (!grid) {\\n        return false;\\n    }\\n\\n    const len = grid.length;\\n\\n    for (let i = 0; i < len; i++) {\\n        const arr = grid[i];\\n\\n        let first = arr[i];\\n        let second = arr[len - i - 1];\\n\\n        if (!first || !second) {\\n             return false;\\n        }\\n\\n        for (let j = 0; j < len; j++) {\\n            let el = arr[j];\\n\\n            if (el && (j !== i && j !== (len - i - 1))) {\\n                return false;\\n            }\\n            \\n        }\\n    }\\n\\n    return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} grid\\n * @return {boolean}\\n */\\nvar checkXMatrix = function(grid) {\\n    if (!grid) {\\n        return false;\\n    }\\n\\n    const len = grid.length;\\n\\n    for (let i = 0; i < len; i++) {\\n        const arr = grid[i];\\n\\n        let first = arr[i];\\n        let second = arr[len - i - 1];\\n\\n        if (!first || !second) {\\n             return false;\\n        }\\n\\n        for (let j = 0; j < len; j++) {\\n            let el = arr[j];\\n\\n            if (el && (j !== i && j !== (len - i - 1))) {\\n                return false;\\n            }\\n            \\n        }\\n    }\\n\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3960984,
                "title": "for-beginner-s-easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def checkXMatrix(self, grid: List[List[int]]) -> bool:\\n        n=len(grid)\\n        <!-- s=0 -->\\n        for i in range(len(grid)):\\n            j=i\\n            if grid[i][j] == 0 or grid[i][n-1-i] == 0:\\n                return False\\n        arr=sum(row.count(0) for row in grid)\\n        <!-- for row in grid:\\n            s+=row.count(0) --> \\n        if n%2 == 0:\\n            return s == (n*n)-(2*n)\\n        else:\\n            return s == (n*n)-((n*2)-1)\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkXMatrix(self, grid: List[List[int]]) -> bool:\\n        n=len(grid)\\n        <!-- s=0 -->\\n        for i in range(len(grid)):\\n            j=i\\n            if grid[i][j] == 0 or grid[i][n-1-i] == 0:\\n                return False\\n        arr=sum(row.count(0) for row in grid)\\n        <!-- for row in grid:\\n            s+=row.count(0) --> \\n        if n%2 == 0:\\n            return s == (n*n)-(2*n)\\n        else:\\n            return s == (n*n)-((n*2)-1)\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3954397,
                "title": "easy-to-understand-python3-solution-tc-o-n-sc-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def checkXMatrix(self, grid: List[List[int]]) -> bool:\\n        for r in range(len(grid)):\\n            for c in range(len(grid[r])):\\n                # Check diagonal values\\n                if r == c or r == (len(grid[r]) - (c+1)):\\n                    if grid[r][c] == 0:\\n                        return False\\n                else:\\n                    # Check non doagonal values\\n                    if grid[r][c] != 0:\\n                        return False\\n        return True\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkXMatrix(self, grid: List[List[int]]) -> bool:\\n        for r in range(len(grid)):\\n            for c in range(len(grid[r])):\\n                # Check diagonal values\\n                if r == c or r == (len(grid[r]) - (c+1)):\\n                    if grid[r][c] == 0:\\n                        return False\\n                else:\\n                    # Check non doagonal values\\n                    if grid[r][c] != 0:\\n                        return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3951928,
                "title": "easy-c-solution-beginner-s-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkXMatrix(vector<vector<int>>& grid) {\\n        int row=grid.size();\\n        int col=grid[0].size();\\n\\n        //For first diagonal \\' \\\\\\'\\n        for(int i=0;i<row;i++){\\n            for(int j=0;j<col;j++){\\n                if(i==j && grid[i][j]==0){\\n                   return false;\\n                }\\n                else if(i==j && grid[i][j]!=0){\\n                    grid[i][j]=-1;\\n                }\\n            }\\n        }\\n\\n        //For Second diagonal \\'/\\'\\n        for(int i=0,j=col-1;i<row,j>=0;i++,j--){\\n                if(grid[i][j]==0){\\n                    return false;\\n                }\\n                else{\\n                    grid[i][j]=-1;\\n                }\\n        }\\n\\n        //For Rest of the element\\n        for(int i=0;i<row;i++){\\n            for(int j=0;j<col;j++){\\n                if(grid[i][j]!=-1  && grid[i][j]!=0){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkXMatrix(vector<vector<int>>& grid) {\\n        int row=grid.size();\\n        int col=grid[0].size();\\n\\n        //For first diagonal \\' \\\\\\'\\n        for(int i=0;i<row;i++){\\n            for(int j=0;j<col;j++){\\n                if(i==j && grid[i][j]==0){\\n                   return false;\\n                }\\n                else if(i==j && grid[i][j]!=0){\\n                    grid[i][j]=-1;\\n                }\\n            }\\n        }\\n\\n        //For Second diagonal \\'/\\'\\n        for(int i=0,j=col-1;i<row,j>=0;i++,j--){\\n                if(grid[i][j]==0){\\n                    return false;\\n                }\\n                else{\\n                    grid[i][j]=-1;\\n                }\\n        }\\n\\n        //For Rest of the element\\n        for(int i=0;i<row;i++){\\n            for(int j=0;j<col;j++){\\n                if(grid[i][j]!=-1  && grid[i][j]!=0){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3930579,
                "title": "beats-easy-beginner-friendly-solution-simple-and-easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean checkXMatrix(int[][] g) {\\n        boolean ans = true;\\n        int n=g.length;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(i==j || i+j==n-1){\\n                    if(g[i][j]==0){\\n                        return false;\\n                    }\\n                }\\n                else{\\n                     if(g[i][j]!=0){\\n                         return false;\\n                     }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkXMatrix(int[][] g) {\\n        boolean ans = true;\\n        int n=g.length;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(i==j || i+j==n-1){\\n                    if(g[i][j]==0){\\n                        return false;\\n                    }\\n                }\\n                else{\\n                     if(g[i][j]!=0){\\n                         return false;\\n                     }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3929885,
                "title": "check-if-matrix-is-x-matrix",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkXMatrix(vector<vector<int>>& grid) \\n    {\\n        int k=grid.size();\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            k--;\\n            for(int j=0;j<grid.size();j++)\\n            {\\n                if(i==j && grid[i][j]==0)\\n                return false;\\n                \\n                else if(j==k && grid[i][k]==0)\\n                return false;\\n                \\n                else if(j!=k && i!=j && grid[i][j]!=0)\\n                return false;\\n                \\n\\n            }\\n            \\n        }\\n        return true;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkXMatrix(vector<vector<int>>& grid) \\n    {\\n        int k=grid.size();\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            k--;\\n            for(int j=0;j<grid.size();j++)\\n            {\\n                if(i==j && grid[i][j]==0)\\n                return false;\\n                \\n                else if(j==k && grid[i][k]==0)\\n                return false;\\n                \\n                else if(j!=k && i!=j && grid[i][j]!=0)\\n                return false;\\n                \\n\\n            }\\n            \\n        }\\n        return true;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3929650,
                "title": "java-easy-solution-matrix-traversal",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nJust check with the matrix which contains the 0 or not .\\n# Code\\n```\\nclass Solution {\\n    public boolean checkXMatrix(int[][] grid) {\\n        int n = grid.length;\\n        for(int i = 0;i<n;i++)\\n        {\\n            for(int j =0;j<n;j++)\\n            {\\n                if(j==i || j==n-i-1)\\n                {\\n                    if(grid[i][j]==0) return false;\\n                }\\n\\n                else\\n                {\\n                    if(grid[i][j]!=0) return false;\\n                }\\n                \\n            }\\n        }\\n        return true;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkXMatrix(int[][] grid) {\\n        int n = grid.length;\\n        for(int i = 0;i<n;i++)\\n        {\\n            for(int j =0;j<n;j++)\\n            {\\n                if(j==i || j==n-i-1)\\n                {\\n                    if(grid[i][j]==0) return false;\\n                }\\n\\n                else\\n                {\\n                    if(grid[i][j]!=0) return false;\\n                }\\n                \\n            }\\n        }\\n        return true;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3927389,
                "title": "simple-c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkXMatrix(vector<vector<int>>& grid) {\\n        int cnt = 0, n = grid.size();\\n        for(auto i : grid)\\n            cnt += count(i.begin(), i.end(), 0);\\n        for(int i = 0;i < n;i++)\\n            if(grid[i][i] == 0) return false;\\n        for(int i = 0;i < n;i++)\\n            if(grid[i][n-1-i] == 0) return false;\\n        return cnt == n*n - ((n % 2 == 0) ? 2*n : 2*n-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkXMatrix(vector<vector<int>>& grid) {\\n        int cnt = 0, n = grid.size();\\n        for(auto i : grid)\\n            cnt += count(i.begin(), i.end(), 0);\\n        for(int i = 0;i < n;i++)\\n            if(grid[i][i] == 0) return false;\\n        for(int i = 0;i < n;i++)\\n            if(grid[i][n-1-i] == 0) return false;\\n        return cnt == n*n - ((n % 2 == 0) ? 2*n : 2*n-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3920808,
                "title": "qs-2319-easy-java-solution",
                "content": "# Intuition\\nTo eastablish a formula for diagonal elements \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nPrimary diagonal elements: (0,0),(1,1),(2,2)...\\nSecondary diagonal elements: (0,3),(1,2),(2,1),(3,0)... for a 4*4 matrix. (0,3) -> (0 is the row number, 3 can be represented as matrix.length-1-i). We could have also used i+j==matrix.length-1 ie 0+3==4-1, 1+2==4-1 and so on\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean checkXMatrix(int[][] grid) {\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid.length;j++){\\n                if(j==i || j==grid.length-1-i){  // for diagonal elements\\n                    if(grid[i][j]==0)\\n                    return false;\\n                }\\n                if(!(j==i || j==grid.length-1-i)){  // for non diagonal elements\\n                    if(grid[i][j]!=0)\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkXMatrix(int[][] grid) {\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid.length;j++){\\n                if(j==i || j==grid.length-1-i){  // for diagonal elements\\n                    if(grid[i][j]==0)\\n                    return false;\\n                }\\n                if(!(j==i || j==grid.length-1-i)){  // for non diagonal elements\\n                    if(grid[i][j]!=0)\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3911598,
                "title": "check-if-matrix-is-x-matrix-c-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->Diagonal elements are:\\n- left diagonal indices condition: i==j\\n- right diagonal indices condition: j==n-1-i\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->Brute force approach\\n\\n# Complexity\\n- Time complexity:O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n- Space complexity:O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkXMatrix(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){ \\n                 if(i==j ||j==n-i-1)\\n                    { if(grid[i][j]==0 )\\n                       return false;}\\n                 else if(grid[i][j]!=0)\\n                     return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkXMatrix(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){ \\n                 if(i==j ||j==n-i-1)\\n                    { if(grid[i][j]==0 )\\n                       return false;}\\n                 else if(grid[i][j]!=0)\\n                     return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3904668,
                "title": "intuitive-approach-c-simple-beats-90",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. In all the code we will check the edge condition only i.e if this occurs than return {false immediately} so that no further computation should be performed.\\n2. First we will check all the diagonal elements i.e {i == i} if it is zero then return {false}.\\n3. then we will check diagonal from {right - left} i.e (grid[i][grid.size()-(i+1)] if it is {0}  return {false}) because all this conditions are oppose the problem statement.\\n4. then we will check non-diagonal element, logic is {i != j} and {j != grid.size()-(i+1)} and {grid[i][j] != 0} if it is true then return {false} immediately.\\n5. all the above condition runs perfectly then our matrix is X-Matrix\\n6. just return {true}.\\n\\nIMMPLEMENT ALL ABOVE STEP ON PAPER YOU WILL DEFINETELY GET UNDERSTOOD.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkXMatrix(vector<vector<int>>& grid) {\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            if(grid[i][i] == 0) return false;\\n            else if(grid[i][grid.size()-(i+1)] == 0){\\n                return false;\\n            }\\n            for(int j=0;j<grid[0].size();j++)\\n            {\\n                if((i != j) && (j != grid.size()-(i+1)) && (grid[i][j] != 0))\\n                {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkXMatrix(vector<vector<int>>& grid) {\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            if(grid[i][i] == 0) return false;\\n            else if(grid[i][grid.size()-(i+1)] == 0){\\n                return false;\\n            }\\n            for(int j=0;j<grid[0].size();j++)\\n            {\\n                if((i != j) && (j != grid.size()-(i+1)) && (grid[i][j] != 0))\\n                {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3903842,
                "title": "very-easy-cpp-solution-with-explaination",
                "content": "\\nclass Solution {\\npublic:\\n    bool checkXMatrix(vector<vector<int>>& grid) {\\n          int n = grid.size();\\n\\n    for (int i = 0; i < n; i++) {\\n        for (int j = 0; j < n; j++) {\\n            // Check if the element is on the main diagonal or secondary diagonal\\n            if (i == j || i + j == n - 1) {\\n                if (grid[i][j] == 0) {\\n                    return false; // Condition 1: Diagonal element should be non-zero\\n                }\\n            } else {\\n                if (grid[i][j] != 0) {\\n                    return false; // Condition 2: Non-diagonal element should be zero\\n                }\\n            }\\n        }\\n    }\\n\\n    return true;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Matrix"
                ],
                "code": "class Solution {\\npublic:\\n    bool checkXMatrix(vector<vector<int>>& grid) {\\n          int n = grid.size();\\n\\n    for (int i = 0; i < n; i++) {\\n        for (int j = 0; j < n; j++) {\\n            // Check if the element is on the main diagonal or secondary diagonal\\n            if (i == j || i + j == n - 1) {\\n                if (grid[i][j] == 0) {\\n                    return false; // Condition 1: Diagonal element should be non-zero\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3900022,
                "title": "c-python-brute-force-approach-too-easy-fully-explained",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nLet\\'s trace the given `checkXMatrix` function with the provided input:\\n\\n```\\nvector<vector<int>> grid = {{2, 0, 0, 1},\\n                             {0, 3, 1, 0},\\n                             {0, 5, 2, 0},\\n                             {4, 0, 0, 2}};\\n```\\n\\nNow, let\\'s go through the function step by step:\\n\\n1. Initialize `i` to 0 and `j` to 0.\\n2. Initialize `sum` to 0, which will store the sum of diagonal elements, and `exSum` to 0, which will store the sum of non-diagonal elements.\\n3. Get the size of the matrix using `mat.size()` and store it in the variable `size`, which is 4 in this case.\\n\\n4. Start a loop that iterates while `i` is less than the size of the matrix (4):\\n   - First iteration: `i` is 0, and `j` is reset to 0.\\n     - Start another loop that iterates while `j` is less than the size of the inner vector (4):\\n       - First iteration: `j` is 0.\\n         - Check if `i` is equal to `j` (diagonal element).\\n           - Since `(0, 0)` is a diagonal element, add `grid[0][0]` (which is 2) to `sum` and continue.\\n       - Second iteration: `j` is 1.\\n         - This element is not on the main diagonal.\\n       - Third iteration: `j` is 2.\\n         - This element is not on the main diagonal.\\n       - Fourth iteration: `j` is 3.\\n         - Check if `(i + j + 1)` is equal to `size` (secondary diagonal element).\\n           - Since `(0, 3)` is a secondary diagonal element, add `grid[0][3]` (which is 1) to `sum`.\\n\\n   - Move to the next row:\\n   - Second iteration: `i` is 1, and `j` is reset to 0.\\n     - Start another loop that iterates while `j` is less than the size of the inner vector (4):\\n       - ... (similar to the previous steps)\\n       - The diagonal elements are: 3, 5, 2, 4.\\n\\n   - Move to the next row:\\n   - Third iteration: `i` is 2, and `j` is reset to 0.\\n     - Start another loop that iterates while `j` is less than the size of the inner vector (4):\\n       - ... (similar to the previous steps)\\n\\n   - Move to the next row:\\n   - Fourth iteration: `i` is 3, and `j` is reset to 0.\\n     - Start another loop that iterates while `j` is less than the size of the inner vector (4):\\n       - ... (similar to the previous steps)\\n\\n5. After the loops, `sum` contains the sum of diagonal elements (2 + 1 + 3 + 1 + 5 + 2 + 4 + 2 = 20) and `exSum` contains the sum of non-diagonal elements.\\n\\n6. Check if `exSum` is not 0. If it\\'s not 0, return `false`. Otherwise, return `true`.\\n7. In above case since `exSum` is 0. So, the function will return `true`;\\n\\n# Complexity\\n- Time complexity:$$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n``` C++ []\\nclass Solution {\\npublic:\\n    bool checkXMatrix(vector<vector<int>>& mat) {\\n        int i = 0, j = 0;\\n        int sum = 0,exSum = 0;\\n        int size = mat.size();\\n        while(i < mat.size()){\\n            j = 0;\\n            while(j < mat[i].size()){\\n                if(i == j){\\n                    sum += mat[i][j];\\n                    if(mat[i][j] == 0)\\n                        return false;\\n                }\\n                else if(size % 2 == 0 && (i + j + 1) == size){\\n                    sum += mat[i][j];\\n                    if(mat[i][j] == 0)\\n                        return false;\\n                }\\n                else if(size % 2 != 0 && (i + j + 1) == size){\\n                    sum += mat[i][j];\\n                    if(mat[i][j] == 0)\\n                        return false;\\n                }\\n                else\\n                    exSum += mat[i][j];\\n                j++;\\n            }\\n            i++;\\n        }\\n        if(exSum != 0)\\n            return false;\\n    return true;\\n    }\\n};\\n```\\n``` Python []\\nclass Solution:\\n    def checkXMatrix(self, grid: List[List[int]]) -> bool:\\n        dSum = 0\\n        ndSum = 0\\n\\n        for i in range(len(grid)):\\n            j = 0\\n            for j in range(len(grid[i])):\\n                if i == j:\\n                    dSum += grid[i][j]\\n                    if grid[i][j] is 0:\\n                        return False\\n                elif i + j + 1 == len(grid):\\n                    dSum += grid[i][j]\\n                    if grid[i][j] is 0:\\n                        return False\\n                else:\\n                    ndSum += grid[i][j]\\n        if ndSum is not 0:\\n            return False\\n        return True\\n```",
                "solutionTags": [
                    "C++",
                    "Python3"
                ],
                "code": "```\\nvector<vector<int>> grid = {{2, 0, 0, 1},\\n                             {0, 3, 1, 0},\\n                             {0, 5, 2, 0},\\n                             {4, 0, 0, 2}};\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    bool checkXMatrix(vector<vector<int>>& mat) {\\n        int i = 0, j = 0;\\n        int sum = 0,exSum = 0;\\n        int size = mat.size();\\n        while(i < mat.size()){\\n            j = 0;\\n            while(j < mat[i].size()){\\n                if(i == j){\\n                    sum += mat[i][j];\\n                    if(mat[i][j] == 0)\\n                        return false;\\n                }\\n                else if(size % 2 == 0 && (i + j + 1) == size){\\n                    sum += mat[i][j];\\n                    if(mat[i][j] == 0)\\n                        return false;\\n                }\\n                else if(size % 2 != 0 && (i + j + 1) == size){\\n                    sum += mat[i][j];\\n                    if(mat[i][j] == 0)\\n                        return false;\\n                }\\n                else\\n                    exSum += mat[i][j];\\n                j++;\\n            }\\n            i++;\\n        }\\n        if(exSum != 0)\\n            return false;\\n    return true;\\n    }\\n};\\n```\n``` Python []\\nclass Solution:\\n    def checkXMatrix(self, grid: List[List[int]]) -> bool:\\n        dSum = 0\\n        ndSum = 0\\n\\n        for i in range(len(grid)):\\n            j = 0\\n            for j in range(len(grid[i])):\\n                if i == j:\\n                    dSum += grid[i][j]\\n                    if grid[i][j] is 0:\\n                        return False\\n                elif i + j + 1 == len(grid):\\n                    dSum += grid[i][j]\\n                    if grid[i][j] is 0:\\n                        return False\\n                else:\\n                    ndSum += grid[i][j]\\n        if ndSum is not 0:\\n            return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3899778,
                "title": "identifying-an-x-matrix-elegant-solution-for-efficient-verification",
                "content": "**Problem Overview:**\\nWe are tasked with determining if a given 2D integer array `grid` of size `n x n` represents an X-Matrix. An X-Matrix fulfills two critical criteria:\\n1. Diagonal elements are non-zero.\\n2. All non-diagonal elements are zero.\\n\\n**Solution Insights:**\\nThe solution to this problem rests on a careful examination of the matrix\\'s elements. Here\\'s a breakdown of the approach:\\n\\n1. Iterate through each element of the matrix using nested loops for rows and columns.\\n2. For each element:\\n   - If the element is located on the main diagonal (`i == j`) or the secondary diagonal (`i + j == n - 1`):\\n     - If the value is zero, it contradicts the X-Matrix definition, so we promptly return `false`.\\n   - If the element is off any diagonal (`i != j` and `i + j != n - 1`):\\n     - If the value is non-zero, it violates the X-Matrix condition, leading us to return `false`.\\n3. If none of the above conditions are met, it confirms that the matrix is indeed an X-Matrix, allowing us to return `true`.\\n\\n**Code Illustration:**\\nHere\\'s the implementation of this elegant approach in C++, reflecting the logic described:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    bool checkXMatrix(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        \\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                \\n                if ((i == j || i + j == n - 1) && grid[i][j] == 0) {\\n                    return false;\\n                }\\n                \\n                \\n                if (i != j && i + j != n - 1 && grid[i][j] != 0) {\\n                    return false;\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```\\n\\n**Conclusion:**\\nBy meticulously considering the diagonal and non-diagonal elements, this solution elegantly determines whether the given matrix qualifies as an X-Matrix. It showcases the beauty of problem-solving through a methodical approach.\\n\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    bool checkXMatrix(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        \\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                \\n                if ((i == j || i + j == n - 1) && grid[i][j] == 0) {\\n                    return false;\\n                }\\n                \\n                \\n                if (i != j && i + j != n - 1 && grid[i][j] != 0) {\\n                    return false;\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3894552,
                "title": "one-pass",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkXMatrix(vector<vector<int>>& grid) {\\n        int n=grid.size()-1;\\n        for(int i=0;i<=n;i++){\\n            for(int j=0;j<=n;j++){\\n                if((i==j||n-i==j)&&grid[i][j]==0)return false;\\n                {\\n                     if(grid[i][j]>0&&(i!=j&&n-i!=j))return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkXMatrix(vector<vector<int>>& grid) {\\n        int n=grid.size()-1;\\n        for(int i=0;i<=n;i++){\\n            for(int j=0;j<=n;j++){\\n                if((i==j||n-i==j)&&grid[i][j]==0)return false;\\n                {\\n                     if(grid[i][j]>0&&(i!=j&&n-i!=j))return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3885249,
                "title": "2ms-brute-force-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean checkXMatrix(int[][] grid) {\\n        for(int i = 0; i < grid.length; i++) {\\n            for(int j = 0; j < grid[i].length; j++) {\\n                if(i == j || i == grid[i].length - 1 - j) {\\n                    if(grid[i][j] == 0) return false;\\n                }\\n                else {\\n                    if(grid[i][j] != 0) return false;\\n                }\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```\\n\\n\\nESCAPE THE MATRIX",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkXMatrix(int[][] grid) {\\n        for(int i = 0; i < grid.length; i++) {\\n            for(int j = 0; j < grid[i].length; j++) {\\n                if(i == j || i == grid[i].length - 1 - j) {\\n                    if(grid[i][j] == 0) return false;\\n                }\\n                else {\\n                    if(grid[i][j] != 0) return false;\\n                }\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3880641,
                "title": "c-easy-to-understand-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkXMatrix(vector<vector<int>>& grid) {\\n        int side = grid[0].size();\\n        int index = side - 1;\\n        for (int i = 0; i < side; i++) {\\n            if (grid[i][index] == 0) {\\n                return false;\\n            }\\n\\n            for (int j = 0; j < side; j++) {\\n                if (i == j && grid[i][j] == 0) {\\n                    return false;\\n                }\\n                if (i != j && j != index && grid[i][j] != 0) {\\n                    return false;\\n                }\\n            }\\n            index--;\\n        }\\n\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkXMatrix(vector<vector<int>>& grid) {\\n        int side = grid[0].size();\\n        int index = side - 1;\\n        for (int i = 0; i < side; i++) {\\n            if (grid[i][index] == 0) {\\n                return false;\\n            }\\n\\n            for (int j = 0; j < side; j++) {\\n                if (i == j && grid[i][j] == 0) {\\n                    return false;\\n                }\\n                if (i != j && j != index && grid[i][j] != 0) {\\n                    return false;\\n                }\\n            }\\n            index--;\\n        }\\n\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3876186,
                "title": "java-fastest-solution",
                "content": "\\n# Complexity\\n- Time complexity: *O(n)*\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: *O(1)*\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean checkXMatrix(int[][] grid) {\\n        int n = grid.length-1;\\n\\n        for(int i = 0; i <= n; i++)\\n            for(int j = 0; j <= n; j++)\\n                if(i == j || i + j == n){\\n                    if(grid[i][j] == 0) return false;\\n                }else if(grid[i][j] != 0) return false;\\n\\n        return true;   \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkXMatrix(int[][] grid) {\\n        int n = grid.length-1;\\n\\n        for(int i = 0; i <= n; i++)\\n            for(int j = 0; j <= n; j++)\\n                if(i == j || i + j == n){\\n                    if(grid[i][j] == 0) return false;\\n                }else if(grid[i][j] != 0) return false;\\n\\n        return true;   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3876056,
                "title": "rust-with-iterators-and-logical-operators",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn check_x_matrix(grid: Vec<Vec<i32>>) -> bool {\\n        grid\\n            .iter()\\n            .enumerate()\\n            .all(|(row_index, row)| {\\n                row\\n                    .iter()\\n                    .enumerate()\\n                    .all(|(col_index, val)| {\\n                        (col_index == row_index && *val > 0)\\n                     || (n - col_index - 1 == row_index && *val > 0)\\n                     || (col_index != row_index && n - col_index - 1 != row_index && *val == 0)\\n                    })\\n            })\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Array",
                    "Matrix",
                    "Iterator"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn check_x_matrix(grid: Vec<Vec<i32>>) -> bool {\\n        grid\\n            .iter()\\n            .enumerate()\\n            .all(|(row_index, row)| {\\n                row\\n                    .iter()\\n                    .enumerate()\\n                    .all(|(col_index, val)| {\\n                        (col_index == row_index && *val > 0)\\n                     || (n - col_index - 1 == row_index && *val > 0)\\n                     || (col_index != row_index && n - col_index - 1 != row_index && *val == 0)\\n                    })\\n            })\\n        \\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3873195,
                "title": "simple-method-every-beginner-can-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def checkXMatrix(self, grid: List[List[int]]) -> bool:\\n\\n\\n        n = len(grid)\\n        for i in range(n):\\n            if grid[i][i] == 0 or grid[i][n - 1 - i] == 0:\\n                return False\\n        for i in range(n):\\n            for j in range(n):\\n                if i != j and j != n - 1 - i and grid[i][j] != 0:\\n                    return False\\n\\n        return True\\n\\n\\n\\n        \\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkXMatrix(self, grid: List[List[int]]) -> bool:\\n\\n\\n        n = len(grid)\\n        for i in range(n):\\n            if grid[i][i] == 0 or grid[i][n - 1 - i] == 0:\\n                return False\\n        for i in range(n):\\n            for j in range(n):\\n                if i != j and j != n - 1 - i and grid[i][j] != 0:\\n                    return False\\n\\n        return True\\n\\n\\n\\n        \\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3873041,
                "title": "solution-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def checkXMatrix(self, grid: List[List[int]]) -> bool:\\n        a=0\\n        for i in range(0,len(grid)) :\\n            if grid[i][i]==0 :\\n                a+=1\\n        for i in range(0,len(grid)) :\\n            if grid[i][len(grid)-1-i]==0 :\\n                a+=1\\n        b=grid\\n        for i in range(0,len(b)) :\\n            b[i][i]=0\\n            b[i][len(b)-1-i]=0\\n        c=[]\\n        for i in range(0,len(b)) :\\n            for j in range(0,len(b)) :\\n                c.append(b[i][j])\\n        for i in c :\\n            if i!=0 :\\n                a+=1\\n        return False if a>0 else True\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkXMatrix(self, grid: List[List[int]]) -> bool:\\n        a=0\\n        for i in range(0,len(grid)) :\\n            if grid[i][i]==0 :\\n                a+=1\\n        for i in range(0,len(grid)) :\\n            if grid[i][len(grid)-1-i]==0 :\\n                a+=1\\n        b=grid\\n        for i in range(0,len(b)) :\\n            b[i][i]=0\\n            b[i][len(b)-1-i]=0\\n        c=[]\\n        for i in range(0,len(b)) :\\n            for j in range(0,len(b)) :\\n                c.append(b[i][j])\\n        for i in c :\\n            if i!=0 :\\n                a+=1\\n        return False if a>0 else True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3872573,
                "title": "solution-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def checkXMatrix(self, grid: List[List[int]]) -> bool:\\n        a=0\\n        for i in range(0,len(grid)) :\\n            if grid[i][i]==0 :\\n                a+=1\\n        for i in range(0,len(grid)) :\\n            if grid[i][len(grid)-1-i]==0 :\\n                a+=1\\n        b=grid\\n        for i in range(0,len(b)) :\\n            b[i][i]=0\\n            b[i][len(b)-1-i]=0\\n        c=[]\\n        for i in range(0,len(b)) :\\n            for j in range(0,len(b)) :\\n                c.append(b[i][j])\\n        for i in c :\\n            if i!=0 :\\n                a+=1\\n        return False if a>0 else True\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkXMatrix(self, grid: List[List[int]]) -> bool:\\n        a=0\\n        for i in range(0,len(grid)) :\\n            if grid[i][i]==0 :\\n                a+=1\\n        for i in range(0,len(grid)) :\\n            if grid[i][len(grid)-1-i]==0 :\\n                a+=1\\n        b=grid\\n        for i in range(0,len(b)) :\\n            b[i][i]=0\\n            b[i][len(b)-1-i]=0\\n        c=[]\\n        for i in range(0,len(b)) :\\n            for j in range(0,len(b)) :\\n                c.append(b[i][j])\\n        for i in c :\\n            if i!=0 :\\n                a+=1\\n        return False if a>0 else True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3841698,
                "title": "swift-solution-easy-for-newbies",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    func checkXMatrix(_ grid: [[Int]]) -> Bool {\\n        var countD = 0\\n        var countNotD = 0\\n\\n        for i in 0..<grid.count{\\n            if grid[i][i] == 0 || grid[i][grid.count - 1 - i] == 0 {\\n                return false \\n            }\\n            countD += grid[i][i]\\n            countD += grid[i][grid.count - 1 - i]\\n            let a = grid[i].reduce(0){ $0 + $1}\\n            countNotD += a\\n        }\\n        if grid.count % 2 != 0 {\\n            countD -= grid[(grid.count / 2)][(grid.count / 2)]\\n        }\\n\\n        if countD == countNotD  {\\n            return true\\n        } else {\\n            return false\\n        }\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func checkXMatrix(_ grid: [[Int]]) -> Bool {\\n        var countD = 0\\n        var countNotD = 0\\n\\n        for i in 0..<grid.count{\\n            if grid[i][i] == 0 || grid[i][grid.count - 1 - i] == 0 {\\n                return false \\n            }\\n            countD += grid[i][i]\\n            countD += grid[i][grid.count - 1 - i]\\n            let a = grid[i].reduce(0){ $0 + $1}\\n            countNotD += a\\n        }\\n        if grid.count % 2 != 0 {\\n            countD -= grid[(grid.count / 2)][(grid.count / 2)]\\n        }\\n\\n        if countD == countNotD  {\\n            return true\\n        } else {\\n            return false\\n        }\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3838945,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean checkXMatrix(int[][] grid) {\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                if((i==j||i+j==grid[0].length-1)){\\n                    if(grid[i][j]==0){\\n                        return false;\\n                    }\\n                }else{\\n                    if(grid[i][j]!=0){\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkXMatrix(int[][] grid) {\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                if((i==j||i+j==grid[0].length-1)){\\n                    if(grid[i][j]==0){\\n                        return false;\\n                    }\\n                }else{\\n                    if(grid[i][j]!=0){\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3835732,
                "title": "c-solution-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkXMatrix(vector<vector<int>>& grid) {\\n        int k = grid[0].size()-1;\\n        for(int i=0; i<grid.size(); i++)\\n        {\\n            for(int j=0; j<grid[i].size(); j++)\\n            {\\n                if((i==j) || (j==k))\\n                {\\n                    if((grid[i][j]==0) || (grid[i][k]==0))\\n                    {\\n                        return false;\\n                    }\\n                }\\n                else if(i!=j)\\n                {\\n                    if(grid[i][j]!=0)\\n                    {\\n                        return false;\\n                    }\\n                }\\n            }\\n            k--;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkXMatrix(vector<vector<int>>& grid) {\\n        int k = grid[0].size()-1;\\n        for(int i=0; i<grid.size(); i++)\\n        {\\n            for(int j=0; j<grid[i].size(); j++)\\n            {\\n                if((i==j) || (j==k))\\n                {\\n                    if((grid[i][j]==0) || (grid[i][k]==0))\\n                    {\\n                        return false;\\n                    }\\n                }\\n                else if(i!=j)\\n                {\\n                    if(grid[i][j]!=0)\\n                    {\\n                        return false;\\n                    }\\n                }\\n            }\\n            k--;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3835563,
                "title": "check-if-matrix-is-x-matrix",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean checkXMatrix(int[][] grid) {\\n        int i=0;\\n        int j=grid.length-1;\\n        for(int l=0;l<grid.length;l++)\\n        {\\n            for(int m=0;m<grid.length;m++)\\n            {\\n                if(grid[l][i]==0||grid[l][j]==0)\\n                return false;\\n                if(i!=m&&j!=m)\\n                {\\n                    if(grid[l][m]!=0)\\n                    return false;\\n                }\\n            }\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkXMatrix(int[][] grid) {\\n        int i=0;\\n        int j=grid.length-1;\\n        for(int l=0;l<grid.length;l++)\\n        {\\n            for(int m=0;m<grid.length;m++)\\n            {\\n                if(grid[l][i]==0||grid[l][j]==0)\\n                return false;\\n                if(i!=m&&j!=m)\\n                {\\n                    if(grid[l][m]!=0)\\n                    return false;\\n                }\\n            }\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3829218,
                "title": "fast-simple-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def checkXMatrix(self, grid: List[List[int]]) -> bool:\\n        l = len(grid)\\n        for i in range(l):\\n            for j in range(l):\\n                if i == j or l-1-j == i:\\n                    if grid[i][j] == 0:\\n                        return False\\n                else:\\n                    if grid[i][j] != 0:\\n                        return False\\n        return True\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkXMatrix(self, grid: List[List[int]]) -> bool:\\n        l = len(grid)\\n        for i in range(l):\\n            for j in range(l):\\n                if i == j or l-1-j == i:\\n                    if grid[i][j] == 0:\\n                        return False\\n                else:\\n                    if grid[i][j] != 0:\\n                        return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3826132,
                "title": "beat-100-python-one-pass-solution",
                "content": "![image.png](https://assets.leetcode.com/users/images/0f80ee29-44dc-4c4a-b5a4-db75d66ae88c_1690500285.7396328.png)\\n\\n\\n# Approach\\nUsing two nested loops to check all elements\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(1) , No extra space required, just checking\\n\\n# Code\\n```\\nclass Solution:\\n    def checkXMatrix(self, grid: List[List[int]]) -> bool:\\n        r = length(grid) // Determine the size of the square matrix\\n        for i from 0 to r-1:\\n            for j from 0 to r-1:\\n                if i == j or i + j == r-1: // Check if the element is on the main diagonal or secondary diagonal\\n                    if grid[i][j] == 0: // Check if the element is zero\\n                        return False\\n                else:\\n                    if grid[i][j] != 0: // Check if the element is non-zero for other positions\\n                        return False\\n\\n        return True // If all conditions are met, return True indicating an X-matrix\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkXMatrix(self, grid: List[List[int]]) -> bool:\\n        r = length(grid) // Determine the size of the square matrix\\n        for i from 0 to r-1:\\n            for j from 0 to r-1:\\n                if i == j or i + j == r-1: // Check if the element is on the main diagonal or secondary diagonal\\n                    if grid[i][j] == 0: // Check if the element is zero\\n                        return False\\n                else:\\n                    if grid[i][j] != 0: // Check if the element is non-zero for other positions\\n                        return False\\n\\n        return True // If all conditions are met, return True indicating an X-matrix\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3823262,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean checkXMatrix(int[][] grid) {\\n        int n = grid.length;\\n        boolean flag =  true;\\n        for(int i = 0; i < n ; i++){\\n            for(int j =0 ; j < n ; j++){\\n                if(i == j){\\n                    if(grid[i][j] == 0){\\n                        return false;\\n                    }\\n                }else if(i+j == n-1){\\n                    if(grid[i][j] == 0) return false;\\n                }\\n                else if(i != j){\\n                    if(grid[i][j] != 0) return false;\\n                }\\n            }\\n        }\\n        return flag;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkXMatrix(int[][] grid) {\\n        int n = grid.length;\\n        boolean flag =  true;\\n        for(int i = 0; i < n ; i++){\\n            for(int j =0 ; j < n ; j++){\\n                if(i == j){\\n                    if(grid[i][j] == 0){\\n                        return false;\\n                    }\\n                }else if(i+j == n-1){\\n                    if(grid[i][j] == 0) return false;\\n                }\\n                else if(i != j){\\n                    if(grid[i][j] != 0) return false;\\n                }\\n            }\\n        }\\n        return flag;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3817391,
                "title": "easy-straightforward-java-sol-1ms-beats-98-92-of-users-with-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean checkXMatrix(int[][] grid) {\\n       int n = grid.length;\\n    for (int i = 0; i < grid.length; i++) {\\n      if (grid[i][i] == 0 || grid[i][n - i - 1] == 0) return false;//check diagonals\\n       else {\\n        for (int j = 0; j < grid.length; j++) {\\n          if (i == j || j == n - 1 - i) continue;//check none diagonals\\n          if (grid[i][j] != 0) return false;\\n        }\\n      }\\n    }\\n\\n    return true;  \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkXMatrix(int[][] grid) {\\n       int n = grid.length;\\n    for (int i = 0; i < grid.length; i++) {\\n      if (grid[i][i] == 0 || grid[i][n - i - 1] == 0) return false;//check diagonals\\n       else {\\n        for (int j = 0; j < grid.length; j++) {\\n          if (i == j || j == n - 1 - i) continue;//check none diagonals\\n          if (grid[i][j] != 0) return false;\\n        }\\n      }\\n    }\\n\\n    return true;  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3817311,
                "title": "beats-94-of-users-with-javascript",
                "content": "![image.png](https://assets.leetcode.com/users/images/ecc4b7d7-f9f8-444a-ba4a-1787bc859fe3_1690346249.5766687.png)\\n\\n# Intuition\\nBeats 94% of users with JavaScript\\n\\n# Approach\\nJust return flase if there is a conditional that is false\\n\\n# Complexity\\n- Time complexity:\\n57 ms (Beats 94% of users with JavaScript)\\n\\n- Space complexity:\\n44.65 mb (Beats 66% of users with JavaScript)\\n\\n# Code\\n```\\n/**\\n * @param {number[][]} grid\\n * @return {boolean}\\n */\\nvar checkXMatrix = function(grid) {\\n\\n    for (let i = 0; i < grid.length; i++) {\\n        // first diagonal\\n        if (grid[i][i] !== 0) { \\n\\n        } else {\\n            return false;\\n        } \\n\\n        // second diagonal\\n        if (grid[i][(grid.length - 1) - i] !== 0) {\\n\\n        } else {\\n            return false;\\n        } \\n\\n        for (let j = 0; j < grid[0].length; j++) {\\n            if (i !== j && j !== grid.length - 1 - i && grid[i][j] !== 0) {\\n                return false;\\n            }\\n        }\\n    }\\n\\n    return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Matrix"
                ],
                "code": "```\\n/**\\n * @param {number[][]} grid\\n * @return {boolean}\\n */\\nvar checkXMatrix = function(grid) {\\n\\n    for (let i = 0; i < grid.length; i++) {\\n        // first diagonal\\n        if (grid[i][i] !== 0) { \\n\\n        } else {\\n            return false;\\n        } \\n\\n        // second diagonal\\n        if (grid[i][(grid.length - 1) - i] !== 0) {\\n\\n        } else {\\n            return false;\\n        } \\n\\n        for (let j = 0; j < grid[0].length; j++) {\\n            if (i !== j && j !== grid.length - 1 - i && grid[i][j] !== 0) {\\n                return false;\\n            }\\n        }\\n    }\\n\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3804450,
                "title": "nested-for-loop",
                "content": "# Code\\n```\\nclass Solution:\\n    def checkXMatrix(self, grid: List[List[int]]) -> bool:\\n        n = len(grid)\\n        for i in range(n):\\n            for j in range(n):\\n                if (i == j or i == n - 1 - j):\\n                    if grid[i][j] == 0:\\n                        return False\\n                else:\\n                    if grid[i][j] > 0:\\n                        return False\\n        return True\\n                \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkXMatrix(self, grid: List[List[int]]) -> bool:\\n        n = len(grid)\\n        for i in range(n):\\n            for j in range(n):\\n                if (i == j or i == n - 1 - j):\\n                    if grid[i][j] == 0:\\n                        return False\\n                else:\\n                    if grid[i][j] > 0:\\n                        return False\\n        return True\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3789333,
                "title": "fastest-java-solution-beats-99-10-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean checkXMatrix(int[][] grid) {\\n        int n = grid.length;\\n\\n        int xCounter = 0;\\n        int yCounter = 0;\\n\\n        while (xCounter < n) {\\n            if (grid[xCounter][yCounter] == 0) return false;\\n            xCounter++;\\n            yCounter++;\\n        }\\n\\n        xCounter = 0;\\n        yCounter = n - 1;\\n\\n        while (xCounter < n) {\\n            if (grid[xCounter][yCounter] == 0) return false;\\n            xCounter++;\\n            yCounter--;\\n        }\\n\\n        for (int i = 0; i < n; i++) {\\n            int counter = 0;\\n            for (int k = 0; k < n; k++) {\\n                if (grid[i][k] != 0) counter++;\\n            }\\n            if (counter == 0 || counter > 2) return false;\\n            if (counter != 1 && i == n / 2 && n % 2 == 1) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkXMatrix(int[][] grid) {\\n        int n = grid.length;\\n\\n        int xCounter = 0;\\n        int yCounter = 0;\\n\\n        while (xCounter < n) {\\n            if (grid[xCounter][yCounter] == 0) return false;\\n            xCounter++;\\n            yCounter++;\\n        }\\n\\n        xCounter = 0;\\n        yCounter = n - 1;\\n\\n        while (xCounter < n) {\\n            if (grid[xCounter][yCounter] == 0) return false;\\n            xCounter++;\\n            yCounter--;\\n        }\\n\\n        for (int i = 0; i < n; i++) {\\n            int counter = 0;\\n            for (int k = 0; k < n; k++) {\\n                if (grid[i][k] != 0) counter++;\\n            }\\n            if (counter == 0 || counter > 2) return false;\\n            if (counter != 1 && i == n / 2 && n % 2 == 1) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3786949,
                "title": "nice-and-elegant-solution-in-java-beats-100-rt-and-98-memory",
                "content": "```\\nclass Solution {\\n    public boolean checkXMatrix(int[][] grid) {\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid.length; j++) {\\n                if (i == j || i == grid.length - 1 - j) {\\n                    if (grid[i][j] == 0) {\\n                        return false;\\n                    }\\n                }\\n                else {\\n                    if (grid[i][j] != 0) {\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkXMatrix(int[][] grid) {\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid.length; j++) {\\n                if (i == j || i == grid.length - 1 - j) {\\n                    if (grid[i][j] == 0) {\\n                        return false;\\n                    }\\n                }\\n                else {\\n                    if (grid[i][j] != 0) {\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3784029,
                "title": "c-easy-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkXMatrix(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(j==i or j==(n-i-1)){\\n                    if(grid[i][j]==0){\\n                        return false;\\n                    }\\n                }\\n                else{\\n                    if(grid[i][j]!=0){\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n\\n\\n        return true;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkXMatrix(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(j==i or j==(n-i-1)){\\n                    if(grid[i][j]==0){\\n                        return false;\\n                    }\\n                }\\n                else{\\n                    if(grid[i][j]!=0){\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n\\n\\n        return true;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3782020,
                "title": "check-if-matrix-is-x-matrix-runtime-1ms-beats-99-11",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->(i==j) and     (i+j=n-1) to check diagonal of the matrix . Where n is sizeof row or column.\\n\\n# Complexity\\n- Time complexity:O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n![image.png](https://assets.leetcode.com/users/images/cd0c9535-9b9c-4050-9a75-b27e47b9451b_1689668318.6386657.png)\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean checkXMatrix(int[][] grid) {\\n        int n = grid.length;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(i==j){\\n                    if(grid[i][j]==0){\\n                        return false;\\n                    }\\n                }\\n                else if(i+j==n-1){\\n                    if(grid[i][j]==0){\\n                        return false;\\n                    }\\n                }\\n                else{\\n                    if(grid[i][j]!=0){\\n                    return false;}\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkXMatrix(int[][] grid) {\\n        int n = grid.length;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(i==j){\\n                    if(grid[i][j]==0){\\n                        return false;\\n                    }\\n                }\\n                else if(i+j==n-1){\\n                    if(grid[i][j]==0){\\n                        return false;\\n                    }\\n                }\\n                else{\\n                    if(grid[i][j]!=0){\\n                    return false;}\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3775610,
                "title": "double-for-loop-solution-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[][]} grid\\n * @return {boolean}\\n */\\nvar checkXMatrix = function(grid) {\\n    let ans = false;\\n    let n = grid.length;\\n\\n    for (let i = 0; i < n; i++) {\\n        for (let j = 0; j < n; j++) {\\n            if (i == j) {\\n                if (grid[i][j] == 0) {\\n                    return ans;\\n                }\\n            }\\n\\n            if (i + j == n - 1) {\\n                if (grid[i][j] == 0) {\\n                    return ans;\\n                }\\n            }\\n\\n            if (i != j && (i + j != n - 1)) {\\n                if (grid[i][j] != 0) {\\n                    return ans;\\n                }\\n            }\\n        }\\n    }\\n\\n    ans = true;\\n\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} grid\\n * @return {boolean}\\n */\\nvar checkXMatrix = function(grid) {\\n    let ans = false;\\n    let n = grid.length;\\n\\n    for (let i = 0; i < n; i++) {\\n        for (let j = 0; j < n; j++) {\\n            if (i == j) {\\n                if (grid[i][j] == 0) {\\n                    return ans;\\n                }\\n            }\\n\\n            if (i + j == n - 1) {\\n                if (grid[i][j] == 0) {\\n                    return ans;\\n                }\\n            }\\n\\n            if (i != j && (i + j != n - 1)) {\\n                if (grid[i][j] != 0) {\\n                    return ans;\\n                }\\n            }\\n        }\\n    }\\n\\n    ans = true;\\n\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3754754,
                "title": "c-best-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nthe logic behind i + j == n - 1 is as following:\\nIf you start from left bottom corner, for 4x4 matrix, it\\'s for example [3, 0], 0 + 3 = n - 1, now if you go up the diagonal everytime You are increasing the j by 1 and decreasing the i by 1, thus the sum remains the same on the whole diagonal.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkXMatrix(vector<vector<int>>& grid) {\\n        \\n        int n = grid.size();\\n\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n; j++){\\n\\n                if(i == j || i + j == n - 1) {\\n                    if(grid[i][j] == 0) return false;\\n                }\\n                else if(grid[i][j] != 0) return false;\\n\\n            }\\n        }\\n\\n        return true;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkXMatrix(vector<vector<int>>& grid) {\\n        \\n        int n = grid.size();\\n\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n; j++){\\n\\n                if(i == j || i + j == n - 1) {\\n                    if(grid[i][j] == 0) return false;\\n                }\\n                else if(grid[i][j] != 0) return false;\\n\\n            }\\n        }\\n\\n        return true;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3749208,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkXMatrix(vector<vector<int>>&g){\\n        for(int i=0; i<g.size(); i++){\\n            for(int j=0; j<g.size(); j++){\\n                if(i==j || g.size()-1==i+j){\\n                    if(g[i][j]==0){\\n                        return false;\\n                    }\\n                }\\n                else{\\n                    if(g[i][j]!=0){\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkXMatrix(vector<vector<int>>&g){\\n        for(int i=0; i<g.size(); i++){\\n            for(int j=0; j<g.size(); j++){\\n                if(i==j || g.size()-1==i+j){\\n                    if(g[i][j]==0){\\n                        return false;\\n                    }\\n                }\\n                else{\\n                    if(g[i][j]!=0){\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3741977,
                "title": "java-easy-approach-o-n-2",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean checkXMatrix(int[][] grid) {\\n        int n=grid.length;\\n        for(int i=0;i<grid.length;i++)\\n        {\\n            for(int j=0;j<grid[0].length;j++)\\n            {\\n                if(i==j || j==n-1-i)\\n                {\\n                    if(grid[i][j]==0) return false;\\n                }\\n                else\\n                {\\n                     if(grid[i][j]!=0) return false;\\n                }          \\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkXMatrix(int[][] grid) {\\n        int n=grid.length;\\n        for(int i=0;i<grid.length;i++)\\n        {\\n            for(int j=0;j<grid[0].length;j++)\\n            {\\n                if(i==j || j==n-1-i)\\n                {\\n                    if(grid[i][j]==0) return false;\\n                }\\n                else\\n                {\\n                     if(grid[i][j]!=0) return false;\\n                }          \\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3738751,
                "title": "easy-go-solution",
                "content": "```\\nfunc checkXMatrix(grid [][]int) bool {\\n        n := len(grid)\\n        firstDiagonal := [2]int{0, 0}\\n        secondDiagonal := [2]int{0, len(grid[0]) - 1}\\n\\n        for i := 0; i < n; i++ {\\n                for j := 0; j < n; j++ {\\n                        num := grid[i][j]\\n\\n                        if i == firstDiagonal[0] && j == firstDiagonal[1] {\\n                                if num == 0 {\\n                                        return false\\n                                }\\n                        } else if i == secondDiagonal[0] && j == secondDiagonal[1] {\\n                                if num == 0 {\\n                                        return false\\n                                }\\n                        } else {\\n                                if num != 0 {\\n                                        return false\\n                                }\\n                        }\\n                }\\n\\n                firstDiagonal[0]++\\n                firstDiagonal[1]++\\n                secondDiagonal[0]++\\n                secondDiagonal[1]--\\n        }\\n\\n        return true\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc checkXMatrix(grid [][]int) bool {\\n        n := len(grid)\\n        firstDiagonal := [2]int{0, 0}\\n        secondDiagonal := [2]int{0, len(grid[0]) - 1}\\n\\n        for i := 0; i < n; i++ {\\n                for j := 0; j < n; j++ {\\n                        num := grid[i][j]\\n\\n                        if i == firstDiagonal[0] && j == firstDiagonal[1] {\\n                                if num == 0 {\\n                                        return false\\n                                }\\n                        } else if i == secondDiagonal[0] && j == secondDiagonal[1] {\\n                                if num == 0 {\\n                                        return false\\n                                }\\n                        } else {\\n                                if num != 0 {\\n                                        return false\\n                                }\\n                        }\\n                }\\n\\n                firstDiagonal[0]++\\n                firstDiagonal[1]++\\n                secondDiagonal[0]++\\n                secondDiagonal[1]--\\n        }\\n\\n        return true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3729865,
                "title": "python-code-that-beats-76-in-runtime-and-81-in-memory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def checkXMatrix(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: bool\\n        \"\"\"\\n        for outer_index in range(len(grid)):\\n\\n            for inner_index in range(len(grid)):\\n\\n                if outer_index == inner_index:\\n\\n                    if grid[outer_index][inner_index] == 0:\\n\\n                        return False\\n\\n                elif inner_index == len(grid) - 1 - outer_index:\\n\\n                    if grid[outer_index][inner_index] == 0:\\n\\n                        return False\\n                \\n                else:\\n\\n                    if grid[outer_index][inner_index] != 0:\\n\\n                        return False\\n\\n        return True\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def checkXMatrix(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: bool\\n        \"\"\"\\n        for outer_index in range(len(grid)):\\n\\n            for inner_index in range(len(grid)):\\n\\n                if outer_index == inner_index:\\n\\n                    if grid[outer_index][inner_index] == 0:\\n\\n                        return False\\n\\n                elif inner_index == len(grid) - 1 - outer_index:\\n\\n                    if grid[outer_index][inner_index] == 0:\\n\\n                        return False\\n                \\n                else:\\n\\n                    if grid[outer_index][inner_index] != 0:\\n\\n                        return False\\n\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3709516,
                "title": "python-simple-bruteforce",
                "content": "```\\ndef checkXMatrix(self, grid: List[List[int]]) -> bool:\\n        n = len(grid)\\n        for i in range(n):\\n            for j in range(n):\\n                if i == j:\\n                    if grid[i][j] == 0:\\n                        return False\\n                elif i + j == n-1:\\n                    if grid[i][j] == 0:\\n                        return False\\n                elif grid[i][j] != 0:\\n                    return False\\n                    \\n                \\n        return True",
                "solutionTags": [],
                "code": "```\\ndef checkXMatrix(self, grid: List[List[int]]) -> bool:\\n        n = len(grid)\\n        for i in range(n):\\n            for j in range(n):\\n                if i == j:\\n                    if grid[i][j] == 0:\\n                        return False\\n                elif i + j == n-1:\\n                    if grid[i][j] == 0:\\n                        return False\\n                elif grid[i][j] != 0:\\n                    return False\\n                    \\n                \\n        return True",
                "codeTag": "Python3"
            },
            {
                "id": 3705363,
                "title": "check-if-matrix-is-x-matrix-easy-solution",
                "content": "\\n# Complexity\\n- Time complexity:O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean checkXMatrix(int[][] arr) {\\n    int sum=0;\\n    for(int i=0;i<arr.length;i++){\\n\\n        for(int j=0;j<arr.length;j++){\\n\\n// check  1 digonal\\n            if(i==j ){\\n                if(arr[i][j]==0)\\n                return false; \\n            }\\n\\n// check 2 digonal\\n           else if(i+j==arr.length-1){\\n               if(arr[i][j]==0)\\n               return false;\\n           }\\n\\n// check other element.\\n\\n           else if(arr[i][j]!=0){\\n            return false;\\n           }\\n        }\\n    }\\nreturn true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkXMatrix(int[][] arr) {\\n    int sum=0;\\n    for(int i=0;i<arr.length;i++){\\n\\n        for(int j=0;j<arr.length;j++){\\n\\n// check  1 digonal\\n            if(i==j ){\\n                if(arr[i][j]==0)\\n                return false; \\n            }\\n\\n// check 2 digonal\\n           else if(i+j==arr.length-1){\\n               if(arr[i][j]==0)\\n               return false;\\n           }\\n\\n// check other element.\\n\\n           else if(arr[i][j]!=0){\\n            return false;\\n           }\\n        }\\n    }\\nreturn true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3705324,
                "title": "python-simple-solution",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def checkXMatrix(self, grid: List[List[int]]) -> bool:\\n        l = 0\\n        r = len(grid[0]) - 1 \\n        for i in grid:\\n            for j in range(len(i)):\\n                if j != l and j!= r:\\n                    if i[j] != 0:\\n                        return False\\n                elif i[l] == 0 or i[r] == 0:\\n                    return False\\n            l+=1\\n            r-=1\\n        return True\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkXMatrix(self, grid: List[List[int]]) -> bool:\\n        l = 0\\n        r = len(grid[0]) - 1 \\n        for i in grid:\\n            for j in range(len(i)):\\n                if j != l and j!= r:\\n                    if i[j] != 0:\\n                        return False\\n                elif i[l] == 0 or i[r] == 0:\\n                    return False\\n            l+=1\\n            r-=1\\n        return True\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3699002,
                "title": "c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(m) where m=n*n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkXMatrix(vector<vector<int>>& grid) {\\n        int n=grid.size()-1;\\n        for(int i=0;i<=n;i++)\\n        {\\n            for(int j=0;j<=n;j++)\\n            {\\n                if(i==j || i+j==n)\\n                {\\n                    if(grid[i][j]==0)\\n                    return false;\\n                }\\n                else\\n                {\\n                    if(grid[i][j]!=0)\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkXMatrix(vector<vector<int>>& grid) {\\n        int n=grid.size()-1;\\n        for(int i=0;i<=n;i++)\\n        {\\n            for(int j=0;j<=n;j++)\\n            {\\n                if(i==j || i+j==n)\\n                {\\n                    if(grid[i][j]==0)\\n                    return false;\\n                }\\n                else\\n                {\\n                    if(grid[i][j]!=0)\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3689906,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkXMatrix(vector<vector<int>>& grid) {\\n      \\n          for(int i=0; i<grid.size(); i++)\\n            for(int j=0; j<grid.size(); j++)\\n                {\\n                    if((i==j) || (i+j==grid.size()-1))\\n                     {\\n                         if(grid[i][j]==0)\\n                         return false;\\n                     }\\n                     else{\\n                         if(grid[i][j]!=0)\\n                         return false;\\n                     }\\n\\n                \\n                } \\n        return true;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkXMatrix(vector<vector<int>>& grid) {\\n      \\n          for(int i=0; i<grid.size(); i++)\\n            for(int j=0; j<grid.size(); j++)\\n                {\\n                    if((i==j) || (i+j==grid.size()-1))\\n                     {\\n                         if(grid[i][j]==0)\\n                         return false;\\n                     }\\n                     else{\\n                         if(grid[i][j]!=0)\\n                         return false;\\n                     }\\n\\n                \\n                } \\n        return true;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3681563,
                "title": "simple-javascript-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[][]} grid\\n * @return {boolean}\\n */\\nvar checkXMatrix = function(grid) {\\n    let count=0;\\n    for(let i=0;i<grid.length;i++){\\n        for(let j=0;j<grid[i].length;j++)\\n        if(i===j || j===grid.length-i-1){\\n            if(grid[i][j]===0)\\n            return false;\\n            else\\n            continue;\\n        }\\n        else if(grid[i][j]!==0){\\n            return false;\\n        }\\n    }\\n    return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} grid\\n * @return {boolean}\\n */\\nvar checkXMatrix = function(grid) {\\n    let count=0;\\n    for(let i=0;i<grid.length;i++){\\n        for(let j=0;j<grid[i].length;j++)\\n        if(i===j || j===grid.length-i-1){\\n            if(grid[i][j]===0)\\n            return false;\\n            else\\n            continue;\\n        }\\n        else if(grid[i][j]!==0){\\n            return false;\\n        }\\n    }\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3680094,
                "title": "test-diagonality-of-a-matrix-java",
                "content": "class Solution\\n{\\n    public boolean checkXMatrix(int[][] grid)\\n    {\\n        int n=grid.length;\\n        for(int i=0;i<n;i++)\\n        {\\n        for(int j=0;j<n;j++)\\n        {\\n            if(i!=j&&i+j!=n-1&&grid[i][j]!=0)\\n            {\\n                return false;\\n            }\\n            if((i==j||i+j==n-1)&&grid[i][j]==0)\\n            {\\n                return false;\\n            }\\n        }\\n        }\\n        return true;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Matrix"
                ],
                "code": "class Solution\\n{\\n    public boolean checkXMatrix(int[][] grid)\\n    {\\n        int n=grid.length;\\n        for(int i=0;i<n;i++)\\n        {\\n        for(int j=0;j<n;j++)\\n        {\\n            if(i!=j&&i+j!=n-1&&grid[i][j]!=0)\\n            {\\n                return false;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3647319,
                "title": "python-3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(row * col)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def checkXMatrix(self, grid: List[List[int]]) -> bool:\\n        row = len(grid)\\n        col = len(grid[0])\\n\\n        for i in range(row):\\n            for j in range(col):\\n                if i == j or i+j == row-1:\\n                    if grid[i][j] == 0:\\n                        return False\\n                elif grid[i][j] != 0:\\n                    return False\\n\\n        return True\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkXMatrix(self, grid: List[List[int]]) -> bool:\\n        row = len(grid)\\n        col = len(grid[0])\\n\\n        for i in range(row):\\n            for j in range(col):\\n                if i == j or i+j == row-1:\\n                    if grid[i][j] == 0:\\n                        return False\\n                elif grid[i][j] != 0:\\n                    return False\\n\\n        return True\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3646530,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkXMatrix(vector<vector<int>>& grid) {\\n        for (int i=0 ; i<grid.size() ; i++){\\n            for (int j=0 ; j<grid.size() ; j++){\\n                if (i==j){\\n                    if (grid[i][j] == 0)\\n                        return false;\\n                }\\n                else if (i+j == grid.size()-1){\\n                    if (grid[i][j] == 0)\\n                        return false;\\n                }\\n                else{\\n                    if (grid[i][j] != 0)\\n                        return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkXMatrix(vector<vector<int>>& grid) {\\n        for (int i=0 ; i<grid.size() ; i++){\\n            for (int j=0 ; j<grid.size() ; j++){\\n                if (i==j){\\n                    if (grid[i][j] == 0)\\n                        return false;\\n                }\\n                else if (i+j == grid.size()-1){\\n                    if (grid[i][j] == 0)\\n                        return false;\\n                }\\n                else{\\n                    if (grid[i][j] != 0)\\n                        return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3636815,
                "title": "java-solution-beats-99",
                "content": "# Code\\n```\\nclass Solution {\\n    public boolean checkXMatrix(int[][] grid) {\\n        int n1 = grid.length;\\n        int n2 = grid[0].length;\\n        for(int i=0;i<n1;i++){\\n            for(int j=0;j<n2;j++){\\n                if(i==j || i+j==n1-1){\\n                    if(grid[i][j]==0) return false;\\n                }\\n                else{\\n                    if(grid[i][j]!=0) return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkXMatrix(int[][] grid) {\\n        int n1 = grid.length;\\n        int n2 = grid[0].length;\\n        for(int i=0;i<n1;i++){\\n            for(int j=0;j<n2;j++){\\n                if(i==j || i+j==n1-1){\\n                    if(grid[i][j]==0) return false;\\n                }\\n                else{\\n                    if(grid[i][j]!=0) return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3623413,
                "title": "one-pass-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe fastest way to solve this is to check if the current element satisfes both conditions and, only move ahead if it does. Return False otherwise.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- As you iterate through the matrix, check if the current element is \\'diagonal-element\\' or not.\\n- Have nested if statements that check the second condition; diagonal-elements must be non-zero and others must be zero.\\n\\n# Complexity\\n- Time complexity: O(n*n) where, n = len(grid)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def checkXMatrix(self, grid: List[List[int]]) -> bool:\\n        n = len(grid)\\n        for row in range(n):\\n            for col in range(n):\\n                if (row == col) or (row + col == n - 1):    # diagonal elements \\n                    if grid[row][col] == 0:\\n                        return False\\n                else:                                       # others\\n                    if grid[row][col] != 0:\\n                        return False\\n        return True\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkXMatrix(self, grid: List[List[int]]) -> bool:\\n        n = len(grid)\\n        for row in range(n):\\n            for col in range(n):\\n                if (row == col) or (row + col == n - 1):    # diagonal elements \\n                    if grid[row][col] == 0:\\n                        return False\\n                else:                                       # others\\n                    if grid[row][col] != 0:\\n                        return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3613504,
                "title": "beats-95",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkXMatrix(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n; j++){\\n                if(i==j){\\n                    if(grid[i][j]==0) return false;\\n                } \\n                else if(i==n-j-1){\\n                    if(grid[i][j]==0) return false;\\n                } \\n                else{\\n                    if(grid[i][j]!=0)  return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkXMatrix(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n; j++){\\n                if(i==j){\\n                    if(grid[i][j]==0) return false;\\n                } \\n                else if(i==n-j-1){\\n                    if(grid[i][j]==0) return false;\\n                } \\n                else{\\n                    if(grid[i][j]!=0)  return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3606050,
                "title": "java-simple-and-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public boolean checkXMatrix(int[][] grid) {\\n        int n = grid.length;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(i==j && grid[i][j]==0) return false;\\n                else if((i+j==n-1) && grid[i][j]==0) return false;\\n                else if(i!=j && (i+j!=n-1) && grid[i][j]!=0) return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkXMatrix(int[][] grid) {\\n        int n = grid.length;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(i==j && grid[i][j]==0) return false;\\n                else if((i+j==n-1) && grid[i][j]==0) return false;\\n                else if(i!=j && (i+j!=n-1) && grid[i][j]!=0) return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3580017,
                "title": "easier-and-faster-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkXMatrix(vector<vector<int>>& grid) {\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid.size();j++)\\n            {\\n                if(i==j || j==(grid.size()-i-1))\\n                {\\n                    if(grid[i][j]==0)\\n                    return false;\\n                }\\n                else if(grid[i][j]!=0)\\n                return false; \\n            }\\n        }\\n    return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkXMatrix(vector<vector<int>>& grid) {\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid.size();j++)\\n            {\\n                if(i==j || j==(grid.size()-i-1))\\n                {\\n                    if(grid[i][j]==0)\\n                    return false;\\n                }\\n                else if(grid[i][j]!=0)\\n                return false; \\n            }\\n        }\\n    return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3574701,
                "title": "python-simple-solution",
                "content": "# Intuition\\nI have to check all the values in the grid.\\n\\n# Approach\\nCheck all the values and use a helper to see which ones are diagonal.\\n\\n# Complexity\\n- Time complexity:\\n I go through and do constant work to determine if index is a diagonal and to see if my value is non zero. O(n)\\n\\n- Space complexity:\\nI am not storing anything O(1)\\n\\n# Checking Diagonals\\n\\n        Example 3 x 3 matrix\\n\\n            (0, 0)  (0, 1) (0, 2)\\n            (1, 0)  (1, 1) (1, 2)\\n            (2, 0)  (2, 1) (2, 2)\\n\\n        Notice if column is equal to row, we are a diagonal:\\n\\n            (0, 0)  X      X\\n            X      (1, 1)  X\\n            X       X     (2, 2)\\n\\n        Or if the sum of the index equals the square size - 1 we are a diagonal:\\n\\n            Grid of i j with index positions\\n\\n            (0, 0)  (0, 1) (0, 2)\\n            (1, 0)  (1, 1) (1, 2)\\n            (2, 0)  (2, 1) (2, 2)\\n\\n            Grid of i + j values at their index \\n\\n            (0)     (1)    (2)\\n            (1)     (2)    (3)\\n            (2)     (3)    (4)\\n\\n            Diagonals all equal to 2 for a 3X3 matrix:\\n\\n            (X)     (X)    (2)\\n            (X)     (2)    (X)\\n            (2)     (X)    (X)\\n\\n# Code\\n```\\nclass Solution:\\n    def checkXMatrix(self, grid: List[List[int]]) -> bool:\\n        # Get the size of the square\\n        square_size = len(grid)\\n\\n        # Go through all of the indices\\n        for i in range(square_size):\\n            for j in range(square_size):\\n                # Check the value of index i, j\\n                check_value = grid[i][j]\\n                # See if it is a diagonal\\n                if self.is_diag(i, j, square_size):\\n                    # If it is diagnoal, and a zero value, return False\\n                    if (check_value == 0):\\n                        return False\\n                else:\\n                    # It is a non-diagnoal, if it is a non-zero value, return False\\n                    if (check_value != 0):\\n                        return False\\n        return True\\n\\n    def is_diag(self, i, j, square_size):\\n        \\'\\'\\'Check to see if diagonal index.\\'\\'\\'\\n        # args:\\n        #     i: the row index\\n        #     j: the column index\\n        #     square_size: the max number of rows/columns of the grid\\n        # returns:\\n        #     True if the index at i, j is a diagonal, False otherwise\\n        if i == j:\\n            return True\\n        elif ( i + j ) == square_size - 1:\\n            return True\\n        else:\\n            return False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkXMatrix(self, grid: List[List[int]]) -> bool:\\n        # Get the size of the square\\n        square_size = len(grid)\\n\\n        # Go through all of the indices\\n        for i in range(square_size):\\n            for j in range(square_size):\\n                # Check the value of index i, j\\n                check_value = grid[i][j]\\n                # See if it is a diagonal\\n                if self.is_diag(i, j, square_size):\\n                    # If it is diagnoal, and a zero value, return False\\n                    if (check_value == 0):\\n                        return False\\n                else:\\n                    # It is a non-diagnoal, if it is a non-zero value, return False\\n                    if (check_value != 0):\\n                        return False\\n        return True\\n\\n    def is_diag(self, i, j, square_size):\\n        \\'\\'\\'Check to see if diagonal index.\\'\\'\\'\\n        # args:\\n        #     i: the row index\\n        #     j: the column index\\n        #     square_size: the max number of rows/columns of the grid\\n        # returns:\\n        #     True if the index at i, j is a diagonal, False otherwise\\n        if i == j:\\n            return True\\n        elif ( i + j ) == square_size - 1:\\n            return True\\n        else:\\n            return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3554353,
                "title": "trivial-c-beats-100",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    bool checkXMatrix(vector<vector<int>>& grid) {\\n        const auto n = grid.size();\\n        for (auto i = 0; i < n; ++i)\\n            for (auto j = 0; j < n; ++j)\\n                if ((i == j || i + j == n - 1) == !grid[i][j])\\n                    return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkXMatrix(vector<vector<int>>& grid) {\\n        const auto n = grid.size();\\n        for (auto i = 0; i < n; ++i)\\n            for (auto j = 0; j < n; ++j)\\n                if ((i == j || i + j == n - 1) == !grid[i][j])\\n                    return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3546077,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nbool checkXMatrix(int** grid, int gridSize, int* gridColSize){\\n    int b=gridSize-1;\\n    for(int i=0;i<gridSize;i++)\\n    {\\n        for(int j=0;j<gridSize;j++)\\n        {\\n            if(i==j || i+j==b)\\n            {\\n                if(grid[i][j]==0)\\n                {\\n                    return false;\\n                }\\n            }\\n                else \\n                {\\n                    if(grid[i][j]!=0)\\n                    {\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool checkXMatrix(int** grid, int gridSize, int* gridColSize){\\n    int b=gridSize-1;\\n    for(int i=0;i<gridSize;i++)\\n    {\\n        for(int j=0;j<gridSize;j++)\\n        {\\n            if(i==j || i+j==b)\\n            {\\n                if(grid[i][j]==0)\\n                {\\n                    return false;\\n                }\\n            }\\n                else \\n                {\\n                    if(grid[i][j]!=0)\\n                    {\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3543244,
                "title": "straightforward-python-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def checkXMatrix(self, grid: List[List[int]]) -> bool:\\n        for i in range(len(grid)):\\n            for j in range(len(grid[i])):\\n                if i == j or i+j == len(grid)-1:\\n                    if grid[i][j] == 0:\\n                        return False\\n                else:\\n                    if grid[i][j] != 0:\\n                        return False\\n        return True\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkXMatrix(self, grid: List[List[int]]) -> bool:\\n        for i in range(len(grid)):\\n            for j in range(len(grid[i])):\\n                if i == j or i+j == len(grid)-1:\\n                    if grid[i][j] == 0:\\n                        return False\\n                else:\\n                    if grid[i][j] != 0:\\n                        return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3532587,
                "title": "1-ms-java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public boolean checkXMatrix(int[][] grid) {\\n\\t\\t\\n    \\tint n = grid[0].length;\\n    \\t\\n    \\tfor(int i=0;i<n;i++) {\\n    \\t\\tfor(int j=0;j<n;j++) {\\n    \\t\\t\\tif(i==j || j==n-i-1) {\\n    \\t\\t\\t\\tif(grid[i][j] == 0) {\\n    \\t\\t\\t\\t\\treturn false;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}else {\\n    \\t\\t\\t\\tif(grid[i][j]!=0) {\\n    \\t\\t\\t\\t\\treturn false;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t}\\n    \\treturn true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkXMatrix(int[][] grid) {\\n\\t\\t\\n    \\tint n = grid[0].length;\\n    \\t\\n    \\tfor(int i=0;i<n;i++) {\\n    \\t\\tfor(int j=0;j<n;j++) {\\n    \\t\\t\\tif(i==j || j==n-i-1) {\\n    \\t\\t\\t\\tif(grid[i][j] == 0) {\\n    \\t\\t\\t\\t\\treturn false;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}else {\\n    \\t\\t\\t\\tif(grid[i][j]!=0) {\\n    \\t\\t\\t\\t\\treturn false;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t}\\n    \\treturn true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520012,
                "title": "check-grid-sum-diagonal-sum-n-n-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkXMatrix(vector<vector<int>>& grid) {\\n         long long sum=0;long long re=0;\\n        for(int i=0;i<grid.size();i++)\\n        {   if(grid[i][i]==0 || grid[i][grid.size()-1-i]==0 ) return false;\\n            sum+=grid[i][i];\\n            sum+=grid[i][grid.size()-1-i];\\n        }\\n        if(grid.size()%2!=0)sum-=grid[(grid.size()-1)/2][(grid.size()-1)/2];           for(int i=0;i<grid.size();i++)                                                                               for(int j=0;j<grid.size();j++)                                                                                                  re+=grid[i][j];                                                                                         if(sum==re) return true; else return false;\\n    }       \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkXMatrix(vector<vector<int>>& grid) {\\n         long long sum=0;long long re=0;\\n        for(int i=0;i<grid.size();i++)\\n        {   if(grid[i][i]==0 || grid[i][grid.size()-1-i]==0 ) return false;\\n            sum+=grid[i][i];\\n            sum+=grid[i][grid.size()-1-i];\\n        }\\n        if(grid.size()%2!=0)sum-=grid[(grid.size()-1)/2][(grid.size()-1)/2];           for(int i=0;i<grid.size();i++)                                                                               for(int j=0;j<grid.size();j++)                                                                                                  re+=grid[i][j];                                                                                         if(sum==re) return true; else return false;\\n    }       \\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1781385,
                "content": [
                    {
                        "username": "longluo",
                        "content": "We can use this logic to make the code **clean**:\n\n```java\nif ((grid[i][j] == 0) == (i == j || i + j == n - 1)) {\n    return false;\n}\n```\n"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "this one was pretty tricky... I think maybe it should be medium"
                    },
                    {
                        "username": "Limon020",
                        "content": "only knew how to do this one quickly due to N-Queens"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "pretty tricky .."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2319.%20Check%20if%20Matrix%20Is%20X-Matrix.CPP\\nLEAVE A STAR "
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "       int n=grid.size();\\n        int m=grid[0].size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(i==j||i+j==n-1){\\n                    if(grid[i][j]==0){\\n                        return 0;\\n                    }\\n                }\\n                else if(grid[i][j]!=0){\\n                    return 0;\\n                }\\n            }\\n        }\\n        return 1;\\n    }"
                    },
                    {
                        "username": "upscchap",
                        "content": "Will iterating over a grid be O(n) or O(n^2)?"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "[@ndharmateja](/ndharmateja) it will be o(m*n)"
                    },
                    {
                        "username": "aramfilak",
                        "content": "O(n), you only check each element once"
                    },
                    {
                        "username": "ndharmateja",
                        "content": "It will be O(n^2) as we will have a two nested loops with each loop taking O(n) time."
                    },
                    {
                        "username": "jaiyadav",
                        "content": "[[5,0,0,1],[0,4,1,5],[0,5,2,0],[4,1,0,2]] this matrix should be an X-matrix but why this is considered as non X-matrix?\\n"
                    },
                    {
                        "username": "Lt_Surge",
                        "content": "It is not an X Matrix. The second row needs to be [0,4,1,0] and the fourth row needs to be [4,0,0,2]"
                    }
                ]
            },
            {
                "id": 1992330,
                "content": [
                    {
                        "username": "longluo",
                        "content": "We can use this logic to make the code **clean**:\n\n```java\nif ((grid[i][j] == 0) == (i == j || i + j == n - 1)) {\n    return false;\n}\n```\n"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "this one was pretty tricky... I think maybe it should be medium"
                    },
                    {
                        "username": "Limon020",
                        "content": "only knew how to do this one quickly due to N-Queens"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "pretty tricky .."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2319.%20Check%20if%20Matrix%20Is%20X-Matrix.CPP\\nLEAVE A STAR "
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "       int n=grid.size();\\n        int m=grid[0].size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(i==j||i+j==n-1){\\n                    if(grid[i][j]==0){\\n                        return 0;\\n                    }\\n                }\\n                else if(grid[i][j]!=0){\\n                    return 0;\\n                }\\n            }\\n        }\\n        return 1;\\n    }"
                    },
                    {
                        "username": "upscchap",
                        "content": "Will iterating over a grid be O(n) or O(n^2)?"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "[@ndharmateja](/ndharmateja) it will be o(m*n)"
                    },
                    {
                        "username": "aramfilak",
                        "content": "O(n), you only check each element once"
                    },
                    {
                        "username": "ndharmateja",
                        "content": "It will be O(n^2) as we will have a two nested loops with each loop taking O(n) time."
                    },
                    {
                        "username": "jaiyadav",
                        "content": "[[5,0,0,1],[0,4,1,5],[0,5,2,0],[4,1,0,2]] this matrix should be an X-matrix but why this is considered as non X-matrix?\\n"
                    },
                    {
                        "username": "Lt_Surge",
                        "content": "It is not an X Matrix. The second row needs to be [0,4,1,0] and the fourth row needs to be [4,0,0,2]"
                    }
                ]
            },
            {
                "id": 2063940,
                "content": [
                    {
                        "username": "longluo",
                        "content": "We can use this logic to make the code **clean**:\n\n```java\nif ((grid[i][j] == 0) == (i == j || i + j == n - 1)) {\n    return false;\n}\n```\n"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "this one was pretty tricky... I think maybe it should be medium"
                    },
                    {
                        "username": "Limon020",
                        "content": "only knew how to do this one quickly due to N-Queens"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "pretty tricky .."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2319.%20Check%20if%20Matrix%20Is%20X-Matrix.CPP\\nLEAVE A STAR "
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "       int n=grid.size();\\n        int m=grid[0].size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(i==j||i+j==n-1){\\n                    if(grid[i][j]==0){\\n                        return 0;\\n                    }\\n                }\\n                else if(grid[i][j]!=0){\\n                    return 0;\\n                }\\n            }\\n        }\\n        return 1;\\n    }"
                    },
                    {
                        "username": "upscchap",
                        "content": "Will iterating over a grid be O(n) or O(n^2)?"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "[@ndharmateja](/ndharmateja) it will be o(m*n)"
                    },
                    {
                        "username": "aramfilak",
                        "content": "O(n), you only check each element once"
                    },
                    {
                        "username": "ndharmateja",
                        "content": "It will be O(n^2) as we will have a two nested loops with each loop taking O(n) time."
                    },
                    {
                        "username": "jaiyadav",
                        "content": "[[5,0,0,1],[0,4,1,5],[0,5,2,0],[4,1,0,2]] this matrix should be an X-matrix but why this is considered as non X-matrix?\\n"
                    },
                    {
                        "username": "Lt_Surge",
                        "content": "It is not an X Matrix. The second row needs to be [0,4,1,0] and the fourth row needs to be [4,0,0,2]"
                    }
                ]
            },
            {
                "id": 1854775,
                "content": [
                    {
                        "username": "longluo",
                        "content": "We can use this logic to make the code **clean**:\n\n```java\nif ((grid[i][j] == 0) == (i == j || i + j == n - 1)) {\n    return false;\n}\n```\n"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "this one was pretty tricky... I think maybe it should be medium"
                    },
                    {
                        "username": "Limon020",
                        "content": "only knew how to do this one quickly due to N-Queens"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "pretty tricky .."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2319.%20Check%20if%20Matrix%20Is%20X-Matrix.CPP\\nLEAVE A STAR "
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "       int n=grid.size();\\n        int m=grid[0].size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(i==j||i+j==n-1){\\n                    if(grid[i][j]==0){\\n                        return 0;\\n                    }\\n                }\\n                else if(grid[i][j]!=0){\\n                    return 0;\\n                }\\n            }\\n        }\\n        return 1;\\n    }"
                    },
                    {
                        "username": "upscchap",
                        "content": "Will iterating over a grid be O(n) or O(n^2)?"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "[@ndharmateja](/ndharmateja) it will be o(m*n)"
                    },
                    {
                        "username": "aramfilak",
                        "content": "O(n), you only check each element once"
                    },
                    {
                        "username": "ndharmateja",
                        "content": "It will be O(n^2) as we will have a two nested loops with each loop taking O(n) time."
                    },
                    {
                        "username": "jaiyadav",
                        "content": "[[5,0,0,1],[0,4,1,5],[0,5,2,0],[4,1,0,2]] this matrix should be an X-matrix but why this is considered as non X-matrix?\\n"
                    },
                    {
                        "username": "Lt_Surge",
                        "content": "It is not an X Matrix. The second row needs to be [0,4,1,0] and the fourth row needs to be [4,0,0,2]"
                    }
                ]
            },
            {
                "id": 1805136,
                "content": [
                    {
                        "username": "longluo",
                        "content": "We can use this logic to make the code **clean**:\n\n```java\nif ((grid[i][j] == 0) == (i == j || i + j == n - 1)) {\n    return false;\n}\n```\n"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "this one was pretty tricky... I think maybe it should be medium"
                    },
                    {
                        "username": "Limon020",
                        "content": "only knew how to do this one quickly due to N-Queens"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "pretty tricky .."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2319.%20Check%20if%20Matrix%20Is%20X-Matrix.CPP\\nLEAVE A STAR "
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "       int n=grid.size();\\n        int m=grid[0].size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(i==j||i+j==n-1){\\n                    if(grid[i][j]==0){\\n                        return 0;\\n                    }\\n                }\\n                else if(grid[i][j]!=0){\\n                    return 0;\\n                }\\n            }\\n        }\\n        return 1;\\n    }"
                    },
                    {
                        "username": "upscchap",
                        "content": "Will iterating over a grid be O(n) or O(n^2)?"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "[@ndharmateja](/ndharmateja) it will be o(m*n)"
                    },
                    {
                        "username": "aramfilak",
                        "content": "O(n), you only check each element once"
                    },
                    {
                        "username": "ndharmateja",
                        "content": "It will be O(n^2) as we will have a two nested loops with each loop taking O(n) time."
                    },
                    {
                        "username": "jaiyadav",
                        "content": "[[5,0,0,1],[0,4,1,5],[0,5,2,0],[4,1,0,2]] this matrix should be an X-matrix but why this is considered as non X-matrix?\\n"
                    },
                    {
                        "username": "Lt_Surge",
                        "content": "It is not an X Matrix. The second row needs to be [0,4,1,0] and the fourth row needs to be [4,0,0,2]"
                    }
                ]
            },
            {
                "id": 1748043,
                "content": [
                    {
                        "username": "longluo",
                        "content": "We can use this logic to make the code **clean**:\n\n```java\nif ((grid[i][j] == 0) == (i == j || i + j == n - 1)) {\n    return false;\n}\n```\n"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "this one was pretty tricky... I think maybe it should be medium"
                    },
                    {
                        "username": "Limon020",
                        "content": "only knew how to do this one quickly due to N-Queens"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "pretty tricky .."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2319.%20Check%20if%20Matrix%20Is%20X-Matrix.CPP\\nLEAVE A STAR "
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "       int n=grid.size();\\n        int m=grid[0].size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(i==j||i+j==n-1){\\n                    if(grid[i][j]==0){\\n                        return 0;\\n                    }\\n                }\\n                else if(grid[i][j]!=0){\\n                    return 0;\\n                }\\n            }\\n        }\\n        return 1;\\n    }"
                    },
                    {
                        "username": "upscchap",
                        "content": "Will iterating over a grid be O(n) or O(n^2)?"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "[@ndharmateja](/ndharmateja) it will be o(m*n)"
                    },
                    {
                        "username": "aramfilak",
                        "content": "O(n), you only check each element once"
                    },
                    {
                        "username": "ndharmateja",
                        "content": "It will be O(n^2) as we will have a two nested loops with each loop taking O(n) time."
                    },
                    {
                        "username": "jaiyadav",
                        "content": "[[5,0,0,1],[0,4,1,5],[0,5,2,0],[4,1,0,2]] this matrix should be an X-matrix but why this is considered as non X-matrix?\\n"
                    },
                    {
                        "username": "Lt_Surge",
                        "content": "It is not an X Matrix. The second row needs to be [0,4,1,0] and the fourth row needs to be [4,0,0,2]"
                    }
                ]
            },
            {
                "id": 1707236,
                "content": [
                    {
                        "username": "longluo",
                        "content": "We can use this logic to make the code **clean**:\n\n```java\nif ((grid[i][j] == 0) == (i == j || i + j == n - 1)) {\n    return false;\n}\n```\n"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "this one was pretty tricky... I think maybe it should be medium"
                    },
                    {
                        "username": "Limon020",
                        "content": "only knew how to do this one quickly due to N-Queens"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "pretty tricky .."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2319.%20Check%20if%20Matrix%20Is%20X-Matrix.CPP\\nLEAVE A STAR "
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "       int n=grid.size();\\n        int m=grid[0].size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(i==j||i+j==n-1){\\n                    if(grid[i][j]==0){\\n                        return 0;\\n                    }\\n                }\\n                else if(grid[i][j]!=0){\\n                    return 0;\\n                }\\n            }\\n        }\\n        return 1;\\n    }"
                    },
                    {
                        "username": "upscchap",
                        "content": "Will iterating over a grid be O(n) or O(n^2)?"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "[@ndharmateja](/ndharmateja) it will be o(m*n)"
                    },
                    {
                        "username": "aramfilak",
                        "content": "O(n), you only check each element once"
                    },
                    {
                        "username": "ndharmateja",
                        "content": "It will be O(n^2) as we will have a two nested loops with each loop taking O(n) time."
                    },
                    {
                        "username": "jaiyadav",
                        "content": "[[5,0,0,1],[0,4,1,5],[0,5,2,0],[4,1,0,2]] this matrix should be an X-matrix but why this is considered as non X-matrix?\\n"
                    },
                    {
                        "username": "Lt_Surge",
                        "content": "It is not an X Matrix. The second row needs to be [0,4,1,0] and the fourth row needs to be [4,0,0,2]"
                    }
                ]
            },
            {
                "id": 1693670,
                "content": [
                    {
                        "username": "longluo",
                        "content": "We can use this logic to make the code **clean**:\n\n```java\nif ((grid[i][j] == 0) == (i == j || i + j == n - 1)) {\n    return false;\n}\n```\n"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "this one was pretty tricky... I think maybe it should be medium"
                    },
                    {
                        "username": "Limon020",
                        "content": "only knew how to do this one quickly due to N-Queens"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "pretty tricky .."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2319.%20Check%20if%20Matrix%20Is%20X-Matrix.CPP\\nLEAVE A STAR "
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "       int n=grid.size();\\n        int m=grid[0].size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(i==j||i+j==n-1){\\n                    if(grid[i][j]==0){\\n                        return 0;\\n                    }\\n                }\\n                else if(grid[i][j]!=0){\\n                    return 0;\\n                }\\n            }\\n        }\\n        return 1;\\n    }"
                    },
                    {
                        "username": "upscchap",
                        "content": "Will iterating over a grid be O(n) or O(n^2)?"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "[@ndharmateja](/ndharmateja) it will be o(m*n)"
                    },
                    {
                        "username": "aramfilak",
                        "content": "O(n), you only check each element once"
                    },
                    {
                        "username": "ndharmateja",
                        "content": "It will be O(n^2) as we will have a two nested loops with each loop taking O(n) time."
                    },
                    {
                        "username": "jaiyadav",
                        "content": "[[5,0,0,1],[0,4,1,5],[0,5,2,0],[4,1,0,2]] this matrix should be an X-matrix but why this is considered as non X-matrix?\\n"
                    },
                    {
                        "username": "Lt_Surge",
                        "content": "It is not an X Matrix. The second row needs to be [0,4,1,0] and the fourth row needs to be [4,0,0,2]"
                    }
                ]
            }
        ]
    },
    {
        "title": "The Latest Time to Catch a Bus",
        "question_content": "<p>You are given a <strong>0-indexed</strong> integer array <code>buses</code> of length <code>n</code>, where <code>buses[i]</code> represents the departure time of the <code>i<sup>th</sup></code> bus. You are also given a <strong>0-indexed</strong> integer array <code>passengers</code> of length <code>m</code>, where <code>passengers[j]</code> represents the arrival time of the <code>j<sup>th</sup></code> passenger. All bus departure times are unique. All passenger arrival times are unique.</p>\n\n<p>You are given an integer <code>capacity</code>, which represents the <strong>maximum</strong> number of passengers that can get on each bus.</p>\n\n<p>When a passenger arrives, they will wait in line for the next available bus. You can get on a bus that departs at <code>x</code> minutes if you arrive at <code>y</code> minutes where <code>y &lt;= x</code>, and the bus is not full. Passengers with the <strong>earliest</strong> arrival times get on the bus first.</p>\n\n<p>More formally when a bus arrives, either:</p>\n\n<ul>\n\t<li>If <code>capacity</code> or fewer passengers are waiting for a bus, they will <strong>all</strong> get on the bus, or</li>\n\t<li>The <code>capacity</code> passengers with the <strong>earliest</strong> arrival times will get on the bus.</li>\n</ul>\n\n<p>Return <em>the latest time you may arrive at the bus station to catch a bus</em>. You <strong>cannot</strong> arrive at the same time as another passenger.</p>\n\n<p><strong>Note: </strong>The arrays <code>buses</code> and <code>passengers</code> are not necessarily sorted.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> buses = [10,20], passengers = [2,17,18,19], capacity = 2\n<strong>Output:</strong> 16\n<strong>Explanation:</strong> Suppose you arrive at time 16.\nAt time 10, the first bus departs with the 0<sup>th</sup> passenger. \nAt time 20, the second bus departs with you and the 1<sup>st</sup> passenger.\nNote that you may not arrive at the same time as another passenger, which is why you must arrive before the 1<sup>st</sup> passenger to catch the bus.</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> buses = [20,30,10], passengers = [19,13,26,4,25,11,21], capacity = 2\n<strong>Output:</strong> 20\n<strong>Explanation:</strong> Suppose you arrive at time 20.\nAt time 10, the first bus departs with the 3<sup>rd</sup> passenger. \nAt time 20, the second bus departs with the 5<sup>th</sup> and 1<sup>st</sup> passengers.\nAt time 30, the third bus departs with the 0<sup>th</sup> passenger and you.\nNotice if you had arrived any later, then the 6<sup>th</sup> passenger would have taken your seat on the third bus.</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == buses.length</code></li>\n\t<li><code>m == passengers.length</code></li>\n\t<li><code>1 &lt;= n, m, capacity &lt;= 10<sup>5</sup></code></li>\n\t<li><code>2 &lt;= buses[i], passengers[i] &lt;= 10<sup>9</sup></code></li>\n\t<li>Each element in <code>buses</code> is <strong>unique</strong>.</li>\n\t<li>Each element in <code>passengers</code> is <strong>unique</strong>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 2259211,
                "title": "what-is-latest-time-c-java-python",
                "content": "\\n\\uD83D\\uDC80\\uD83D\\uDC80\\uD83D\\uDC80\\uD83D\\uDC80\\uD83D\\uDC80\\uD83D\\uDC80\\uD83D\\uDC80\\uD83D\\uDC80\\uD83D\\uDC80\\uD83D\\uDC80\\uD83D\\uDC80\\uD83D\\uDC80\\uD83D\\uDC80\\uD83D\\uDC80\\uD83D\\uDC80\\uD83D\\uDC80\\nThe passengers will get on the next available bus. You can get on a bus that will depart at x minutes if you arrive at y minutes where y <= x, and the bus is not full. Passengers with the earliest arrival times get on the bus first.\\n\\nReturn the latest time you may arrive at the bus station to catch a bus. You cannot arrive at the same time as another passenger.\\n\\nHow to get on bus ?\\n\\nDo we have to reach early or late ? what is latest ?\\n**Return the latest time you may arrive at the bus station to catch a bus.**\\nis same as \\n**Return the maximum late possible time for which you can board the bus**\\n\\n**latest == late**\\n\\nAnyway Let\\'s understand  this problem.\\nHere we have to come as late as possible and still be able to board on the bus.\\nWe have to come late, so definitely the optimal approach is to board on the last bus.\\n\\n**Cases**\\n1. Last bus is not full: We can reach at bus time, but we have to make sure that our time should not clash with any other passenger.\\n2. Last bus is full: We have to reach before the last person which is on board and we have to make sure that our time should not clash with any other passenger. \\n\\nLet\\'s take some examples:\\n```\\nB = Buses Departure time and P is the Passenger Arrival Time, C is Capacity of a single bus.\\n\\n// Example 1\\nB -> [10,20]\\nP -> [2,17,19]\\nC -> 2\\n\\nBus with passengers\\n1st Bus [10] -> [2]\\n2nd Bus [20] -> [17, 19]\\n\\nAnswer = latest Time = late time = 18\\nBus is full, so reach before last passenger and don\\'t clash with other passenger time, so reach @18\\n\\n// Example 2\\nB -> [10,20]\\nP -> [2,17]\\nC -> 2\\n\\nBus with passengers\\n1st Bus [10] -> [2]\\n2nd Bus [20] -> [17]\\n\\nAnswer = latest Time = late time = 20\\nBus is not full, so reach at bus time, but don\\'t clash with other passenger time, so reach @20\\n\\n// Example 3\\nB -> [10,20]\\nP -> [2,17,18]\\nC -> 2\\n\\nBus with passengers\\n1st Bus [10] -> [2]\\n2nd Bus [20] -> [17, 18]\\n\\nAnswer = latest Time = late time = 16\\nBus is full, so reach before the last passenger and don\\'t clash with other passenger time, so reach @16\\n\\n// Example 4\\nB -> [10,20]\\nP -> [2,17,18,19]\\nC -> 2\\n\\nBus with passengers\\n1st Bus [10] -> [2]\\n2nd Bus [20] -> [17, 18]\\n\\nAnswer = latest Time = late time = 16\\nBus is full, so reach before the last passenger and don\\'t clash with other passenger time, so reach @16\\n```\\n\\nCredits  @<a href=\"https://leetcode.com/Dengxj/\">Dengxj</a>\\nU can see his blog <a href=\"https://leetcode.com/problems/the-latest-time-to-catch-a-bus/discuss/2259243/C%2B%2B-catch-the-last-bus\">[C++] catch the last bus</a>\\n\\n**Approach : Greedy**\\n**TC: O(NlogN) + O(MlogM)**\\n**SC: O(1)**\\n```\\nclass Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& buses, vector<int>& passengers, int capacity) {\\n        sort(buses.begin(), buses.end());\\n        sort(passengers.begin(), passengers.end());\\n        int n = buses.size(), m = passengers.size();\\n\\n        int res = 0;\\n        for (int i = 0, j = 0; i < n; ++i) {\\n            int cnt = 0;\\n            while (j < m && passengers[j] <= buses[i] && cnt < capacity) {\\n                ++cnt;\\n                ++j;\\n            }\\n            if (i == n - 1) { // the last bus\\n                if (cnt < capacity) { // still have seats\\n                    int t = buses[i]; // can be as late as the bus arrive time\\n                    for (int k = j - 1; k >= 0 && passengers[k] == t; --k, --t);\\n                    res = max(res, t);\\n                } else { // full of passegers\\n                    int t = passengers[j - 1] - 1; // should arrive earlier than last passenger aboard\\n                    for (int k = j - 2; k >= 0 && passengers[k] == t; --k, --t);\\n                    res = max(res, t);\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n\\n```\\n// My Code\\nclass Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& buses, vector<int>& passengers, int totalCapacity){\\n        sort(buses.begin(), buses.end());\\n        sort(passengers.begin(), passengers.end());\\n        \\n        int i = 0, j = 0, n = buses.size(), m = passengers.size(), currentCapacity;\\n        while(i < n){\\n            currentCapacity = 0;\\n            while(j < m && currentCapacity < totalCapacity && passengers[j] <= buses[i]){\\n                j++;\\n                currentCapacity++;\\n            }\\n            \\n\\t\\t\\t// Last Bus\\n            if(i == n - 1){\\n                j--;\\n                // If last bus has some seats left, then reach station at last bus departure time.\\n                if(currentCapacity < totalCapacity){\\n                    int time = buses[i];\\n                    while(j >= 0 && time == passengers[j]){ // if time clashes with other passenger, reach 1 minute early\\n                        time--, j--;\\n                    }\\n                    return time;\\n                }else{\\n                    // If bus is full, then we have to reach before the last person which is on board\\n                    int time = passengers[j] - 1;\\n                    j--;\\n                    while(j >= 0 && time == passengers[j]){  // if time clashes with other passenger, reach 1 minute early\\n                        time--, j--;\\n                    }\\n                    return time;\\n                }\\n            }\\n            i++;\\n        }\\n        return buses.back(); // just compiler thing\\n    }\\n};\\n```\\n**Python**\\n```\\nclass Solution:\\n    def latestTimeCatchTheBus(self, buses, passengers, totalCapacity):\\n        buses.sort()\\n        passengers.sort()\\n        \\n        i, j = 0, 0\\n        n, m = len(buses), len(passengers)\\n        currentCapacity = 0\\n        \\n        while i < n:\\n            currentCapacity = 0\\n            while j < m and currentCapacity < totalCapacity and passengers[j] <= buses[i]:\\n                j += 1\\n                currentCapacity += 1\\n            \\n            # Last Bus\\n            if i == n - 1:\\n                j -= 1\\n                if currentCapacity < totalCapacity:\\n                    time = buses[i]\\n                    while j >= 0 and time == passengers[j]:\\n                        time -= 1\\n                        j -= 1\\n                    return time\\n                else:\\n                    time = passengers[j] - 1\\n                    j -= 1\\n                    while j >= 0 and time == passengers[j]:\\n                        time -= 1\\n                        j -= 1\\n                    return time\\n            \\n            i += 1\\n        \\n        return buses[-1]\\n```\\n**Java**\\n```\\nclass Solution {\\n    public int latestTimeCatchTheBus(int[] buses, int[] passengers, int totalCapacity) {\\n        // Convert arrays to lists\\n        List<Integer> busList = new ArrayList<>();\\n        for (int bus : buses) {\\n            busList.add(bus);\\n        }\\n        \\n        List<Integer> passengerList = new ArrayList<>();\\n        for (int passenger : passengers) {\\n            passengerList.add(passenger);\\n        }\\n        \\n        // Sort lists\\n        Collections.sort(busList);\\n        Collections.sort(passengerList);\\n        \\n        int i = 0, j = 0;\\n        int n = busList.size(), m = passengerList.size();\\n        int currentCapacity = 0;\\n        \\n        while (i < n) {\\n            currentCapacity = 0;\\n            while (j < m && currentCapacity < totalCapacity && passengerList.get(j) <= busList.get(i)) {\\n                j++;\\n                currentCapacity++;\\n            }\\n            \\n            // Last Bus\\n            if (i == n - 1) {\\n                j--;\\n                if (currentCapacity < totalCapacity) {\\n                    int time = busList.get(i);\\n                    while (j >= 0 && time == passengerList.get(j)) {\\n                        time--;\\n                        j--;\\n                    }\\n                    return time;\\n                } else {\\n                    int time = passengerList.get(j) - 1;\\n                    j--;\\n                    while (j >= 0 && time == passengerList.get(j)) {\\n                        time--;\\n                        j--;\\n                    }\\n                    return time;\\n                }\\n            }\\n            i++;\\n        }\\n        return busList.get(n - 1);\\n    }\\n}\\n```\\n**Note: I am unable to solve this  during contest.**\\n**Just in case if u r unable to understand this question & feeling low,  don\\'t worry u r not alone. We just have to practice more of understatement questions**\\n\\n\\nAny suggestion or better approaches are most Welcome.\\n**Have a good day \\uD83C\\uDF3B**",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nB = Buses Departure time and P is the Passenger Arrival Time, C is Capacity of a single bus.\\n\\n// Example 1\\nB -> [10,20]\\nP -> [2,17,19]\\nC -> 2\\n\\nBus with passengers\\n1st Bus [10] -> [2]\\n2nd Bus [20] -> [17, 19]\\n\\nAnswer = latest Time = late time = 18\\nBus is full, so reach before last passenger and don\\'t clash with other passenger time, so reach @18\\n\\n// Example 2\\nB -> [10,20]\\nP -> [2,17]\\nC -> 2\\n\\nBus with passengers\\n1st Bus [10] -> [2]\\n2nd Bus [20] -> [17]\\n\\nAnswer = latest Time = late time = 20\\nBus is not full, so reach at bus time, but don\\'t clash with other passenger time, so reach @20\\n\\n// Example 3\\nB -> [10,20]\\nP -> [2,17,18]\\nC -> 2\\n\\nBus with passengers\\n1st Bus [10] -> [2]\\n2nd Bus [20] -> [17, 18]\\n\\nAnswer = latest Time = late time = 16\\nBus is full, so reach before the last passenger and don\\'t clash with other passenger time, so reach @16\\n\\n// Example 4\\nB -> [10,20]\\nP -> [2,17,18,19]\\nC -> 2\\n\\nBus with passengers\\n1st Bus [10] -> [2]\\n2nd Bus [20] -> [17, 18]\\n\\nAnswer = latest Time = late time = 16\\nBus is full, so reach before the last passenger and don\\'t clash with other passenger time, so reach @16\\n```\n```\\nclass Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& buses, vector<int>& passengers, int capacity) {\\n        sort(buses.begin(), buses.end());\\n        sort(passengers.begin(), passengers.end());\\n        int n = buses.size(), m = passengers.size();\\n\\n        int res = 0;\\n        for (int i = 0, j = 0; i < n; ++i) {\\n            int cnt = 0;\\n            while (j < m && passengers[j] <= buses[i] && cnt < capacity) {\\n                ++cnt;\\n                ++j;\\n            }\\n            if (i == n - 1) { // the last bus\\n                if (cnt < capacity) { // still have seats\\n                    int t = buses[i]; // can be as late as the bus arrive time\\n                    for (int k = j - 1; k >= 0 && passengers[k] == t; --k, --t);\\n                    res = max(res, t);\\n                } else { // full of passegers\\n                    int t = passengers[j - 1] - 1; // should arrive earlier than last passenger aboard\\n                    for (int k = j - 2; k >= 0 && passengers[k] == t; --k, --t);\\n                    res = max(res, t);\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\n```\\n// My Code\\nclass Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& buses, vector<int>& passengers, int totalCapacity){\\n        sort(buses.begin(), buses.end());\\n        sort(passengers.begin(), passengers.end());\\n        \\n        int i = 0, j = 0, n = buses.size(), m = passengers.size(), currentCapacity;\\n        while(i < n){\\n            currentCapacity = 0;\\n            while(j < m && currentCapacity < totalCapacity && passengers[j] <= buses[i]){\\n                j++;\\n                currentCapacity++;\\n            }\\n            \\n\\t\\t\\t// Last Bus\\n            if(i == n - 1){\\n                j--;\\n                // If last bus has some seats left, then reach station at last bus departure time.\\n                if(currentCapacity < totalCapacity){\\n                    int time = buses[i];\\n                    while(j >= 0 && time == passengers[j]){ // if time clashes with other passenger, reach 1 minute early\\n                        time--, j--;\\n                    }\\n                    return time;\\n                }else{\\n                    // If bus is full, then we have to reach before the last person which is on board\\n                    int time = passengers[j] - 1;\\n                    j--;\\n                    while(j >= 0 && time == passengers[j]){  // if time clashes with other passenger, reach 1 minute early\\n                        time--, j--;\\n                    }\\n                    return time;\\n                }\\n            }\\n            i++;\\n        }\\n        return buses.back(); // just compiler thing\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def latestTimeCatchTheBus(self, buses, passengers, totalCapacity):\\n        buses.sort()\\n        passengers.sort()\\n        \\n        i, j = 0, 0\\n        n, m = len(buses), len(passengers)\\n        currentCapacity = 0\\n        \\n        while i < n:\\n            currentCapacity = 0\\n            while j < m and currentCapacity < totalCapacity and passengers[j] <= buses[i]:\\n                j += 1\\n                currentCapacity += 1\\n            \\n            # Last Bus\\n            if i == n - 1:\\n                j -= 1\\n                if currentCapacity < totalCapacity:\\n                    time = buses[i]\\n                    while j >= 0 and time == passengers[j]:\\n                        time -= 1\\n                        j -= 1\\n                    return time\\n                else:\\n                    time = passengers[j] - 1\\n                    j -= 1\\n                    while j >= 0 and time == passengers[j]:\\n                        time -= 1\\n                        j -= 1\\n                    return time\\n            \\n            i += 1\\n        \\n        return buses[-1]\\n```\n```\\nclass Solution {\\n    public int latestTimeCatchTheBus(int[] buses, int[] passengers, int totalCapacity) {\\n        // Convert arrays to lists\\n        List<Integer> busList = new ArrayList<>();\\n        for (int bus : buses) {\\n            busList.add(bus);\\n        }\\n        \\n        List<Integer> passengerList = new ArrayList<>();\\n        for (int passenger : passengers) {\\n            passengerList.add(passenger);\\n        }\\n        \\n        // Sort lists\\n        Collections.sort(busList);\\n        Collections.sort(passengerList);\\n        \\n        int i = 0, j = 0;\\n        int n = busList.size(), m = passengerList.size();\\n        int currentCapacity = 0;\\n        \\n        while (i < n) {\\n            currentCapacity = 0;\\n            while (j < m && currentCapacity < totalCapacity && passengerList.get(j) <= busList.get(i)) {\\n                j++;\\n                currentCapacity++;\\n            }\\n            \\n            // Last Bus\\n            if (i == n - 1) {\\n                j--;\\n                if (currentCapacity < totalCapacity) {\\n                    int time = busList.get(i);\\n                    while (j >= 0 && time == passengerList.get(j)) {\\n                        time--;\\n                        j--;\\n                    }\\n                    return time;\\n                } else {\\n                    int time = passengerList.get(j) - 1;\\n                    j--;\\n                    while (j >= 0 && time == passengerList.get(j)) {\\n                        time--;\\n                        j--;\\n                    }\\n                    return time;\\n                }\\n            }\\n            i++;\\n        }\\n        return busList.get(n - 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2259200,
                "title": "python-just-calculate-faster-than-100-00",
                "content": "Runtime: `797 ms`, faster than `100.00%` of Python3 online submissions for The Latest Time to Catch a Bus.\\nMemory Usage: `33.6 MB`, less than `100.00%` of Python3 online submissions for The Latest Time to Catch a Bus.\\n\\n```python\\nclass Solution:\\n    def latestTimeCatchTheBus(self, buses: List[int], passengers: List[int], capacity: int) -> int:\\n        passengers.sort()\\n        cur = 0\\n\\n        for time in sorted(buses):\\n            cap = capacity\\n            while cur < len(passengers) and passengers[cur] <= time and cap > 0:\\n                cur += 1\\n                cap -= 1\\n\\n        best = time if cap > 0 else passengers[cur - 1]\\n\\n        passengers = set(passengers)\\n        while best in passengers:\\n            best -= 1\\n        return best\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```python\\nclass Solution:\\n    def latestTimeCatchTheBus(self, buses: List[int], passengers: List[int], capacity: int) -> int:\\n        passengers.sort()\\n        cur = 0\\n\\n        for time in sorted(buses):\\n            cap = capacity\\n            while cur < len(passengers) and passengers[cur] <= time and cap > 0:\\n                cur += 1\\n                cap -= 1\\n\\n        best = time if cap > 0 else passengers[cur - 1]\\n\\n        passengers = set(passengers)\\n        while best in passengers:\\n            best -= 1\\n        return best\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2259708,
                "title": "c-100-faster-explanation-beginner-friendly-easy-unordered-set-o-n",
                "content": "Sort the buses array and passengers array. \\n\\nNow consider a bus departing at time **t1** so as passengers array is also sorted just iterate over passengers array and look which all passengers can travel by this bus. Suppose a passenger arriving at time **t2** can travel by this bus , then **t2-1** can be a possible answer , if and only if there is not any passenger arriving at t2-1.\\n\\nNow , there can be a condition that there are less passengers than the capacity which can travel by the bus departing at t1.\\nFor ex - bus departs at t=10 and has capacity 2\\nbut there is only 1 passenger to travel. So departure time of the bus can be a possible answer.\\nBut what if that 1 passenger has arrival time equal to departure time of the bus then departure time cannot be our answer.\\n\\n\\nDry Run-\\nbuses - [10,20]\\npassengers - [4,7,18]\\ncapacity = 2\\n\\nnow from bus1 ->  4 can travel so answer can be  3 which is also not the arrival time of any passenger  **ans = 3**\\n7 can also travel from bus1  so  6 can be a possible ans , as it is also not an arrival time of any passenger so **ans=6** as of now.\\n\\nNow capacity for bus1 is 2 , so no more passengers can travel.\\n\\nnow bus2 departs at 20  and 18 can travel by bus2  so ans can be 17 if it is not the arrival time of any passenger and yes it is not ,  so **ans=17** \\n\\nBut here we can see cap=1 for bus2 so last passenger can arrive at t=20 (max) to travel by bus2 hence ans will be equal to **20**\\n\\n**Code -** \\n```\\nclass Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& b, vector<int>& p, int cap) {\\n        int n1 = b.size() , n2 = p.size() , j=0 , ans;\\n        unordered_set<int> u;\\n        sort(b.begin() , b.end());\\n        sort(p.begin() , p.end());\\n        \\n        for(int i=0 ; i<n1 ; i++){\\n            int c = 0;\\n            while(c<cap && j<n2 && p[j]<=b[i]){\\n                if(u.find(p[j]-1)==u.end()) ans = p[j]-1; \\n                u.insert(p[j]);\\n                c++;\\n                j++;\\n            }\\n            if(c<cap && u.find(b[i])==u.end()) ans = b[i];\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nNow here , if we look there is no need to maintain an unordered set as passengers arrival time is sorted so we are just concerned with the previous passenger\\'s arrival time , so instead of maintaining the set , we can store the arrival time of previous passenger in a variable.\\n\\n**Code -**\\n```\\nint latestTimeCatchTheBus(vector<int>& b, vector<int>& p, int cap) {\\n        int n1 = b.size() , n2 = p.size() , j=0 , ans , prev=-1;\\n        sort(b.begin() , b.end());\\n        sort(p.begin() , p.end());\\n        \\n        for(int i=0 ; i<n1 ; i++){\\n            int c = 0;\\n            while(c<cap && j<n2 && p[j]<=b[i]){\\n                if(p[j]-1!=prev) ans = p[j]-1; \\n                prev = p[j];\\n                c++;\\n                j++;\\n            }\\n            if(c<cap && b[i]!=prev) ans = b[i];\\n        }\\n        return ans;\\n    }\\n```\\nIn case you like the approach ,  **DO UPVOTE**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& b, vector<int>& p, int cap) {\\n        int n1 = b.size() , n2 = p.size() , j=0 , ans;\\n        unordered_set<int> u;\\n        sort(b.begin() , b.end());\\n        sort(p.begin() , p.end());\\n        \\n        for(int i=0 ; i<n1 ; i++){\\n            int c = 0;\\n            while(c<cap && j<n2 && p[j]<=b[i]){\\n                if(u.find(p[j]-1)==u.end()) ans = p[j]-1; \\n                u.insert(p[j]);\\n                c++;\\n                j++;\\n            }\\n            if(c<cap && u.find(b[i])==u.end()) ans = b[i];\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nint latestTimeCatchTheBus(vector<int>& b, vector<int>& p, int cap) {\\n        int n1 = b.size() , n2 = p.size() , j=0 , ans , prev=-1;\\n        sort(b.begin() , b.end());\\n        sort(p.begin() , p.end());\\n        \\n        for(int i=0 ; i<n1 ; i++){\\n            int c = 0;\\n            while(c<cap && j<n2 && p[j]<=b[i]){\\n                if(p[j]-1!=prev) ans = p[j]-1; \\n                prev = p[j];\\n                c++;\\n                j++;\\n            }\\n            if(c<cap && b[i]!=prev) ans = b[i];\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2259176,
                "title": "easy-c-solution-using-queue-and-set-optimised-without-queue",
                "content": "**Approach:**\\nWe put the people in the queue based on their arrival times and also put the pasenger timings in the set so that we donot clash with timings. Now their can be two cases:\\nCase1: when the bus goes by full capcity\\nIn this case we need to know the person who boarded the bus at last and assign time 1 less than that person if possible. To fulfill this whenever we see make a person board a bus we update the answer such that we assign a number such that it is 1 less than this person timings if possible.\\nCase2: bus goes half filled\\nIn this case we need to board the bus when it is departuring.\\n```\\nclass Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& buses, vector<int>& passengers, int capacity) {\\n        queue<int> q;\\n        sort(buses.begin(),buses.end());\\n        sort(passengers.begin(),passengers.end());\\n        int n=buses.size();\\n        int m=passengers.size();\\n        set<int> st;\\n        for(auto p:passengers)\\n        {\\n            q.push(p);\\n            st.insert(p);\\n        }\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int currbus=buses[i]; // curr bus depature time.\\n            int count=0; //number of people in curr bus\\n            int x;\\n            //CASE1\\n            while(!q.empty() && count<capacity && q.front()<=currbus)\\n            {\\n                x=q.front();\\n                q.pop();\\n                if(st.find(x-1)==st.end()) //checking if person timing-1 doesnt exist and update the answer.\\n                    ans=x-1; \\n                count++;\\n            }\\n            //CASE2\\n            if(count<capacity)\\n            {\\n                while(st.find(currbus)!=st.end()) //starting from dept time find a time which does not exist int the set already.\\n                {\\n                    currbus--;\\n                }\\n                ans=max(ans,currbus);\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Optimised Solution without Queue**\\nCourtesy: [@ryankert](https://leetcode.com/ryankert/) for this optimised solution\\n```\\nclass Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& buses, vector<int>& passengers, int capacity) {\\n        int q = 0;\\n        sort(buses.begin(),buses.end());\\n        sort(passengers.begin(),passengers.end());\\n        int n=buses.size();\\n        int m=passengers.size();\\n        set<int> st;\\n        for(auto p:passengers)\\n        {\\n            st.insert(p);\\n        }\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int currbus=buses[i]; // curr bus depature time.\\n            int count=0; //number of people in curr bus\\n            int x;\\n            //CASE1\\n            while(q < passengers.size() && count<capacity && passengers[q]<=currbus)\\n            {\\n                x=passengers[q];\\n                q++;\\n                if(st.find(x-1)==st.end()) //checking if person timing-1 doesnt exist and update the answer.\\n                    ans=x-1; \\n                count++;\\n            }\\n            //CASE2\\n            if(count<capacity)\\n            {\\n                while(st.find(currbus)!=st.end()) //starting from dept time find a time which does not exist int the set already.\\n                {\\n                    currbus--;\\n                }\\n                ans=max(ans,currbus);\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Queue",
                    "Sorting",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& buses, vector<int>& passengers, int capacity) {\\n        queue<int> q;\\n        sort(buses.begin(),buses.end());\\n        sort(passengers.begin(),passengers.end());\\n        int n=buses.size();\\n        int m=passengers.size();\\n        set<int> st;\\n        for(auto p:passengers)\\n        {\\n            q.push(p);\\n            st.insert(p);\\n        }\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int currbus=buses[i]; // curr bus depature time.\\n            int count=0; //number of people in curr bus\\n            int x;\\n            //CASE1\\n            while(!q.empty() && count<capacity && q.front()<=currbus)\\n            {\\n                x=q.front();\\n                q.pop();\\n                if(st.find(x-1)==st.end()) //checking if person timing-1 doesnt exist and update the answer.\\n                    ans=x-1; \\n                count++;\\n            }\\n            //CASE2\\n            if(count<capacity)\\n            {\\n                while(st.find(currbus)!=st.end()) //starting from dept time find a time which does not exist int the set already.\\n                {\\n                    currbus--;\\n                }\\n                ans=max(ans,currbus);\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& buses, vector<int>& passengers, int capacity) {\\n        int q = 0;\\n        sort(buses.begin(),buses.end());\\n        sort(passengers.begin(),passengers.end());\\n        int n=buses.size();\\n        int m=passengers.size();\\n        set<int> st;\\n        for(auto p:passengers)\\n        {\\n            st.insert(p);\\n        }\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int currbus=buses[i]; // curr bus depature time.\\n            int count=0; //number of people in curr bus\\n            int x;\\n            //CASE1\\n            while(q < passengers.size() && count<capacity && passengers[q]<=currbus)\\n            {\\n                x=passengers[q];\\n                q++;\\n                if(st.find(x-1)==st.end()) //checking if person timing-1 doesnt exist and update the answer.\\n                    ans=x-1; \\n                count++;\\n            }\\n            //CASE2\\n            if(count<capacity)\\n            {\\n                while(st.find(currbus)!=st.end()) //starting from dept time find a time which does not exist int the set already.\\n                {\\n                    currbus--;\\n                }\\n                ans=max(ans,currbus);\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2259320,
                "title": "greedy-solution-java",
                "content": "```\\npublic int latestTimeCatchTheBus(int[] buses, int[] passengers, int capacity) {\\n        Arrays.sort(buses);\\n        Arrays.sort(passengers);\\n        Set<Integer> set = new HashSet<>();\\n        int ans=0,j=0;\\n        for(int i=0;i<buses.length;i++){\\n            int c = 0;\\n            while(j<passengers.length && c<capacity && passengers[j]<=buses[i]){\\n                if(!set.contains(passengers[j]-1)){\\n                    ans=passengers[j]-1;\\n                }\\n                set.add(passengers[j]);\\n                j++; c++;\\n            }\\n            if(c<capacity && !set.contains(buses[i])){\\n                ans = buses[i];\\n            }\\n        }\\n        return ans;\\n    }\\n```\\n\\n**Space Optimised Solution** (credit :- [@abdulazizms](https://leetcode.com/abdulazizms/))\\n```\\npublic int latestTimeCatchTheBus(int[] buses, int[] passengers, int capacity) {\\n    Arrays.sort(passengers);\\n    Arrays.sort(buses);\\n    if(passengers[0] > buses[buses.length - 1]) return buses[buses.length - 1];\\n    int result = passengers[0] - 1;\\n    int i = 0, j = 0;\\n    while(i < buses.length){\\n        int occupiedSeats = 0;\\n        while(occupiedSeats < capacity && j < passengers.length && passengers[j] <= buses[i]){\\n            if(j > 0 && passengers[j] - passengers[j-1] != 1){\\n                result = passengers[j] - 1;\\n            }\\n            j++;\\n            occupiedSeats++;\\n        }\\n        if(j > 0 && occupiedSeats < capacity && buses[i] != passengers[j-1]){\\n            result = buses[i];\\n        }\\n        i++;\\n    }\\n    return result;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int latestTimeCatchTheBus(int[] buses, int[] passengers, int capacity) {\\n        Arrays.sort(buses);\\n        Arrays.sort(passengers);\\n        Set<Integer> set = new HashSet<>();\\n        int ans=0,j=0;\\n        for(int i=0;i<buses.length;i++){\\n            int c = 0;\\n            while(j<passengers.length && c<capacity && passengers[j]<=buses[i]){\\n                if(!set.contains(passengers[j]-1)){\\n                    ans=passengers[j]-1;\\n                }\\n                set.add(passengers[j]);\\n                j++; c++;\\n            }\\n            if(c<capacity && !set.contains(buses[i])){\\n                ans = buses[i];\\n            }\\n        }\\n        return ans;\\n    }\\n```\n```\\npublic int latestTimeCatchTheBus(int[] buses, int[] passengers, int capacity) {\\n    Arrays.sort(passengers);\\n    Arrays.sort(buses);\\n    if(passengers[0] > buses[buses.length - 1]) return buses[buses.length - 1];\\n    int result = passengers[0] - 1;\\n    int i = 0, j = 0;\\n    while(i < buses.length){\\n        int occupiedSeats = 0;\\n        while(occupiedSeats < capacity && j < passengers.length && passengers[j] <= buses[i]){\\n            if(j > 0 && passengers[j] - passengers[j-1] != 1){\\n                result = passengers[j] - 1;\\n            }\\n            j++;\\n            occupiedSeats++;\\n        }\\n        if(j > 0 && occupiedSeats < capacity && buses[i] != passengers[j-1]){\\n            result = buses[i];\\n        }\\n        i++;\\n    }\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2262636,
                "title": "two-pointers",
                "content": "This problem is difficult to implement due to many edge cases. \\n\\nTo make it simpler, we first fill all buses except the last one. Then, we put passengers into the last bus, tracking the last passenger and remaining capacity.\\n\\nWe then search for the `latest` time starting from either:\\n- the last bus departure time if we have a capacity there;\\n- or the arrival of the last passenger.\\n\\nWe then iterate arrival times backward from the last passenger, looking for a gap we can take.\\n\\n**C++**\\n```cpp\\nint latestTimeCatchTheBus(vector<int>& b, vector<int>& p, int cap) {\\n    sort(begin(b), end(b));\\n    sort(begin(p), end(p));\\n    int i = 0, j = 0, start = 0;\\n    while (i < b.size() - 1 && j < p.size())\\n        if(p[j] <= b[i] && j - start < cap)\\n            ++j;\\n        else {\\n            ++i;\\n            start = j;\\n        }\\n    while (j < p.size() && p[j] <= b.back() && cap) {\\n        ++j;\\n        --cap;\\n    }\\n    int latest = cap ? b.back() : p[j - 1];\\n \\xA0 \\xA0for (j = j - 1; j >= 0 && latest == p[j]; --j)\\n        latest = p[j] - 1;\\n    return latest;\\n}\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint latestTimeCatchTheBus(vector<int>& b, vector<int>& p, int cap) {\\n    sort(begin(b), end(b));\\n    sort(begin(p), end(p));\\n    int i = 0, j = 0, start = 0;\\n    while (i < b.size() - 1 && j < p.size())\\n        if(p[j] <= b[i] && j - start < cap)\\n            ++j;\\n        else {\\n            ++i;\\n            start = j;\\n        }\\n    while (j < p.size() && p[j] <= b.back() && cap) {\\n        ++j;\\n        --cap;\\n    }\\n    int latest = cap ? b.back() : p[j - 1];\\n \\xA0 \\xA0for (j = j - 1; j >= 0 && latest == p[j]; --j)\\n        latest = p[j] - 1;\\n    return latest;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2262591,
                "title": "easiest-java-solution-with-comment-explanation",
                "content": "```\\nclass Solution {\\n    public int latestTimeCatchTheBus(int[] buses, int[] passengers, int capacity) {\\n//         sort both the arrays \\n        Arrays.sort(buses);\\n        Arrays.sort(passengers);\\n        \\n        int last = 0; // keep track of the last passenger boarded on the bus;\\n        int j = 0; // a pointer to iterate on the passenger array\\n        HashSet<Integer> set = new HashSet<>(); // to keep track of all passengers boarded till on the bus\\n        \\n        for(int i = 0 ; i < buses.length ; i++){\\n            int count = 0; // keep a count of passengers on each bus, so that (count > capacity) never happen\\n            \\n            // keep boarding passengers on the current bus till there is capacity left on the bus and arrival time of passenger <= departure time of the bus\\n            while(j < passengers.length && count < capacity && passengers[j] <= buses[i]){\\n                last = passengers[j]; // update the last passenger\\n                set.add(passengers[j++]); // add the passenger in the set and increment the pointer\\n                    count++; // increment the count\\n            }\\n            \\n            // if we are on the last bus and the arrival time of last passenger boarded is less than the departure time of the last bus and still there is some space left so simply return the departure time of that bus as we can afford to reach at the bus station at that time and still able to get the bus because there is still some space and no valid passengers left to on board.\\n            if(i == buses.length - 1 && count < capacity && last < buses[i]){\\n                return buses[buses.length - 1];\\n            }\\n        }\\n        // another corner case, if there is no passenger then also we can  afford to reach the station by buses[buses.length - 1] time;\\n        if(set.size() == 0) return buses[buses.length - 1];\\n        \\n        // now the last variable tells us the arrival time of the last passenger who boarded so we must have to reach before him/her so that we can catch the bus, but also our arrival time must be unique so we will perform this operation.\\n        while(set.contains(last)) last--;\\n        \\n        return last; // return answer :)\\n    }\\n}\\n```\\n\\n**PLEASE UPVOTE IF FOUND HELPFUL :)**",
                "solutionTags": [
                    "Java",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    public int latestTimeCatchTheBus(int[] buses, int[] passengers, int capacity) {\\n//         sort both the arrays \\n        Arrays.sort(buses);\\n        Arrays.sort(passengers);\\n        \\n        int last = 0; // keep track of the last passenger boarded on the bus;\\n        int j = 0; // a pointer to iterate on the passenger array\\n        HashSet<Integer> set = new HashSet<>(); // to keep track of all passengers boarded till on the bus\\n        \\n        for(int i = 0 ; i < buses.length ; i++){\\n            int count = 0; // keep a count of passengers on each bus, so that (count > capacity) never happen\\n            \\n            // keep boarding passengers on the current bus till there is capacity left on the bus and arrival time of passenger <= departure time of the bus\\n            while(j < passengers.length && count < capacity && passengers[j] <= buses[i]){\\n                last = passengers[j]; // update the last passenger\\n                set.add(passengers[j++]); // add the passenger in the set and increment the pointer\\n                    count++; // increment the count\\n            }\\n            \\n            // if we are on the last bus and the arrival time of last passenger boarded is less than the departure time of the last bus and still there is some space left so simply return the departure time of that bus as we can afford to reach at the bus station at that time and still able to get the bus because there is still some space and no valid passengers left to on board.\\n            if(i == buses.length - 1 && count < capacity && last < buses[i]){\\n                return buses[buses.length - 1];\\n            }\\n        }\\n        // another corner case, if there is no passenger then also we can  afford to reach the station by buses[buses.length - 1] time;\\n        if(set.size() == 0) return buses[buses.length - 1];\\n        \\n        // now the last variable tells us the arrival time of the last passenger who boarded so we must have to reach before him/her so that we can catch the bus, but also our arrival time must be unique so we will perform this operation.\\n        while(set.contains(last)) last--;\\n        \\n        return last; // return answer :)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2259175,
                "title": "simple-two-pointer-traversal-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& b, vector<int>& p, int c) {\\n        int n = b.size();\\n        int m = p.size();\\n        sort(b.begin(),b.end());\\n        sort(p.begin(), p.end());\\n        unordered_map<int,int> mpp;\\n        for(auto it: p){\\n            mpp[it]++;\\n        }\\n        int i = 0;\\n        int j = 0;\\n        int count = 0;\\n        int lastPassenger = -1;\\n        while(i<n){\\n            count = 0;\\n            while(j<m and p[j]<=b[i] and count<c){\\n                lastPassenger = p[j];\\n                count++;\\n                j++;\\n            }\\n            i++;\\n        }\\n        int val = 0;\\n        if(lastPassenger==-1){\\n            val = b[n-1];\\n        }\\n        else if(count==c){\\n            val = lastPassenger;\\n        }\\n        else{\\n            val = b[n-1];\\n        }\\n        while(val>=0){\\n            if(mpp.find(val)==mpp.end()){\\n                return val;\\n            }\\n            val--;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& b, vector<int>& p, int c) {\\n        int n = b.size();\\n        int m = p.size();\\n        sort(b.begin(),b.end());\\n        sort(p.begin(), p.end());\\n        unordered_map<int,int> mpp;\\n        for(auto it: p){\\n            mpp[it]++;\\n        }\\n        int i = 0;\\n        int j = 0;\\n        int count = 0;\\n        int lastPassenger = -1;\\n        while(i<n){\\n            count = 0;\\n            while(j<m and p[j]<=b[i] and count<c){\\n                lastPassenger = p[j];\\n                count++;\\n                j++;\\n            }\\n            i++;\\n        }\\n        int val = 0;\\n        if(lastPassenger==-1){\\n            val = b[n-1];\\n        }\\n        else if(count==c){\\n            val = lastPassenger;\\n        }\\n        else{\\n            val = b[n-1];\\n        }\\n        while(val>=0){\\n            if(mpp.find(val)==mpp.end()){\\n                return val;\\n            }\\n            val--;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2259409,
                "title": "wasted-15-minutes-for-understanding-this-question",
                "content": "Wasted 15 minutes for understanding this question.\\n\\n**BUT** Somehow i solved this problem......\\n\\n```\\nclass Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& buses, vector<int>& passengers, int capacity) {\\n        sort(buses.begin(),buses.end());\\n        sort(passengers.begin(),passengers.end());\\n        int i=0,j=0,n=buses.size(),m=passengers.size();\\n        while(i<n){\\n            int k=0;\\n            while(j<m && k<capacity && buses[i]>=passengers[j])\\n            {\\n                k++;\\n                if(i==n-1&&k==capacity){\\n                    while(find (passengers.begin(),passengers.end(), passengers[j]-1)!=passengers.end())\\n                    {\\n                        passengers[j]--;\\n                    }\\n                    return passengers[j]-1;\\n                }\\n                j++;\\n            }\\n            i++;\\n        }\\n        while(find (passengers.begin(),passengers.end(), buses[n-1])!=passengers.end())         \\n        {\\n            buses[n-1]--;\\n        }\\n        return buses[n-1];\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& buses, vector<int>& passengers, int capacity) {\\n        sort(buses.begin(),buses.end());\\n        sort(passengers.begin(),passengers.end());\\n        int i=0,j=0,n=buses.size(),m=passengers.size();\\n        while(i<n){\\n            int k=0;\\n            while(j<m && k<capacity && buses[i]>=passengers[j])\\n            {\\n                k++;\\n                if(i==n-1&&k==capacity){\\n                    while(find (passengers.begin(),passengers.end(), passengers[j]-1)!=passengers.end())\\n                    {\\n                        passengers[j]--;\\n                    }\\n                    return passengers[j]-1;\\n                }\\n                j++;\\n            }\\n            i++;\\n        }\\n        while(find (passengers.begin(),passengers.end(), buses[n-1])!=passengers.end())         \\n        {\\n            buses[n-1]--;\\n        }\\n        return buses[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2260432,
                "title": "two-pointer-easy-solution-faster-than-100-00",
                "content": "**Runtime: 223 ms, faster than 100.00% of C++ online submissions for The Latest Time to Catch a Bus.**\\n**Memory Usage: 66.3 MB, less than 50.00% of C++ online submissions for The Latest Time to Catch a Bus.**\\n\\n```\\nclass Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& buses, vector<int>& passengers, int capacity) {\\n        \\n        sort(begin(buses),end(buses));\\n        sort(begin(passengers),end(passengers));\\n        int bus = buses.size() , pass = passengers.size() , j=0 ,ans=0,prev=0;\\n        for(int i=0;i<bus;i++){\\n            int count=0;\\n            while(j< pass && passengers[j]<=buses[i] && count<capacity)\\n            {\\n                if(passengers[j]-prev > 1) ans = passengers[j]-1;\\n                prev=passengers[j] , j++ ,count++;\\n            }\\n            if(count<capacity && buses[i]-prev>=1) ans=buses[i];\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& buses, vector<int>& passengers, int capacity) {\\n        \\n        sort(begin(buses),end(buses));\\n        sort(begin(passengers),end(passengers));\\n        int bus = buses.size() , pass = passengers.size() , j=0 ,ans=0,prev=0;\\n        for(int i=0;i<bus;i++){\\n            int count=0;\\n            while(j< pass && passengers[j]<=buses[i] && count<capacity)\\n            {\\n                if(passengers[j]-prev > 1) ans = passengers[j]-1;\\n                prev=passengers[j] , j++ ,count++;\\n            }\\n            if(count<capacity && buses[i]-prev>=1) ans=buses[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2259467,
                "title": "c-easy-optimized",
                "content": "```\\nclass Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& buses, vector<int>& passengers, int capacity) {\\n        sort(buses.begin() , buses.end());\\n        vector<int> pass = passengers;\\n        sort(pass.begin() , pass.end());\\n        \\n        vector<int> a; int j=0;\\n        \\n        for(int i=0 ; i<buses.size()-1 ; i++)\\n        {\\n            int count=0;\\n            while(j<pass.size() && count<capacity && pass[j]<=buses[i]) \\n            {\\n                a.push_back(pass[j]);\\n                count++;\\n                j++;\\n            }\\n        }\\n        \\n        int count=0;\\n        \\n        while(j<pass.size() && count<capacity && pass[j]<=buses[buses.size()-1])\\n        {\\n            a.push_back(pass[j]);\\n            count++;\\n            j++;\\n            \\n        }\\n        \\n        if(count == capacity)\\n        {\\n            int m = a.size()-1;\\n            \\n            while(m>0)\\n            {\\n                if(a[m] == a[m-1]+1) m--;\\n                else return a[m]-1;\\n            }\\n            return a[0]-1;\\n        }\\n        else{\\n            int m = a.size()-1;\\n            int last = buses[buses.size()-1];\\n            \\n            while(m>=0){\\n                if(a[m] == last) last--, m-- ;\\n                else return last;\\n            }\\n            return last;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& buses, vector<int>& passengers, int capacity) {\\n        sort(buses.begin() , buses.end());\\n        vector<int> pass = passengers;\\n        sort(pass.begin() , pass.end());\\n        \\n        vector<int> a; int j=0;\\n        \\n        for(int i=0 ; i<buses.size()-1 ; i++)\\n        {\\n            int count=0;\\n            while(j<pass.size() && count<capacity && pass[j]<=buses[i]) \\n            {\\n                a.push_back(pass[j]);\\n                count++;\\n                j++;\\n            }\\n        }\\n        \\n        int count=0;\\n        \\n        while(j<pass.size() && count<capacity && pass[j]<=buses[buses.size()-1])\\n        {\\n            a.push_back(pass[j]);\\n            count++;\\n            j++;\\n            \\n        }\\n        \\n        if(count == capacity)\\n        {\\n            int m = a.size()-1;\\n            \\n            while(m>0)\\n            {\\n                if(a[m] == a[m-1]+1) m--;\\n                else return a[m]-1;\\n            }\\n            return a[0]-1;\\n        }\\n        else{\\n            int m = a.size()-1;\\n            int last = buses[buses.size()-1];\\n            \\n            while(m>=0){\\n                if(a[m] == last) last--, m-- ;\\n                else return last;\\n            }\\n            return last;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2259307,
                "title": "python-3-2-pointers",
                "content": "Wasted a lot of time trying to understand the question \\uD83D\\uDE13. Keep adding passenger to the earliest bus until capacity limit reached or bus needs to depart. If one arrives 1 minute earlier than last added (given that the time slot is not occupied by an other passenger), he can get on the bus. If the last one added, his arrival is less than bus departure, check capacity, and if not full, we can arrive at the bus departure time.\\n\\n```\\nclass Solution:\\n    def latestTimeCatchTheBus(self, buses: List[int], passengers: List[int], capacity: int) -> int:\\n        buses.sort()\\n        passengers.sort()\\n        m = len(buses)\\n        n = len(passengers)\\n        \\n        ans = 1\\n        c = 0\\n        j = 0\\n        for i in range(m):\\n            while j < n and c < capacity and passengers[j] <= buses[i]:\\n                if passengers[j] - 1 != passengers[j - 1]:\\n                    ans = passengers[j] - 1\\n                c += 1\\n                j += 1\\n            if c < capacity and (j == 0 or passengers[j - 1] < buses[i]):\\n                ans = buses[i]\\n            c = 0\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def latestTimeCatchTheBus(self, buses: List[int], passengers: List[int], capacity: int) -> int:\\n        buses.sort()\\n        passengers.sort()\\n        m = len(buses)\\n        n = len(passengers)\\n        \\n        ans = 1\\n        c = 0\\n        j = 0\\n        for i in range(m):\\n            while j < n and c < capacity and passengers[j] <= buses[i]:\\n                if passengers[j] - 1 != passengers[j - 1]:\\n                    ans = passengers[j] - 1\\n                c += 1\\n                j += 1\\n            if c < capacity and (j == 0 or passengers[j - 1] < buses[i]):\\n                ans = buses[i]\\n            c = 0\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2259765,
                "title": "c-binary-search",
                "content": "# **Approach**\\nIn binary search most imp part is to find:\\n1. * decision making condition\\n2. * range of search\\n\\n# ***For a Range of Search***\\n**Min Range** value will be **earliest** time we can arrive at bus station which will be 1 minute (not 0 as we cant arrive in 0 min :)  )\\n**Max Range** will be **last** arrival time to catch last bus at bus station , **Here comes 2 scenario**  \\n (as we can get on a bus that will depart at x minutes if we arrive at y minutes where **y <= x**)\\n1. so if bus is **not full** we can arrive at last bus depart time .\\n2. but if last bus is already **full** then we have to arrive before **last person arrival time** . \\n\\n# ***For decision  making function***\\n***(note:- we cannot arrive at the same time as another passenger.)***\\n\\nThe idea is to **count no of slots available** for future arrivals of us.\\n\\nIf we found some available future slots  from current arrival time then we move to higher arrival time i,e **(s=mid+1)** condition and store latest arrival time in an answer variable.\\nelse no future slots are available then move to lower arrival time  i,e **(e=mid-1)**\\n\\nfirst we will mark all the **occupied time** slots by other passengers in a map \\n\\n**Now let us assume** we are finding decision for  a variable **currentArrival** which is our current mid value in binary search \\n\\nAs maps are already in ascending order we will count no. of slots after **currentArrival** are already booked by other passengers (using map).\\n if this count match with the total available future slots **(Max Range - cuurentArrival +1)**  then it means all future time slots are already booked. so **return false** as indication to move in **lower range i,e (e=mid-1)**\\nelse **return true i,e (s=mid+1)**     \\n\\n\\n```\\nclass Solution {\\npublic:\\n    bool check(map<int,int> &mp,int mid,int mx,int mp_size)\\n    {\\n        int id=mp_size;\\n            for(auto x=mp.begin();x!=mp.end();x++)\\n            {\\n                if(x->first>=mid)\\n                    break;\\n                id--;\\n            }\\n        if(mx-mid+1==id)\\n            return false;\\n        return true;\\n    }\\n    int latestTimeCatchTheBus(vector<int>& b, vector<int>& p, int cap) {\\n           sort(b.begin(), b.end());\\n           sort(p.begin(), p.end());\\n            int s,e,ans,c=0,j=0;\\n        ans=s=e=1;\\n        for(int i=0;i<b.size();i++)\\n        {\\n            while(j<p.size()&&c<cap&&p[j]<=b[i])\\n            {\\n                j++;\\n                c++;\\n            }\\n            if(c<cap)\\n                e=b[i];\\n            else if(j>0)\\n                e=p[j-1]-1;\\n            c=0;\\n        }\\n        j=0;\\n        map<int,int> mp;\\n        while(j<p.size()&&p[j]<=e)\\n        {\\n            mp[p[j]]++;\\n        j++;\\n        }\\n        int mx=e;\\n\\n        while(s<=e)\\n        {\\n            int mid=s+(e-s)/2;\\n           if(mp.find(mid)==mp.end())\\n               ans=mid;\\n            \\n            if(check(mp,mid,mx,mp.size()))\\n                s=mid+1;\\n            else\\n                e=mid-1;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**(I hope, I am able to explain you about my approach  if you liked it please upvote my post \\uD83D\\uDE04\\uD83D\\uDE04)**",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(map<int,int> &mp,int mid,int mx,int mp_size)\\n    {\\n        int id=mp_size;\\n            for(auto x=mp.begin();x!=mp.end();x++)\\n            {\\n                if(x->first>=mid)\\n                    break;\\n                id--;\\n            }\\n        if(mx-mid+1==id)\\n            return false;\\n        return true;\\n    }\\n    int latestTimeCatchTheBus(vector<int>& b, vector<int>& p, int cap) {\\n           sort(b.begin(), b.end());\\n           sort(p.begin(), p.end());\\n            int s,e,ans,c=0,j=0;\\n        ans=s=e=1;\\n        for(int i=0;i<b.size();i++)\\n        {\\n            while(j<p.size()&&c<cap&&p[j]<=b[i])\\n            {\\n                j++;\\n                c++;\\n            }\\n            if(c<cap)\\n                e=b[i];\\n            else if(j>0)\\n                e=p[j-1]-1;\\n            c=0;\\n        }\\n        j=0;\\n        map<int,int> mp;\\n        while(j<p.size()&&p[j]<=e)\\n        {\\n            mp[p[j]]++;\\n        j++;\\n        }\\n        int mx=e;\\n\\n        while(s<=e)\\n        {\\n            int mid=s+(e-s)/2;\\n           if(mp.find(mid)==mp.end())\\n               ans=mid;\\n            \\n            if(check(mp,mid,mx,mp.size()))\\n                s=mid+1;\\n            else\\n                e=mid-1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2259235,
                "title": "greedy-o-nlogn-check-for-each-batch",
                "content": "Just check for every batch at what maximum time we can come just take care for the last timing of every batch\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int latestTimeCatchTheBus(vector<int>& b, vector<int>& p, int c) {\\n        sort(b.begin(), b.end());\\n        sort(p.rbegin(), p.rend());\\n        \\n        vector<vector<int>> batch;\\n        for(int i = 0; i < b.size(); ++i) {\\n            batch.push_back({});\\n            for(int j = 0; j < c and !p.empty() and p.back() <= b[i]; ++j) {\\n                batch.back().push_back(p.back());\\n                p.pop_back();\\n            }\\n        }\\n        \\n        long long mx = 1, prev = 0;\\n        for(int i = 0; i < batch.size(); ++i) {\\n            for(int j = 0; j < batch[i].size(); ++j) {\\n                if(batch[i][j] - prev > 1)\\n                    mx = batch[i][j] - 1;\\n                prev = batch[i][j];\\n            }\\n            if(!batch[i].empty() and batch[i].size() < c and batch[i].back() != b[i]) mx = max(mx, 1LL * b[i]);\\n            if(batch[i].empty()) mx = max(mx, 1LL * b[i]);\\n        }\\n        \\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int latestTimeCatchTheBus(vector<int>& b, vector<int>& p, int c) {\\n        sort(b.begin(), b.end());\\n        sort(p.rbegin(), p.rend());\\n        \\n        vector<vector<int>> batch;\\n        for(int i = 0; i < b.size(); ++i) {\\n            batch.push_back({});\\n            for(int j = 0; j < c and !p.empty() and p.back() <= b[i]; ++j) {\\n                batch.back().push_back(p.back());\\n                p.pop_back();\\n            }\\n        }\\n        \\n        long long mx = 1, prev = 0;\\n        for(int i = 0; i < batch.size(); ++i) {\\n            for(int j = 0; j < batch[i].size(); ++j) {\\n                if(batch[i][j] - prev > 1)\\n                    mx = batch[i][j] - 1;\\n                prev = batch[i][j];\\n            }\\n            if(!batch[i].empty() and batch[i].size() < c and batch[i].back() != b[i]) mx = max(mx, 1LL * b[i]);\\n            if(batch[i].empty()) mx = max(mx, 1LL * b[i]);\\n        }\\n        \\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2259189,
                "title": "clean-and-concise-greedy-with-intuitive-explanation",
                "content": "##### Rationale\\n* We could imagine the time given in the `passengers` Array to be a seat. A passenger may take a seat only if it is not taken already. The problem then boils down to finding the last possible seat for our candidate. This analogy makes it easier to visualize the problem\\n* Since we would like our candidate to take the last seat, we could find the last possible seat number that they could take\\n\\t* Fit as many people as possible in every bus until you max out. We could sort the Arrays to make it easier\\n\\t* The maximum seat would either be the last seat in the last bus if it is maxed out or the bus capacity (buses[-1])\\n* Iterate backwards from the last possible seat, if it is available, allocate it\\n\\n##### Complexities\\n* Time: `O(blogb + plogp)`\\n* Space: `O(p)`\\n\\n\\n```\\nclass Solution:\\n    def latestTimeCatchTheBus(self, buses: List[int], passengers: List[int], capacity: int) -> int:\\n        buses.sort()\\n        passengers.sort()\\n        \\n        passenger = 0\\n        for bus in buses:\\n            maxed_out = False\\n            cap = capacity\\n            \\n            while passenger < len(passengers) and passengers[passenger] <= bus and cap != 0:\\n                passenger += 1\\n                cap -= 1\\n                \\n            if cap == 0:\\n                maxed_out = True\\n                \\n        if maxed_out:\\n            max_seat = passengers[passenger - 1]\\n        else:\\n            max_seat = buses[-1]\\n    \\n        booked = set(passengers)\\n        for seat in range(max_seat, 0, -1):\\n            if seat not in booked:\\n                return seat\\n```",
                "solutionTags": [
                    "Python3",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def latestTimeCatchTheBus(self, buses: List[int], passengers: List[int], capacity: int) -> int:\\n        buses.sort()\\n        passengers.sort()\\n        \\n        passenger = 0\\n        for bus in buses:\\n            maxed_out = False\\n            cap = capacity\\n            \\n            while passenger < len(passengers) and passengers[passenger] <= bus and cap != 0:\\n                passenger += 1\\n                cap -= 1\\n                \\n            if cap == 0:\\n                maxed_out = True\\n                \\n        if maxed_out:\\n            max_seat = passengers[passenger - 1]\\n        else:\\n            max_seat = buses[-1]\\n    \\n        booked = set(passengers)\\n        for seat in range(max_seat, 0, -1):\\n            if seat not in booked:\\n                return seat\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2259747,
                "title": "binary-search-solution-alternative",
                "content": "This solution is clearly not the most efficient one, nor the easiest to implement. But it passes the test cases and is likely different from the other solutions. So I think it\\'s worth to be shared just for the though experiment.\\n\\nI started to implement a smart linear solution but got tripped with every edge case, so I thought about the problem a different way : \\n\\nIt\\'s easy to tell if by arriving at time `t` you can catch a bus or not. Let\\'s call that `f(t)`. `f(t) = true`  means you can catch a bus if you arrive at time `t`, `f(t) = false` means you can\\'t. `f(t)` is \"monotically decreasing\" as there is a value `k` for which  `f(t <= k) = true` and `f(t > k) = false`. **The value `k` is the  answer to the problem**. This is a simple binary search. If we define `n` as the range of possible values and `p` as the number of passengers, computing `f(t)` is `O(p)` and so the binary search is `O(p log n)`.\\n\\nNow the **tricky part** is that there are values that can\\'t be solutions, which are the existing values of the passengers. This makes the binary search more tricky. The solution is to build an array of intervals that contain the possible solutions (all intervals between passengers) and run a binary search on these intervals.\\n For each interval you consider, you know that\\n* if(`f(lower_bound) == false`), the whole interval is false.\\n* if(`f(higher_bound) == true`), the whole interval is true.\\n* If neither of the cases above then the value `k` is inside the interval, that you can find with a second binary search.\\n\\nThat\\'s it. I am not sure exactly how to compute the exact complexity, I think it\\'s something like `O(p log (p + n))` with `n` being the largest interval size.\\n\\n# Here is the Java solution.\\n\\nPlease note that my binary searches are always implemented this way :\\n\\n1. Verify that f(l) = true\\n2. Verify that  f(h) = false\\n3. Keep the two conditions above as a loop invariant and look for the last `l`\\n\\nThere might be more efficient implementations that are more concise to write, but I found this way of thinking to prevent making mistakes when implementing a binary search.\\n\\n```\\n\\nimport javax.swing.tree.TreeNode;\\nimport java.util.*;\\n\\npublic class Solution {\\n\\n    private int[] buses;\\n    private int[] passengers;\\n    private int capacity;\\n    \\n    public int latestTimeCatchTheBus(int[] buses, int[] passengers, int capacity) {\\n        this.buses = buses;\\n        this.passengers = passengers;\\n        this.capacity = capacity;\\n        Arrays.sort(buses);\\n\\n        Arrays.sort(passengers);\\n\\n\\n        // The answer will never be after the last bus\\n        int maxValue = buses[buses.length-1];\\n        // You can always get the bus if you come before the first passenger or at the time of the first bus\\n        int minValue = Math.min(passengers[0]-1, buses[0]);\\n\\n        // Creating a list of intervals\\n        List<int[]> intervals = new ArrayList<>();\\n        int prev = minValue-1;\\n        for (int passenger : passengers) {\\n            if(passenger - prev <=1) {\\n                prev = passenger;\\n                continue;\\n            }\\n            intervals.add(new int[]{prev+1, passenger-1});\\n            prev = passenger;\\n        }\\n        if(maxValue > prev) intervals.add(new int[]{prev+1, maxValue});\\n\\n\\n        int l = 0;\\n        int h = intervals.size()-1;\\n\\n        // Check that the answer is not in the last interval\\n        int willGetBusIntervalH = willGetBusInterval(intervals.get(h));\\n        if(willGetBusIntervalH >= 0){\\n            if(willGetBusIntervalH > 0) return willGetBusIntervalH;\\n            else return intervals.get(h)[1];\\n        }\\n\\n        // invariant : willGetBusInterval(l) = true (i.e >= 0) && willGetBusInterval(h) = false\\n        // we are looking for the highest l\\n        while(h - l > 1){\\n            int m = (h + l) >>> 1;\\n            int result = willGetBusInterval(intervals.get(m));\\n            if(result > 0) return result;\\n            else if(result == 0) l = m;\\n            else h = m;\\n        }\\n\\n        // Still need to find the value inside l\\n        int willGetBusIntervalL = willGetBusInterval(intervals.get(l));\\n        if(willGetBusIntervalL > 0) return willGetBusIntervalL;\\n        else return intervals.get(l)[1];\\n    }\\n\\n    // Return value means :\\n    // -1 : false for the whole interval\\n    // 0 : true for the whole interval\\n    // other number : value inside interval\\n    private int willGetBusInterval(int[] interval){\\n        int l = interval[0];\\n        int h = interval[1];\\n\\n        if(!willGetBus(l)) return -1;\\n        if(willGetBus(h)) return 0;\\n\\n        // invariant: f(l) = true && f(h) = false\\n        // we are looking for the highest l\\n        while(h - l > 1){\\n            int m = (h + l) >>> 1;\\n            if(willGetBus(m)) l = m;\\n            else h = m;\\n        }\\n\\n        return l;\\n    }\\n    private boolean willGetBus(int value){\\n        int[] passengers = insertTimeInsidePassengersArray(value);\\n\\n        int index = 0;\\n        for (int bus : buses) {\\n            int seatsTaken = 0;\\n            while(index < passengers.length && seatsTaken < capacity){\\n                if(passengers[index] <= bus ){\\n                    if(passengers[index] == value) return true;\\n                    index++;\\n                    seatsTaken++;\\n                }\\n                else break;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    // Similar to the insertion part of an insertion sort\\n    private int[] insertTimeInsidePassengersArray(int time){\\n        int[] result = Arrays.copyOf(this.passengers, this.passengers.length +1);\\n        int i = result.length -2;\\n        for(; i >= 0 && time < result[i]; i--){\\n            result[i+1] = result[i];\\n        }\\n        result[i+1] = time;\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\n\\nimport javax.swing.tree.TreeNode;\\nimport java.util.*;\\n\\npublic class Solution {\\n\\n    private int[] buses;\\n    private int[] passengers;\\n    private int capacity;\\n    \\n    public int latestTimeCatchTheBus(int[] buses, int[] passengers, int capacity) {\\n        this.buses = buses;\\n        this.passengers = passengers;\\n        this.capacity = capacity;\\n        Arrays.sort(buses);\\n\\n        Arrays.sort(passengers);\\n\\n\\n        // The answer will never be after the last bus\\n        int maxValue = buses[buses.length-1];\\n        // You can always get the bus if you come before the first passenger or at the time of the first bus\\n        int minValue = Math.min(passengers[0]-1, buses[0]);\\n\\n        // Creating a list of intervals\\n        List<int[]> intervals = new ArrayList<>();\\n        int prev = minValue-1;\\n        for (int passenger : passengers) {\\n            if(passenger - prev <=1) {\\n                prev = passenger;\\n                continue;\\n            }\\n            intervals.add(new int[]{prev+1, passenger-1});\\n            prev = passenger;\\n        }\\n        if(maxValue > prev) intervals.add(new int[]{prev+1, maxValue});\\n\\n\\n        int l = 0;\\n        int h = intervals.size()-1;\\n\\n        // Check that the answer is not in the last interval\\n        int willGetBusIntervalH = willGetBusInterval(intervals.get(h));\\n        if(willGetBusIntervalH >= 0){\\n            if(willGetBusIntervalH > 0) return willGetBusIntervalH;\\n            else return intervals.get(h)[1];\\n        }\\n\\n        // invariant : willGetBusInterval(l) = true (i.e >= 0) && willGetBusInterval(h) = false\\n        // we are looking for the highest l\\n        while(h - l > 1){\\n            int m = (h + l) >>> 1;\\n            int result = willGetBusInterval(intervals.get(m));\\n            if(result > 0) return result;\\n            else if(result == 0) l = m;\\n            else h = m;\\n        }\\n\\n        // Still need to find the value inside l\\n        int willGetBusIntervalL = willGetBusInterval(intervals.get(l));\\n        if(willGetBusIntervalL > 0) return willGetBusIntervalL;\\n        else return intervals.get(l)[1];\\n    }\\n\\n    // Return value means :\\n    // -1 : false for the whole interval\\n    // 0 : true for the whole interval\\n    // other number : value inside interval\\n    private int willGetBusInterval(int[] interval){\\n        int l = interval[0];\\n        int h = interval[1];\\n\\n        if(!willGetBus(l)) return -1;\\n        if(willGetBus(h)) return 0;\\n\\n        // invariant: f(l) = true && f(h) = false\\n        // we are looking for the highest l\\n        while(h - l > 1){\\n            int m = (h + l) >>> 1;\\n            if(willGetBus(m)) l = m;\\n            else h = m;\\n        }\\n\\n        return l;\\n    }\\n    private boolean willGetBus(int value){\\n        int[] passengers = insertTimeInsidePassengersArray(value);\\n\\n        int index = 0;\\n        for (int bus : buses) {\\n            int seatsTaken = 0;\\n            while(index < passengers.length && seatsTaken < capacity){\\n                if(passengers[index] <= bus ){\\n                    if(passengers[index] == value) return true;\\n                    index++;\\n                    seatsTaken++;\\n                }\\n                else break;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    // Similar to the insertion part of an insertion sort\\n    private int[] insertTimeInsidePassengersArray(int time){\\n        int[] result = Arrays.copyOf(this.passengers, this.passengers.length +1);\\n        int i = result.length -2;\\n        for(; i >= 0 && time < result[i]; i--){\\n            result[i+1] = result[i];\\n        }\\n        result[i+1] = time;\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2259243,
                "title": "c-catch-the-last-bus",
                "content": "```\\nclass Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& buses, vector<int>& passengers, int capacity) {\\n        sort(buses.begin(), buses.end());\\n        sort(passengers.begin(), passengers.end());\\n        int n = buses.size(), m = passengers.size();\\n\\n        int res = 0;\\n        for (int i = 0, j = 0; i < n; ++i) {\\n            int cnt = 0;\\n            while (j < m && passengers[j] <= buses[i] && cnt < capacity) {\\n                ++cnt;\\n                ++j;\\n            }\\n            if (i == n - 1) { // the last bus\\n                if (cnt < capacity) { // still have seats\\n                    int t = buses[i]; // can be as late as the bus arrive time\\n                    for (int k = j - 1; k >= 0 && passengers[k] == t; --k, --t);\\n                    res = max(res, t);\\n                } else { // full of passegers\\n                    int t = passengers[j - 1] - 1; // should arrive earlier than last passenger aboard\\n                    for (int k = j - 2; k >= 0 && passengers[k] == t; --k, --t);\\n                    res = max(res, t);\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& buses, vector<int>& passengers, int capacity) {\\n        sort(buses.begin(), buses.end());\\n        sort(passengers.begin(), passengers.end());\\n        int n = buses.size(), m = passengers.size();\\n\\n        int res = 0;\\n        for (int i = 0, j = 0; i < n; ++i) {\\n            int cnt = 0;\\n            while (j < m && passengers[j] <= buses[i] && cnt < capacity) {\\n                ++cnt;\\n                ++j;\\n            }\\n            if (i == n - 1) { // the last bus\\n                if (cnt < capacity) { // still have seats\\n                    int t = buses[i]; // can be as late as the bus arrive time\\n                    for (int k = j - 1; k >= 0 && passengers[k] == t; --k, --t);\\n                    res = max(res, t);\\n                } else { // full of passegers\\n                    int t = passengers[j - 1] - 1; // should arrive earlier than last passenger aboard\\n                    for (int k = j - 2; k >= 0 && passengers[k] == t; --k, --t);\\n                    res = max(res, t);\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2277506,
                "title": "easy-to-understand-with-comments-c-solution-o-nlogn",
                "content": "```\\nclass Solution {\\npublic:\\n    /*\\n    TC: O(NLog(N))  BECAUSE OF SORTING\\n    SC: O(1)\\n    \\n    1) THE INTUITION IS TO ASSIGN BUSES TO PASSENGERS (IN SORTED ORDER SINCE A PASSENGER WHO ARRIVES FIRST GETS ON THE EARLIEST BUS POSSIBLE FIRST) \\n    \\n    2) TAKE TWO POINTERS I AND J USED FOR ITERATING THROUGH THE BUSES ARRAY AND PASSENGERS ARRAY RESPECTIVELY\\n    \\n    3) WHILE THE BUS IS UNDER CAPACITY KEEP ASSIGNING THE I\\'TH BUS TO A J\\'TH PASSENGER TILL THE DEPARTURE TIME OF THE I\\'TH BUS IS GREATER THAN OR EQUAL TO THE ARRIVAL TIME OF THE J\\'TH PASSENGER (buses[i]>= passengers[j] && count< capacity)\\n    \\n    4) KEEP TRACK OF THE DIFFERENCE BETWEEN CONSECUTIVE PASSENGERS TO KNOW POSSIBLE EMPTY SLOTS\\n    \\n    5) IF THERE IS NO MORE PASSENGER LEFT TO ASSIGN TO BUS, CHECK IF IT IS NOT AT FULL CAPACITY, AND IF WE DONT HAVE A PASSENGER ARRIVING AT THE SAME TIME AS THE DEPARTURE OF THE BUS, UPDATE THE ANSWER TO THAT\\n    \\n    6) WHILE FILLING ALL THE BUSES IF WE ASSIGNED ALL THE PASSENGERS AND STILL THERE ARE BUSES LEFT, THEN THE ANSWER WOULD BE THE DEPARTURE TIME OF THE LAST BUS\\n    \\n    */\\n    \\n    int latestTimeCatchTheBus(vector<int>& buses, vector<int>& passengers, int capacity) {\\n        \\n        //SORT THE BUSES AND PASSENGERS ARRAY, SO THAT WE CAN ASSIGN BUSSES TO PASSENGERS IN THE ORDER OF THEIR ARRIVAL\\n        sort(buses.begin(),buses.end());\\n        sort(passengers.begin(),passengers.end());\\n        \\n        int i=0; // POINTER FOR KEEPING TRACK OF THE I\\'TH BUS \\n        int j=0; // POINTER FOR KEEPING TRACK OF THE J\\'TH BUS\\n        int m=buses.size();\\n        int n= passengers.size();\\n        \\n        int ans= min(passengers[0]-1, buses[m-1]);  //INITIALISE THE ANSWER TO THE MINIMUM POSSIBLE VALUE (IF THE LAST BUS HAS A DEPT TIME LESS THAN ALL PASSENGERS, TAKE THE LAST BUS TIME,  ELSE TAKE THE FIRST PASSENGERS ARRIVAL TIME-1)\\n        \\n        \\n        while(i<m && j<n)\\n        {\\n            int count=0;   //COUNT THAT MAINTAINS THE NUMBER OF PASSENGERS IN A BUS\\n            while(j<n && buses[i]>=passengers[j] && count< capacity)    // WHILE THE I\\'TH BUS HAS A DEPARTURE TIME GREATER THAN EQUAL TO THE J\\'TH PASSENGER \\n            {\\n                if(j>0 && passengers[j]-passengers[j-1]>1) // IF THE J\\'TH AND J-1\\'TH PASSENGERS ARE NOT GETTING IN THE BUS IN CONSECUTIVE TIME UNITS(THEIR DIFF WOULB BE GREATER THAN 1, WHICH WOULD GIVE US AN ANSWER POSSIBILITY OR AN EMPTY SLOT)\\n                    \\n                    ans= passengers[j]-1; // THE MAXIMUM EMPTY SLOT\\n    \\n                count++; j++; // ASSIGN PASSENGER TO BUS AND MOVE TO THE NEXT PASSENGER \\n            }\\n            \\n            if(count < capacity) // IF A BUS IS NOT COMPLETELY FILLED\\n            {\\n                if(j>0 && passengers[j-1]!=buses[i]) // IF WE DONT HAVE A PASSENGER COMING AT THE SAME TIME AS THE I\\'TH BUS\\n                    ans=buses[i];\\n            }\\n            i++; // MOVE TO THE NEXT BUS\\n        }\\n        \\n        if(i!=m) // IF WE HAVEN\\'T REACHED AT THE LAST BUS IN THE SORTED BUSES ARRAY, THEN THE ANSWER WOULD BE THE DEPARTURE TIME OF THE LAST BUS\\n        {\\n            ans= buses[m-1];\\n        }\\n        \\n        \\n        //SINCE WE ARE MOVING IN SORTED ORDER, WE WOULD GET THE MAXIMISED ANSWER\\n        return ans; \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    /*\\n    TC: O(NLog(N))  BECAUSE OF SORTING\\n    SC: O(1)\\n    \\n    1) THE INTUITION IS TO ASSIGN BUSES TO PASSENGERS (IN SORTED ORDER SINCE A PASSENGER WHO ARRIVES FIRST GETS ON THE EARLIEST BUS POSSIBLE FIRST) \\n    \\n    2) TAKE TWO POINTERS I AND J USED FOR ITERATING THROUGH THE BUSES ARRAY AND PASSENGERS ARRAY RESPECTIVELY\\n    \\n    3) WHILE THE BUS IS UNDER CAPACITY KEEP ASSIGNING THE I\\'TH BUS TO A J\\'TH PASSENGER TILL THE DEPARTURE TIME OF THE I\\'TH BUS IS GREATER THAN OR EQUAL TO THE ARRIVAL TIME OF THE J\\'TH PASSENGER (buses[i]>= passengers[j] && count< capacity)\\n    \\n    4) KEEP TRACK OF THE DIFFERENCE BETWEEN CONSECUTIVE PASSENGERS TO KNOW POSSIBLE EMPTY SLOTS\\n    \\n    5) IF THERE IS NO MORE PASSENGER LEFT TO ASSIGN TO BUS, CHECK IF IT IS NOT AT FULL CAPACITY, AND IF WE DONT HAVE A PASSENGER ARRIVING AT THE SAME TIME AS THE DEPARTURE OF THE BUS, UPDATE THE ANSWER TO THAT\\n    \\n    6) WHILE FILLING ALL THE BUSES IF WE ASSIGNED ALL THE PASSENGERS AND STILL THERE ARE BUSES LEFT, THEN THE ANSWER WOULD BE THE DEPARTURE TIME OF THE LAST BUS\\n    \\n    */\\n    \\n    int latestTimeCatchTheBus(vector<int>& buses, vector<int>& passengers, int capacity) {\\n        \\n        //SORT THE BUSES AND PASSENGERS ARRAY, SO THAT WE CAN ASSIGN BUSSES TO PASSENGERS IN THE ORDER OF THEIR ARRIVAL\\n        sort(buses.begin(),buses.end());\\n        sort(passengers.begin(),passengers.end());\\n        \\n        int i=0; // POINTER FOR KEEPING TRACK OF THE I\\'TH BUS \\n        int j=0; // POINTER FOR KEEPING TRACK OF THE J\\'TH BUS\\n        int m=buses.size();\\n        int n= passengers.size();\\n        \\n        int ans= min(passengers[0]-1, buses[m-1]);  //INITIALISE THE ANSWER TO THE MINIMUM POSSIBLE VALUE (IF THE LAST BUS HAS A DEPT TIME LESS THAN ALL PASSENGERS, TAKE THE LAST BUS TIME,  ELSE TAKE THE FIRST PASSENGERS ARRIVAL TIME-1)\\n        \\n        \\n        while(i<m && j<n)\\n        {\\n            int count=0;   //COUNT THAT MAINTAINS THE NUMBER OF PASSENGERS IN A BUS\\n            while(j<n && buses[i]>=passengers[j] && count< capacity)    // WHILE THE I\\'TH BUS HAS A DEPARTURE TIME GREATER THAN EQUAL TO THE J\\'TH PASSENGER \\n            {\\n                if(j>0 && passengers[j]-passengers[j-1]>1) // IF THE J\\'TH AND J-1\\'TH PASSENGERS ARE NOT GETTING IN THE BUS IN CONSECUTIVE TIME UNITS(THEIR DIFF WOULB BE GREATER THAN 1, WHICH WOULD GIVE US AN ANSWER POSSIBILITY OR AN EMPTY SLOT)\\n                    \\n                    ans= passengers[j]-1; // THE MAXIMUM EMPTY SLOT\\n    \\n                count++; j++; // ASSIGN PASSENGER TO BUS AND MOVE TO THE NEXT PASSENGER \\n            }\\n            \\n            if(count < capacity) // IF A BUS IS NOT COMPLETELY FILLED\\n            {\\n                if(j>0 && passengers[j-1]!=buses[i]) // IF WE DONT HAVE A PASSENGER COMING AT THE SAME TIME AS THE I\\'TH BUS\\n                    ans=buses[i];\\n            }\\n            i++; // MOVE TO THE NEXT BUS\\n        }\\n        \\n        if(i!=m) // IF WE HAVEN\\'T REACHED AT THE LAST BUS IN THE SORTED BUSES ARRAY, THEN THE ANSWER WOULD BE THE DEPARTURE TIME OF THE LAST BUS\\n        {\\n            ans= buses[m-1];\\n        }\\n        \\n        \\n        //SINCE WE ARE MOVING IN SORTED ORDER, WE WOULD GET THE MAXIMISED ANSWER\\n        return ans; \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2259439,
                "title": "c-very-easy-greedy-approach-sorting",
                "content": "**Please UPVOTE if find Userful :)**\\n\\n*  Initially sort the buses departure time and passenger arrival\\n* Now put all passengers on buses according to capacity\\n* For last bus , check the maximum time that person can come to catch the bus\\n\\n\\n```\\n\\nint latestTimeCatchTheBus(vector<int>& buses, vector<int>& passengers, int capacity) {\\n        sort(begin(buses),end(buses));\\n        sort(begin(passengers),end(passengers));\\n        int n=buses.size(),m=passengers.size(),j=0;\\n        int result=0;\\n        for(int i=0;i<buses.size();i++){\\n            int depart=buses[i];\\n            int cnt=0;\\n            if(i==n-1){\\n                while(j<m and cnt<capacity-1 and passengers[j]<depart) cnt++,j++; // passenger with arrival=depart can\\'t onboard\\n                if(j==m) return depart;  // as capacity is not full , he can come at departure time\\n                result=passengers[j];  // we need to get any time but less than this result , as time are unique\\n            }\\n            else{\\n                while(j<m and cnt<capacity and passengers[j]<=depart) cnt++,j++;\\n                if(j==m) return depart;\\n            }\\n        }\\n\\t\\t\\n\\t\\t// check the maximum time that person can come and that time don\\'t clash with any\\n        while(j>=0 and passengers[j]==result){\\n            result--;\\n            j--;\\n        }\\n\\t\\t\\n\\t\\t// for  cases like \\n\\t\\t// [5]          Here the person we are comparing it with has time 7\\n\\t\\t// [7,8]       so 6 can be the answer to onbaord bus\\n\\t\\t// 1           but 6 is greater than the departure time\\n\\n        return min(result,buses[n-1]);\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\n\\nint latestTimeCatchTheBus(vector<int>& buses, vector<int>& passengers, int capacity) {\\n        sort(begin(buses),end(buses));\\n        sort(begin(passengers),end(passengers));\\n        int n=buses.size(),m=passengers.size(),j=0;\\n        int result=0;\\n        for(int i=0;i<buses.size();i++){\\n            int depart=buses[i];\\n            int cnt=0;\\n            if(i==n-1){\\n                while(j<m and cnt<capacity-1 and passengers[j]<depart) cnt++,j++; // passenger with arrival=depart can\\'t onboard\\n                if(j==m) return depart;  // as capacity is not full , he can come at departure time\\n                result=passengers[j];  // we need to get any time but less than this result , as time are unique\\n            }\\n            else{\\n                while(j<m and cnt<capacity and passengers[j]<=depart) cnt++,j++;\\n                if(j==m) return depart;\\n            }\\n        }\\n\\t\\t\\n\\t\\t// check the maximum time that person can come and that time don\\'t clash with any\\n        while(j>=0 and passengers[j]==result){\\n            result--;\\n            j--;\\n        }\\n\\t\\t\\n\\t\\t// for  cases like \\n\\t\\t// [5]          Here the person we are comparing it with has time 7\\n\\t\\t// [7,8]       so 6 can be the answer to onbaord bus\\n\\t\\t// 1           but 6 is greater than the departure time\\n\\n        return min(result,buses[n-1]);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2259280,
                "title": "easy-c-solution-greedy",
                "content": "```\\nint latestTimeCatchTheBus(vector<int>& buses, vector<int>& passengers, int capacity) {\\n        sort(passengers.begin(),passengers.end());\\n        sort(buses.begin(),buses.end());\\n        int bus_ind=0,pas_ind=0;\\n        map<int,int> mp;int cnt=0;\\n        for(int i=0;i<buses.size();i++)\\n        {\\n            cnt=0;\\n             while(pas_ind<passengers.size() && buses[i]>=passengers[pas_ind] && cnt<capacity )\\n             {\\n                 mp[passengers[pas_ind]]=1;\\n                 pas_ind++;\\n                 cnt++;\\n             }\\n        }\\n        if(pas_ind==0)\\n        {\\n            return buses[buses.size()-1];\\n        }\\n        pas_ind--;\\n        int last=passengers[pas_ind];\\n        if(cnt<capacity)\\n        last=buses[buses.size()-1];\\n        while(mp[last]==1)\\n        {\\n            last--;\\n        }\\n        return last;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nint latestTimeCatchTheBus(vector<int>& buses, vector<int>& passengers, int capacity) {\\n        sort(passengers.begin(),passengers.end());\\n        sort(buses.begin(),buses.end());\\n        int bus_ind=0,pas_ind=0;\\n        map<int,int> mp;int cnt=0;\\n        for(int i=0;i<buses.size();i++)\\n        {\\n            cnt=0;\\n             while(pas_ind<passengers.size() && buses[i]>=passengers[pas_ind] && cnt<capacity )\\n             {\\n                 mp[passengers[pas_ind]]=1;\\n                 pas_ind++;\\n                 cnt++;\\n             }\\n        }\\n        if(pas_ind==0)\\n        {\\n            return buses[buses.size()-1];\\n        }\\n        pas_ind--;\\n        int last=passengers[pas_ind];\\n        if(cnt<capacity)\\n        last=buses[buses.size()-1];\\n        while(mp[last]==1)\\n        {\\n            last--;\\n        }\\n        return last;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2431194,
                "title": "c-sorting-simple-solution-faster-than-100",
                "content": "```\\nint latestTimeCatchTheBus(vector<int>& buses, vector<int>& passengers, int capacity)     {\\n        sort(buses.begin(), buses.end());\\n        sort(passengers.begin(), passengers.end());\\n        int ans, j=0;\\n        for(int i=0;i<buses.size();i++) {\\n            int cap=0;\\n            while(j<passengers.size() && passengers[j]<=buses[i] && cap<capacity) {\\n                if(j==0 || passengers[j]-passengers[j-1]>1) ans=passengers[j]-1;\\n                cap++, j++;\\n            }\\n            if(j==0 || cap<capacity && passengers[j-1]!=buses[i]) ans=buses[i];\\n        }\\n        return ans;\\n    }\\n```\\n\\nPlease upvote if you liked the solution",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nint latestTimeCatchTheBus(vector<int>& buses, vector<int>& passengers, int capacity)     {\\n        sort(buses.begin(), buses.end());\\n        sort(passengers.begin(), passengers.end());\\n        int ans, j=0;\\n        for(int i=0;i<buses.size();i++) {\\n            int cap=0;\\n            while(j<passengers.size() && passengers[j]<=buses[i] && cap<capacity) {\\n                if(j==0 || passengers[j]-passengers[j-1]>1) ans=passengers[j]-1;\\n                cap++, j++;\\n            }\\n            if(j==0 || cap<capacity && passengers[j-1]!=buses[i]) ans=buses[i];\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2305385,
                "title": "python-code-with-proper-comments-and-explanation",
                "content": "```\\nclass Solution:\\n    def latestTimeCatchTheBus(self, buses: List[int], passengers: List[int], capacity: int) -> int:\\n        \"\"\"\\n        [4,11,13,19,21,25,26]\\n        [10,20,30]\\n        \\n        for 10:\\n        we can have only 4 \\n        \\n        for 20:\\n        we can have 11,13,19 but since capacity is 2 so only 11 and 13 are taken\\n        into consideration\\n        \\n        for 30:\\n        we can have 19,21,25,26. Here 19 and 21 are selected\\n        \\n        | 10 | 20 | 30 |\\n         ______________\\n        |  4 | 11 | 19 |\\n        |    | 13 | 21 |\\n        \\n        We have to find the latest element \\n        last bucket is full and its last element is 21 then we can arrive at 20 \\n        to catch the last bus\\n        \\n        If last bucket is not filled for example \\n        buses = [10] passengers = [4]\\n        capacity = 2\\n        \\n        | 10 |\\n         ____\\n        | 4  |\\n        | 9  |\\n        \\n        We can arrive the latest by 9 which is 10 - 1 i.e., buses[i]-1\\n        \\n        Please note we are only interested in the capacity of the last bucket\\n        \"\"\"\\n        buslen = len(buses)\\n        passengerlen = len(passengers)\\n        \\n        buses.sort()\\n        passengers.sort()\\n        \\n        # j will keep the track of the last passenger inserted into the bucket\\n        j = 0 \\n        # c will keep track of the current capacity of each bus\\n        c = 0\\n        # Below variable will keep track of our time\\n        ourTime = 0\\n        s = set(passengers)\\n        \\n        for i in buses:\\n            # For each bus we are starting with 0 capacity for that bus\\n            c = 0\\n            # In the below code we are adding passengers to their respective buckets\\n            while j < passengerlen and c < capacity and passengers[j] <= i:\\n                c += 1\\n                j += 1\\n        \\n        # After the above loop execution c will have the last bucket capacity\\n        # and j will have the index of the last element inserted in the last bucket\\n        \\n        # 1st condition when the last bucket is not filled\\n        # Here in this case we will start from the time of arrival of the last bus\\n        # and go on checking whether the arrival time is \\n        # the arrival time of any other passenger \\n        # by decrementing this arrival time by 1\\n        if c != capacity:\\n            ourTime = buses[-1]\\n            while ourTime in s:\\n                ourTime -= 1\\n        \\n        # 2nd condition is same as first condition but here we need to start\\n        # from an arrival time of passenger which should be less \\n\\t\\t# than the last arrival time of the last passenger of last bucket\\n        \\n        if c == capacity:\\n            ourTime = passengers[j-1]\\n            while ourTime in s:\\n                ourTime -= 1\\n        \\n        return ourTime\\n            \\n                \\n            \\n        \\n```",
                "solutionTags": [
                    "Array",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def latestTimeCatchTheBus(self, buses: List[int], passengers: List[int], capacity: int) -> int:\\n        \"\"\"\\n        [4,11,13,19,21,25,26]\\n        [10,20,30]\\n        \\n        for 10:\\n        we can have only 4 \\n        \\n        for 20:\\n        we can have 11,13,19 but since capacity is 2 so only 11 and 13 are taken\\n        into consideration\\n        \\n        for 30:\\n        we can have 19,21,25,26. Here 19 and 21 are selected\\n        \\n        | 10 | 20 | 30 |\\n         ______________\\n        |  4 | 11 | 19 |\\n        |    | 13 | 21 |\\n        \\n        We have to find the latest element \\n        last bucket is full and its last element is 21 then we can arrive at 20 \\n        to catch the last bus\\n        \\n        If last bucket is not filled for example \\n        buses = [10] passengers = [4]\\n        capacity = 2\\n        \\n        | 10 |\\n         ____\\n        | 4  |\\n        | 9  |\\n        \\n        We can arrive the latest by 9 which is 10 - 1 i.e., buses[i]-1\\n        \\n        Please note we are only interested in the capacity of the last bucket\\n        \"\"\"\\n        buslen = len(buses)\\n        passengerlen = len(passengers)\\n        \\n        buses.sort()\\n        passengers.sort()\\n        \\n        # j will keep the track of the last passenger inserted into the bucket\\n        j = 0 \\n        # c will keep track of the current capacity of each bus\\n        c = 0\\n        # Below variable will keep track of our time\\n        ourTime = 0\\n        s = set(passengers)\\n        \\n        for i in buses:\\n            # For each bus we are starting with 0 capacity for that bus\\n            c = 0\\n            # In the below code we are adding passengers to their respective buckets\\n            while j < passengerlen and c < capacity and passengers[j] <= i:\\n                c += 1\\n                j += 1\\n        \\n        # After the above loop execution c will have the last bucket capacity\\n        # and j will have the index of the last element inserted in the last bucket\\n        \\n        # 1st condition when the last bucket is not filled\\n        # Here in this case we will start from the time of arrival of the last bus\\n        # and go on checking whether the arrival time is \\n        # the arrival time of any other passenger \\n        # by decrementing this arrival time by 1\\n        if c != capacity:\\n            ourTime = buses[-1]\\n            while ourTime in s:\\n                ourTime -= 1\\n        \\n        # 2nd condition is same as first condition but here we need to start\\n        # from an arrival time of passenger which should be less \\n\\t\\t# than the last arrival time of the last passenger of last bucket\\n        \\n        if c == capacity:\\n            ourTime = passengers[j-1]\\n            while ourTime in s:\\n                ourTime -= 1\\n        \\n        return ourTime\\n            \\n                \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2263339,
                "title": "greedy-o-n-two-pointer-c",
                "content": "1st one might just look at the constriants and go for a binary search solution which I did during the contest and messed up. People might have varying opinions but to me questions like these teaches me to not just think in one direction.\\nI had a rough idea for the binary search solution, but it was getting way too complicated, you can check out this post in case you all wanna have a look behind the intution [link](https://leetcode.com/problems/the-latest-time-to-catch-a-bus/discuss/2259747/Binary-Search-solution-(alternative))\\n\\nNow coming to the solution, it becomes quiet obvious when you think it in terms of number of people who can travel in the current bus. We can break down the problem as for a current bus either `capacity` passengers will **board** or else passengers whose `arrivalTime <= departureTime` of the current bus.\\nThus for every bus we can find an index upto which the passengers can travel in the current bus. These people will be in some range in the sorted `passengers` array. In this **range** if we can find the latest time when a person hasn\\'t arrived in the bus station, then that can be an option for our answer, as by the constraints we can\\'t have people **arriving** at the same time. \\n* To find this everytime we are at a current passenger who can board the bus with the given constraints, if there is no one who has arrived at a time `passengers[i] - 1` then that means that time is free and we can arrive at that time and board before the passenger with time `passenger[i]` on the bus. We don\\'t actually need the range but the arrival time of the passengers who can board the bus. Here can use a 2 pointer approach to keep track which all passengers have already boarded the current bus (we won\\'t consider them for the next bus).\\n\\n* And if the capacity isn\\'t fulfilled for a certain bus that means the last passenger which was considered while filling our bus hadn\\'t arrived before the time of departure, thus wasn\\'t able to board the bus. And now since we have some empty seats in the bus we can arrive at the time the bus leaves(`buses[i]`) which is the latest time we need to arrive at to board the bus. Again this can be our answer.\\n\\nConsidering the answers from these two solutions we can find the latest time (max time) when we can arrive and still board the bus.\\n\\nAnd we can always arrive at a time and board the bus since the arrival time of each passenger is `>=2`, so if we arrive at time 1 we can board a bus.\\n\\n\\n\\nBelow I have attached the code for reference purposes, hope with the help of the code the solution will become much clearer.\\n\\n```\\nclass Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& buses, vector<int>& passengers, int capacity) {\\n        int n = buses.size(), m = passengers.size();\\n        sort(buses.begin(), buses.end());\\n        sort(passengers.begin(), passengers.end());\\n        \\n        unordered_set<int> arrivalTimes(passengers.begin(), passengers.end());\\n        \\n        int j = 0, latest = 1;\\n        for(int i = 0; i < n; i++) {\\n            int departure = buses[i], boarded = 0;\\n            while(j < m && boarded < capacity && passengers[j] <= departure) {\\n                int time = passengers[j];\\n                if(arrivalTimes.find(time-1) == arrivalTimes.end()) {\\n                    latest = max(latest, time-1);\\n                }\\n                \\n                j++;\\n                boarded++;\\n            }\\n            //if space left on bus means the person who couldn\\'t hop on must be greater than departure time\\n            if(boarded < capacity) {\\n                int prevPassengerTime = j-1 >= 0? passengers[j-1]: 1;\\n                if(prevPassengerTime < departure)\\n                    latest = max(departure, latest);\\n            }\\n        }\\n        \\n        return latest;\\n    }\\n};\\n```\\n\\nThanks and cheers\\uD83D\\uDE04\\nThis is my 1st post for any LC solutions, feedbacks would be much appreciated.",
                "solutionTags": [
                    "Two Pointers",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& buses, vector<int>& passengers, int capacity) {\\n        int n = buses.size(), m = passengers.size();\\n        sort(buses.begin(), buses.end());\\n        sort(passengers.begin(), passengers.end());\\n        \\n        unordered_set<int> arrivalTimes(passengers.begin(), passengers.end());\\n        \\n        int j = 0, latest = 1;\\n        for(int i = 0; i < n; i++) {\\n            int departure = buses[i], boarded = 0;\\n            while(j < m && boarded < capacity && passengers[j] <= departure) {\\n                int time = passengers[j];\\n                if(arrivalTimes.find(time-1) == arrivalTimes.end()) {\\n                    latest = max(latest, time-1);\\n                }\\n                \\n                j++;\\n                boarded++;\\n            }\\n            //if space left on bus means the person who couldn\\'t hop on must be greater than departure time\\n            if(boarded < capacity) {\\n                int prevPassengerTime = j-1 >= 0? passengers[j-1]: 1;\\n                if(prevPassengerTime < departure)\\n                    latest = max(departure, latest);\\n            }\\n        }\\n        \\n        return latest;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2260506,
                "title": "constant-space-java-o-nlogn",
                "content": "```\\nstatic int latestTimeCatchTheBus(int[] buses, int[] passengers, int capacity) {\\n    Arrays.sort(passengers);\\n    Arrays.sort(buses);\\n    if(passengers[0] > buses[buses.length - 1]) return buses[buses.length - 1];\\n    int result = passengers[0] - 1;\\n    int i = 0, j = 0;\\n    while(i < buses.length){\\n        int occupiedSeats = 0;\\n        while(occupiedSeats < capacity && j < passengers.length && passengers[j] <= buses[i]){\\n            if(j > 0 && passengers[j] - passengers[j-1] != 1){\\n                result = passengers[j] - 1;\\n            }\\n            j++;\\n            occupiedSeats++;\\n        }\\n        if(j - 1 > -1 && occupiedSeats < capacity && buses[i] != passengers[j-1]){\\n            result = buses[i];\\n        }\\n        i++;\\n    }\\n    return result;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nstatic int latestTimeCatchTheBus(int[] buses, int[] passengers, int capacity) {\\n    Arrays.sort(passengers);\\n    Arrays.sort(buses);\\n    if(passengers[0] > buses[buses.length - 1]) return buses[buses.length - 1];\\n    int result = passengers[0] - 1;\\n    int i = 0, j = 0;\\n    while(i < buses.length){\\n        int occupiedSeats = 0;\\n        while(occupiedSeats < capacity && j < passengers.length && passengers[j] <= buses[i]){\\n            if(j > 0 && passengers[j] - passengers[j-1] != 1){\\n                result = passengers[j] - 1;\\n            }\\n            j++;\\n            occupiedSeats++;\\n        }\\n        if(j - 1 > -1 && occupiedSeats < capacity && buses[i] != passengers[j-1]){\\n            result = buses[i];\\n        }\\n        i++;\\n    }\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2260000,
                "title": "c-time-o-nlogn-space-o-1",
                "content": "Let\\'s do it using `binary-serach`.\\n\\nTime: O(NlogN)\\nSpace: O(1) // No extra space used. (if we do not consider space used by sorting function)\\n\\n```\\nint latestTimeCatchTheBus(vector<int>& buses, vector<int>& passengers, int capacity) {\\n\\tsort(buses.begin(), buses.end());\\n\\tsort(passengers.begin(), passengers.end());\\n\\n\\tint passGone = 0; // no of passangers already went till ith bus\\n\\tbool lastBusFilled = true; // if last bus went is filled or not\\n\\n\\tfor(int i=0; i<buses.size(); i++) {\\n\\t\\tint dep = buses[i];\\n\\t\\tint lo = -1; // can ride the bus for lo-th passanger\\n\\t\\tint hi = passengers.size(); // can not ride the bus for hi-th passanger\\n\\n\\t\\twhile(lo+1 < hi) {\\n\\t\\t\\tint mid = lo + (hi-lo)/2;\\n\\t\\t\\tif(passengers[mid] <= dep) {\\n\\t\\t\\t\\tlo = mid;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\thi = mid;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif(passGone + capacity > lo+1) {\\n\\t\\t\\tlastBusFilled = false;\\n\\t\\t} else {\\n\\t\\t\\tlastBusFilled = true;\\n\\t\\t}\\n\\t\\tpassGone = min(passGone+capacity, lo+1);\\n\\t}\\n\\n\\tint possibleAns = (lastBusFilled) ? passengers[passGone-1] : buses[buses.size()-1];\\n\\n\\tfor(int ans = possibleAns; ans > 0; ans--) {\\n\\t\\tif(!binary_search(passengers.begin(), passengers.end(), ans)) {\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t}\\n\\n\\treturn 0;\\n}",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "Let\\'s do it using `binary-serach`.\\n\\nTime: O(NlogN)\\nSpace: O(1) // No extra space used. (if we do not consider space used by sorting function)\\n\\n```\\nint latestTimeCatchTheBus(vector<int>& buses, vector<int>& passengers, int capacity) {\\n\\tsort(buses.begin(), buses.end());\\n\\tsort(passengers.begin(), passengers.end());\\n\\n\\tint passGone = 0; // no of passangers already went till ith bus\\n\\tbool lastBusFilled = true; // if last bus went is filled or not\\n\\n\\tfor(int i=0; i<buses.size(); i++) {\\n\\t\\tint dep = buses[i];\\n\\t\\tint lo = -1; // can ride the bus for lo-th passanger\\n\\t\\tint hi = passengers.size(); // can not ride the bus for hi-th passanger\\n\\n\\t\\twhile(lo+1 < hi) {\\n\\t\\t\\tint mid = lo + (hi-lo)/2;\\n\\t\\t\\tif(passengers[mid] <= dep) {\\n\\t\\t\\t\\tlo = mid;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\thi = mid;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif(passGone + capacity > lo+1) {\\n\\t\\t\\tlastBusFilled = false;\\n\\t\\t} else {\\n\\t\\t\\tlastBusFilled = true;\\n\\t\\t}\\n\\t\\tpassGone = min(passGone+capacity, lo+1);\\n\\t}\\n\\n\\tint possibleAns = (lastBusFilled) ? passengers[passGone-1] : buses[buses.size()-1];\\n\\n\\tfor(int ans = possibleAns; ans > 0; ans--) {\\n\\t\\tif(!binary_search(passengers.begin(), passengers.end(), ans)) {\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t}\\n\\n\\treturn 0;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 2259809,
                "title": "easy-c-code-using-two-methods",
                "content": "C++ Code using two pointers and unordered_set : \\n```\\nclass Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& buses, vector<int>& passengers, int capacity) {\\n        int n = buses.size();\\n        int m = passengers.size();\\n        sort(buses.begin(),buses.end());\\n        sort(passengers.begin(), passengers.end());\\n        unordered_set<int>st;\\n        for(auto p: passengers){\\n            st.insert(p);\\n        }\\n        int i = 0,j=0,count=0;\\n        int lPassenger = -1;\\n        while(i<n){\\n            count = 0;\\n            while(j<m && passengers[j]<=buses[i] && count<capacity){\\n                lPassenger = passengers[j];\\n                count++;\\n                j++;\\n            }\\n            i++;\\n        }\\n        int val = 0;\\n        if(lPassenger==-1){\\n            val = buses[n-1];\\n        }\\n        else if(count==capacity){\\n            val = lPassenger;\\n        }\\n        else{\\n            val = buses[n-1];\\n        }\\n        while(val>=0){\\n            if(st.find(val)==st.end()){\\n                return val;\\n            }\\n            val--;\\n        }\\n        return -1;\\n\\n    }\\n};\\n```\\n\\nC++ Code using min heap and unordered_set :\\n\\n```\\nclass Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& buses, vector<int>& passengers, int capacity) {\\n         int n = buses.size();\\n         sort(buses.begin(),buses.end());\\n         unordered_set<int> st;\\n        priority_queue<int,vector<int>,greater<int>> pq;\\n        for(auto &it : passengers){\\n            pq.push(it);\\n        }\\n    \\n        int val = capacity;  \\n        for(int i = 0;i<n;i++){\\n            val = capacity;\\n            if(i == n-1){\\n                while(!pq.empty() && pq.top()<=buses[i] && val>1){\\n                        st.insert(pq.top());\\n                        pq.pop();\\n                        val--;\\n                }\\n                int latestTime = 0;\\n                if(pq.empty()==true)\\n                latestTime = buses[i];\\n                else \\n                    latestTime = min(buses[i],pq.top()-1);\\n                while(st.count(latestTime)>0)\\n                    latestTime--;\\n                return latestTime;\\n            }\\n            while(!pq.empty() && pq.top()<=buses[i] && val){\\n                st.insert(pq.top());\\n                pq.pop();\\n                val--;\\n            } \\n        }\\n        return 0;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "Greedy",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& buses, vector<int>& passengers, int capacity) {\\n        int n = buses.size();\\n        int m = passengers.size();\\n        sort(buses.begin(),buses.end());\\n        sort(passengers.begin(), passengers.end());\\n        unordered_set<int>st;\\n        for(auto p: passengers){\\n            st.insert(p);\\n        }\\n        int i = 0,j=0,count=0;\\n        int lPassenger = -1;\\n        while(i<n){\\n            count = 0;\\n            while(j<m && passengers[j]<=buses[i] && count<capacity){\\n                lPassenger = passengers[j];\\n                count++;\\n                j++;\\n            }\\n            i++;\\n        }\\n        int val = 0;\\n        if(lPassenger==-1){\\n            val = buses[n-1];\\n        }\\n        else if(count==capacity){\\n            val = lPassenger;\\n        }\\n        else{\\n            val = buses[n-1];\\n        }\\n        while(val>=0){\\n            if(st.find(val)==st.end()){\\n                return val;\\n            }\\n            val--;\\n        }\\n        return -1;\\n\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& buses, vector<int>& passengers, int capacity) {\\n         int n = buses.size();\\n         sort(buses.begin(),buses.end());\\n         unordered_set<int> st;\\n        priority_queue<int,vector<int>,greater<int>> pq;\\n        for(auto &it : passengers){\\n            pq.push(it);\\n        }\\n    \\n        int val = capacity;  \\n        for(int i = 0;i<n;i++){\\n            val = capacity;\\n            if(i == n-1){\\n                while(!pq.empty() && pq.top()<=buses[i] && val>1){\\n                        st.insert(pq.top());\\n                        pq.pop();\\n                        val--;\\n                }\\n                int latestTime = 0;\\n                if(pq.empty()==true)\\n                latestTime = buses[i];\\n                else \\n                    latestTime = min(buses[i],pq.top()-1);\\n                while(st.count(latestTime)>0)\\n                    latestTime--;\\n                return latestTime;\\n            }\\n            while(!pq.empty() && pq.top()<=buses[i] && val){\\n                st.insert(pq.top());\\n                pq.pop();\\n                val--;\\n            } \\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2259585,
                "title": "c-priority-queue-min-heap",
                "content": "Finding Last Passenger and Last bus then calculating appropriate time.\\n```\\nclass Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& buses, vector<int>& passengers, int capacity) {\\n        priority_queue <int, vector<int>, greater<int>> bus;\\n        priority_queue <int, vector<int>, greater<int>> pass;\\n        \\n        for(int i=0; i<buses.size(); i++)\\n            bus.push(buses[i]);\\n        for(int i=0; i<passengers.size(); i++)\\n            pass.push(passengers[i]);\\n\\n        set<int> st;\\n        for(int i=0; i<passengers.size(); i++)\\n            st.insert(passengers[i]);\\n        \\n        int lastPass = pass.top();\\n        int lastBus = bus.top();\\n        int lastCap = capacity;\\n        \\n        \\n        while(!bus.empty() and !pass.empty()){\\n            int temp = capacity;\\n            while(temp){\\n                if(!pass.empty() and bus.top()>=pass.top()){\\n                    lastPass = pass.top();\\n                    pass.pop();\\n                    temp--;\\n                    lastCap = temp;\\n                }else{\\n                    lastBus = bus.top();\\n                    bus.pop();\\n                    break;\\n                }\\n            }\\n            \\n            if(temp==0){\\n                lastBus = bus.top();\\n                bus.pop();\\n            }\\n        }\\n        \\n        \\n        int ans;\\n        if(!bus.empty()){\\n            return bus.top();\\n        }\\n        if(lastCap==0 or lastBus==lastPass ){\\n            ans = lastPass;\\n            while(ans>0){\\n                if(!st.count(ans))\\n                    break;\\n                ans = ans-1;\\n            }\\n        }\\n        else if(lastCap>0){\\n            ans = lastBus;\\n            while(ans>lastPass){\\n                if(!st.count(ans))\\n                    break;\\n                ans = ans-1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& buses, vector<int>& passengers, int capacity) {\\n        priority_queue <int, vector<int>, greater<int>> bus;\\n        priority_queue <int, vector<int>, greater<int>> pass;\\n        \\n        for(int i=0; i<buses.size(); i++)\\n            bus.push(buses[i]);\\n        for(int i=0; i<passengers.size(); i++)\\n            pass.push(passengers[i]);\\n\\n        set<int> st;\\n        for(int i=0; i<passengers.size(); i++)\\n            st.insert(passengers[i]);\\n        \\n        int lastPass = pass.top();\\n        int lastBus = bus.top();\\n        int lastCap = capacity;\\n        \\n        \\n        while(!bus.empty() and !pass.empty()){\\n            int temp = capacity;\\n            while(temp){\\n                if(!pass.empty() and bus.top()>=pass.top()){\\n                    lastPass = pass.top();\\n                    pass.pop();\\n                    temp--;\\n                    lastCap = temp;\\n                }else{\\n                    lastBus = bus.top();\\n                    bus.pop();\\n                    break;\\n                }\\n            }\\n            \\n            if(temp==0){\\n                lastBus = bus.top();\\n                bus.pop();\\n            }\\n        }\\n        \\n        \\n        int ans;\\n        if(!bus.empty()){\\n            return bus.top();\\n        }\\n        if(lastCap==0 or lastBus==lastPass ){\\n            ans = lastPass;\\n            while(ans>0){\\n                if(!st.count(ans))\\n                    break;\\n                ans = ans-1;\\n            }\\n        }\\n        else if(lastCap>0){\\n            ans = lastBus;\\n            while(ans>lastPass){\\n                if(!st.count(ans))\\n                    break;\\n                ans = ans-1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2259293,
                "title": "c-sorting-and-unordered-set",
                "content": "```\\nclass Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& buses, vector<int>& passengers, int capacity) {\\n        sort(passengers.begin(),passengers.end());\\n        sort(buses.begin(),buses.end());\\n        int maxi = INT_MIN;\\n        unordered_set<int>taken;\\n        int n=buses.size(),m=passengers.size(),j=0;\\n        for(int i=0;i<n;i++){\\n            int res = capacity;\\n            while(j<m && passengers[j] <= buses[i] && res){\\n                res--;\\n                int t = passengers[j];\\n                taken.insert(t);\\n                while(t>0 && taken.count(t)){\\n                    t--;\\n                }\\n                maxi = t;\\n                j++;\\n            }\\n            if(i==n-1 && res){\\n                int c = buses.back();\\n                while(c>0 && taken.count(c)){\\n                    c--;\\n                }\\n                maxi = c;\\n            }\\n        }\\n        return maxi;\\n        \\n    }\\n};``\\n```",
                "solutionTags": [
                    "C",
                    "Sorting",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& buses, vector<int>& passengers, int capacity) {\\n        sort(passengers.begin(),passengers.end());\\n        sort(buses.begin(),buses.end());\\n        int maxi = INT_MIN;\\n        unordered_set<int>taken;\\n        int n=buses.size(),m=passengers.size(),j=0;\\n        for(int i=0;i<n;i++){\\n            int res = capacity;\\n            while(j<m && passengers[j] <= buses[i] && res){\\n                res--;\\n                int t = passengers[j];\\n                taken.insert(t);\\n                while(t>0 && taken.count(t)){\\n                    t--;\\n                }\\n                maxi = t;\\n                j++;\\n            }\\n            if(i==n-1 && res){\\n                int c = buses.back();\\n                while(c>0 && taken.count(c)){\\n                    c--;\\n                }\\n                maxi = c;\\n            }\\n        }\\n        return maxi;\\n        \\n    }\\n};``\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2259273,
                "title": "easy-c-heap",
                "content": "```\\nclass Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& buses, vector<int>& pass, int cap) {\\n        priority_queue<int,vector<int>,greater<int>> pq;\\n        for(auto &it : pass){\\n            pq.push(it);\\n        }\\n        unordered_set<int> st;\\n        int n = buses.size();\\n        int val = cap;\\n        sort(buses.begin(),buses.end());\\n        for(int i = 0;i<n;i++){\\n            val = cap;\\n            if(i == n-1){\\n                while(!pq.empty() && pq.top()<=buses[i] && val>1){\\n                        st.insert(pq.top());\\n                        pq.pop();\\n                        val--;\\n                }\\n                int vali = 0;\\n                if(pq.empty())\\n                vali = buses[i];\\n                else vali = min(buses[i],pq.top()-1);\\n                while(st.count(vali))\\n                    vali--;\\n                return vali;\\n            }\\n            while(!pq.empty() && pq.top()<=buses[i] && val){\\n                st.insert(pq.top());\\n                pq.pop();\\n                val--;\\n            } \\n        }\\n        return 0;\\n    }\\n};\\n\\n```\\nPop out all the eligible elements from heap uptil the last bus, and for the last bus, do some operations, check some edge cases, and return the most latest value you can.",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& buses, vector<int>& pass, int cap) {\\n        priority_queue<int,vector<int>,greater<int>> pq;\\n        for(auto &it : pass){\\n            pq.push(it);\\n        }\\n        unordered_set<int> st;\\n        int n = buses.size();\\n        int val = cap;\\n        sort(buses.begin(),buses.end());\\n        for(int i = 0;i<n;i++){\\n            val = cap;\\n            if(i == n-1){\\n                while(!pq.empty() && pq.top()<=buses[i] && val>1){\\n                        st.insert(pq.top());\\n                        pq.pop();\\n                        val--;\\n                }\\n                int vali = 0;\\n                if(pq.empty())\\n                vali = buses[i];\\n                else vali = min(buses[i],pq.top()-1);\\n                while(st.count(vali))\\n                    vali--;\\n                return vali;\\n            }\\n            while(!pq.empty() && pq.top()<=buses[i] && val){\\n                st.insert(pq.top());\\n                pq.pop();\\n                val--;\\n            } \\n        }\\n        return 0;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3456171,
                "title": "java-two-pointer-beat-100-with-detail-explanation",
                "content": "# Intuition\\nFor this problem, we only care about the last bus, and there are only two cases for last bus, full and not full, if full we need to replace one, otherwise, we just simply insert one.\\nTo replace and To add, we simply need to follow the rule -> **You cannot arrive at the same time as another passenger.**\\n\\n\\n# Approach\\n0. Sort both array first.\\n1. Use two pointers, one point to bus, the other point to passengers.\\n2. After the loop, we can get two value, **k**(capacity left for last bus), **j**(how many passengers were on the last bus)\\n3. Then based on value k, we can decide if last bus is full or not\\n    1. if it\\'s not full(k>0), we add one (tricky part, check the code below)\\n    2. if it\\'s full we replace one (details in the code);\\n\\n# Complexity\\n- Time complexity:\\nO(2nlogn) + O(n*m) + O(n) => O(n*m) (worst case)\\n\\n- Space complexity:\\nO(n) Just some variables\\n\\n# Code\\n```\\nclass Solution {\\n    public int latestTimeCatchTheBus(int[] buses, int[] passengers, int capacity) {\\n        Arrays.sort(buses);\\n        Arrays.sort(passengers);\\n\\n        int k = 0;\\n        int n = buses.length;\\n        int m = passengers.length;\\n        int j = 0;\\n        int ret = 0;\\n        int last_bus_time = buses[n-1];\\n\\n        for(int i=0;i<n;i++) {\\n            k = capacity;\\n            while(j<m && passengers[j]<=buses[i] && k>0) {\\n                k--;\\n                j++;      \\n            } \\n        }\\n// After the for-loop, j-1 = last person on last bus   \\n \\n        if (k>0) {\\n// if k == capacity means, last bus is empty, \\n// we can simply catch the bus at last min, which is buses[n-1];\\n            if(k == capacity) { \\n                ret = last_bus_time;\\n            } else {\\n// if k > 0 and k < capacity that means, \\n// there are at least one passenger on last bus, \\n// and we have to consider if that/last passenger is \\n// catch last bus on last timing which passengers[j-1] == last_bus,\\n// if this is the case, we can\\'t catch bus on last timing cuz already \\n// taken, we have to find the largest available timing. \\n// Note: passengers[j-1] is either less than \\n// or equal to last_bus_time, other wise \\n// the passenger can\\'t onboard the bus\\n\\n                if (passengers[j-1] == last_bus_time) { \\n                    j--;\\n                    while(j>0 && passengers[j]-1 == passengers[j-1]) {\\n                        j--;\\n                    }\\n                    ret = passengers[j]-1;\\n                } else {\\n                    ret = last_bus_time;\\n                }\\n            } \\n        } else {\\n\\n// this means last bus is full, \\n// we have to replace one, simply follow the rules, find the largest \\n// available timing\\n            j--;\\n            while(j>0 && passengers[j]-1 == passengers[j-1]) {\\n                j--;\\n            }\\n            ret = passengers[j]-1;\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int latestTimeCatchTheBus(int[] buses, int[] passengers, int capacity) {\\n        Arrays.sort(buses);\\n        Arrays.sort(passengers);\\n\\n        int k = 0;\\n        int n = buses.length;\\n        int m = passengers.length;\\n        int j = 0;\\n        int ret = 0;\\n        int last_bus_time = buses[n-1];\\n\\n        for(int i=0;i<n;i++) {\\n            k = capacity;\\n            while(j<m && passengers[j]<=buses[i] && k>0) {\\n                k--;\\n                j++;      \\n            } \\n        }\\n// After the for-loop, j-1 = last person on last bus   \\n \\n        if (k>0) {\\n// if k == capacity means, last bus is empty, \\n// we can simply catch the bus at last min, which is buses[n-1];\\n            if(k == capacity) { \\n                ret = last_bus_time;\\n            } else {\\n// if k > 0 and k < capacity that means, \\n// there are at least one passenger on last bus, \\n// and we have to consider if that/last passenger is \\n// catch last bus on last timing which passengers[j-1] == last_bus,\\n// if this is the case, we can\\'t catch bus on last timing cuz already \\n// taken, we have to find the largest available timing. \\n// Note: passengers[j-1] is either less than \\n// or equal to last_bus_time, other wise \\n// the passenger can\\'t onboard the bus\\n\\n                if (passengers[j-1] == last_bus_time) { \\n                    j--;\\n                    while(j>0 && passengers[j]-1 == passengers[j-1]) {\\n                        j--;\\n                    }\\n                    ret = passengers[j]-1;\\n                } else {\\n                    ret = last_bus_time;\\n                }\\n            } \\n        } else {\\n\\n// this means last bus is full, \\n// we have to replace one, simply follow the rules, find the largest \\n// available timing\\n            j--;\\n            while(j>0 && passengers[j]-1 == passengers[j-1]) {\\n                j--;\\n            }\\n            ret = passengers[j]-1;\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3234341,
                "title": "python-simple-solution-95-6",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def latestTimeCatchTheBus(self, buses: List[int], passengers: List[int], capacity: int) -> int:\\n        buses.sort()\\n        passengers.sort()\\n        index = 0\\n        l = len(passengers)\\n        for start in buses:\\n            cap = capacity\\n            while index < len(passengers) and start >= passengers[index] and cap > 0:\\n                cap -= 1\\n                index += 1\\n\\n        latest = start if cap > 0 else passengers[index-1] \\n\\n        while latest in set(passengers):\\n            latest -= 1\\n        return latest            \\n            \\n                                    \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def latestTimeCatchTheBus(self, buses: List[int], passengers: List[int], capacity: int) -> int:\\n        buses.sort()\\n        passengers.sort()\\n        index = 0\\n        l = len(passengers)\\n        for start in buses:\\n            cap = capacity\\n            while index < len(passengers) and start >= passengers[index] and cap > 0:\\n                cap -= 1\\n                index += 1\\n\\n        latest = start if cap > 0 else passengers[index-1] \\n\\n        while latest in set(passengers):\\n            latest -= 1\\n        return latest            \\n            \\n                                    \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2435302,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& buses, vector<int>& passengers, int capacity) {\\n        sort(buses.begin(),buses.end());\\n        sort(passengers.begin(),passengers.end());\\n        \\n        int n=buses.size();\\n        unordered_set<int>s;\\n        \\n        for(auto ele:passengers)s.insert(ele);\\n        \\n        \\n        int j=0,i=0;\\n        for(i=0;i<n-1;i++){\\n            int t=capacity;\\n            \\n            while(j<passengers.size() && passengers[j]<=buses[i] && t){\\n                j++;\\n                t--;\\n            }\\n        }\\n        \\n        int prev=passengers[passengers.size()-1];\\n        while(j<passengers.size() && passengers[j]<=buses[i] && capacity){\\n            prev=passengers[j];\\n            j++;\\n            capacity--;\\n        }\\n        \\n        if(capacity){\\n            if(s.find(buses[i])==s.end())return buses[i];\\n        }\\n        \\n        prev--;\\n        while(prev>0 && s.find(prev)!=s.end()){\\n            prev--;\\n        }\\n     \\n        return prev;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& buses, vector<int>& passengers, int capacity) {\\n        sort(buses.begin(),buses.end());\\n        sort(passengers.begin(),passengers.end());\\n        \\n        int n=buses.size();\\n        unordered_set<int>s;\\n        \\n        for(auto ele:passengers)s.insert(ele);\\n        \\n        \\n        int j=0,i=0;\\n        for(i=0;i<n-1;i++){\\n            int t=capacity;\\n            \\n            while(j<passengers.size() && passengers[j]<=buses[i] && t){\\n                j++;\\n                t--;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2297702,
                "title": "easy-faster-efficient-java-soln",
                "content": "```\\nclass Solution {\\n    public int latestTimeCatchTheBus(int[] buses, int[] passengers, int capacity) {\\n        Arrays.sort(buses);\\n        Arrays.sort(passengers);\\n        HashSet<Integer> set = new HashSet<>();\\n        for(int val : passengers){\\n            set.add(val);\\n        }\\n        int n = buses.length;\\n        int m = passengers.length;\\n        int solb = capacity; // solb = space on last bus\\n        int lastPerson = 0;\\n        int i = 0,  j = 0;\\n        while(i < n && j < m){\\n            int cc = capacity; // cc => current capacity;\\n            while(j < m && cc > 0 && buses[i] >= passengers[j]){\\n                cc--;\\n                lastPerson = passengers[j];\\n                j++;\\n            }\\n            i++;\\n            solb = cc;\\n        }\\n        int x = lastPerson;\\n        if(solb > 0 || i != n){\\n            x = buses[n - 1];\\n        }\\n        while(set.contains(x) == true){\\n            x--;\\n        }\\n        return x;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int latestTimeCatchTheBus(int[] buses, int[] passengers, int capacity) {\\n        Arrays.sort(buses);\\n        Arrays.sort(passengers);\\n        HashSet<Integer> set = new HashSet<>();\\n        for(int val : passengers){\\n            set.add(val);\\n        }\\n        int n = buses.length;\\n        int m = passengers.length;\\n        int solb = capacity; // solb = space on last bus\\n        int lastPerson = 0;\\n        int i = 0,  j = 0;\\n        while(i < n && j < m){\\n            int cc = capacity; // cc => current capacity;\\n            while(j < m && cc > 0 && buses[i] >= passengers[j]){\\n                cc--;\\n                lastPerson = passengers[j];\\n                j++;\\n            }\\n            i++;\\n            solb = cc;\\n        }\\n        int x = lastPerson;\\n        if(solb > 0 || i != n){\\n            x = buses[n - 1];\\n        }\\n        while(set.contains(x) == true){\\n            x--;\\n        }\\n        return x;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2263559,
                "title": "greedy-solution-took-me-1-hrs-to-do-it-please-like-it",
                "content": "import java.util.*;\\nclass Solution {\\n    public int latestTimeCatchTheBus(int[] buses, int[] passengers, int capacity) {\\n         Arrays.sort(buses);\\n         Arrays.sort(passengers);\\n        //sort the buuses and passengers array\\n         Set<Integer> hash_Set = new HashSet<Integer>();\\n        for(int l=0;l<passengers.length;l++)\\n        {\\n            hash_Set.add(passengers[l]);\\n        }\\n        int i=0,j=0,count=0,p=0,z=0,k=0,a=0,b=0,c=0,d=0;\\n         for( i=0;i<buses.length;i++)\\n         {\\n             for(;j<passengers.length;j++)\\n             {\\n                 \\n                   if(passengers[j]<=buses[i]&&count<capacity)\\n                   {\\n                       p++;\\n                       count++;\\n                       z=count;\\n                       System.out.print(passengers[j]+\"  \"+buses[i]+\"  \"+count); \\n                       a=passengers[j];\\n                       b=buses[i];\\n                       c=count;\\n                       d=i;\\n                   }\\n                   else\\n                   {\\n                       j=p;\\n                       break;\\n                   }\\n                  System.out.println(\"\");\\n             }\\n             \\n             count=0;\\n             j=p;\\n             k=i;\\n             \\n         }\\n        System.out.println(z+\"  \"+j+\"  \"+k);\\n        int value=0;\\n        if(d!=buses.length-1)\\n        {\\n            return buses[buses.length-1];\\n        }\\n        if(capacity==z)\\n        {\\n            int x=passengers[p-1];\\n            value=passengers[p-1];\\n            while(true)\\n            {\\n                \\n                if(hash_Set.contains(value))\\n                {\\n                    value--;\\n                    \\n                }\\n                else\\n                {\\n                    break;\\n                }\\n            }\\n        }\\n        else\\n        {\\n            value=buses[k];\\n            \\n            while(true)\\n            {\\n                \\n                if(hash_Set.contains(value))\\n                {\\n                    value--;\\n                    \\n                }\\n                else\\n                {\\n                    break;\\n                }\\n            }\\n        }\\n       return value;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Sorting",
                    "Ordered Set"
                ],
                "code": "class Solution {\\n    public int latestTimeCatchTheBus(int[] buses, int[] passengers, int capacity) {\\n         Arrays.sort(buses);\\n         Arrays.sort(passengers);\\n        //sort the buuses and passengers array\\n         Set<Integer> hash_Set = new HashSet<Integer>();\\n        for(int l=0;l<passengers.length;l++)\\n        {\\n            hash_Set.add(passengers[l]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2260829,
                "title": "binary-search-go",
                "content": "```go\\nfunc binarySearch(array []int, left, target int) int{\\n    // find the index of the first element \\n    // which is strictly greater than target\\n    // from left\\n\\tvar mid int\\n\\tright := len(array)\\n    for left < right {\\n        mid = (right + left) / 2\\n\\t\\tif mid >= len(array) {\\n\\t\\t\\treturn mid\\n\\t\\t}\\n        if array[mid] <= target {\\n            left = mid + 1\\n        } else {\\n            right = mid\\n        }\\n    }\\n    return left\\n}\\n\\nfunc latestTimeCatchTheBus(buses []int, passengers []int, capacity int) int {\\n    sort.Ints(buses)\\n    sort.Ints(passengers)\\n    n, m := len(buses), len(passengers)\\n    \\n    occur := make(map[int]bool, m)\\n    for _, p := range passengers  {\\n        occur[p] = true\\n    }\\n    \\n    // left, index of last person \\n    // who can catch current bus\\n    // start from -1 since no one\\n    // catchs any bus in the begining\\n    left := -1 \\n    lastBusNotFull := false\\n    \\n    // find the index of last person who\\n    // is able to catch a bus\\n    // \"I\" must come early than the last person\\n    for i, bus := range buses {\\n        // binary search from index left + 1\\n        // since every person arrives earlier\\n        // than left is already leaving\\n        index := binarySearch(passengers, left + 1, bus)\\n        newPassengers := index - left - 1\\n        if newPassengers >= capacity {\\n            newPassengers = capacity\\n        } else if i == n - 1 {\\n            lastBusNotFull = true\\n        }\\n        left += newPassengers\\n    }\\n    // every bus leaves before the earliest person\\n    // just return the departure time of the last bus\\n    if left == -1 {\\n        return buses[n - 1]\\n    }\\n    \\n    // possible result, try from arrive time \\n    // of last person who can catch a bus\\n    possible := passengers[left] - 1\\n    if lastBusNotFull {\\n        // if the last bus leaves with non-zero capacity\\n        // try from its\\' departure time\\n        possible = buses[n - 1]\\n    }\\n    \\n    for {\\n        _, ok := occur[possible]\\n        if ok {\\n            possible--;\\n        } else {\\n            break\\n        }\\n    }\\n    return possible\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Binary Tree"
                ],
                "code": "```go\\nfunc binarySearch(array []int, left, target int) int{\\n    // find the index of the first element \\n    // which is strictly greater than target\\n    // from left\\n\\tvar mid int\\n\\tright := len(array)\\n    for left < right {\\n        mid = (right + left) / 2\\n\\t\\tif mid >= len(array) {\\n\\t\\t\\treturn mid\\n\\t\\t}\\n        if array[mid] <= target {\\n            left = mid + 1\\n        } else {\\n            right = mid\\n        }\\n    }\\n    return left\\n}\\n\\nfunc latestTimeCatchTheBus(buses []int, passengers []int, capacity int) int {\\n    sort.Ints(buses)\\n    sort.Ints(passengers)\\n    n, m := len(buses), len(passengers)\\n    \\n    occur := make(map[int]bool, m)\\n    for _, p := range passengers  {\\n        occur[p] = true\\n    }\\n    \\n    // left, index of last person \\n    // who can catch current bus\\n    // start from -1 since no one\\n    // catchs any bus in the begining\\n    left := -1 \\n    lastBusNotFull := false\\n    \\n    // find the index of last person who\\n    // is able to catch a bus\\n    // \"I\" must come early than the last person\\n    for i, bus := range buses {\\n        // binary search from index left + 1\\n        // since every person arrives earlier\\n        // than left is already leaving\\n        index := binarySearch(passengers, left + 1, bus)\\n        newPassengers := index - left - 1\\n        if newPassengers >= capacity {\\n            newPassengers = capacity\\n        } else if i == n - 1 {\\n            lastBusNotFull = true\\n        }\\n        left += newPassengers\\n    }\\n    // every bus leaves before the earliest person\\n    // just return the departure time of the last bus\\n    if left == -1 {\\n        return buses[n - 1]\\n    }\\n    \\n    // possible result, try from arrive time \\n    // of last person who can catch a bus\\n    possible := passengers[left] - 1\\n    if lastBusNotFull {\\n        // if the last bus leaves with non-zero capacity\\n        // try from its\\' departure time\\n        possible = buses[n - 1]\\n    }\\n    \\n    for {\\n        _, ok := occur[possible]\\n        if ok {\\n            possible--;\\n        } else {\\n            break\\n        }\\n    }\\n    return possible\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2260597,
                "title": "c-simple-greedy",
                "content": "The idea is very simple: the result is either right before some passenger or exactly when the bus is going if it\\'s not full.\\n```\\n    int latestTimeCatchTheBus(vector<int>& buses, vector<int>& passengers, int capacity) {\\n        int m = buses.size();\\n        int n = passengers.size();\\n        sort(buses.begin(), buses.end());\\n        sort(passengers.begin(), passengers.end()); \\n\\t\\t// This dumb passenger is added not to check if all passengers are already gone\\n\\t\\tpassengers.push_back(INT_MAX);\\n        int res = INT_MIN;\\n        int idx = 0;\\n        int prevPassenger = 0;\\n        for (auto b : buses) {\\n            for (int i = 0; i < capacity; i++) {\\n                if (passengers[idx] <= b) {\\n                    if (prevPassenger != passengers[idx]-1) res = passengers[idx]-1;\\n                    prevPassenger = passengers[idx++];\\n                } else {\\n                    if (prevPassenger != b) res = b;\\n                    break;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\n    int latestTimeCatchTheBus(vector<int>& buses, vector<int>& passengers, int capacity) {\\n        int m = buses.size();\\n        int n = passengers.size();\\n        sort(buses.begin(), buses.end());\\n        sort(passengers.begin(), passengers.end()); \\n\\t\\t// This dumb passenger is added not to check if all passengers are already gone\\n\\t\\tpassengers.push_back(INT_MAX);\\n        int res = INT_MIN;\\n        int idx = 0;\\n        int prevPassenger = 0;\\n        for (auto b : buses) {\\n            for (int i = 0; i < capacity; i++) {\\n                if (passengers[idx] <= b) {\\n                    if (prevPassenger != passengers[idx]-1) res = passengers[idx]-1;\\n                    prevPassenger = passengers[idx++];\\n                } else {\\n                    if (prevPassenger != b) res = b;\\n                    break;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2260529,
                "title": "c-solution-explanation-greedy-easy-to-understand",
                "content": "One of the constraints defined within the problem description is that `2 <= buses[i], passengers[i] <= 109`. This guarantees us that we will always be able to catch a bus if we arrive at the time of `1`.\\n\\nWe can follow a straight-forward logic described in the following steps:\\n- We sort the array of passengers and busses so we can start from the beginning and iterate both of the collections in ascending order.\\n- We use a set to check if a passenger will arive at a given time with constant complexity.\\n- We need to find the **latest** time to catch a bus. There are three options:\\n\\t- As said in the beginning, if there are passengers arriving at every minute before all the busses depart, we have to arrive at the time of `1` in order to catch a bus.\\n\\t- If the bus that we can catch will be full (there are at least `capacity` waiting passengers), it is obvious that we should arrive before the last passenger. There we should be careful of chosing the right time: `You cannot arrive at the same time as another passenger.`\\n\\t- If the bus that we can catch will not be full (there are at less than `capacity` waiting passengers), it is obvious that arriving at the time of departure will be the best. Again, we should be careful of chosing the right time: `You cannot arrive at the same time as another passenger.` If any other passenger arrives at the time of departure, this is covered by the upper bullet - we will arrive before them and this is enough.\\n```C#\\npublic class Solution {\\n    public int LatestTimeCatchTheBus(int[] buses, int[] passengers, int capacity) {\\n        Array.Sort(buses);\\n        Array.Sort(passengers);\\n        HashSet<int> used = new HashSet<int>(passengers);\\n  \\n        int bi = 0, pi = 0, ans = 1;\\n        while (bi < buses.Length) {\\n            int end = Math.Min(passengers.Length, pi + capacity), t = 0;\\n            while (pi < end && passengers[pi] <= buses[bi]) {\\n                if (!used.Contains(passengers[pi] - 1)) ans = passengers[pi] - 1;\\n                pi++; t++;\\n            }\\n            \\n            if (t < capacity && !used.Contains(buses[bi])) ans = buses[bi];\\n            bi++;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```C#\\npublic class Solution {\\n    public int LatestTimeCatchTheBus(int[] buses, int[] passengers, int capacity) {\\n        Array.Sort(buses);\\n        Array.Sort(passengers);\\n        HashSet<int> used = new HashSet<int>(passengers);\\n  \\n        int bi = 0, pi = 0, ans = 1;\\n        while (bi < buses.Length) {\\n            int end = Math.Min(passengers.Length, pi + capacity), t = 0;\\n            while (pi < end && passengers[pi] <= buses[bi]) {\\n                if (!used.Contains(passengers[pi] - 1)) ans = passengers[pi] - 1;\\n                pi++; t++;\\n            }\\n            \\n            if (t < capacity && !used.Contains(buses[bi])) ans = buses[bi];\\n            bi++;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2259890,
                "title": "c-map-sorting",
                "content": "```\\nclass Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& buses, vector<int>& passengers, int capacity) {\\n        sort(buses.begin(),buses.end());      \\n        sort(passengers.begin(),passengers.end());\\n        map<int,int>hash;\\n        int ans=0,k=0;\\n        for(int i=0;i<buses.size();i++)\\n        {\\n            int size=0;\\n            int a;\\n            while(k<passengers.size()&&size<capacity&&passengers[k]<=buses[i])\\n            {\\n                a=passengers[k]-1;\\n                hash[passengers[k]]++;\\n                k++;\\n                size++;\\n                \\n            }\\n            if(size<capacity&&a!=buses[i]-1)\\n            {\\n                ans=buses[i];\\n                continue;\\n            }\\n            while(a>=ans)\\n            {\\n                if(hash.find(a)==hash.end())ans=max(ans,a);\\n                a--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& buses, vector<int>& passengers, int capacity) {\\n        sort(buses.begin(),buses.end());      \\n        sort(passengers.begin(),passengers.end());\\n        map<int,int>hash;\\n        int ans=0,k=0;\\n        for(int i=0;i<buses.size();i++)\\n        {\\n            int size=0;\\n            int a;\\n            while(k<passengers.size()&&size<capacity&&passengers[k]<=buses[i])\\n            {\\n                a=passengers[k]-1;\\n                hash[passengers[k]]++;\\n                k++;\\n                size++;\\n                \\n            }\\n            if(size<capacity&&a!=buses[i]-1)\\n            {\\n                ans=buses[i];\\n                continue;\\n            }\\n            while(a>=ans)\\n            {\\n                if(hash.find(a)==hash.end())ans=max(ans,a);\\n                a--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2259515,
                "title": "well-commented-python-code",
                "content": "Sort both arrays.\\nfill buses fufiling giving critereas.\\nafter filling buses, if some buses are empty iterate bacwards from last departure time. -->during contest i was going foraward from last passenger encounterd :( \\nelse take the time of last passenger time and iterate backwards till available time is encountered.\\n```\\nclass Solution:\\n    def latestTimeCatchTheBus(self, buses: List[int], passengers: List[int], capacity: int) -> int:\\n        buses.sort()\\n        passengers.sort()\\n        np=0                                                             #maintains the index of next passenger\\n        for b in buses:\\n            last=False                                                   #bus is not initially full so last is intialized with False\\n            cb=capacity\\n            while cb!=0 and np<len(passengers) and passengers[np]<=b:    #for every bus fill passengers in it till conditions are satisfied\\n                np+=1\\n                cb-=1\\n            if cb==0:                                                    #when capacity is full last becomes true\\n                last=True\\n            \\n        if last==True:                                      #if last is true means all buses are full so take time of last passenger encounterd\\n            avail=passengers[np-1]\\n        else:                                               #if last is full means some buses have capacity left. So come as late as possible\\n            avail=buses[-1]\\n            \\n        for i in range(avail,0,-1):                         #from avail iterate backwards till first available time encounters\\n            if not i in passengers:\\n                return i\\n            \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def latestTimeCatchTheBus(self, buses: List[int], passengers: List[int], capacity: int) -> int:\\n        buses.sort()\\n        passengers.sort()\\n        np=0                                                             #maintains the index of next passenger\\n        for b in buses:\\n            last=False                                                   #bus is not initially full so last is intialized with False\\n            cb=capacity\\n            while cb!=0 and np<len(passengers) and passengers[np]<=b:    #for every bus fill passengers in it till conditions are satisfied\\n                np+=1\\n                cb-=1\\n            if cb==0:                                                    #when capacity is full last becomes true\\n                last=True\\n            \\n        if last==True:                                      #if last is true means all buses are full so take time of last passenger encounterd\\n            avail=passengers[np-1]\\n        else:                                               #if last is full means some buses have capacity left. So come as late as possible\\n            avail=buses[-1]\\n            \\n        for i in range(avail,0,-1):                         #from avail iterate backwards till first available time encounters\\n            if not i in passengers:\\n                return i\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2259457,
                "title": "python-greedy-o-nlogn",
                "content": "```\\nclass Solution:\\n    def latestTimeCatchTheBus(self, buses: List[int], passengers: List[int], capacity: int) -> int:\\n        buses.sort()\\n        passengers.sort()\\n        i = 0 \\n        onboard = set()\\n        for bus in buses:\\n            curcap = 0\\n            while i < len(passengers) and curcap < capacity and passengers[i] <= bus:\\n                onboard.add(passengers[i])\\n                i += 1\\n                curcap += 1\\n        if curcap == capacity:\\n            for j in range(i-1,-1,-1):\\n                if j:\\n                    if passengers[j]-1 != passengers[j-1]:\\n                        return passengers[j] - 1\\n                else:\\n                    return passengers[j] - 1\\n        else:\\n            for t in range(buses[-1],-1,-1):\\n                if t not in onboard:\\n                    return t",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def latestTimeCatchTheBus(self, buses: List[int], passengers: List[int], capacity: int) -> int:\\n        buses.sort()\\n        passengers.sort()\\n        i = 0 \\n        onboard = set()\\n        for bus in buses:\\n            curcap = 0\\n            while i < len(passengers) and curcap < capacity and passengers[i] <= bus:\\n                onboard.add(passengers[i])\\n                i += 1\\n                curcap += 1\\n        if curcap == capacity:\\n            for j in range(i-1,-1,-1):\\n                if j:\\n                    if passengers[j]-1 != passengers[j-1]:\\n                        return passengers[j] - 1\\n                else:\\n                    return passengers[j] - 1\\n        else:\\n            for t in range(buses[-1],-1,-1):\\n                if t not in onboard:\\n                    return t",
                "codeTag": "Java"
            },
            {
                "id": 2259400,
                "title": "sorting-c-just-maximise-the-possible-and-available-times",
                "content": "Use 2 pointers to traverse the both arrays.\\nKeep traversing and maximising that the possible time is not coinciding with any passengers time.\\n\\n```\\nclass Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& bus, vector<int>& p, int cap) {\\n        int i=0,j=0;\\n        \\n        sort(begin(bus),end(bus));\\n        sort(begin(p),end(p));\\n        \\n        unordered_set<int> st(p.begin(),p.end());\\n        \\n        int cur = 0;\\n        int res = 1;\\n        \\n        while(i<bus.size() and j<p.size())\\n        {\\n            cur = 0;\\n            \\n            while(cur<cap and j<p.size() and p[j]<=bus[i])\\n            {\\n                cur++;\\n                if(j>0 and p[j]>p[j-1]+1)\\n                {\\n                    res = max(res,p[j]-1);\\n                }else if(j==0)\\n                {\\n                    res = max(res,p[j]-1);\\n                }\\n                \\n                j++;\\n            }\\n            \\n            if(cur<cap)\\n            {\\n                if(st.find(bus[i])==st.end())\\n                res = max(res,bus[i]);\\n            }\\n            \\n            i++;\\n        }\\n        \\n        if(i<bus.size())\\n        {\\n            return bus.back();\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& bus, vector<int>& p, int cap) {\\n        int i=0,j=0;\\n        \\n        sort(begin(bus),end(bus));\\n        sort(begin(p),end(p));\\n        \\n        unordered_set<int> st(p.begin(),p.end());\\n        \\n        int cur = 0;\\n        int res = 1;\\n        \\n        while(i<bus.size() and j<p.size())\\n        {\\n            cur = 0;\\n            \\n            while(cur<cap and j<p.size() and p[j]<=bus[i])\\n            {\\n                cur++;\\n                if(j>0 and p[j]>p[j-1]+1)\\n                {\\n                    res = max(res,p[j]-1);\\n                }else if(j==0)\\n                {\\n                    res = max(res,p[j]-1);\\n                }\\n                \\n                j++;\\n            }\\n            \\n            if(cur<cap)\\n            {\\n                if(st.find(bus[i])==st.end())\\n                res = max(res,bus[i]);\\n            }\\n            \\n            i++;\\n        }\\n        \\n        if(i<bus.size())\\n        {\\n            return bus.back();\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2259397,
                "title": "easy-java-solution",
                "content": "\\nclass Solution {\\n\\n    public int latestTimeCatchTheBus(int[] bus, int[] pass, int c) {\\n\\t\\n        Arrays.sort(bus);\\n        Arrays.sort(pass);\\n\\n        \\n        HashSet<Integer> set = new HashSet<>();\\n        for(int i = 0 ; i < pass.length ; i ++) set.add(pass[i]);\\n        \\n        int s = 0;\\n        int ans = -1;\\n        for(int i = 0 ; i < bus.length ; i ++){\\n            int[] v = helper(pass, c, bus[i], s);\\n\\n            if(v[1] < c && v[0] != bus[i]){\\n                ans = bus[i];\\n            }else {\\n                \\n                while(set.contains(v[0])){\\n                    v[0]--;\\n                }\\n                ans = v[0];\\n            }    \\n            \\n            s = v[2];\\n        }\\n        \\n        return ans;\\n            \\n            \\n    }\\n    \\n    public int[] helper(int[] arr, int c, int bt, int s){\\n        int[] ans = new int[3];\\n        int i = s;\\n        int x = 0;\\n        while(i < arr.length){\\n            if(x == c || arr[i] > bt) break;\\n            if(arr[i] <= bt){\\n                ans[0] = arr[i];\\n                x++;\\n            }\\n            i++;\\n        }\\n        ans[1] = x;\\n        ans[2] = i;\\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "class Solution {\\n\\n    public int latestTimeCatchTheBus(int[] bus, int[] pass, int c) {\\n\\t\\n        Arrays.sort(bus);\\n        Arrays.sort(pass);\\n\\n        \\n        HashSet<Integer> set = new HashSet<>();\\n        for(int i = 0 ; i < pass.length ; i ++) set.add(pass[i]);\\n        \\n        int s = 0;\\n        int ans = -1;\\n        for(int i = 0 ; i < bus.length ; i ++){\\n            int[] v = helper(pass, c, bus[i], s);\\n\\n            if(v[1] < c && v[0] != bus[i]){\\n                ans = bus[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2259303,
                "title": "python3-greedy-sorting-hashmap-solution",
                "content": "Basically when we see the words \"unique\" in the question, its better to go with set or hasmap and i used both here.\\n\\nWe first populate the valid passengers boarding each of the bus in the \"pickup\" hashmap.\\nVariable i is used to board passengers while the variable j is used to pick the appropriate bus.\\nIf the arrival time of user > boarding time of bus or if the bus is full, we choose the next bus for the passengers.\\nElse we board the current passenger and move to the next passenger.\\n\\nThen we start from the last bus since we need the \"latest::largest valid time\" valid boarding time for the user.\\n\\nWe check if the last bus is full or not.\\n\\nIf it is full, then we start with the arrival time of the last passenger that got inside the last bus and go on checking lineraly until we find the last time where we could get in.\\nEg for bus time of 30, if the passengers are [19,21] && capacity=2, then if we arrive after 21, we cannot get in since earliest passengers have higher preference.\\nHence we start with 21 and check for number smaller than 21 that is not in the passengers set which is 20 here.\\n\\nif it is not full,we can greedily start with the bus time \"y\" itself (since you cannot get into the last bus if your arrival time > y) and check for a valid time to board in.\\n\\nSince we cannot arrive at the same time of the passenger, we run a while loop until the arrival time is not present in the passengers set.\\n\\nas soon as we find such an arrival time ,we return it.\\n```\\nclass Solution:\\n    def latestTimeCatchTheBus(self, buses: List[int], passengers: List[int], capacity: int) -> int:\\n        buses.sort()\\n        customers = [passenger for passenger in passengers]\\n        customers.sort()\\n        passengers = set(passengers)\\n\\n        pickup = {}\\n        for bus in buses:\\n            pickup[bus] = []\\n\\n        i,j = 0,0\\n        while i<len(buses) and j<len(customers):\\n            arrival = customers[j]\\n            leave = buses[i]\\n\\n            if arrival>leave:\\n                i+=1\\n            else:\\n                if len(pickup[leave])==capacity:\\n                    i+=1\\n                else:\\n                    pickup[leave].append(arrival)\\n                    j+=1\\n\\n        print(pickup)\\n\\n        size = len(pickup[buses[-1]])\\n        if size==capacity:\\n            #if its filled, you should be before the last arriving passenger to get a seat\\n            person = pickup[bus][-1]\\n        else:\\n            #if its not filled, start from last possible time\\n            person = buses[-1]\\n\\n        while person in passengers:\\n                person-=1\\n        return person\\n```",
                "solutionTags": [
                    "Python",
                    "Hash Table",
                    "Greedy",
                    "Sorting",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def latestTimeCatchTheBus(self, buses: List[int], passengers: List[int], capacity: int) -> int:\\n        buses.sort()\\n        customers = [passenger for passenger in passengers]\\n        customers.sort()\\n        passengers = set(passengers)\\n\\n        pickup = {}\\n        for bus in buses:\\n            pickup[bus] = []\\n\\n        i,j = 0,0\\n        while i<len(buses) and j<len(customers):\\n            arrival = customers[j]\\n            leave = buses[i]\\n\\n            if arrival>leave:\\n                i+=1\\n            else:\\n                if len(pickup[leave])==capacity:\\n                    i+=1\\n                else:\\n                    pickup[leave].append(arrival)\\n                    j+=1\\n\\n        print(pickup)\\n\\n        size = len(pickup[buses[-1]])\\n        if size==capacity:\\n            #if its filled, you should be before the last arriving passenger to get a seat\\n            person = pickup[bus][-1]\\n        else:\\n            #if its not filled, start from last possible time\\n            person = buses[-1]\\n\\n        while person in passengers:\\n                person-=1\\n        return person\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2259157,
                "title": "simple-c",
                "content": "**Explanation:**\\n```lessThan``` - In this function iterating the list of passenger to get first time which is less than equal to our latest time, since current user can not be reach at same time of any other passenger.\\n\\n**C++ Code:**\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int lessThan(int x, set<int> &s)\\n    {\\n        while(s.find(x) != s.end())  x--;\\n        return x;\\n    }\\n    int latestTimeCatchTheBus(vector<int>& b, vector<int>& p, int capacity) {\\n        sort(b.begin(), b.end());\\n        sort(p.begin(), p.end());\\n        set<int> s(p.begin(), p.end());\\n        int j=0, c = 0;\\n        \\n        for(int i=0; (i<p.size()) && (j<b.size()); i++)\\n        {\\n            if(p[i] <= b[j]) c++;\\n            else\\n            {\\n                j++;  i--;\\n                c = 0;\\n            }\\n            if( (j == b.size()-1) && (c == capacity) )\\n                return lessThan(p[i], s);\\n            \\n            if(c == capacity)\\n            {\\n                j++;\\n                c = 0;\\n            }\\n        }\\n        \\n        return lessThan(b.back(), s);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```lessThan```\n```cpp\\nclass Solution {\\npublic:\\n    int lessThan(int x, set<int> &s)\\n    {\\n        while(s.find(x) != s.end())  x--;\\n        return x;\\n    }\\n    int latestTimeCatchTheBus(vector<int>& b, vector<int>& p, int capacity) {\\n        sort(b.begin(), b.end());\\n        sort(p.begin(), p.end());\\n        set<int> s(p.begin(), p.end());\\n        int j=0, c = 0;\\n        \\n        for(int i=0; (i<p.size()) && (j<b.size()); i++)\\n        {\\n            if(p[i] <= b[j]) c++;\\n            else\\n            {\\n                j++;  i--;\\n                c = 0;\\n            }\\n            if( (j == b.size()-1) && (c == capacity) )\\n                return lessThan(p[i], s);\\n            \\n            if(c == capacity)\\n            {\\n                j++;\\n                c = 0;\\n            }\\n        }\\n        \\n        return lessThan(b.back(), s);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3891272,
                "title": "easiest-one",
                "content": "# Code\\n```\\nclass Solution:\\n    def latestTimeCatchTheBus(self, buses: List[int], passengers: List[int], capacity: int) -> int:\\n        buses.sort()\\n        passengers.sort()\\n\\n        index = 0\\n\\n        for start in buses:\\n            cap = capacity\\n            while index < len(passengers) and start >= passengers[index] and cap > 0:\\n                cap -= 1\\n                index += 1\\n\\n        latest = start if cap > 0 else passengers[index-1] \\n\\n        while latest in set(passengers):\\n            latest -= 1\\n        return latest       \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def latestTimeCatchTheBus(self, buses: List[int], passengers: List[int], capacity: int) -> int:\\n        buses.sort()\\n        passengers.sort()\\n\\n        index = 0\\n\\n        for start in buses:\\n            cap = capacity\\n            while index < len(passengers) and start >= passengers[index] and cap > 0:\\n                cap -= 1\\n                index += 1\\n\\n        latest = start if cap > 0 else passengers[index-1] \\n\\n        while latest in set(passengers):\\n            latest -= 1\\n        return latest       \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3159086,
                "title": "c-sort-binary-search",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n$$O(n.logn)$$ -->\\n- Space complexity:\\n$$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& b, vector<int>& p, int cap) {\\n        int n1 = b.size() , n2 = p.size() , j=0 , ans;\\n        unordered_set<int> st;\\n        sort(b.begin() , b.end());\\n        sort(p.begin() , p.end());\\n\\n        for(int i=0; i<n1; i++){\\n            int c=0;\\n            while(c<cap && j<n2 && p[j]<=b[i]){\\n                if(st.find(p[j]-1) == st.end())\\n                    ans = p[j]-1;\\n                st.insert(p[j]);\\n                c++;\\n                j++;\\n            }\\n            if(c<cap && st.find(b[i]) == st.end()) ans=b[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Two Pointers",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& b, vector<int>& p, int cap) {\\n        int n1 = b.size() , n2 = p.size() , j=0 , ans;\\n        unordered_set<int> st;\\n        sort(b.begin() , b.end());\\n        sort(p.begin() , p.end());\\n\\n        for(int i=0; i<n1; i++){\\n            int c=0;\\n            while(c<cap && j<n2 && p[j]<=b[i]){\\n                if(st.find(p[j]-1) == st.end())\\n                    ans = p[j]-1;\\n                st.insert(p[j]);\\n                c++;\\n                j++;\\n            }\\n            if(c<cap && st.find(b[i]) == st.end()) ans=b[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2536978,
                "title": "c-two-pointers-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& b, vector<int>& p, int cap)\\n    {\\n        int n=b.size(),m=p.size();\\n        sort(b.begin(),b.end());\\n        sort(p.begin(),p.end());\\n        int j=0,ans,prev=-1;\\n        for(int i=0;i<n;i++)\\n        {\\n            int c=0;\\n            while(j<m&&c<cap&&p[j]<=b[i])\\n            {\\n                if(p[j]-1!=prev)\\n                    ans=p[j]-1;\\n                prev=p[j];\\n                c++;\\n                j++;\\n            }\\n            if(c<cap&&b[i]!=prev)\\n                ans=b[i];\\n        }\\n        return ans;\\n        \\n    }\\n};\\n//if you like the solution plz upvote.",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "class Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& b, vector<int>& p, int cap)\\n    {\\n        int n=b.size(),m=p.size();\\n        sort(b.begin(),b.end());\\n        sort(p.begin(),p.end());\\n        int j=0,ans,prev=-1;\\n        for(int i=0;i<n;i++)\\n        {\\n            int c=0;\\n            while(j<m&&c<cap&&p[j]<=b[i])\\n            {\\n                if(p[j]-1!=prev)\\n                    ans=p[j]-1;\\n                prev=p[j];\\n                c++;\\n                j++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2502862,
                "title": "c-simple-logic-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    /* \\n       p=[0, 1, 3, 5]\\n       b=[4, 10]\\n             |\\n       cap = 2\\n       \\n       {0, 1}\\n       \\n        \\n    */\\n    int latestTimeCatchTheBus(vector<int>& buses, vector<int>& passengers, int capacity) {\\n        int latest = 1;\\n        priority_queue<int, vector<int>, greater<int>> nextBus, nextPas;\\n        unordered_set<int> seenPas;\\n        \\n\\t\\t// sort all buses and passengers in inc order (min heap)\\n        for (auto b : buses) nextBus.push(b);\\n        for (auto p : passengers) nextPas.push(p);\\n        \\n        while (!nextBus.empty()) {\\n\\t\\t\\t// next bus time & seats left\\n            int b = nextBus.top(); nextBus.pop();\\n            int capLeft = capacity;\\n            \\n            while (!nextPas.empty() && nextPas.top() <= b && capLeft > 0) {\\n\\t\\t\\t\\t// if pas arrives before b, they can get onto the bus\\n\\t\\t\\t\\t// add this passenger to seen since can\\'t have two passengers arriving at same time\\n                seenPas.insert(nextPas.top());\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// if no one has arrived just before pas, use that to update latest\\n                if (!seenPas.count(nextPas.top()-1)) latest = nextPas.top()-1;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// discard passenger\\n                nextPas.pop();\\n                \\n\\t\\t\\t\\t// dec seats left\\n\\t\\t\\t\\t--capLeft;\\n            }\\n            \\n\\t\\t\\t// if current bus has some seats left, look for the latest time that is not there in seen\\n\\t\\t\\t// use that to update latest\\n            if (capLeft > 0) {\\n                int time = b;\\n                while (time >= latest && seenPas.count(time)) --time;\\n                latest = time;\\n            }   \\n        }\\n        \\n        return latest;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    /* \\n       p=[0, 1, 3, 5]\\n       b=[4, 10]\\n             |\\n       cap = 2\\n       \\n       {0, 1}\\n       \\n        \\n    */\\n    int latestTimeCatchTheBus(vector<int>& buses, vector<int>& passengers, int capacity) {\\n        int latest = 1;\\n        priority_queue<int, vector<int>, greater<int>> nextBus, nextPas;\\n        unordered_set<int> seenPas;\\n        \\n\\t\\t// sort all buses and passengers in inc order (min heap)\\n        for (auto b : buses) nextBus.push(b);\\n        for (auto p : passengers) nextPas.push(p);\\n        \\n        while (!nextBus.empty()) {\\n\\t\\t\\t// next bus time & seats left\\n            int b = nextBus.top(); nextBus.pop();\\n            int capLeft = capacity;\\n            \\n            while (!nextPas.empty() && nextPas.top() <= b && capLeft > 0) {\\n\\t\\t\\t\\t// if pas arrives before b, they can get onto the bus\\n\\t\\t\\t\\t// add this passenger to seen since can\\'t have two passengers arriving at same time\\n                seenPas.insert(nextPas.top());\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// if no one has arrived just before pas, use that to update latest\\n                if (!seenPas.count(nextPas.top()-1)) latest = nextPas.top()-1;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// discard passenger\\n                nextPas.pop();\\n                \\n\\t\\t\\t\\t// dec seats left\\n\\t\\t\\t\\t--capLeft;\\n            }\\n            \\n\\t\\t\\t// if current bus has some seats left, look for the latest time that is not there in seen\\n\\t\\t\\t// use that to update latest\\n            if (capLeft > 0) {\\n                int time = b;\\n                while (time >= latest && seenPas.count(time)) --time;\\n                latest = time;\\n            }   \\n        }\\n        \\n        return latest;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2311329,
                "title": "java-solution",
                "content": "Fill all the bus except the last bus.\\nFind the people who will take the last bus.\\nIf the last bus has remaining seat, back track from the bus departure time. If no remaing seat, back track from the last people who takes the last bus.\\n```\\nclass Solution {\\n    public int latestTimeCatchTheBus(int[] buses, int[] passengers, int capacity) {\\n        Arrays.sort(buses);\\n        Arrays.sort(passengers);\\n        \\n        int j = 0;\\n        int remaining;\\n        for (int i = 0; i < buses.length - 1; i++) {\\n            remaining = capacity;\\n            int time = buses[i];\\n            while (j < passengers.length && passengers[j] <= time && remaining > 0) {\\n                remaining--;\\n                j++;\\n            }\\n        }\\n        if (j == passengers.length) return buses[buses.length - 1];\\n\\n        remaining = capacity;\\n        while (j < passengers.length && passengers[j] <= buses[buses.length - 1] && remaining > 0) {\\n            remaining--;\\n            j++;\\n        }\\n        int t = remaining > 0 ? buses[buses.length - 1] : passengers[j-1];\\n        for (int k = j - 1; k >= 0; k--) {\\n            if (passengers[k] != t) {\\n                return t;\\n            }\\n            t--;\\n        }\\n        return t;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int latestTimeCatchTheBus(int[] buses, int[] passengers, int capacity) {\\n        Arrays.sort(buses);\\n        Arrays.sort(passengers);\\n        \\n        int j = 0;\\n        int remaining;\\n        for (int i = 0; i < buses.length - 1; i++) {\\n            remaining = capacity;\\n            int time = buses[i];\\n            while (j < passengers.length && passengers[j] <= time && remaining > 0) {\\n                remaining--;\\n                j++;\\n            }\\n        }\\n        if (j == passengers.length) return buses[buses.length - 1];\\n\\n        remaining = capacity;\\n        while (j < passengers.length && passengers[j] <= buses[buses.length - 1] && remaining > 0) {\\n            remaining--;\\n            j++;\\n        }\\n        int t = remaining > 0 ? buses[buses.length - 1] : passengers[j-1];\\n        for (int k = j - 1; k >= 0; k--) {\\n            if (passengers[k] != t) {\\n                return t;\\n            }\\n            t--;\\n        }\\n        return t;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2276195,
                "title": "java-brute-force-to-optimized-easy-solution",
                "content": "**Brute force: `sc: O(n)`**\\n```\\n    public int latestTimeCatchTheBus(int[] buses, int[] passengers, int capacity) {\\n        Arrays.sort(buses);\\n        Arrays.sort(passengers);\\n        HashSet<Integer> set = new HashSet<>();\\n        int ans = 0, j = 0;\\n\\n        for(int i = 0; i < passengers.length; i++) set.add(passengers[i]);\\n        \\n        for(int i = 0; i < buses.length; i++) {\\n            int space = capacity;\\n            while(j < passengers.length && space > 0 && passengers[j] <= buses[i]) {\\n                ans = passengers[j];\\n                j++;\\n                space--;\\n            }\\n            if(t != 0) ans = buses[i];\\n        }\\n\\t\\t\\n        while(set.contains(ans)) ans--;\\n        \\n        return ans;\\n    }\\n```\\nThanks to [@virendra115](https://leetcode.com/virendra115/) for optimized solution.\\n**Optimized: `sc: O(1)`**\\n```\\n    public int latestTimeCatchTheBus(int[] buses, int[] passengers, int capacity) {\\n        Arrays.sort(buses);\\n        Arrays.sort(passengers);\\n        \\n        if(passengers[0] > buses[buses.length - 1]) return buses[buses.length - 1];\\n        int ans = passengers[0] - 1, j = 0;\\n        \\n        for(int i = 0; i < buses.length; i++) {\\n            int space = capacity;\\n            while(j < passengers.length && space > 0 && passengers[j] <= buses[i]) {\\n                if(j > 0 && passengers[j] - passengers[j-1] != 1) ans = passengers[j] - 1;\\n                j++;\\n                space--;\\n            }\\n            \\n            if(j > 0 && space > 0 && buses[i] != passengers[j-1]) ans = buses[i];\\n        }\\n                \\n        return ans;\\n    }\\n```\\n**Upvote^, If you liked it.**\\n*Comment down, If you have any doubt.*",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\n    public int latestTimeCatchTheBus(int[] buses, int[] passengers, int capacity) {\\n        Arrays.sort(buses);\\n        Arrays.sort(passengers);\\n        HashSet<Integer> set = new HashSet<>();\\n        int ans = 0, j = 0;\\n\\n        for(int i = 0; i < passengers.length; i++) set.add(passengers[i]);\\n        \\n        for(int i = 0; i < buses.length; i++) {\\n            int space = capacity;\\n            while(j < passengers.length && space > 0 && passengers[j] <= buses[i]) {\\n                ans = passengers[j];\\n                j++;\\n                space--;\\n            }\\n            if(t != 0) ans = buses[i];\\n        }\\n\\t\\t\\n        while(set.contains(ans)) ans--;\\n        \\n        return ans;\\n    }\\n```\n```\\n    public int latestTimeCatchTheBus(int[] buses, int[] passengers, int capacity) {\\n        Arrays.sort(buses);\\n        Arrays.sort(passengers);\\n        \\n        if(passengers[0] > buses[buses.length - 1]) return buses[buses.length - 1];\\n        int ans = passengers[0] - 1, j = 0;\\n        \\n        for(int i = 0; i < buses.length; i++) {\\n            int space = capacity;\\n            while(j < passengers.length && space > 0 && passengers[j] <= buses[i]) {\\n                if(j > 0 && passengers[j] - passengers[j-1] != 1) ans = passengers[j] - 1;\\n                j++;\\n                space--;\\n            }\\n            \\n            if(j > 0 && space > 0 && buses[i] != passengers[j-1]) ans = buses[i];\\n        }\\n                \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2265905,
                "title": "c-easy-detailed-explanation",
                "content": "Algorithm:\\n1. We do not care about which passengers go into which bus, just that the passengers arriving early catch the early leaving buses. So we can safey sort bus timings and passenger timings.\\n2. We want our passenger(Let\\'s call her Shweta) to arrive at the LAST time possible. So we greedily fill each bus with passengers. We also want Shweta to catch the last bus as that will allow for LAST time.\\n3. Two cases can arise: Bus is filled till capacity, Bus has empty space.\\n4. If bus is filled till capacity, we go to the last time that a passenger arrived for the bus and Shweta arrives just before that. If the bus is not filled, it is enough for Shweta to arrive at bus departure time only if no other passenger arrives at that buses departure time.\\n\\n```\\nclass Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& buses, vector<int>& passengers, int capacity) {\\n        \\n        int total_buses = buses.size();\\n        int total_passengers = passengers.size();\\n        \\n        sort(buses.begin(),buses.end());\\n        sort(passengers.begin(),passengers.end());\\n\\n        int bus_time = 0;\\n        int cap = 0;\\n        int curr = 0;\\n        \\n        for(int i=0;i<total_buses;i++) {\\n            bus_time = buses[i];\\n            cap = capacity;\\n            while(curr<total_passengers && passengers[curr]<=bus_time && cap>0) {\\n                cap--;\\n                curr++;\\n            }\\n        }\\n        \\n        int best = 0;\\n        \\n        if(cap>0) {\\n            best = bus_time;\\n        } else {\\n            best = passengers[curr-1];\\n        }\\n        \\n        unordered_set<int> passenger_set(passengers.begin(),passengers.end());\\n        \\n       \\n        while(passenger_set.count(best)) {\\n            best--;\\n        }\\n        \\n        return best;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& buses, vector<int>& passengers, int capacity) {\\n        \\n        int total_buses = buses.size();\\n        int total_passengers = passengers.size();\\n        \\n        sort(buses.begin(),buses.end());\\n        sort(passengers.begin(),passengers.end());\\n\\n        int bus_time = 0;\\n        int cap = 0;\\n        int curr = 0;\\n        \\n        for(int i=0;i<total_buses;i++) {\\n            bus_time = buses[i];\\n            cap = capacity;\\n            while(curr<total_passengers && passengers[curr]<=bus_time && cap>0) {\\n                cap--;\\n                curr++;\\n            }\\n        }\\n        \\n        int best = 0;\\n        \\n        if(cap>0) {\\n            best = bus_time;\\n        } else {\\n            best = passengers[curr-1];\\n        }\\n        \\n        unordered_set<int> passenger_set(passengers.begin(),passengers.end());\\n        \\n       \\n        while(passenger_set.count(best)) {\\n            best--;\\n        }\\n        \\n        return best;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2263756,
                "title": "easy-c-solution-using-sort-and-an-unordered-set",
                "content": "```\\nclass Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& buses, vector<int>& passengers, int capacity) {\\n        \\n        sort(passengers.begin(), passengers.end());\\n        sort(buses.begin(), buses.end());\\n        \\n        unordered_set<int> exist(passengers.begin(), passengers.end());\\n        \\n        int ans = 0;\\n        int ptr = 0;\\n        \\n        for(int i = 0; i < buses.size() - 1; i++) {\\n            int k = capacity;\\n            while(k > 0 and buses[i] >= passengers[ptr]) {\\n                ptr++;\\n                k--;\\n            }\\n        }\\n        \\n        while(capacity - 1 > 0 and ptr < passengers.size()) {\\n            ptr++;\\n            capacity--;\\n        }\\n        \\n        if(passengers.size() == ptr) \\n            ans = buses.back();\\n        \\n        else\\n            ans = passengers[ptr];\\n        \\n        \\n        while(exist.find(ans) != exist.end() or ans > buses.back()) {\\n            ans--;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& buses, vector<int>& passengers, int capacity) {\\n        \\n        sort(passengers.begin(), passengers.end());\\n        sort(buses.begin(), buses.end());\\n        \\n        unordered_set<int> exist(passengers.begin(), passengers.end());\\n        \\n        int ans = 0;\\n        int ptr = 0;\\n        \\n        for(int i = 0; i < buses.size() - 1; i++) {\\n            int k = capacity;\\n            while(k > 0 and buses[i] >= passengers[ptr]) {\\n                ptr++;\\n                k--;\\n            }\\n        }\\n        \\n        while(capacity - 1 > 0 and ptr < passengers.size()) {\\n            ptr++;\\n            capacity--;\\n        }\\n        \\n        if(passengers.size() == ptr) \\n            ans = buses.back();\\n        \\n        else\\n            ans = passengers[ptr];\\n        \\n        \\n        while(exist.find(ans) != exist.end() or ans > buses.back()) {\\n            ans--;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2263454,
                "title": "find-last-bus-passengers-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& b, vector<int>& p, int c) {\\n        sort(b.begin(), b.end());\\n        sort(p.begin(), p.end());\\n        \\n        int i = 0, j = 0, k = c;\\n        vector<int> lbp; //last bus passengers\\n        \\n        while(true) { //loop for finding last bus passengers\\n            if(!k) i++, k = c;\\n            if(i >= b.size() || j >= p.size()) break;\\n            \\n            if(b[i] >= p[j]) {\\n                if(i == b.size() - 1) lbp.push_back(p[j]);\\n                j++;\\n                k--;\\n            }\\n            else i++, k = c;    \\n        }\\n\\n        if(!lbp.size() || (lbp.size() < c && lbp.back() != b.back())) return b.back(); //edge cases\\n        \\n        unordered_set<int> s(p.begin(), p.end());\\n        for(int i=lbp.back(); i>=0; i--) {\\n            if(s.find(i) == s.end()) return i;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Sorting",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& b, vector<int>& p, int c) {\\n        sort(b.begin(), b.end());\\n        sort(p.begin(), p.end());\\n        \\n        int i = 0, j = 0, k = c;\\n        vector<int> lbp; //last bus passengers\\n        \\n        while(true) { //loop for finding last bus passengers\\n            if(!k) i++, k = c;\\n            if(i >= b.size() || j >= p.size()) break;\\n            \\n            if(b[i] >= p[j]) {\\n                if(i == b.size() - 1) lbp.push_back(p[j]);\\n                j++;\\n                k--;\\n            }\\n            else i++, k = c;    \\n        }\\n\\n        if(!lbp.size() || (lbp.size() < c && lbp.back() != b.back())) return b.back(); //edge cases\\n        \\n        unordered_set<int> s(p.begin(), p.end());\\n        for(int i=lbp.back(); i>=0; i--) {\\n            if(s.find(i) == s.end()) return i;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2262996,
                "title": "c-greedy-solution",
                "content": "We fill buses one after one while checking the two main possibilities:\\n\\n1. If it\\'s possible to come just (`1` miniute) before the `passIndex`-th passenger\\n2. If it\\'s possible to come just befofe `busIndex` departure  \\n\\n```\\npublic class Solution {\\n    \\n    public int LatestTimeCatchTheBus(int[] buses, int[] passengers, int capacity) {\\n      Array.Sort(buses);\\n      Array.Sort(passengers);\\n\\n      int result = int.MinValue;\\n      int passIndex = 0;\\n\\n      for (int busIndex = 0; busIndex < buses.Length; ++busIndex) {\\n        int line = 0;\\n\\n        for (; passIndex < passengers.Length && line < capacity && passengers[passIndex] <= buses[busIndex]; ++line, ++passIndex) \\n          if (Array.BinarySearch(passengers, passengers[passIndex] - 1) < 0) \\n            result = passengers[passIndex] - 1;\\n\\n        if (line < capacity && Array.BinarySearch(passengers, buses[busIndex]) < 0) \\n          result = buses[busIndex];\\n      }\\n\\n      return result;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\npublic class Solution {\\n    \\n    public int LatestTimeCatchTheBus(int[] buses, int[] passengers, int capacity) {\\n      Array.Sort(buses);\\n      Array.Sort(passengers);\\n\\n      int result = int.MinValue;\\n      int passIndex = 0;\\n\\n      for (int busIndex = 0; busIndex < buses.Length; ++busIndex) {\\n        int line = 0;\\n\\n        for (; passIndex < passengers.Length && line < capacity && passengers[passIndex] <= buses[busIndex]; ++line, ++passIndex) \\n          if (Array.BinarySearch(passengers, passengers[passIndex] - 1) < 0) \\n            result = passengers[passIndex] - 1;\\n\\n        if (line < capacity && Array.BinarySearch(passengers, buses[busIndex]) < 0) \\n          result = buses[busIndex];\\n      }\\n\\n      return result;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2262988,
                "title": "c-o-nlog-n-mlog-m-time-o-n-m-space-1200-ms",
                "content": "```\\nclass Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& buses, vector<int>& passengers, int capacity) {\\n        map<int,unordered_set<int>> t;\\n        unordered_set pset(passengers.begin(),passengers.end());\\n        sort(buses.begin(), buses.end());\\n        sort(passengers.begin(),passengers.end());\\n        int j = 0;\\n        \\n        for(int i: buses){\\n            t[i] = unordered_set<int>();\\n            while(j < passengers.size() && passengers[j] <= i && t[i].size() < capacity){\\n                t[i].insert(passengers[j]);\\n                j++;\\n            } \\n        }\\n        int z = 0;\\n        int p = 0;\\n        unordered_set<int> r;\\n        for(auto it: t){\\n            if(it.second.size() < capacity || it.first - z > capacity){\\n                r = it.second;\\n                p = it.first;\\n            }\\n            z = it.first;\\n        }\\n        \\n        if(r.size() == capacity){\\n            int e = 0;\\n            for(int q: r){\\n                e = max(e,q);\\n            }\\n            p = e;\\n        }\\n        \\n        while(r.find(p) != r.end() || pset.find(p) != pset.end()){\\n            p--;\\n        }\\n        return p;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& buses, vector<int>& passengers, int capacity) {\\n        map<int,unordered_set<int>> t;\\n        unordered_set pset(passengers.begin(),passengers.end());\\n        sort(buses.begin(), buses.end());\\n        sort(passengers.begin(),passengers.end());\\n        int j = 0;\\n        \\n        for(int i: buses){\\n            t[i] = unordered_set<int>();\\n            while(j < passengers.size() && passengers[j] <= i && t[i].size() < capacity){\\n                t[i].insert(passengers[j]);\\n                j++;\\n            } \\n        }\\n        int z = 0;\\n        int p = 0;\\n        unordered_set<int> r;\\n        for(auto it: t){\\n            if(it.second.size() < capacity || it.first - z > capacity){\\n                r = it.second;\\n                p = it.first;\\n            }\\n            z = it.first;\\n        }\\n        \\n        if(r.size() == capacity){\\n            int e = 0;\\n            for(int q: r){\\n                e = max(e,q);\\n            }\\n            p = e;\\n        }\\n        \\n        while(r.find(p) != r.end() || pset.find(p) != pset.end()){\\n            p--;\\n        }\\n        return p;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2260725,
                "title": "simulation",
                "content": "```cpp\\nsort(begin(buses), end(buses));\\nsort(begin(pass), end(pass));\\n\\nint i = 0;\\nint p = 0;\\nmap<int, bool> hit;\\nint last_p = 0;\\n\\n// for each bus\\nfor (int b : buses)\\n{\\n\\t// abord enough passenger less than or equal to capacity\\n\\t// we keep track of the last aborded passenger \\n\\tfor (i = 0; i < capacity && p < pass.size() && pass[p] <= b; ++i)\\n\\t{\\n\\t\\tlast_p = pass[p];\\n\\t\\thit[last_p] = true;\\n\\t\\t++ p;\\n\\t}\\n}\\n\\n// if the last bus is full, the we have to jump in before the last passenger.\\nif (i == capacity)\\n\\t-- last_p;\\n// otherwise, we can take our time, we only have to reach the stop before the last bus depart.\\nelse\\n\\tlast_p = buses.back();\\n\\n// forward checking if the time slot has been occupied by some passenger.\\nwhile (hit[last_p])\\n\\t\\t-- last_p;\\n\\t\\nreturn last_p;\\n```\\n",
                "solutionTags": [
                    "C",
                    "Simulation"
                ],
                "code": "```cpp\\nsort(begin(buses), end(buses));\\nsort(begin(pass), end(pass));\\n\\nint i = 0;\\nint p = 0;\\nmap<int, bool> hit;\\nint last_p = 0;\\n\\n// for each bus\\nfor (int b : buses)\\n{\\n\\t// abord enough passenger less than or equal to capacity\\n\\t// we keep track of the last aborded passenger \\n\\tfor (i = 0; i < capacity && p < pass.size() && pass[p] <= b; ++i)\\n\\t{\\n\\t\\tlast_p = pass[p];\\n\\t\\thit[last_p] = true;\\n\\t\\t++ p;\\n\\t}\\n}\\n\\n// if the last bus is full, the we have to jump in before the last passenger.\\nif (i == capacity)\\n\\t-- last_p;\\n// otherwise, we can take our time, we only have to reach the stop before the last bus depart.\\nelse\\n\\tlast_p = buses.back();\\n\\n// forward checking if the time slot has been occupied by some passenger.\\nwhile (hit[last_p])\\n\\t\\t-- last_p;\\n\\t\\nreturn last_p;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2260095,
                "title": "easy-binary-search-approach-without-use-of-set",
                "content": "```\\nclass Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& buses, vector<int>& pass, int cap) {\\n        sort(buses.begin(),buses.end());\\n        sort(pass.begin(),pass.end());\\n        vector<int> v(pass.size());\\n        v[0]=pass[0]-1;\\n        for(int i=1;i<pass.size();i++)\\n        {\\n            if(pass[i]==pass[i-1]+1)\\n            {\\n                v[i]=v[i-1];\\n            }\\n            else\\n            {\\n                v[i]=pass[i]-1;\\n            }\\n        }\\n        int st=0;\\n        int ans;\\n        for(int i=0;i<buses.size()-1;i++)\\n        {\\n            int u=upper_bound(pass.begin(),pass.end(),buses[i])-pass.begin();\\n            int cansit=u-st;\\n            if(cansit>=cap)\\n            {\\n                st+=cap;\\n            }\\n            else\\n                st+=cansit;\\n           \\n        }\\n            int u=upper_bound(pass.begin(),pass.end(),buses[buses.size()-1])-pass.begin();\\n            int cansit=u-st;\\n            if(cansit>=cap)\\n            {\\n                \\n                st+=cap;\\n            }\\n            else\\n            {\\n                st+=cansit;\\n                if(st>=pass.size())\\n                {\\n                    if(pass[pass.size()-1]==buses[buses.size()-1])\\n                    {\\n                        return v[pass.size()-1];\\n                    }\\n                    else\\n                     return  buses[buses.size()-1];\\n                }\\n                else\\n                {\\n                    if(st>0)\\n                    {\\n                        if(pass[st-1]==buses[buses.size()-1])\\n                            return v[st-1];\\n                        else\\n                            return buses[buses.size()-1];\\n                    }\\n                    return buses[buses.size()-1];\\n                    \\n                }\\n                    \\n            }\\n        return v[st-1];     \\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& buses, vector<int>& pass, int cap) {\\n        sort(buses.begin(),buses.end());\\n        sort(pass.begin(),pass.end());\\n        vector<int> v(pass.size());\\n        v[0]=pass[0]-1;\\n        for(int i=1;i<pass.size();i++)\\n        {\\n            if(pass[i]==pass[i-1]+1)\\n            {\\n                v[i]=v[i-1];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2260030,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& buses, vector<int>& passengers, int capacity) {\\n        sort(passengers.begin(),passengers.end());\\n        sort(buses.begin(),buses.end());\\n        int j=0;\\n        vector<int>ans;\\n        int cap=0;\\n        unordered_map<int,int>mp;\\n        for(auto it:passengers) mp[it]++;\\n        for(int i=0;i<buses.size();i++){\\n             cap=0;\\n            while(j<passengers.size() && passengers[j]<=buses[i] && cap<capacity){\\n                ans.push_back(passengers[j]);\\n                j++;\\n                cap++;\\n            }\\n            \\n        }\\n        int x=buses.back();\\n       if(cap<capacity) {\\n\\n           while(mp.find(x)!=mp.end())\\n           {\\n               x--;\\n           }\\n           return x;\\n       }\\n\\t  \\n       int i=ans.size()-1;\\n        while(i-1>=0 && ans[i]-1==ans[i-1]){\\n            i--;\\n        }\\n          return ans[i]-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& buses, vector<int>& passengers, int capacity) {\\n        sort(passengers.begin(),passengers.end());\\n        sort(buses.begin(),buses.end());\\n        int j=0;\\n        vector<int>ans;\\n        int cap=0;\\n        unordered_map<int,int>mp;\\n        for(auto it:passengers) mp[it]++;\\n        for(int i=0;i<buses.size();i++){\\n             cap=0;\\n            while(j<passengers.size() && passengers[j]<=buses[i] && cap<capacity){\\n                ans.push_back(passengers[j]);\\n                j++;\\n                cap++;\\n            }\\n            \\n        }\\n        int x=buses.back();\\n       if(cap<capacity) {\\n\\n           while(mp.find(x)!=mp.end())\\n           {\\n               x--;\\n           }\\n           return x;\\n       }\\n\\t  \\n       int i=ans.size()-1;\\n        while(i-1>=0 && ans[i]-1==ans[i-1]){\\n            i--;\\n        }\\n          return ans[i]-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2259791,
                "title": "c-solution-greedy",
                "content": "\\'\\'\\'\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint latestTimeCatchTheBus(vector<int>& bus, vector<int>& pas, int cap) {\\n\\t\\t\\tint n = bus.size(), m = pas.size();\\n\\t\\t\\tsort(pas.begin(), pas.end());\\n\\t\\t\\tsort(bus.begin(), bus.end());\\n\\t\\t\\tunordered_set<int> st(pas.begin(), pas.end());\\n\\t\\t\\tint ans = 0;\\n\\t\\t\\tint ind = 0;\\n\\t\\t\\tfor(int i=0; i<n; i++){\\n\\t\\t\\t\\tif(ind < m){\\n\\t\\t\\t\\t\\tfor(int j=0; j<cap; j++){\\n\\t\\t\\t\\t\\t\\tif(ind < m && pas[ind] <= bus[i]){\\n\\t\\t\\t\\t\\t\\t\\tans = pas[ind];\\n\\t\\t\\t\\t\\t\\t\\tind++;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\t\\t\\tans = bus[i];\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t} \\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tans = bus[n - 1];\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t} \\n\\t\\t\\t}\\n\\t\\t\\twhile(st.count(ans)) ans--;\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\n",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint latestTimeCatchTheBus(vector<int>& bus, vector<int>& pas, int cap) {\\n\\t\\t\\tint n = bus.size(), m = pas.size();\\n\\t\\t\\tsort(pas.begin(), pas.end());\\n\\t\\t\\tsort(bus.begin(), bus.end());\\n\\t\\t\\tunordered_set<int> st(pas.begin(), pas.end());\\n\\t\\t\\tint ans = 0;\\n\\t\\t\\tint ind = 0;\\n\\t\\t\\tfor(int i=0; i<n; i++){\\n\\t\\t\\t\\tif(ind < m){\\n\\t\\t\\t\\t\\tfor(int j=0; j<cap; j++){\\n\\t\\t\\t\\t\\t\\tif(ind < m && pas[ind] <= bus[i]){\\n\\t\\t\\t\\t\\t\\t\\tans = pas[ind];\\n\\t\\t\\t\\t\\t\\t\\tind++;\\n\\t\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2259644,
                "title": "easy-simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& buses, vector<int>& passengers, int capacity) {\\n        int n = buses.size(), m = passengers.size();\\n        sort(buses.begin(), buses.end());\\n        sort(passengers.begin(), passengers.end());\\n        unordered_map<int,int> mpp;\\n        for(auto it: passengers){\\n            mpp[it]++;\\n        }\\n        int j = 0, prevj = -1, count = 0;\\n        for(int i = 0; i < n; i++) {\\n            count = 0;\\n            while(j < m and count < capacity and passengers[j] <= buses[i]) {\\n                prevj = passengers[j];\\n                j++;\\n                count++;\\n            }\\n        }\\n        cout << prevj << endl;\\n        int val = 0;\\n        if(count == capacity){\\n            val = prevj;\\n        }\\n        else{\\n            val = buses[n - 1];\\n        }\\n        while(val >= 0){\\n            if(mpp.find(val) == mpp.end()){\\n                return val;\\n            }\\n            val--;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& buses, vector<int>& passengers, int capacity) {\\n        int n = buses.size(), m = passengers.size();\\n        sort(buses.begin(), buses.end());\\n        sort(passengers.begin(), passengers.end());\\n        unordered_map<int,int> mpp;\\n        for(auto it: passengers){\\n            mpp[it]++;\\n        }\\n        int j = 0, prevj = -1, count = 0;\\n        for(int i = 0; i < n; i++) {\\n            count = 0;\\n            while(j < m and count < capacity and passengers[j] <= buses[i]) {\\n                prevj = passengers[j];\\n                j++;\\n                count++;\\n            }\\n        }\\n        cout << prevj << endl;\\n        int val = 0;\\n        if(count == capacity){\\n            val = prevj;\\n        }\\n        else{\\n            val = buses[n - 1];\\n        }\\n        while(val >= 0){\\n            if(mpp.find(val) == mpp.end()){\\n                return val;\\n            }\\n            val--;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2259592,
                "title": "python-priority-queue-intuitive-simulation-easy-to-understand",
                "content": "First easy to think of using a min heap to simulate the arrival of passengers;\\nnext sort buses arrival time, \\nfor each bus, as long as the passenger arrival is <= the bus depart time and capacity >0; \\nthe passenger queue just pop.\\n\\nThe tricky part is the last bus round:\\n\\nMy intuitive approach is that we simply load all \"legal\" as long as the capacity is not used up.\\nnow this ends up in two secnarios:\\n(1) bus is not fully loaded, more rooms for passengers.\\n    in this case, if the last passenger board is less than than the bus depart time, we can just arrive exactly on the bus depart time;\\n\\tor, the last passenger actually arrives exactly when the bus departs, in this case we have to arrive earlier and not collide with previous passenger. Here I introduce a  set to record all previous board time, each time we move minute earlier, till no collision.\\n(2) bus is fully loaded. we have to be earlier than the last passenger and not collide with others, so similarly as above, we just -1 minute each time, and compare with previous time set, till we find one time not present in the previous board time.\\n\\n```\\ndef latestTimeCatchTheBus(self, buses: List[int], passengers: List[int], capacity: int) -> int:\\n        q=[]\\n        for a in passengers:\\n            heappush(q,a)\\n        buses.sort()\\n        n=len(buses)\\n        prevts=set()\\n        for b in range(n-1):\\n            btime=buses[b]\\n            K=capacity\\n            while K>0 and q[0]<=btime:\\n                K-=1\\n                prevts.add(q[0])\\n                heappop(q)\\n        ###\\n        lastbtime=buses[-1]\\n        K=capacity\\n        cnt=0 ## count the number of passengers for last bus\\n        while K>0 and q and q[0]<=lastbtime:\\n            K-=1\\n            tp=heappop(q)\\n            prevts.add(tp)\\n            cnt+=1\\n        if cnt<capacity: ## bus is not fully loaded\\n            mx=max(prevts) if prevts else 0\\n            if mx<lastbtime:  ## last passenger boards before bus departs\\n                return lastbtime\\n            else: ##last passenger boards exactly when bus departs,need to arrive earlier\\n                x=mx-1\\n                while x in prevts:\\n                    x-=1\\n                return x\\n        else: ## bus is fully loaded, need arrive earlier and not collide with others\\n            y=max(prevts)-1\\n            while y in prevts:\\n                y-=1\\n            return y",
                "solutionTags": [],
                "code": "First easy to think of using a min heap to simulate the arrival of passengers;\\nnext sort buses arrival time, \\nfor each bus, as long as the passenger arrival is <= the bus depart time and capacity >0; \\nthe passenger queue just pop.\\n\\nThe tricky part is the last bus round:\\n\\nMy intuitive approach is that we simply load all \"legal\" as long as the capacity is not used up.\\nnow this ends up in two secnarios:\\n(1) bus is not fully loaded, more rooms for passengers.\\n    in this case, if the last passenger board is less than than the bus depart time, we can just arrive exactly on the bus depart time;\\n\\tor, the last passenger actually arrives exactly when the bus departs, in this case we have to arrive earlier and not collide with previous passenger. Here I introduce a  set to record all previous board time, each time we move minute earlier, till no collision.\\n(2) bus is fully loaded. we have to be earlier than the last passenger and not collide with others, so similarly as above, we just -1 minute each time, and compare with previous time set, till we find one time not present in the previous board time.\\n\\n```\\ndef latestTimeCatchTheBus(self, buses: List[int], passengers: List[int], capacity: int) -> int:\\n        q=[]\\n        for a in passengers:\\n            heappush(q,a)\\n        buses.sort()\\n        n=len(buses)\\n        prevts=set()\\n        for b in range(n-1):\\n            btime=buses[b]\\n            K=capacity\\n            while K>0 and q[0]<=btime:\\n                K-=1\\n                prevts.add(q[0])\\n                heappop(q)\\n        ###\\n        lastbtime=buses[-1]\\n        K=capacity\\n        cnt=0 ## count the number of passengers for last bus\\n        while K>0 and q and q[0]<=lastbtime:\\n            K-=1\\n            tp=heappop(q)\\n            prevts.add(tp)\\n            cnt+=1\\n        if cnt<capacity: ## bus is not fully loaded\\n            mx=max(prevts) if prevts else 0\\n            if mx<lastbtime:  ## last passenger boards before bus departs\\n                return lastbtime\\n            else: ##last passenger boards exactly when bus departs,need to arrive earlier\\n                x=mx-1\\n                while x in prevts:\\n                    x-=1\\n                return x\\n        else: ## bus is fully loaded, need arrive earlier and not collide with others\\n            y=max(prevts)-1\\n            while y in prevts:\\n                y-=1\\n            return y",
                "codeTag": "Python3"
            },
            {
                "id": 2259587,
                "title": "c-max-heap-two-pointer-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& buses, vector<int>& passengers, int capacity) {\\n        unordered_map<int,int> m;\\n        for(auto x : passengers){\\n            m[x]++;\\n        }\\n        \\n        sort(passengers.begin(),passengers.end());\\n        sort(buses.begin(),buses.end());\\n        \\n        int i = 0;\\n        int answer = 0;\\n        int j = 0;\\n        int cap = 0;\\n        \\n        while(j<buses.size()){\\n            priority_queue<int> pq;\\n            cap=0;\\n            while((i<passengers.size()) && (passengers[i] <= buses[j]) && (cap+1 <=capacity)){\\n                pq.push(passengers[i]);\\n                i++;\\n                cap++;\\n            }\\n            \\n            if(cap+1<=capacity){\\n                if(m[buses[j]]==0){\\n                    answer = max(answer,buses[j]);\\n                }\\n            }\\n            \\n            while(pq.size()>0){\\n                if(m[pq.top()-1] == 0){\\n                    answer = max(answer,pq.top()-1);\\n                    break;\\n                }\\n                pq.pop();\\n            }\\n            \\n            j++;\\n        }\\n        \\n        \\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& buses, vector<int>& passengers, int capacity) {\\n        unordered_map<int,int> m;\\n        for(auto x : passengers){\\n            m[x]++;\\n        }\\n        \\n        sort(passengers.begin(),passengers.end());\\n        sort(buses.begin(),buses.end());\\n        \\n        int i = 0;\\n        int answer = 0;\\n        int j = 0;\\n        int cap = 0;\\n        \\n        while(j<buses.size()){\\n            priority_queue<int> pq;\\n            cap=0;\\n            while((i<passengers.size()) && (passengers[i] <= buses[j]) && (cap+1 <=capacity)){\\n                pq.push(passengers[i]);\\n                i++;\\n                cap++;\\n            }\\n            \\n            if(cap+1<=capacity){\\n                if(m[buses[j]]==0){\\n                    answer = max(answer,buses[j]);\\n                }\\n            }\\n            \\n            while(pq.size()>0){\\n                if(m[pq.top()-1] == 0){\\n                    answer = max(answer,pq.top()-1);\\n                    break;\\n                }\\n                pq.pop();\\n            }\\n            \\n            j++;\\n        }\\n        \\n        \\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2259586,
                "title": "faster-than-100-nlogn",
                "content": "\\n\\n```\\nclass Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& buses, vector<int>& passengers, int capacity) {\\n     sort(buses.begin(),buses.end());\\n     sort(passengers.begin(),passengers.end());\\n     int ans=min(passengers[0]-1,buses[0]);\\n     int i=0;\\n     int j=0;\\n     int prev=-1;\\n     for(;i<buses.size();i++){\\n         if(j==passengers.size())break;\\n         int temp=capacity;\\n         bool check=true;\\n         while(j<passengers.size()&&temp>0&&passengers[j]<=buses[i]){\\n             if(prev!=passengers[j]-1)ans=max(ans,passengers[j]-1);\\n             if(passengers[j]==buses[i])check=false;\\n             prev=passengers[j];\\n             j++;\\n             temp--;\\n         }\\n         if(temp>0&&check==true)ans=max(ans,buses[i]);\\n     }\\n     if(i<buses.size())return buses[buses.size()-1];\\n     return ans;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& buses, vector<int>& passengers, int capacity) {\\n     sort(buses.begin(),buses.end());\\n     sort(passengers.begin(),passengers.end());\\n     int ans=min(passengers[0]-1,buses[0]);\\n     int i=0;\\n     int j=0;\\n     int prev=-1;\\n     for(;i<buses.size();i++){\\n         if(j==passengers.size())break;\\n         int temp=capacity;\\n         bool check=true;\\n         while(j<passengers.size()&&temp>0&&passengers[j]<=buses[i]){\\n             if(prev!=passengers[j]-1)ans=max(ans,passengers[j]-1);\\n             if(passengers[j]==buses[i])check=false;\\n             prev=passengers[j];\\n             j++;\\n             temp--;\\n         }\\n         if(temp>0&&check==true)ans=max(ans,buses[i]);\\n     }\\n     if(i<buses.size())return buses[buses.size()-1];\\n     return ans;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2259577,
                "title": "easy-c-iterative-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& buses, vector<int>& passengers, int capacity) {\\n        int n = buses.size();\\n        int m = passengers.size();\\n        \\n        sort(buses.begin(),buses.end());\\n        sort(passengers.begin(),passengers.end());\\n        \\n        int i = 0;\\n        int j = 0;\\n        while(j<n){\\n            int temp = capacity;\\n            while(i<m && temp && passengers[i]<=buses[j]){\\n                i++;\\n                temp--;\\n            }\\n            j++;\\n            if(j==n)\\n                capacity = temp;\\n        }\\n        \\n        \\n        \\n        if(capacity!=0){\\n            if(i>0)\\n            if(buses[j-1]==passengers[i-1])\\n                return buses[j-1]-1;\\n                \\n            return buses[j-1];\\n        }\\n            \\n            set<int> pass(passengers.begin(),passengers.begin()+i);\\n            int ans = passengers[i-1];\\n            \\n            while(ans){\\n                if(!pass.count(ans))\\n                    return ans;\\n                ans--;\\n            }\\n         \\n        return passengers[0]-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Iterator",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& buses, vector<int>& passengers, int capacity) {\\n        int n = buses.size();\\n        int m = passengers.size();\\n        \\n        sort(buses.begin(),buses.end());\\n        sort(passengers.begin(),passengers.end());\\n        \\n        int i = 0;\\n        int j = 0;\\n        while(j<n){\\n            int temp = capacity;\\n            while(i<m && temp && passengers[i]<=buses[j]){\\n                i++;\\n                temp--;\\n            }\\n            j++;\\n            if(j==n)\\n                capacity = temp;\\n        }\\n        \\n        \\n        \\n        if(capacity!=0){\\n            if(i>0)\\n            if(buses[j-1]==passengers[i-1])\\n                return buses[j-1]-1;\\n                \\n            return buses[j-1];\\n        }\\n            \\n            set<int> pass(passengers.begin(),passengers.begin()+i);\\n            int ans = passengers[i-1];\\n            \\n            while(ans){\\n                if(!pass.count(ans))\\n                    return ans;\\n                ans--;\\n            }\\n         \\n        return passengers[0]-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2259566,
                "title": "c-priority-queue-set-fully-explained",
                "content": "Question explanation: \\n* A passenger can get on a bus if it arrives before the bus, or more formally if `passengers[i]<=buses[j]`. \\n* Each bus has a fixed capacity and therefore, a bus cannot take more passengers than it\\'s capacity. We need to return the maximum time at which we go such that we are able to board the (last) bus. \\n* Each passenger time is unique and we need to return our time such that it does not match with another passenger\\'s time.\\n\\nWe first need to sort the passengers and buses, and then we store the passengers\\' timings in our set (unique values). Used a priority queue to determine which passenger goes in which bus. However, we only need to care about the passengers of the last bus. We then look up the maximum available value in our set such that it does not collide with another passengers time.\\n\\nC++ code:\\n```\\nclass Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& buses, vector<int>& passengers, int capacity) {\\n        sort(buses.begin(), buses.end());\\n        sort(passengers.begin(), passengers.end());\\n        unordered_set<int> all(passengers.begin(), passengers.end());\\n        priority_queue<int, vector<int>, greater<int>>pq;\\n        for(auto &it: passengers){\\n            pq.push(it);\\n        }\\n        vector<int> last;\\n        int n = buses.size();\\n        for(int i=0; i<n; i++){\\n            int k = capacity;\\n\\t\\t\\t// we only care about the passengers boarding the last bus\\n            last.clear();\\n            while(!pq.empty() && k--){\\n                if(pq.top() > buses[i]) break;\\n                last.push_back(pq.top());\\n                pq.pop();\\n            }\\n        }\\n\\t\\t// maximum time such that we can onboard the bus, in case, last.size()<capacity\\n        int x = buses[n-1];\\n        if(last.size() == capacity) \\n\\t\\t// we definitely need to remove some passenger \\n\\t\\t\\tx = last.back()-1;\\n        while(all.find(x) != all.end()){\\n            x--;                           // checking for unique passenger timings\\n        }\\n        return x;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& buses, vector<int>& passengers, int capacity) {\\n        sort(buses.begin(), buses.end());\\n        sort(passengers.begin(), passengers.end());\\n        unordered_set<int> all(passengers.begin(), passengers.end());\\n        priority_queue<int, vector<int>, greater<int>>pq;\\n        for(auto &it: passengers){\\n            pq.push(it);\\n        }\\n        vector<int> last;\\n        int n = buses.size();\\n        for(int i=0; i<n; i++){\\n            int k = capacity;\\n\\t\\t\\t// we only care about the passengers boarding the last bus\\n            last.clear();\\n            while(!pq.empty() && k--){\\n                if(pq.top() > buses[i]) break;\\n                last.push_back(pq.top());\\n                pq.pop();\\n            }\\n        }\\n\\t\\t// maximum time such that we can onboard the bus, in case, last.size()<capacity\\n        int x = buses[n-1];\\n        if(last.size() == capacity) \\n\\t\\t// we definitely need to remove some passenger \\n\\t\\t\\tx = last.back()-1;\\n        while(all.find(x) != all.end()){\\n            x--;                           // checking for unique passenger timings\\n        }\\n        return x;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2259532,
                "title": "a-concise-small-o-n-time-o-1-space-approach",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& buses, vector<int>& passengers, int capacity) \\n    {\\n        sort(begin(buses),end(buses));\\n        sort(begin(passengers),end(passengers));\\n        int j=0,ans=0,prev=0;\\n        for(int i=0;i<size(buses);i++)\\n        {\\n            int count=0;\\n            while(j<passengers.size()&&passengers[j]<=buses[i]&&count<capacity) // first put all the passengers till the bus has capacity.\\n            {\\n                if(passengers[j]-prev>1)// if last passenger\\'s time and current passenger\\'s time has time difference greater than 1\\n// the answer will be the current passengers time -1;\\n                {\\n                    ans=passengers[j]-1;\\n                }\\n                prev=passengers[j];\\n                j++;\\n                count++;\\n            }\\n            if(count<capacity&&buses[i]-prev>=1)// here i have checked if bus still had capacity and no passenger arrived at the time bust departed the ans will be buses departure time.\\n            {\\n                ans=buses[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& buses, vector<int>& passengers, int capacity) \\n    {\\n        sort(begin(buses),end(buses));\\n        sort(begin(passengers),end(passengers));\\n        int j=0,ans=0,prev=0;\\n        for(int i=0;i<size(buses);i++)\\n        {\\n            int count=0;\\n            while(j<passengers.size()&&passengers[j]<=buses[i]&&count<capacity) // first put all the passengers till the bus has capacity.\\n            {\\n                if(passengers[j]-prev>1)// if last passenger\\'s time and current passenger\\'s time has time difference greater than 1\\n// the answer will be the current passengers time -1;\\n                {\\n                    ans=passengers[j]-1;\\n                }\\n                prev=passengers[j];\\n                j++;\\n                count++;\\n            }\\n            if(count<capacity&&buses[i]-prev>=1)// here i have checked if bus still had capacity and no passenger arrived at the time bust departed the ans will be buses departure time.\\n            {\\n                ans=buses[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2259525,
                "title": "100-faster-solution",
                "content": "If you like solution and explanations, please **Upvote!**\\n```\\n\\nclass Solution {\\n    \\n    public int latestTimeCatchTheBus(int[] buses, int[] passengers, int capacity) {\\n        \\n        Arrays.sort(buses);\\n        Arrays.sort(passengers);\\n        \\n        int bn = buses.length;\\n        int pn = passengers.length;\\n        \\n        if (passengers[0]>buses[bn-1]) {\\n            return buses[bn-1];\\n        }\\n        \\n        int p, b, c;\\n        for(p=0, b=0, c = 0; p<pn && b<bn;) {\\n            if (passengers[p]>buses[b]) {\\n                b += 1;\\n                c = 0;\\n            } else {\\n                p += 1;\\n                c += 1;\\n                if (c == capacity) {\\n                    b += 1;\\n                    if (b != bn) {\\n                        c = 0;   \\n                    }\\n                }\\n            }\\n        }\\n        // System.out.println(c+\" \"+p);\\n        if (c != capacity && passengers[p-1]!=buses[bn-1]) {\\n            return buses[bn-1];\\n        }\\n        \\n        p -= 1;\\n        int ans = passengers[p];\\n        \\n        while(p>=0 && ans == passengers[p]) {\\n            ans -= 1;\\n            p -= 1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    \\n    public int latestTimeCatchTheBus(int[] buses, int[] passengers, int capacity) {\\n        \\n        Arrays.sort(buses);\\n        Arrays.sort(passengers);\\n        \\n        int bn = buses.length;\\n        int pn = passengers.length;\\n        \\n        if (passengers[0]>buses[bn-1]) {\\n            return buses[bn-1];\\n        }\\n        \\n        int p, b, c;\\n        for(p=0, b=0, c = 0; p<pn && b<bn;) {\\n            if (passengers[p]>buses[b]) {\\n                b += 1;\\n                c = 0;\\n            } else {\\n                p += 1;\\n                c += 1;\\n                if (c == capacity) {\\n                    b += 1;\\n                    if (b != bn) {\\n                        c = 0;   \\n                    }\\n                }\\n            }\\n        }\\n        // System.out.println(c+\" \"+p);\\n        if (c != capacity && passengers[p-1]!=buses[bn-1]) {\\n            return buses[bn-1];\\n        }\\n        \\n        p -= 1;\\n        int ans = passengers[p];\\n        \\n        while(p>=0 && ans == passengers[p]) {\\n            ans -= 1;\\n            p -= 1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2259502,
                "title": "java-sort-two-pointers",
                "content": "```\\npublic int latestTimeCatchTheBus(int[] buses, int[] passengers, int capacity) {\\n\\tArrays.sort(buses);\\n\\tArrays.sort(passengers);\\n\\t\\n\\t// 1. find the time of the last passenger that gets on the bus and if the last bus departs full\\n\\tint n= buses.length, m= passengers.length, j= 0, count= 0; // i: bus, j: passenger, count: passengers on bus i\\n\\tfor(int i=0; i<n; i++)\\n\\t\\tfor(count= 0; j<m && count<capacity && passengers[j]<=buses[i]; j++) \\n\\t\\t\\tcount++;\\n\\t\\n\\t// 2a. if last bus is full - find the largest unique passenger time < last passenger that got on the last bus\\n\\t// 2b. otherwise - find the largest unique passenger time <= last bus\\n\\tint time = count==capacity ? passengers[j-1] : buses[n-1];\\n\\tfor(j--; j>-1 && time==passengers[j]; j--) \\n\\t\\ttime--;\\n\\treturn time;\\n}",
                "solutionTags": [],
                "code": "```\\npublic int latestTimeCatchTheBus(int[] buses, int[] passengers, int capacity) {\\n\\tArrays.sort(buses);\\n\\tArrays.sort(passengers);\\n\\t\\n\\t// 1. find the time of the last passenger that gets on the bus and if the last bus departs full\\n\\tint n= buses.length, m= passengers.length, j= 0, count= 0; // i: bus, j: passenger, count: passengers on bus i\\n\\tfor(int i=0; i<n; i++)\\n\\t\\tfor(count= 0; j<m && count<capacity && passengers[j]<=buses[i]; j++) \\n\\t\\t\\tcount++;\\n\\t\\n\\t// 2a. if last bus is full - find the largest unique passenger time < last passenger that got on the last bus\\n\\t// 2b. otherwise - find the largest unique passenger time <= last bus\\n\\tint time = count==capacity ? passengers[j-1] : buses[n-1];\\n\\tfor(j--; j>-1 && time==passengers[j]; j--) \\n\\t\\ttime--;\\n\\treturn time;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 2259483,
                "title": "c-priority-queue-easy-commented-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& buses, vector<int>& passengers, int capacity) {\\n        int n = buses.size(), m = passengers.size();\\n        int lastBusTime = *max_element(buses.begin(), buses.end());\\n        priority_queue<int, vector<int>, greater<int>> pqb, pqp;    // pqb: priorityQueueBus, pqp: priorityQueuePasenger\\n        vector<bool> check(lastBusTime+1);     // check[i] = true if any passenger reaching at i time boards bus\\n        \\n        for(auto &i: buses) pqb.push(i);\\n        for(auto &i: passengers) pqp.push(i);\\n        int lastpasstime = -1, lastbuscap = -1;  // storing last passengers time who took bus & last bus capacity left empt\\n        int k=0;\\n        \\n        while(!pqb.empty()) {                // for each arriving bus\\n            int timeDepart = pqb.top(); pqb.pop();\\n            int cap = capacity;\\n            while(!pqp.empty() && pqp.top()<=timeDepart && cap--) {          // till passenger can board bus and there capacity left\\n                check[pqp.top()] = true;        // passeger boarded who reached at time pqp.top()\\n                lastpasstime = pqp.top();\\n                pqp.pop();\\n            }\\n            lastbuscap = cap;\\n        }\\n        // ans will be first zero from lastBusTime if last bus has empty space, else when last passenger boarded bus start looking from that index to first zero back.\\n        int j = (lastbuscap>0) ? lastBusTime : lastpasstime;\\n        for(; j>=0; j--) if(check[j]==0) return j;\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& buses, vector<int>& passengers, int capacity) {\\n        int n = buses.size(), m = passengers.size();\\n        int lastBusTime = *max_element(buses.begin(), buses.end());\\n        priority_queue<int, vector<int>, greater<int>> pqb, pqp;    // pqb: priorityQueueBus, pqp: priorityQueuePasenger\\n        vector<bool> check(lastBusTime+1);     // check[i] = true if any passenger reaching at i time boards bus\\n        \\n        for(auto &i: buses) pqb.push(i);\\n        for(auto &i: passengers) pqp.push(i);\\n        int lastpasstime = -1, lastbuscap = -1;  // storing last passengers time who took bus & last bus capacity left empt\\n        int k=0;\\n        \\n        while(!pqb.empty()) {                // for each arriving bus\\n            int timeDepart = pqb.top(); pqb.pop();\\n            int cap = capacity;\\n            while(!pqp.empty() && pqp.top()<=timeDepart && cap--) {          // till passenger can board bus and there capacity left\\n                check[pqp.top()] = true;        // passeger boarded who reached at time pqp.top()\\n                lastpasstime = pqp.top();\\n                pqp.pop();\\n            }\\n            lastbuscap = cap;\\n        }\\n        // ans will be first zero from lastBusTime if last bus has empty space, else when last passenger boarded bus start looking from that index to first zero back.\\n        int j = (lastbuscap>0) ? lastBusTime : lastpasstime;\\n        for(; j>=0; j--) if(check[j]==0) return j;\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2259424,
                "title": "potentially-wrong-output-for-testcase",
                "content": "buses = [18,8,3,12,9,2,7,13,20,5]\\npassengers = [13,10,8,4,12,14,18,19,5,2,30,34]\\ncapacity = 1\\n\\nsorted(buses) = [2, 3, 5, 7, 8, 9, 12, 13, 18, 20]\\nsorted(passengers) = [2, 4, 5, 8, 10, 12, 13, 14, 18, 19]\\n\\naccording to the question,\\n19 waits for 20\\n14, 18 wait for 18\\n13 waits for 13\\n10,12 wait for 12 (capacity is only 1 so 11 cannot be added since 10 is already in the list)\\nno-one waits for 9\\n8 waits for 8\\nso we can return 9 as answer\\nbut the question says the answer should be 11.\\nAm I missing something here.. Please explain.\\nAttaching ss of evaluation for proof\\n![image](https://assets.leetcode.com/users/images/bf4612cc-02bb-45c7-8ade-07ce669d83c6_1657383813.6209724.png)\\n\\n",
                "solutionTags": [],
                "code": "buses = [18,8,3,12,9,2,7,13,20,5]\\npassengers = [13,10,8,4,12,14,18,19,5,2,30,34]\\ncapacity = 1\\n\\nsorted(buses) = [2, 3, 5, 7, 8, 9, 12, 13, 18, 20]\\nsorted(passengers) = [2, 4, 5, 8, 10, 12, 13, 14, 18, 19]\\n\\naccording to the question,\\n19 waits for 20\\n14, 18 wait for 18\\n13 waits for 13\\n10,12 wait for 12 (capacity is only 1 so 11 cannot be added since 10 is already in the list)\\nno-one waits for 9\\n8 waits for 8\\nso we can return 9 as answer\\nbut the question says the answer should be 11.\\nAm I missing something here.. Please explain.\\nAttaching ss of evaluation for proof\\n![image](https://assets.leetcode.com/users/images/bf4612cc-02bb-45c7-8ade-07ce669d83c6_1657383813.6209724.png)\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2259419,
                "title": "c-priority-queue-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& b, vector<int>& p, int capacity) {\\n        priority_queue<int,vector<int>,greater<int>> fb,fp;\\n        unordered_map<int,int> ma;\\n        \\n            for(auto &i:p){\\n                fp.push(i);\\n                ma[i]++;\\n            }\\n            for(auto &i:b)fb.push(i);\\n        \\n        int ans=1;\\n        while(!fb.empty()){\\n            int cnt=0,last=fb.top()-1;\\n            while(!fp.empty()&&cnt<capacity&&fp.top()<=fb.top()){\\n                int x=fp.top();fp.pop();\\n                if(ma[x-1]==0)ans=x-1;\\n                cnt++;\\n                last=x;\\n            }\\n            \\n            if(cnt<capacity&&last<fb.top())ans=fb.top();\\n            fb.pop();\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& b, vector<int>& p, int capacity) {\\n        priority_queue<int,vector<int>,greater<int>> fb,fp;\\n        unordered_map<int,int> ma;\\n        \\n            for(auto &i:p){\\n                fp.push(i);\\n                ma[i]++;\\n            }\\n            for(auto &i:b)fb.push(i);\\n        \\n        int ans=1;\\n        while(!fb.empty()){\\n            int cnt=0,last=fb.top()-1;\\n            while(!fp.empty()&&cnt<capacity&&fp.top()<=fb.top()){\\n                int x=fp.top();fp.pop();\\n                if(ma[x-1]==0)ans=x-1;\\n                cnt++;\\n                last=x;\\n            }\\n            \\n            if(cnt<capacity&&last<fb.top())ans=fb.top();\\n            fb.pop();\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2259414,
                "title": "c-sorting-greedy",
                "content": "```\\nclass Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& buses, vector<int>& passengers, int capacity) {\\n        sort(buses.begin(), buses.end());\\n        sort(passengers.begin(), passengers.end());\\n        int i = 0, j = 0, n = buses.size(), m = passengers.size();\\n        int ans = min(passengers[0] - 1, buses[n - 1]);\\n        for(i = 0; i < n && j < m; i++){\\n            int cap = capacity;\\n            while(cap && j < m && passengers[j] <= buses[i]){\\n                if(j != 0 && passengers[j] - passengers[j - 1] > 1) ans = passengers[j] - 1;\\n                cap -= 1;\\n                j += 1;\\n            }\\n            if(cap != 0 && j > 0 && buses[i] != passengers[j - 1]) ans = buses[i];\\n        }\\n        if(i != n) ans = buses[n - 1];\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& buses, vector<int>& passengers, int capacity) {\\n        sort(buses.begin(), buses.end());\\n        sort(passengers.begin(), passengers.end());\\n        int i = 0, j = 0, n = buses.size(), m = passengers.size();\\n        int ans = min(passengers[0] - 1, buses[n - 1]);\\n        for(i = 0; i < n && j < m; i++){\\n            int cap = capacity;\\n            while(cap && j < m && passengers[j] <= buses[i]){\\n                if(j != 0 && passengers[j] - passengers[j - 1] > 1) ans = passengers[j] - 1;\\n                cap -= 1;\\n                j += 1;\\n            }\\n            if(cap != 0 && j > 0 && buses[i] != passengers[j - 1]) ans = buses[i];\\n        }\\n        if(i != n) ans = buses[n - 1];\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2259376,
                "title": "greedy-approach-c",
                "content": "We will add in the bus untill the passenger arrival time is less than equal to departure time of bus or the current capacity of bus is less than equal to capacity given.\\nafter this there will be two mainly conditions :\\n1) current capacity is full that means i have to arrive before the last candidates arrival time that is i will start looking for a free time initializing it to the current passengers arrival-1 and verifying everytime whether any passenger has arrived at that time or not.\\n2) current capacity is less than given capacity that means we can arrive lates upto the departure time of the bus and again we will check whether any other passenger is arriving at that time or not.\\n\\n```\\n   int latestTimeCatchTheBus(vector<int>& b, vector<int>& p, int c) {\\n       sort(b.begin(),b.end());\\n       sort(p.begin(),p.end());\\n       int j=0,ans;\\n        map<int,int> m;\\n        for(int i=0;i<p.size();i++)\\n            m[p[i]]=1;\\n       for(int i=0;i<b.size();i++)\\n       {\\n           int curr=0,x;\\n           if(p[j]>b[i])\\n               x=b[i];\\n           else\\n           {\\n              while(j<p.size()&&curr<c&&p[j]<=b[i])\\n              {\\n                  curr++;\\n                  j++;\\n              }\\n              if(curr==c)\\n              {\\n                 if(j>0)\\n                 x=p[j-1]-1;\\n                 else\\n                 x=p[j];\\n              }\\n              else\\n              {\\n                 x=b[i];     \\n              }\\n           }\\n           while(m.find(x)!=m.end())\\n                x--;\\n           m[x]=1;\\n           ans=max(ans,x);\\n       }\\n        return ans;\\n    }",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "We will add in the bus untill the passenger arrival time is less than equal to departure time of bus or the current capacity of bus is less than equal to capacity given.\\nafter this there will be two mainly conditions :\\n1) current capacity is full that means i have to arrive before the last candidates arrival time that is i will start looking for a free time initializing it to the current passengers arrival-1 and verifying everytime whether any passenger has arrived at that time or not.\\n2) current capacity is less than given capacity that means we can arrive lates upto the departure time of the bus and again we will check whether any other passenger is arriving at that time or not.\\n\\n```\\n   int latestTimeCatchTheBus(vector<int>& b, vector<int>& p, int c) {\\n       sort(b.begin(),b.end());\\n       sort(p.begin(),p.end());\\n       int j=0,ans;\\n        map<int,int> m;\\n        for(int i=0;i<p.size();i++)\\n            m[p[i]]=1;\\n       for(int i=0;i<b.size();i++)\\n       {\\n           int curr=0,x;\\n           if(p[j]>b[i])\\n               x=b[i];\\n           else\\n           {\\n              while(j<p.size()&&curr<c&&p[j]<=b[i])\\n              {\\n                  curr++;\\n                  j++;\\n              }\\n              if(curr==c)\\n              {\\n                 if(j>0)\\n                 x=p[j-1]-1;\\n                 else\\n                 x=p[j];\\n              }\\n              else\\n              {\\n                 x=b[i];     \\n              }\\n           }\\n           while(m.find(x)!=m.end())\\n                x--;\\n           m[x]=1;\\n           ans=max(ans,x);\\n       }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2259359,
                "title": "easy-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& buses, vector<int>& passengers, int capacity) {\\n        sort(buses.begin(),buses.end());\\n        sort(passengers.begin(),passengers.end());\\n        int i=0,j=0,k=capacity,ans=0,b=buses.size(),p=passengers.size(),last=0,idx=0;\\n        for(i=0;i<b;i++)\\n        {\\n            k=capacity;\\n            while(j<p && passengers[j]<=buses[i] && k--)\\n            {\\n                idx=j;\\n                last=passengers[j++];\\n            }\\n            if(i==b-1 && k>0 && last<buses[i])\\n                return buses.back();\\n        }\\n\\n        if(j==0)\\n            return buses.back();\\n        ans=last-1;\\n    \\n        for(i=idx-1;i>=0;i--)\\n        {\\n            if(ans==passengers[i])\\n                ans--;\\n            else\\n                return ans;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```\\n\\nFind the last passenger to board the bus and then repeatedly reduce it by 1 to check if another passenger arrived at the same time or not.",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& buses, vector<int>& passengers, int capacity) {\\n        sort(buses.begin(),buses.end());\\n        sort(passengers.begin(),passengers.end());\\n        int i=0,j=0,k=capacity,ans=0,b=buses.size(),p=passengers.size(),last=0,idx=0;\\n        for(i=0;i<b;i++)\\n        {\\n            k=capacity;\\n            while(j<p && passengers[j]<=buses[i] && k--)\\n            {\\n                idx=j;\\n                last=passengers[j++];\\n            }\\n            if(i==b-1 && k>0 && last<buses[i])\\n                return buses.back();\\n        }\\n\\n        if(j==0)\\n            return buses.back();\\n        ans=last-1;\\n    \\n        for(i=idx-1;i>=0;i--)\\n        {\\n            if(ans==passengers[i])\\n                ans--;\\n            else\\n                return ans;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2259236,
                "title": "simple-and-easy-c-solution-using-2-pointers",
                "content": "```\\nclass Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& buses, vector<int>& passengers, int capacity) {\\n        sort(buses.begin(),buses.end());\\n        sort(passengers.begin(),passengers.end());\\n        int i=0,j=0,ans=1;\\n        while (i<buses.size()&&j<passengers.size()) {\\n            int cnt=0;\\n            while (j<passengers.size()&&cnt<capacity) {\\n                if (passengers[j]<=buses[i]) {\\n                    if (j>0&&passengers[j-1]==passengers[j]-1) ans=ans;\\n                    else ans=passengers[j]-1;\\n                    j++;\\n                    cnt++;\\n                }\\n                else break;\\n            }\\n            i++;\\n            if (i==buses.size()&&cnt!=capacity) {\\n                if (j>0&&passengers[j-1]!=buses[i-1]||j==0) return buses[i-1];\\n            }\\n        }\\n        if (j==passengers.size()) {\\n            if (i!=buses.size()) return buses[buses.size()-1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& buses, vector<int>& passengers, int capacity) {\\n        sort(buses.begin(),buses.end());\\n        sort(passengers.begin(),passengers.end());\\n        int i=0,j=0,ans=1;\\n        while (i<buses.size()&&j<passengers.size()) {\\n            int cnt=0;\\n            while (j<passengers.size()&&cnt<capacity) {\\n                if (passengers[j]<=buses[i]) {\\n                    if (j>0&&passengers[j-1]==passengers[j]-1) ans=ans;\\n                    else ans=passengers[j]-1;\\n                    j++;\\n                    cnt++;\\n                }\\n                else break;\\n            }\\n            i++;\\n            if (i==buses.size()&&cnt!=capacity) {\\n                if (j>0&&passengers[j-1]!=buses[i-1]||j==0) return buses[i-1];\\n            }\\n        }\\n        if (j==passengers.size()) {\\n            if (i!=buses.size()) return buses[buses.size()-1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2259203,
                "title": "c-2-pointer-queue",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& buses, vector<int>& passengers, int capacity) {\\n        sort(buses.begin(), buses.end()); \\n        sort(passengers.begin(), passengers.end()); \\n        int ans = 0; \\n        queue<int> q; \\n        for (int i = 0, j = 0, prefix = 0, prev = INT_MIN; i < buses.size() || j < passengers.size(); ) {\\n            if (i == buses.size() || (j < passengers.size() && passengers[j] <= buses[i])) {\\n                if (j == 0 || passengers[j-1] + 1 < passengers[j]) prev = passengers[j]-1; \\n                if (++prefix % capacity == 0) q.push(prev); \\n                ++j; \\n            } else {\\n                if (prefix < capacity) {\\n                    if (j == 0 || (buses[i] != passengers[j-1])) ans = buses[i]; \\n                    else ans = prev; \\n                    prefix = 0; \\n                } else if (q.size()) {\\n                    ans = q.front(); q.pop(); \\n                    prefix -= capacity; \\n                }\\n                ++i; \\n            }\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& buses, vector<int>& passengers, int capacity) {\\n        sort(buses.begin(), buses.end()); \\n        sort(passengers.begin(), passengers.end()); \\n        int ans = 0; \\n        queue<int> q; \\n        for (int i = 0, j = 0, prefix = 0, prev = INT_MIN; i < buses.size() || j < passengers.size(); ) {\\n            if (i == buses.size() || (j < passengers.size() && passengers[j] <= buses[i])) {\\n                if (j == 0 || passengers[j-1] + 1 < passengers[j]) prev = passengers[j]-1; \\n                if (++prefix % capacity == 0) q.push(prev); \\n                ++j; \\n            } else {\\n                if (prefix < capacity) {\\n                    if (j == 0 || (buses[i] != passengers[j-1])) ans = buses[i]; \\n                    else ans = prev; \\n                    prefix = 0; \\n                } else if (q.size()) {\\n                    ans = q.front(); q.pop(); \\n                    prefix -= capacity; \\n                }\\n                ++i; \\n            }\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2259196,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& buses, vector<int>& passengers, int capacity) {\\n      \\n      sort(buses.begin(),buses.end());\\n      sort(passengers.begin(),passengers.end());\\n      unordered_map<int,int> map1;\\n      \\n      int j = 0;\\n      int max_arrival = -1;\\n      \\n      for (int i = 0; i < buses.size(); i++)\\n      {\\n        int k = capacity;\\n        // map1[buses[i]]++;\\n        \\n        \\n        while (j < passengers.size() && passengers[j] <= buses[i] && k)\\n        {\\n          map1[passengers[j]]++;\\n          j++;\\n          k--;\\n        }\\n        // cout << j << endl;\\n        if (i == buses.size()-1)\\n        {\\n          if (k == 0)\\n            max_arrival = passengers[j-1];\\n          else\\n            max_arrival = buses[i];\\n        }\\n      }\\n      \\n      // cout << max_arrival << endl;\\n      while (map1[max_arrival])\\n        max_arrival--;\\n      \\n      return max_arrival;\\n    }\\n};****\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& buses, vector<int>& passengers, int capacity) {\\n      \\n      sort(buses.begin(),buses.end());\\n      sort(passengers.begin(),passengers.end());\\n      unordered_map<int,int> map1;\\n      \\n      int j = 0;\\n      int max_arrival = -1;\\n      \\n      for (int i = 0; i < buses.size(); i++)\\n      {\\n        int k = capacity;\\n        // map1[buses[i]]++;\\n        \\n        \\n        while (j < passengers.size() && passengers[j] <= buses[i] && k)\\n        {\\n          map1[passengers[j]]++;\\n          j++;\\n          k--;\\n        }\\n        // cout << j << endl;\\n        if (i == buses.size()-1)\\n        {\\n          if (k == 0)\\n            max_arrival = passengers[j-1];\\n          else\\n            max_arrival = buses[i];\\n        }\\n      }\\n      \\n      // cout << max_arrival << endl;\\n      while (map1[max_arrival])\\n        max_arrival--;\\n      \\n      return max_arrival;\\n    }\\n};****\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4076398,
                "title": "easy-to-understand-sort-2-pointers-algorithm",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBasically, we just sort arrays and go throught 2 arrays , checking if we can seat in the current bus. There\\'re 2 cases:\\n1. we seat between 2 passangers if there\\'s a place\\n2. we seat after all passangers in the current bus , if there\\'re avaliable places \\nSo, the go throught 2 arrays, checking these 2 conditions and that\\'s it\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSort arrays + 2 pointers \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(nlogn) + O(mlogm) $$ \\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$, no extra memory allocations in code (except sort part)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& buses, vector<int>& passengers, int capacity) {\\n        std::sort(buses.begin(), buses.end());\\n        std::sort(passengers.begin(), passengers.end());\\n        size_t pass_cntr = 0;\\n        int prev_time = 0;\\n        int latest_time = 0;\\n        for (size_t i = 0; i < buses.size(); ++i) {\\n            int tmp_cntr = 0;\\n            while (pass_cntr < passengers.size()\\n                   && passengers[pass_cntr] <= buses[i]\\n                   && tmp_cntr < capacity) {\\n                if (passengers[pass_cntr] - prev_time > 1) {\\n                    latest_time = passengers[pass_cntr] - 1;\\n                }\\n                prev_time = passengers[pass_cntr];\\n                pass_cntr++;\\n                tmp_cntr++;\\n            }\\n            if (tmp_cntr < capacity && buses[i] - prev_time >= 1) {\\n                latest_time = buses[i];\\n            }\\n        }\\n        return latest_time;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& buses, vector<int>& passengers, int capacity) {\\n        std::sort(buses.begin(), buses.end());\\n        std::sort(passengers.begin(), passengers.end());\\n        size_t pass_cntr = 0;\\n        int prev_time = 0;\\n        int latest_time = 0;\\n        for (size_t i = 0; i < buses.size(); ++i) {\\n            int tmp_cntr = 0;\\n            while (pass_cntr < passengers.size()\\n                   && passengers[pass_cntr] <= buses[i]\\n                   && tmp_cntr < capacity) {\\n                if (passengers[pass_cntr] - prev_time > 1) {\\n                    latest_time = passengers[pass_cntr] - 1;\\n                }\\n                prev_time = passengers[pass_cntr];\\n                pass_cntr++;\\n                tmp_cntr++;\\n            }\\n            if (tmp_cntr < capacity && buses[i] - prev_time >= 1) {\\n                latest_time = buses[i];\\n            }\\n        }\\n        return latest_time;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4070302,
                "title": "why-is-it-downvoted-seems-like-a-fun-problem",
                "content": "Curious why there are so many thumbs down for this problem. It seems fun and reasonably explained. You can relate to this problem as well. \\nIf you downvoted, why?",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 4028652,
                "title": "simple-python-iteration",
                "content": "# Approach\\nFirst, sort both `buses` and `passengers`. Then iterate over `bus_times`, keep track of the last valid index of passenger that makes sure we can leave with the last bus. Finally, subtract the last valid passenger time by 1 until it doesn\\'t exist in `passengers` as the times are unique. \\n\\n# Complexity\\n- Time complexity: O(n + nlogn)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nimport heapq \\nclass Solution:\\n    def latestTimeCatchTheBus(self, buses: List[int], passengers: List[int], capacity: int) -> int:\\n        buses.sort()\\n        passengers.sort()\\n        last_passenger_index = 0\\n        \\n        for bus_time in buses:\\n            c = capacity\\n\\n            while c > 0 and last_passenger_index < len(passengers) and passengers[last_passenger_index] <= bus_time:\\n                c -= 1\\n                last_passenger_index += 1\\n\\n        latest_time = bus_time if c > 0 else passengers[last_passenger_index-1] - 1\\n\\n        while latest_time in set(passengers):\\n            latest_time -= 1\\n\\n        return latest_time\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport heapq \\nclass Solution:\\n    def latestTimeCatchTheBus(self, buses: List[int], passengers: List[int], capacity: int) -> int:\\n        buses.sort()\\n        passengers.sort()\\n        last_passenger_index = 0\\n        \\n        for bus_time in buses:\\n            c = capacity\\n\\n            while c > 0 and last_passenger_index < len(passengers) and passengers[last_passenger_index] <= bus_time:\\n                c -= 1\\n                last_passenger_index += 1\\n\\n        latest_time = bus_time if c > 0 else passengers[last_passenger_index-1] - 1\\n\\n        while latest_time in set(passengers):\\n            latest_time -= 1\\n\\n        return latest_time\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4018374,
                "title": "well-commented-solution-with-o-nlogn-time-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n    bus will take capacity of passengers arrive time <= departure time.\\n    find a gap that we can squeeze in latest.\\n\\n    edge case: \\n    1. might have no gap between boarding times that we can squeeze in.\\n    2. if a bus has already full. we must board earlier than the last passenger\\n    3. if a bus still has capacity. best case that we can just be on departure time as long as the last boarding person didn\\'t.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nalgo:\\n    1. sort both array. so we can easly group the passengers\\n    2. loop through and keep track of numbers of passengers on each bus. \\n       (since we sorted the array. we can index passenger on bus by these numbers)\\n    3. traverse bus from backward which is latest departure. and try to find the time gap that we can squeeze in.\\n# Complexity\\n- Time complexity: O(nlogn)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int latestTimeCatchTheBus(int[] buses, int[] passengers, int capacity) {\\n        Arrays.sort(buses);\\n        Arrays.sort(passengers);\\n        /**\\n         * we can index passengers on each bus later by tracking the nums on each of it.\\n         */\\n        int[] passengersOnBuses = new int[buses.length];\\n        int busIdx = 0;\\n        int passengerIdx = 0;\\n        /** total passengers on bus */\\n        int totalOnBus = 0;\\n        /**\\n         * count how many passengers on each bus\\n         */\\n        while(passengerIdx < passengers.length && busIdx < buses.length) {\\n            if (buses[busIdx] >= passengers[passengerIdx]) {\\n                passengerIdx++;\\n                passengersOnBuses[busIdx]++;\\n                totalOnBus++;\\n                if (passengersOnBuses[busIdx] == capacity) {\\n                    busIdx++;\\n                }\\n            } else {\\n                busIdx++;\\n            }\\n        }\\n        /**\\n         * boarding time of the previous time during iteration.\\n         * ** initialize with zero. must check before first use **\\n         */\\n        int lastBoardingTime = 0;\\n        int currentBoardingTime = 0;\\n        /**\\n         * the index of last passenger who has boarded\\n         */\\n        int pasIdx = totalOnBus - 1;\\n        /**\\n         * passenger number of the bus\\n         */\\n        int pasOnBus = 0;\\n        /**\\n         * travers passengersOnBuses backward and try to find the gap between boarding times.\\n         * 1. bus is empty: then the latest arrive time will be lastBoardingTime - 1 or just equals to the departure time if it\\'s the last bus\\n         * 2. bus still has capacity, then arrive time can just equals to departure time\\n         * 3. try to find the gap between times on the bus.\\n         */\\n        for (int i = buses.length - 1; i >= 0; i--) {\\n            pasOnBus = passengersOnBuses[i];\\n            if (passengersOnBuses[i] == 0) {\\n                return lastBoardingTime != 0 ? lastBoardingTime - 1 : buses[i];\\n            }\\n            pasOnBus--;\\n            currentBoardingTime = passengers[pasIdx--];\\n            /**\\n             * check if there\\'s gap between lastBoardingTime from previous iteration. \\n             * then we can actually catch on the previos bus by boarding earlier than the first boarding person \\n             */\\n            if (lastBoardingTime != 0 && hasGap(currentBoardingTime, lastBoardingTime)) return lastBoardingTime - 1;\\n            //check if bus still have capacity and the last boarding person didnt just on time.\\n            if (passengersOnBuses[i] < capacity && buses[i] != currentBoardingTime) {\\n                return buses[i];\\n            }\\n            lastBoardingTime = currentBoardingTime;\\n            while (pasOnBus > 0) {\\n                currentBoardingTime = passengers[pasIdx--];\\n                if (hasGap(currentBoardingTime, lastBoardingTime)) return lastBoardingTime - 1;\\n                lastBoardingTime = currentBoardingTime;\\n                pasOnBus--;\\n            }\\n        }\\n        return lastBoardingTime - 1;\\n    }\\n\\n    boolean hasGap(int time1,  int time2) {\\n        return Math.abs(time1 - time2) > 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int latestTimeCatchTheBus(int[] buses, int[] passengers, int capacity) {\\n        Arrays.sort(buses);\\n        Arrays.sort(passengers);\\n        /**\\n         * we can index passengers on each bus later by tracking the nums on each of it.\\n         */\\n        int[] passengersOnBuses = new int[buses.length];\\n        int busIdx = 0;\\n        int passengerIdx = 0;\\n        /** total passengers on bus */\\n        int totalOnBus = 0;\\n        /**\\n         * count how many passengers on each bus\\n         */\\n        while(passengerIdx < passengers.length && busIdx < buses.length) {\\n            if (buses[busIdx] >= passengers[passengerIdx]) {\\n                passengerIdx++;\\n                passengersOnBuses[busIdx]++;\\n                totalOnBus++;\\n                if (passengersOnBuses[busIdx] == capacity) {\\n                    busIdx++;\\n                }\\n            } else {\\n                busIdx++;\\n            }\\n        }\\n        /**\\n         * boarding time of the previous time during iteration.\\n         * ** initialize with zero. must check before first use **\\n         */\\n        int lastBoardingTime = 0;\\n        int currentBoardingTime = 0;\\n        /**\\n         * the index of last passenger who has boarded\\n         */\\n        int pasIdx = totalOnBus - 1;\\n        /**\\n         * passenger number of the bus\\n         */\\n        int pasOnBus = 0;\\n        /**\\n         * travers passengersOnBuses backward and try to find the gap between boarding times.\\n         * 1. bus is empty: then the latest arrive time will be lastBoardingTime - 1 or just equals to the departure time if it\\'s the last bus\\n         * 2. bus still has capacity, then arrive time can just equals to departure time\\n         * 3. try to find the gap between times on the bus.\\n         */\\n        for (int i = buses.length - 1; i >= 0; i--) {\\n            pasOnBus = passengersOnBuses[i];\\n            if (passengersOnBuses[i] == 0) {\\n                return lastBoardingTime != 0 ? lastBoardingTime - 1 : buses[i];\\n            }\\n            pasOnBus--;\\n            currentBoardingTime = passengers[pasIdx--];\\n            /**\\n             * check if there\\'s gap between lastBoardingTime from previous iteration. \\n             * then we can actually catch on the previos bus by boarding earlier than the first boarding person \\n             */\\n            if (lastBoardingTime != 0 && hasGap(currentBoardingTime, lastBoardingTime)) return lastBoardingTime - 1;\\n            //check if bus still have capacity and the last boarding person didnt just on time.\\n            if (passengersOnBuses[i] < capacity && buses[i] != currentBoardingTime) {\\n                return buses[i];\\n            }\\n            lastBoardingTime = currentBoardingTime;\\n            while (pasOnBus > 0) {\\n                currentBoardingTime = passengers[pasIdx--];\\n                if (hasGap(currentBoardingTime, lastBoardingTime)) return lastBoardingTime - 1;\\n                lastBoardingTime = currentBoardingTime;\\n                pasOnBus--;\\n            }\\n        }\\n        return lastBoardingTime - 1;\\n    }\\n\\n    boolean hasGap(int time1,  int time2) {\\n        return Math.abs(time1 - time2) > 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4008989,
                "title": "easy-solution",
                "content": "# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```javascript []\\n\\nvar latestTimeCatchTheBus = function(buses, passengers, capacity) {\\n    buses.sort((a, b) => a - b);\\n    passengers.sort((a, b) => a - b);\\n\\n    let i = 0;\\n    let c;\\n\\n    for (let bTime of buses) {\\n        c = 0;\\n\\n        while(i < passengers.length && passengers[i] <= bTime && c < capacity) {\\n            c++, i++;\\n        }\\n    }\\n\\n    let latest = c !== capacity ? buses[buses.length-1] : passengers[i-1];\\n    const passengerSet = new Set(passengers);\\n\\n    while (passengerSet.has(latest)) {\\n        latest--;\\n    }\\n\\n    return latest;\\n};\\n```\\n```python []\\nclass Solution:\\n    def latestTimeCatchTheBus(self, buses: List[int], passengers: List[int], capacity: int) -> int:\\n        buses.sort()\\n        passengers.sort()\\n\\n        index = 0\\n\\n        for b_time in buses:\\n            c = 0\\n            \\n            while index < len(passengers) and passengers[index] <= b_time and c < capacity:\\n                c += 1\\n                index += 1\\n\\n        latest = buses[-1] if c != capacity else passengers[index-1]\\n\\n        while latest in set(passengers):\\n            latest -= 1\\n        \\n        return latest\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript []\\n\\nvar latestTimeCatchTheBus = function(buses, passengers, capacity) {\\n    buses.sort((a, b) => a - b);\\n    passengers.sort((a, b) => a - b);\\n\\n    let i = 0;\\n    let c;\\n\\n    for (let bTime of buses) {\\n        c = 0;\\n\\n        while(i < passengers.length && passengers[i] <= bTime && c < capacity) {\\n            c++, i++;\\n        }\\n    }\\n\\n    let latest = c !== capacity ? buses[buses.length-1] : passengers[i-1];\\n    const passengerSet = new Set(passengers);\\n\\n    while (passengerSet.has(latest)) {\\n        latest--;\\n    }\\n\\n    return latest;\\n};\\n```\n```python []\\nclass Solution:\\n    def latestTimeCatchTheBus(self, buses: List[int], passengers: List[int], capacity: int) -> int:\\n        buses.sort()\\n        passengers.sort()\\n\\n        index = 0\\n\\n        for b_time in buses:\\n            c = 0\\n            \\n            while index < len(passengers) and passengers[index] <= b_time and c < capacity:\\n                c += 1\\n                index += 1\\n\\n        latest = buses[-1] if c != capacity else passengers[index-1]\\n\\n        while latest in set(passengers):\\n            latest -= 1\\n        \\n        return latest\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3992331,
                "title": "the-latest-time-to-catch-a-bus-greedy",
                "content": "# Intuition\\nSolving the problem with real time calcuations\\n\\n# Approach\\nSorting and Array traversing\\n\\n# Complexity\\n- Time complexity:\\nO(NlogN + MLogM) + O(N+M) ~~ o(NlogN)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public int latestTimeCatchTheBus(int[] buses, int[] passengers, int capacity) {\\n        Arrays.sort(buses);\\n        Arrays.sort(passengers);\\n        \\n        int cap = capacity;\\n        int myTime = passengers[0] - 1;\\n        int p = 0;\\n        Set<Integer> travelled = new HashSet<>();\\n        for(int b = 0; b < buses.length; b++) {\\n            cap = capacity;\\n            while(p < passengers.length && p < p + Math.min(cap, passengers.length-p) && buses[b] >= passengers[p]) {               \\n                if(buses[b] - passengers[p] >= 0 && !travelled.contains(passengers[p] - 1)) {\\n                    myTime = passengers[p] - 1;\\n                }\\n                travelled.add(passengers[p]);\\n                p++;\\n                cap = cap - 1;\\n            }\\n            if(cap > 0 && !travelled.contains(buses[b])) {\\n                myTime = buses[b];\\n            }\\n        }\\n        return myTime;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int latestTimeCatchTheBus(int[] buses, int[] passengers, int capacity) {\\n        Arrays.sort(buses);\\n        Arrays.sort(passengers);\\n        \\n        int cap = capacity;\\n        int myTime = passengers[0] - 1;\\n        int p = 0;\\n        Set<Integer> travelled = new HashSet<>();\\n        for(int b = 0; b < buses.length; b++) {\\n            cap = capacity;\\n            while(p < passengers.length && p < p + Math.min(cap, passengers.length-p) && buses[b] >= passengers[p]) {               \\n                if(buses[b] - passengers[p] >= 0 && !travelled.contains(passengers[p] - 1)) {\\n                    myTime = passengers[p] - 1;\\n                }\\n                travelled.add(passengers[p]);\\n                p++;\\n                cap = cap - 1;\\n            }\\n            if(cap > 0 && !travelled.contains(buses[b])) {\\n                myTime = buses[b];\\n            }\\n        }\\n        return myTime;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3986156,
                "title": "simple-java-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTwo while/for loop over buses array and passenger array and keep the last bus, last passenger index and passenger count.\\nThen get the latest arrival time calcuation in getLatestArrivalTime method. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\nO(m log m) + O(n log n) + O(m + n) \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nUsed exsting arrays!\\n\\n# Code\\n```\\nclass Solution {\\n    public int latestTimeCatchTheBus(int[] buses, int[] passengers, int capacity) {\\n        Arrays.sort(buses);\\n        Arrays.sort(passengers);\\n    \\n        int b = 0, p = 0;\\n        int busTime = 0, passengerIndex = 0, pCount = 0;\\n    \\n        while(b < buses.length) {\\n            busTime = buses[b++]; //keep the last bus time\\n            pCount = 0;\\n\\n            while(p < passengers.length && passengers[p] <= busTime && pCount < capacity) {\\n                if(b == buses.length) { //last bus then keep the passenger index\\n                    passengerIndex = p;\\n                }\\n                p++;\\n                pCount++;\\n            }\\n        }\\n        return getLatestArrivalTime(passengers, busTime, passengerIndex, pCount, capacity);\\n    }\\n\\n    public int getLatestArrivalTime(int[] passengers, int lastBusTime, int passengerIndex, int pCount, int capacity) {\\n        //if no passenger waiting at the bus stop for the last bus -> arrive at the last bus leaving time\\n        if (pCount == 0) return lastBusTime;\\n\\n        int lastPassengerTime = passengers[passengerIndex];\\n\\n        // if there is capacity and the last passenger waiting is earlier than the bus leaving time\\n        // then arrive at last bus leaving time\\n        if (lastPassengerTime < lastBusTime && pCount < capacity) return lastBusTime;\\n\\n        // iterate backward from last passenger arrival time \\n        // to find the latest arrival time which is not in the passengers\\n        for(; lastPassengerTime >= 0 && passengerIndex >= 0; lastPassengerTime--) {\\n            if(lastPassengerTime != passengers[passengerIndex--]) return lastPassengerTime;\\n        }\\n        return lastPassengerTime;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int latestTimeCatchTheBus(int[] buses, int[] passengers, int capacity) {\\n        Arrays.sort(buses);\\n        Arrays.sort(passengers);\\n    \\n        int b = 0, p = 0;\\n        int busTime = 0, passengerIndex = 0, pCount = 0;\\n    \\n        while(b < buses.length) {\\n            busTime = buses[b++]; //keep the last bus time\\n            pCount = 0;\\n\\n            while(p < passengers.length && passengers[p] <= busTime && pCount < capacity) {\\n                if(b == buses.length) { //last bus then keep the passenger index\\n                    passengerIndex = p;\\n                }\\n                p++;\\n                pCount++;\\n            }\\n        }\\n        return getLatestArrivalTime(passengers, busTime, passengerIndex, pCount, capacity);\\n    }\\n\\n    public int getLatestArrivalTime(int[] passengers, int lastBusTime, int passengerIndex, int pCount, int capacity) {\\n        //if no passenger waiting at the bus stop for the last bus -> arrive at the last bus leaving time\\n        if (pCount == 0) return lastBusTime;\\n\\n        int lastPassengerTime = passengers[passengerIndex];\\n\\n        // if there is capacity and the last passenger waiting is earlier than the bus leaving time\\n        // then arrive at last bus leaving time\\n        if (lastPassengerTime < lastBusTime && pCount < capacity) return lastBusTime;\\n\\n        // iterate backward from last passenger arrival time \\n        // to find the latest arrival time which is not in the passengers\\n        for(; lastPassengerTime >= 0 && passengerIndex >= 0; lastPassengerTime--) {\\n            if(lastPassengerTime != passengers[passengerIndex--]) return lastPassengerTime;\\n        }\\n        return lastPassengerTime;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3984108,
                "title": "simple-and-easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int latestTimeCatchTheBus(int[] buses, int[] passengers, int capacity) {\\n        Arrays.sort(buses);\\n        Arrays.sort(passengers);\\n        int n = buses.length-1;\\n        if(passengers[0] > buses[n]) return buses[n];\\n        int ans = passengers[0] - 1,j=0;\\n        for(int i=0;i<=n;i++){\\n            int c =0;\\n            while(j<passengers.length && c < capacity && passengers[j] <= buses[i]){\\n                if(j > 0 && passengers[j] - passengers[j-1] != 1){\\n                    ans = passengers[j] - 1;\\n                }\\n                j++;c++;\\n            }\\n            if( j>0 && c < capacity && buses[i] != passengers[j-1]){\\n                ans = buses[i];\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int latestTimeCatchTheBus(int[] buses, int[] passengers, int capacity) {\\n        Arrays.sort(buses);\\n        Arrays.sort(passengers);\\n        int n = buses.length-1;\\n        if(passengers[0] > buses[n]) return buses[n];\\n        int ans = passengers[0] - 1,j=0;\\n        for(int i=0;i<=n;i++){\\n            int c =0;\\n            while(j<passengers.length && c < capacity && passengers[j] <= buses[i]){\\n                if(j > 0 && passengers[j] - passengers[j-1] != 1){\\n                    ans = passengers[j] - 1;\\n                }\\n                j++;c++;\\n            }\\n            if( j>0 && c < capacity && buses[i] != passengers[j-1]){\\n                ans = buses[i];\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3973896,
                "title": "clean-code-in-java-and-explained-inline",
                "content": "# Code\\n```\\nclass Solution {\\n    public int latestTimeCatchTheBus(int[] buses, int[] passengers, int cap) {\\n        Arrays.sort(buses);\\n        Arrays.sort(passengers);\\n\\n        int b = 0, p = 0;\\n        int m = buses.length, n = passengers.length;\\n        int cur = 0;\\n\\n        while (b < m) {\\n            // reset capacity for each bus\\n            cur = 0;\\n            // move the pointers and fill the bus with passengers until the last bus\\n            while (p < n && passengers[p] <= buses[b] && cur < cap) {\\n                p ++;\\n                cur ++;\\n            }\\n\\n            // for the last bus\\n            if (b == m-1) {\\n                // last p is not successfully added\\n                p--;\\n                // if bus is not full, you can board at bus arrival time or earlier\\n                if (cur < cap) {\\n                    int time = buses[b];\\n                    return findEmptyTimeSlot(passengers, time, p);\\n                } else {\\n                    // the bus is now full, you must board before the last person boarded on the bus\\n                    int time = passengers[p]-1;\\n                    // find the second last person\\n                    p--;\\n                    // skip clashed passengers to find a slot\\n                    return findEmptyTimeSlot(passengers, time, p);\\n                }\\n            }\\n            b++;\\n        }\\n\\n        return -1;\\n    }\\n\\n    private int findEmptyTimeSlot(int[] passenger, int time, int start) {\\n        while (start >= 0 && passenger[start] == time) {\\n            time --;\\n            start --;\\n        }\\n        return time;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int latestTimeCatchTheBus(int[] buses, int[] passengers, int cap) {\\n        Arrays.sort(buses);\\n        Arrays.sort(passengers);\\n\\n        int b = 0, p = 0;\\n        int m = buses.length, n = passengers.length;\\n        int cur = 0;\\n\\n        while (b < m) {\\n            // reset capacity for each bus\\n            cur = 0;\\n            // move the pointers and fill the bus with passengers until the last bus\\n            while (p < n && passengers[p] <= buses[b] && cur < cap) {\\n                p ++;\\n                cur ++;\\n            }\\n\\n            // for the last bus\\n            if (b == m-1) {\\n                // last p is not successfully added\\n                p--;\\n                // if bus is not full, you can board at bus arrival time or earlier\\n                if (cur < cap) {\\n                    int time = buses[b];\\n                    return findEmptyTimeSlot(passengers, time, p);\\n                } else {\\n                    // the bus is now full, you must board before the last person boarded on the bus\\n                    int time = passengers[p]-1;\\n                    // find the second last person\\n                    p--;\\n                    // skip clashed passengers to find a slot\\n                    return findEmptyTimeSlot(passengers, time, p);\\n                }\\n            }\\n            b++;\\n        }\\n\\n        return -1;\\n    }\\n\\n    private int findEmptyTimeSlot(int[] passenger, int time, int start) {\\n        while (start >= 0 && passenger[start] == time) {\\n            time --;\\n            start --;\\n        }\\n        return time;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3951010,
                "title": "golang-solution",
                "content": "# Code\\n```go\\nfunc latestTimeCatchTheBus(buses []int, passengers []int, capacity int) int {\\n\\tmagic := make([]int, 0, len(buses)+len(passengers))\\n\\tbusTime := make(map[int]bool, len(buses))\\n\\tpassengersTime := make(map[int]bool, len(passengers))\\n\\tfor _, b := range buses {\\n\\t\\tbusTime[b] = true\\n\\t\\tmagic = append(magic, b)\\n\\t}\\n\\tfor _, p := range passengers {\\n\\t\\tpassengersTime[p] = true\\n\\t\\tmagic = append(magic, p)\\n\\t}\\n\\tsort.Ints(magic)\\n\\totherPassengers := 0\\n\\tresSeat := len(buses) * capacity\\n\\tlastTime := 1\\n\\n\\tfor i, m := range magic {\\n\\t\\tif i > 0 && magic[i-1] == m {\\n\\t\\t\\t// already calculated\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tif passengersTime[m] {\\n\\t\\t\\tif !passengersTime[m-1] {\\n\\t\\t\\t\\t// arrive before passenger\\n\\t\\t\\t\\tlastTime = m-1\\n\\t\\t\\t}\\n\\t\\t\\totherPassengers++\\n\\t\\t}\\n\\t\\tif busTime[m] {\\n\\t\\t\\tif passengersTime[m] == false {\\n\\t\\t\\t\\t// no passenger at m, arrive with bus at m\\n\\t\\t\\t\\tlastTime = m\\n\\t\\t\\t}\\n\\t\\t\\tresSeat -= capacity\\n\\t\\t\\totherPassengers -= capacity\\n\\t\\t\\tif otherPassengers < 0 {\\n\\t\\t\\t\\totherPassengers = 0\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif otherPassengers + 1 > resSeat {\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t}\\n\\treturn lastTime\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc latestTimeCatchTheBus(buses []int, passengers []int, capacity int) int {\\n\\tmagic := make([]int, 0, len(buses)+len(passengers))\\n\\tbusTime := make(map[int]bool, len(buses))\\n\\tpassengersTime := make(map[int]bool, len(passengers))\\n\\tfor _, b := range buses {\\n\\t\\tbusTime[b] = true\\n\\t\\tmagic = append(magic, b)\\n\\t}\\n\\tfor _, p := range passengers {\\n\\t\\tpassengersTime[p] = true\\n\\t\\tmagic = append(magic, p)\\n\\t}\\n\\tsort.Ints(magic)\\n\\totherPassengers := 0\\n\\tresSeat := len(buses) * capacity\\n\\tlastTime := 1\\n\\n\\tfor i, m := range magic {\\n\\t\\tif i > 0 && magic[i-1] == m {\\n\\t\\t\\t// already calculated\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tif passengersTime[m] {\\n\\t\\t\\tif !passengersTime[m-1] {\\n\\t\\t\\t\\t// arrive before passenger\\n\\t\\t\\t\\tlastTime = m-1\\n\\t\\t\\t}\\n\\t\\t\\totherPassengers++\\n\\t\\t}\\n\\t\\tif busTime[m] {\\n\\t\\t\\tif passengersTime[m] == false {\\n\\t\\t\\t\\t// no passenger at m, arrive with bus at m\\n\\t\\t\\t\\tlastTime = m\\n\\t\\t\\t}\\n\\t\\t\\tresSeat -= capacity\\n\\t\\t\\totherPassengers -= capacity\\n\\t\\t\\tif otherPassengers < 0 {\\n\\t\\t\\t\\totherPassengers = 0\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif otherPassengers + 1 > resSeat {\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t}\\n\\treturn lastTime\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3936309,
                "title": "brute-force-simple-c-solution-without-dealing-with-corner-cases",
                "content": "# Intuition\\nbrute force\\n\\n# Approach\\nGiven that passengers arrival times are absolute and can not be duplicated, they need to tracked and compared as we advance our arrival time.\\n\\nThen we run the buses to services the passenger line. The capacity serves as the quota on each service while the line is allowed to fluctuate and grow and shrink without limit with each passenser\\'s arrival and boarding.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nint comp(const void *a, const void *b)\\n{\\n    const int *ia=a;\\n    const int *ib=b;\\n    return *ia-*ib;\\n}\\n\\nint latestTimeCatchTheBus(int* buses, int busesSize, int* passengers, int passengersSize, int capacity){\\n    int i, j, k, time, prev=-1;\\n\\n    // first sort times in order\\n    qsort(buses, busesSize, sizeof(int), comp);\\n    qsort(passengers, passengersSize, sizeof(int), comp);\\n\\n    for(i=j=0; i<busesSize; ++i) {                          // for each bus\\n        for(k=0;((j<passengersSize)&&(k<capacity));++k) {   // for each seat\\n            if (passengers[j] > buses[i]) {                 // line has been completely serviced\\n                break;\\n            }\\n            if ((passengers[j]-1) != prev) {                // we can delay our arrival and take the seat of this last passenger\\n                time = passengers[j] - 1;                   // if the arrival time has a gap between passengers\\n            }\\n            prev = passengers[j];                           // save current time for reference\\n            ++j;                                            // drain passenger queue\\n        }\\n\\n        // if bus is not at capacity and previous passenger didn\\'t arrival with the bus, we can arrival with the bus and take remaining seat\\n        if ((k!= capacity) && (prev != buses[i])) {\\n            time = buses[i];\\n        }\\n    }\\n\\n    return time;    \\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint comp(const void *a, const void *b)\\n{\\n    const int *ia=a;\\n    const int *ib=b;\\n    return *ia-*ib;\\n}\\n\\nint latestTimeCatchTheBus(int* buses, int busesSize, int* passengers, int passengersSize, int capacity){\\n    int i, j, k, time, prev=-1;\\n\\n    // first sort times in order\\n    qsort(buses, busesSize, sizeof(int), comp);\\n    qsort(passengers, passengersSize, sizeof(int), comp);\\n\\n    for(i=j=0; i<busesSize; ++i) {                          // for each bus\\n        for(k=0;((j<passengersSize)&&(k<capacity));++k) {   // for each seat\\n            if (passengers[j] > buses[i]) {                 // line has been completely serviced\\n                break;\\n            }\\n            if ((passengers[j]-1) != prev) {                // we can delay our arrival and take the seat of this last passenger\\n                time = passengers[j] - 1;                   // if the arrival time has a gap between passengers\\n            }\\n            prev = passengers[j];                           // save current time for reference\\n            ++j;                                            // drain passenger queue\\n        }\\n\\n        // if bus is not at capacity and previous passenger didn\\'t arrival with the bus, we can arrival with the bus and take remaining seat\\n        if ((k!= capacity) && (prev != buses[i])) {\\n            time = buses[i];\\n        }\\n    }\\n\\n    return time;    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3930065,
                "title": "very-intuitive-cpp-beats-99",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& buses, vector<int>& pass, int capacity) {\\n        sort(buses.begin(),buses.end());\\n        sort(pass.begin(),pass.end());\\n\\n        int i = 0, j = 0, ans = -1;\\n        int n = buses.size(), m = pass.size();\\n        int tmp;\\n\\n        while(i<n){\\n            int cap = capacity;\\n            \\n            while(j<m && cap){\\n                if(buses[i] >= pass[j]){\\n                    j++;\\n                    cap--;\\n                }\\n                else break;\\n            }\\n            \\n            if(cap > 0) tmp = buses[i];\\n            else tmp = pass[j-1];\\n            int k = j-1;\\n            \\n            while(k >= 0 && pass[k] == tmp){\\n                k--;\\n                tmp--;\\n            }\\n            ans = max(ans,tmp);\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& buses, vector<int>& pass, int capacity) {\\n        sort(buses.begin(),buses.end());\\n        sort(pass.begin(),pass.end());\\n\\n        int i = 0, j = 0, ans = -1;\\n        int n = buses.size(), m = pass.size();\\n        int tmp;\\n\\n        while(i<n){\\n            int cap = capacity;\\n            \\n            while(j<m && cap){\\n                if(buses[i] >= pass[j]){\\n                    j++;\\n                    cap--;\\n                }\\n                else break;\\n            }\\n            \\n            if(cap > 0) tmp = buses[i];\\n            else tmp = pass[j-1];\\n            int k = j-1;\\n            \\n            while(k >= 0 && pass[k] == tmp){\\n                k--;\\n                tmp--;\\n            }\\n            ans = max(ans,tmp);\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3929112,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public int latestTimeCatchTheBus(int[] buses, int[] passengers, int capacity) {\\n    Arrays.sort(buses);\\n    Arrays.sort(passengers);\\n\\n    if (passengers[0] > buses[buses.length - 1])\\n      return buses[buses.length - 1];\\n\\n    int ans = passengers[0] - 1;\\n    int i = 0; // buses\\' index\\n    int j = 0; // passengers\\' index\\n\\n    while (i < buses.length) {\\n      // Greedily make passengers catch buses[i]\\n      int arrived = 0;\\n      while (arrived < capacity && j < passengers.length && passengers[j] <= buses[i]) {\\n        if (j > 0 && passengers[j] != passengers[j - 1] + 1)\\n          ans = passengers[j] - 1;\\n        ++j;\\n        ++arrived;\\n      }\\n      // there\\'s room for buses[i] to carry a passenger arriving at buses[i]\\n      if (arrived < capacity && j > 0 && passengers[j - 1] != buses[i])\\n        ans = buses[i];\\n      ++i;\\n    }\\n\\n    return ans;\\n  }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public int latestTimeCatchTheBus(int[] buses, int[] passengers, int capacity) {\\n    Arrays.sort(buses);\\n    Arrays.sort(passengers);\\n\\n    if (passengers[0] > buses[buses.length - 1])\\n      return buses[buses.length - 1];\\n\\n    int ans = passengers[0] - 1;\\n    int i = 0; // buses\\' index\\n    int j = 0; // passengers\\' index\\n\\n    while (i < buses.length) {\\n      // Greedily make passengers catch buses[i]\\n      int arrived = 0;\\n      while (arrived < capacity && j < passengers.length && passengers[j] <= buses[i]) {\\n        if (j > 0 && passengers[j] != passengers[j - 1] + 1)\\n          ans = passengers[j] - 1;\\n        ++j;\\n        ++arrived;\\n      }\\n      // there\\'s room for buses[i] to carry a passenger arriving at buses[i]\\n      if (arrived < capacity && j > 0 && passengers[j - 1] != buses[i])\\n        ans = buses[i];\\n      ++i;\\n    }\\n\\n    return ans;\\n  }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3899597,
                "title": "java-solution-stack",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int latestTimeCatchTheBus(int[] buses, int[] passengers, int capacity) {\\n        Arrays.sort(buses);\\n        Arrays.sort(passengers);\\n        int i=0;\\n        int j = 0;\\n        int cap = 0;\\n        Stack<Integer> stack = new Stack<>();\\n        while(i<buses.length){\\n            cap = 0;\\n            while(cap<capacity && j<passengers.length && passengers[j]<=buses[i]){\\n                stack.add(passengers[j]);\\n                cap++;\\n                j++;\\n            }\\n            i++;\\n        }\\n        if(cap!=capacity)\\n        {\\n            int lastNum = buses[buses.length-1];\\n            while(!stack.isEmpty() && stack.peek()==lastNum)\\n            {\\n                lastNum = stack.pop()-1;\\n            }\\n            return lastNum;\\n        }\\n        while(!stack.isEmpty()){\\n            int remove = stack.pop();\\n            if(stack.isEmpty() || stack.peek()!=remove-1)\\n                return remove-1;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int latestTimeCatchTheBus(int[] buses, int[] passengers, int capacity) {\\n        Arrays.sort(buses);\\n        Arrays.sort(passengers);\\n        int i=0;\\n        int j = 0;\\n        int cap = 0;\\n        Stack<Integer> stack = new Stack<>();\\n        while(i<buses.length){\\n            cap = 0;\\n            while(cap<capacity && j<passengers.length && passengers[j]<=buses[i]){\\n                stack.add(passengers[j]);\\n                cap++;\\n                j++;\\n            }\\n            i++;\\n        }\\n        if(cap!=capacity)\\n        {\\n            int lastNum = buses[buses.length-1];\\n            while(!stack.isEmpty() && stack.peek()==lastNum)\\n            {\\n                lastNum = stack.pop()-1;\\n            }\\n            return lastNum;\\n        }\\n        while(!stack.isEmpty()){\\n            int remove = stack.pop();\\n            if(stack.isEmpty() || stack.peek()!=remove-1)\\n                return remove-1;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3888763,
                "title": "java-easy-to-understand-greedy-solution",
                "content": "\\n```\\nclass Solution {\\n    // always try catching the bus\\n    // even we can take on earlier bus, still try delaying the arrival time\\n    // use greedy algorithm\\n    // time: O(nlogn), space: O(n) where n = passenger size\\n    public int latestTimeCatchTheBus(int[] buses, int[] passengers, int capacity) {\\n        Arrays.sort(buses);\\n        Arrays.sort(passengers);\\n        Set<Integer> set = new HashSet<>();\\n        int res = 0, j = 0;\\n        for (int i = 0; i < buses.length; i++) {\\n            int count = 0;\\n            while(j < passengers.length && count < capacity && passengers[j] <= buses[i]) {\\n                if(!set.contains(passengers[j]-1)){\\n                    res = passengers[j]-1;\\n                }\\n                set.add(passengers[j]);\\n                j++; \\n                count++;\\n            }\\n            if (count < capacity && !set.contains(buses[i])){\\n                res = buses[i];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    // always try catching the bus\\n    // even we can take on earlier bus, still try delaying the arrival time\\n    // use greedy algorithm\\n    // time: O(nlogn), space: O(n) where n = passenger size\\n    public int latestTimeCatchTheBus(int[] buses, int[] passengers, int capacity) {\\n        Arrays.sort(buses);\\n        Arrays.sort(passengers);\\n        Set<Integer> set = new HashSet<>();\\n        int res = 0, j = 0;\\n        for (int i = 0; i < buses.length; i++) {\\n            int count = 0;\\n            while(j < passengers.length && count < capacity && passengers[j] <= buses[i]) {\\n                if(!set.contains(passengers[j]-1)){\\n                    res = passengers[j]-1;\\n                }\\n                set.add(passengers[j]);\\n                j++; \\n                count++;\\n            }\\n            if (count < capacity && !set.contains(buses[i])){\\n                res = buses[i];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3855689,
                "title": "python-beats-90-just-write-the-simulation",
                "content": "# Intuition\\nMaintain a queue of passengers waiting, and at each bus\\'s arrival, take passengers from the front of the queue.\\n\\nThe time you should arrive is either:\\n- At the last bus\\'s arrival time, if the last bus is empty\\n- Just before the last passenger, if the last bus is full\\n\\n# Complexity\\n- Time complexity:\\n$$O(nlogn) + O(mlogm) $$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def latestTimeCatchTheBus(self, buses: List[int], passengers: List[int], capacity: int) -> int:\\n        buses.sort()\\n        passengers.sort()\\n        all_pass = set(passengers)\\n        queue = [] # the waiting queue\\n        busses_passengers = [] # which passengers go in which bus\\n        passenger_ind = 0\\n        for bus in buses:\\n\\n            # append all passengers arriving <= bus to waiting queue\\n            while passenger_ind < len(passengers)\\\\\\n                and passengers[passenger_ind] <= bus:\\n                queue.append(passengers[passenger_ind])\\n                passenger_ind += 1\\n            \\n            # depart with passengers at the font of the queue\\n            full = len(queue) >= capacity\\n            if len(queue) > capacity:\\n                busses_passengers.append(queue[:capacity])\\n                queue = queue[capacity:]\\n            else:\\n                busses_passengers.append(queue)\\n                queue = []\\n\\n        # last bus is not full: get there at arrival time\\n        if not full:\\n            arrival = buses[-1]\\n            if arrival not in all_pass:\\n                return arrival\\n            my_time = arrival - 1\\n            return first_free_before(arrival, all_pass)\\n        # last bus is full: you need to get there before the last guy\\n        else:\\n            last_bus_passengers = busses_passengers[-1]\\n            guy_to_beat = last_bus_passengers[-1]\\n            my_time = guy_to_beat - 1\\n            return first_free_before(my_time, all_pass)\\n\\ndef first_free_before(my_time, all_pass):\\n    \"\"\"satisfy the condition that my time must be unique\"\"\"\\n    while my_time in all_pass:\\n        my_time -= 1\\n    return my_time\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def latestTimeCatchTheBus(self, buses: List[int], passengers: List[int], capacity: int) -> int:\\n        buses.sort()\\n        passengers.sort()\\n        all_pass = set(passengers)\\n        queue = [] # the waiting queue\\n        busses_passengers = [] # which passengers go in which bus\\n        passenger_ind = 0\\n        for bus in buses:\\n\\n            # append all passengers arriving <= bus to waiting queue\\n            while passenger_ind < len(passengers)\\\\\\n                and passengers[passenger_ind] <= bus:\\n                queue.append(passengers[passenger_ind])\\n                passenger_ind += 1\\n            \\n            # depart with passengers at the font of the queue\\n            full = len(queue) >= capacity\\n            if len(queue) > capacity:\\n                busses_passengers.append(queue[:capacity])\\n                queue = queue[capacity:]\\n            else:\\n                busses_passengers.append(queue)\\n                queue = []\\n\\n        # last bus is not full: get there at arrival time\\n        if not full:\\n            arrival = buses[-1]\\n            if arrival not in all_pass:\\n                return arrival\\n            my_time = arrival - 1\\n            return first_free_before(arrival, all_pass)\\n        # last bus is full: you need to get there before the last guy\\n        else:\\n            last_bus_passengers = busses_passengers[-1]\\n            guy_to_beat = last_bus_passengers[-1]\\n            my_time = guy_to_beat - 1\\n            return first_free_before(my_time, all_pass)\\n\\ndef first_free_before(my_time, all_pass):\\n    \"\"\"satisfy the condition that my time must be unique\"\"\"\\n    while my_time in all_pass:\\n        my_time -= 1\\n    return my_time\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3820554,
                "title": "easy-java-solution-greedy-clean-self-explanatory-code",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int latestTimeCatchTheBus(int[] buses, int[] passengers, int capacity) {\\n        Arrays.sort(buses);\\n        Arrays.sort(passengers);\\n\\n        int lastPassenger = 0 ; \\n        int currPassenger = 0 ;\\n        HashSet<Integer> boardedPassengers = new HashSet<>();\\n\\n        for(int i = 0 ; i < buses.length ; i++) {\\n            int countofPassengers = 0 ; \\n\\n            while (currPassenger < passengers.length &&\\n             countofPassengers < capacity && passengers[currPassenger] <= buses[i]) {\\n                 lastPassenger = passengers[currPassenger] ;\\n                 boardedPassengers.add(passengers[currPassenger++]);\\n                 countofPassengers++ ;\\n             }\\n\\n             if(i == buses.length - 1 && countofPassengers < capacity && lastPassenger < buses[i]) {\\n                 return buses[buses.length - 1] ;\\n             }\\n        }\\n        \\n        if(boardedPassengers.size() == 0)\\n        return buses[buses.length - 1] ;\\n\\n        while(boardedPassengers.contains(lastPassenger))\\n        lastPassenger-- ;\\n\\n        return lastPassenger ;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int latestTimeCatchTheBus(int[] buses, int[] passengers, int capacity) {\\n        Arrays.sort(buses);\\n        Arrays.sort(passengers);\\n\\n        int lastPassenger = 0 ; \\n        int currPassenger = 0 ;\\n        HashSet<Integer> boardedPassengers = new HashSet<>();\\n\\n        for(int i = 0 ; i < buses.length ; i++) {\\n            int countofPassengers = 0 ; \\n\\n            while (currPassenger < passengers.length &&\\n             countofPassengers < capacity && passengers[currPassenger] <= buses[i]) {\\n                 lastPassenger = passengers[currPassenger] ;\\n                 boardedPassengers.add(passengers[currPassenger++]);\\n                 countofPassengers++ ;\\n             }\\n\\n             if(i == buses.length - 1 && countofPassengers < capacity && lastPassenger < buses[i]) {\\n                 return buses[buses.length - 1] ;\\n             }\\n        }\\n        \\n        if(boardedPassengers.size() == 0)\\n        return buses[buses.length - 1] ;\\n\\n        while(boardedPassengers.contains(lastPassenger))\\n        lastPassenger-- ;\\n\\n        return lastPassenger ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3817062,
                "title": "rust-binary-search-solution-using-partition-point",
                "content": "# Approach\\nFirst we sort the arrays.\\n\\nWe must decide what times to try to arrive on. We try to arrive 1 minute earlier than each one of the passengers, and also right as the last bus is departing; we discard all possible times when we would arrive at the same time as some other passenger. This is collected in the `candidate_arrival_times` array.\\n\\nTo check if it\\'s possible to board a bus at a given arrival time we simulate it iterating through the buses and passengers.\\n\\nWe use the [partition_point method](https://doc.rust-lang.org/std/primitive.slice.html#method.partition_point) to binary search for the first possible time in `candidate_arrival_times` where we can\\'t board the bus. We return the time previous to this one, which is the latest time where we can.\\n\\n# Complexity\\n- Time complexity:\\n$$O(p \\\\log p)$$\\n\\n- Space complexity:\\n$$O(p)$$\\n\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn latest_time_catch_the_bus(mut buses: Vec<i32>, mut passengers: Vec<i32>, capacity: i32) -> i32 {\\n        buses.sort_unstable();\\n        passengers.sort_unstable();\\n\\n        let last_departure = *buses.last().unwrap();\\n        let mut candidate_arrival_times = passengers.iter()\\n            .filter(|&&p| (p <= last_departure && passengers.binary_search(&(p - 1)).is_err()))\\n            .map(|&p| p - 1)\\n            .chain(std::iter::once(last_departure))\\n            .collect::<Vec<_>>();\\n\\n        if passengers.binary_search(&last_departure).is_ok() {\\n            candidate_arrival_times.pop();\\n        }\\n\\n        fn is_possible(arrival_time: i32, buses: &Vec<i32>, passengers: &Vec<i32>, capacity: i32) -> bool {\\n            let mut i = 0;\\n            for &b in buses {\\n                for _ in 0..capacity {\\n                    if i == passengers.len() { return true; }\\n                    if arrival_time < passengers[i] {\\n                        if arrival_time <= b {\\n                            return true;\\n                        } else {\\n                            break;\\n                        }\\n                    } else {\\n                        if passengers[i] <= b {\\n                            i += 1;\\n                        } else {\\n                            break;\\n                        }\\n                    }\\n                }\\n            }\\n            false\\n        }\\n\\n        let idx = candidate_arrival_times\\n            .partition_point(|&arrival_time| is_possible(arrival_time, &buses, &passengers, capacity));\\n        candidate_arrival_times[idx-1]\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Rust",
                    "Two Pointers",
                    "Binary Search"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn latest_time_catch_the_bus(mut buses: Vec<i32>, mut passengers: Vec<i32>, capacity: i32) -> i32 {\\n        buses.sort_unstable();\\n        passengers.sort_unstable();\\n\\n        let last_departure = *buses.last().unwrap();\\n        let mut candidate_arrival_times = passengers.iter()\\n            .filter(|&&p| (p <= last_departure && passengers.binary_search(&(p - 1)).is_err()))\\n            .map(|&p| p - 1)\\n            .chain(std::iter::once(last_departure))\\n            .collect::<Vec<_>>();\\n\\n        if passengers.binary_search(&last_departure).is_ok() {\\n            candidate_arrival_times.pop();\\n        }\\n\\n        fn is_possible(arrival_time: i32, buses: &Vec<i32>, passengers: &Vec<i32>, capacity: i32) -> bool {\\n            let mut i = 0;\\n            for &b in buses {\\n                for _ in 0..capacity {\\n                    if i == passengers.len() { return true; }\\n                    if arrival_time < passengers[i] {\\n                        if arrival_time <= b {\\n                            return true;\\n                        } else {\\n                            break;\\n                        }\\n                    } else {\\n                        if passengers[i] <= b {\\n                            i += 1;\\n                        } else {\\n                            break;\\n                        }\\n                    }\\n                }\\n            }\\n            false\\n        }\\n\\n        let idx = candidate_arrival_times\\n            .partition_point(|&arrival_time| is_possible(arrival_time, &buses, &passengers, capacity));\\n        candidate_arrival_times[idx-1]\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3815243,
                "title": "the-latest-time-to-catch-a-bus",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def latestTimeCatchTheBus(self, buses: List[int], passengers: List[int], capacity: int) -> int:\\n        buses.sort()\\n        passengers.sort()\\n        c=0\\n        d={}\\n        i=0\\n        p=0\\n        while i<len(buses):\\n            l=[]\\n            while p<len(passengers):\\n                if passengers[p]<=buses[i] and c<capacity:\\n                    l.append(passengers[p])\\n                    p=p+1\\n                    c=c+1\\n                else:\\n                    c=0\\n                    break\\n            d[i]=l\\n            i=i+1\\n        print(d)\\n        l=d[len(buses)-1]\\n        print(l)\\n        if len(l)==0:\\n            return max(buses)\\n        elif len(l)<capacity:\\n            p=max(l)\\n            if p<max(buses):\\n                return max(buses)\\n            else:\\n                while p  in passengers:\\n                    p=p-1\\n                return p\\n        else:\\n            p=max(l)\\n            while p  in passengers:\\n                p=p-1\\n            return p\\n        return 0\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def latestTimeCatchTheBus(self, buses: List[int], passengers: List[int], capacity: int) -> int:\\n        buses.sort()\\n        passengers.sort()\\n        c=0\\n        d={}\\n        i=0\\n        p=0\\n        while i<len(buses):\\n            l=[]\\n            while p<len(passengers):\\n                if passengers[p]<=buses[i] and c<capacity:\\n                    l.append(passengers[p])\\n                    p=p+1\\n                    c=c+1\\n                else:\\n                    c=0\\n                    break\\n            d[i]=l\\n            i=i+1\\n        print(d)\\n        l=d[len(buses)-1]\\n        print(l)\\n        if len(l)==0:\\n            return max(buses)\\n        elif len(l)<capacity:\\n            p=max(l)\\n            if p<max(buses):\\n                return max(buses)\\n            else:\\n                while p  in passengers:\\n                    p=p-1\\n                return p\\n        else:\\n            p=max(l)\\n            while p  in passengers:\\n                p=p-1\\n            return p\\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3802500,
                "title": "c-solution-two-pointer-o-1-memory-beats-98",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nApproach described in comment format\\n\\n# Complexity\\n- Time complexity:\\n\\nO(n + m)\\n where n denotes the number of buses and m denotes the number of passengers\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  int latestTimeCatchTheBus(vector<int>& buses, vector<int>& passengers, int capacity) {\\n\\n       // Sort Timings on buses and passengers in increasing order\\n       sort(buses.begin(), buses.end());\\n       sort(passengers.begin(), passengers.end());\\n\\n       // Now for each bus we need to select which passengers are boarding\\n       // currBus is a pointer to the bus, currPass is a pointer to the next passenger who is boarding\\n       // currCap - indicates the current capacity of the bus being boarded\\n       int currBus = 0, currPass = 0, currCap;  \\n       for(currBus = 0; currBus < buses.size(); currBus++) {\\n          \\n          // Set capacity of each bus to 0 as boarding for currBus is starting\\n          currCap = 0;\\n\\n          // If capacity of the bus is not full and all passengers havent boarded yet \\n          // and next passenger to board has arrived before the time of the current bus\\n          while(currCap < capacity && currPass < passengers.size() \\n          && passengers[currPass] <= buses[currBus]) {\\n              currPass++; currCap++;\\n          }\\n       }\\n\\n       // currPass always indicates the next passenger to board the bus \\n       // Thus our latest time should be less than or equal to the last passenger \\n       // who boarded the bus \\n       currPass -= 1;\\n\\n\\n       // If currPass == -1, it means that all the passengers came after the last bus left\\n       // In this case, the latest time to board is the the time the last bus left\\n       if(currPass == -1 || (currCap < capacity && passengers[currPass] < buses[buses.size() - 1]))\\n            return buses[buses.size() - 1];\\n\\n       // currPass now denotes the passenger whose time is the latest we can board the bus at \\n       // However, since two passengers cannot have the same time of arrival\\n       // we can only arrive at time = passengers[currPass] - 1\\n       // It could be highly passenger that the previous passenger who boarded the bus \\n       // boarded at that time. Thus, we need to run the loop until we find an empty timeslot\\n       while(currPass > 0 && passengers[currPass - 1] + 1 == passengers[currPass])\\n            currPass--;\\n       \\n       return passengers[currPass] - 1;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int latestTimeCatchTheBus(vector<int>& buses, vector<int>& passengers, int capacity) {\\n\\n       // Sort Timings on buses and passengers in increasing order\\n       sort(buses.begin(), buses.end());\\n       sort(passengers.begin(), passengers.end());\\n\\n       // Now for each bus we need to select which passengers are boarding\\n       // currBus is a pointer to the bus, currPass is a pointer to the next passenger who is boarding\\n       // currCap - indicates the current capacity of the bus being boarded\\n       int currBus = 0, currPass = 0, currCap;  \\n       for(currBus = 0; currBus < buses.size(); currBus++) {\\n          \\n          // Set capacity of each bus to 0 as boarding for currBus is starting\\n          currCap = 0;\\n\\n          // If capacity of the bus is not full and all passengers havent boarded yet \\n          // and next passenger to board has arrived before the time of the current bus\\n          while(currCap < capacity && currPass < passengers.size() \\n          && passengers[currPass] <= buses[currBus]) {\\n              currPass++; currCap++;\\n          }\\n       }\\n\\n       // currPass always indicates the next passenger to board the bus \\n       // Thus our latest time should be less than or equal to the last passenger \\n       // who boarded the bus \\n       currPass -= 1;\\n\\n\\n       // If currPass == -1, it means that all the passengers came after the last bus left\\n       // In this case, the latest time to board is the the time the last bus left\\n       if(currPass == -1 || (currCap < capacity && passengers[currPass] < buses[buses.size() - 1]))\\n            return buses[buses.size() - 1];\\n\\n       // currPass now denotes the passenger whose time is the latest we can board the bus at \\n       // However, since two passengers cannot have the same time of arrival\\n       // we can only arrive at time = passengers[currPass] - 1\\n       // It could be highly passenger that the previous passenger who boarded the bus \\n       // boarded at that time. Thus, we need to run the loop until we find an empty timeslot\\n       while(currPass > 0 && passengers[currPass - 1] + 1 == passengers[currPass])\\n            currPass--;\\n       \\n       return passengers[currPass] - 1;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3775668,
                "title": "simple-c-solution-o-nlogn-mlogm-n-m",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nKeep assigning the bus to passengers and try to arrive as late as possible\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Please read the comments and follow the code that would be easier\\n2. Consider that you will never arrive and assign a bus to each passenger\\n3. With this, also assign a capacity with which each bus left\\n4. Now with the simple for loop, try to arrive as late as possible either before the last person who got the bus or before the last bus left with empty seats\\n\\n# Complexity\\n- Time complexity: O(nlogn + mlogm + n + m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n1. nlogn for sorting the buses\\n2. mlogm for sorting the passengers\\n3. n for the outer for loop in assign_bus_to_passengers\\n4. m for inner while loop in assign_bus_to_passengers\\nNote that the inner while loop is run once for each bus and not for every iteration of all passengers.\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nTo store the 2 vectors i.e. bus_capacity and bus_assignment\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int max_arrival_time = 1;\\n\\n    vector<int> bus_assignment;\\n\\n    vector<int> bus_capacity;\\n\\n    void assign_bus_to_passengers(vector<int>& buses, vector<int>& passengers, int capacity) {\\n        int bus_number = 0;\\n        int filled = 0;\\n        for ( int i = 0; i < passengers.size(); i++ ) {\\n            //depart all buses with departure time before the passenger arrives\\n            while ( bus_number < buses.size() && passengers[i] > buses[bus_number] ) {\\n                bus_capacity.push_back(filled);\\n                filled = 0;\\n                bus_number++;\\n            }\\n\\n            if ( bus_number == buses.size() ) {\\n                break;\\n            }\\n\\n            //put the customer on the bus\\n            bus_assignment.push_back(bus_number);\\n            filled++;\\n\\n            //if the bus is full, depart the bus\\n            if ( filled == capacity ) {\\n                bus_capacity.push_back(filled);\\n                filled = 0;\\n                bus_number++;\\n            }\\n        }\\n\\n        if ( filled > 0 && filled < capacity ) {\\n            bus_capacity.push_back(filled);\\n        }\\n\\n        for( int i = bus_assignment.size(); i < passengers.size(); i++ ) {\\n            cout<<\"i: \"<<i<<endl;\\n            bus_assignment.push_back(-1);\\n        }\\n        for ( int i = bus_capacity.size(); i < buses.size(); i++ ) {\\n            bus_capacity.push_back(0);\\n        }\\n    }\\n\\n    void calculate_max_arrival_time(vector<int>& buses, vector<int>& passengers, int capacity) {\\n        //if the last bus left with 0 passengers, max arrival time is that bus\\'s departure time\\n        if ( bus_capacity[buses.size() - 1] == 0 ) {\\n            max_arrival_time = buses[buses.size()-1];\\n            return;\\n        }\\n\\n        //this means that last passenger must have gotten onto the last bus\\n        // so if he arrived before the last bus left and last bus did not leave\\n        //with full capacity, that will be the max arrival time\\n        if ( (bus_assignment[passengers.size() - 1] == buses.size() - 1) && \\n             (bus_capacity[buses.size() - 1] < capacity) && \\n             (passengers[passengers.size() - 1] < buses[buses.size() -1 ]) ) {\\n            \\n            max_arrival_time = buses[buses.size() - 1];\\n            return;\\n        }\\n        max_arrival_time = passengers[0] - 1;\\n\\n        //I can get anywhere between the passenger who got the buses and I will get the bus instead of them\\n        for ( int i = 1; i < passengers.size(); i++ ) {\\n            //ith passenger got the bus and he does not immeidately\\n            //come after the previous passenger (consecutive times)\\n            if ( bus_assignment[i] != -1 &&\\n                 passengers[i] - passengers[i-1] != 1) {\\n                \\n                max_arrival_time = passengers[i] - 1;\\n            }\\n            //the first passenger who did not get on the bus.\\n            //see if he was late to get on the bus as the last passenger\\n            else if ( bus_assignment[i] == -1 ) {\\n                \\n                int last_passenger_bus = bus_assignment[i-1];\\n                int last_passenger_bus_capacity = bus_capacity[last_passenger_bus];\\n                if ( last_passenger_bus_capacity < capacity &&\\n                     passengers[i-1] < buses[last_passenger_bus] ) {\\n                    \\n                    max_arrival_time = buses[last_passenger_bus];\\n                }\\n                break;\\n            }\\n        }\\n    }\\n\\n    void set_max_arrival_time(vector<int>& buses, vector<int>& passengers, int capacity) {\\n        sort(buses.begin(), buses.end());\\n        sort(passengers.begin(), passengers.end());\\n        assign_bus_to_passengers(buses, passengers, capacity);\\n        calculate_max_arrival_time(buses, passengers, capacity);\\n    }\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& buses, vector<int>& passengers, int capacity) {\\n        set_max_arrival_time(buses, passengers, capacity);\\n        return max_arrival_time;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int max_arrival_time = 1;\\n\\n    vector<int> bus_assignment;\\n\\n    vector<int> bus_capacity;\\n\\n    void assign_bus_to_passengers(vector<int>& buses, vector<int>& passengers, int capacity) {\\n        int bus_number = 0;\\n        int filled = 0;\\n        for ( int i = 0; i < passengers.size(); i++ ) {\\n            //depart all buses with departure time before the passenger arrives\\n            while ( bus_number < buses.size() && passengers[i] > buses[bus_number] ) {\\n                bus_capacity.push_back(filled);\\n                filled = 0;\\n                bus_number++;\\n            }\\n\\n            if ( bus_number == buses.size() ) {\\n                break;\\n            }\\n\\n            //put the customer on the bus\\n            bus_assignment.push_back(bus_number);\\n            filled++;\\n\\n            //if the bus is full, depart the bus\\n            if ( filled == capacity ) {\\n                bus_capacity.push_back(filled);\\n                filled = 0;\\n                bus_number++;\\n            }\\n        }\\n\\n        if ( filled > 0 && filled < capacity ) {\\n            bus_capacity.push_back(filled);\\n        }\\n\\n        for( int i = bus_assignment.size(); i < passengers.size(); i++ ) {\\n            cout<<\"i: \"<<i<<endl;\\n            bus_assignment.push_back(-1);\\n        }\\n        for ( int i = bus_capacity.size(); i < buses.size(); i++ ) {\\n            bus_capacity.push_back(0);\\n        }\\n    }\\n\\n    void calculate_max_arrival_time(vector<int>& buses, vector<int>& passengers, int capacity) {\\n        //if the last bus left with 0 passengers, max arrival time is that bus\\'s departure time\\n        if ( bus_capacity[buses.size() - 1] == 0 ) {\\n            max_arrival_time = buses[buses.size()-1];\\n            return;\\n        }\\n\\n        //this means that last passenger must have gotten onto the last bus\\n        // so if he arrived before the last bus left and last bus did not leave\\n        //with full capacity, that will be the max arrival time\\n        if ( (bus_assignment[passengers.size() - 1] == buses.size() - 1) && \\n             (bus_capacity[buses.size() - 1] < capacity) && \\n             (passengers[passengers.size() - 1] < buses[buses.size() -1 ]) ) {\\n            \\n            max_arrival_time = buses[buses.size() - 1];\\n            return;\\n        }\\n        max_arrival_time = passengers[0] - 1;\\n\\n        //I can get anywhere between the passenger who got the buses and I will get the bus instead of them\\n        for ( int i = 1; i < passengers.size(); i++ ) {\\n            //ith passenger got the bus and he does not immeidately\\n            //come after the previous passenger (consecutive times)\\n            if ( bus_assignment[i] != -1 &&\\n                 passengers[i] - passengers[i-1] != 1) {\\n                \\n                max_arrival_time = passengers[i] - 1;\\n            }\\n            //the first passenger who did not get on the bus.\\n            //see if he was late to get on the bus as the last passenger\\n            else if ( bus_assignment[i] == -1 ) {\\n                \\n                int last_passenger_bus = bus_assignment[i-1];\\n                int last_passenger_bus_capacity = bus_capacity[last_passenger_bus];\\n                if ( last_passenger_bus_capacity < capacity &&\\n                     passengers[i-1] < buses[last_passenger_bus] ) {\\n                    \\n                    max_arrival_time = buses[last_passenger_bus];\\n                }\\n                break;\\n            }\\n        }\\n    }\\n\\n    void set_max_arrival_time(vector<int>& buses, vector<int>& passengers, int capacity) {\\n        sort(buses.begin(), buses.end());\\n        sort(passengers.begin(), passengers.end());\\n        assign_bus_to_passengers(buses, passengers, capacity);\\n        calculate_max_arrival_time(buses, passengers, capacity);\\n    }\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& buses, vector<int>& passengers, int capacity) {\\n        set_max_arrival_time(buses, passengers, capacity);\\n        return max_arrival_time;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3768981,
                "title": "binary-search-solution-well-commented-complexity-analysis",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} buses\\n * @param {number[]} passengers\\n * @param {number} capacity\\n * @return {number}\\n */\\n/*\\ntime complexity -> blog(b) + plog(p) + b * clog(c) + p = Nlog(N)\\n[b denotes no buses, c denotes capacity and P denotes Passengers]\\nspace complexity -> log(N) considering it as merge sort is used.  \\n*/\\n\\n\\nvar latestTimeCatchTheBus = function(buses, passengers, capacity) {\\n    buses.sort((a, b) => a - b);\\n    passengers.sort((a, b) => a - b);\\n    // search for the passenger we can board last in the current bus\\n    let search = (l ,r, target) => {\\n        while(l <= r){\\n            let mid = l + Math.floor((r - l) / 2);\\n            if(passengers[mid] == target){\\n                return mid;\\n            } else if(passengers[mid] < target){\\n                l = mid + 1;\\n            } else \\n                r = mid - 1;\\n        }\\n        // as l will cross the last value so we need to send l - 1 to get the last one.\\n        return l - 1; \\n    } \\n\\n    let iPassenger = -1;    \\n    let l, r;\\n    let currCapacity = 0;\\n    for(let i = 0; i < buses.length; i++) {\\n        l = iPassenger + 1;\\n        r = (l + capacity) - 1 < passengers.length ? (l + capacity) - 1 : passengers.length - 1;\\n        // iPassenger will be the last successful boarded passenger in the current bus\\n        iPassenger =  search(l, r, buses[i]); \\n        currCapacity =  iPassenger - l + 1; \\n    } \\n    // If current capacity is less than bus capacity means latest time will start from bus departure timing\\n    // else last successful passenger time - 1 is the latest time to arrive. \\n    let time = currCapacity < capacity ? buses[buses.length - 1] : passengers[iPassenger--] - 1;\\n    // as time should be unique, we need to continue shifting left until we found a unique time\\n    while(iPassenger >= 0 && time == passengers[iPassenger]){\\n        time--;\\n        iPassenger--;\\n    }  \\n    return time;   \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} buses\\n * @param {number[]} passengers\\n * @param {number} capacity\\n * @return {number}\\n */\\n/*\\ntime complexity -> blog(b) + plog(p) + b * clog(c) + p = Nlog(N)\\n[b denotes no buses, c denotes capacity and P denotes Passengers]\\nspace complexity -> log(N) considering it as merge sort is used.  \\n*/\\n\\n\\nvar latestTimeCatchTheBus = function(buses, passengers, capacity) {\\n    buses.sort((a, b) => a - b);\\n    passengers.sort((a, b) => a - b);\\n    // search for the passenger we can board last in the current bus\\n    let search = (l ,r, target) => {\\n        while(l <= r){\\n            let mid = l + Math.floor((r - l) / 2);\\n            if(passengers[mid] == target){\\n                return mid;\\n            } else if(passengers[mid] < target){\\n                l = mid + 1;\\n            } else \\n                r = mid - 1;\\n        }\\n        // as l will cross the last value so we need to send l - 1 to get the last one.\\n        return l - 1; \\n    } \\n\\n    let iPassenger = -1;    \\n    let l, r;\\n    let currCapacity = 0;\\n    for(let i = 0; i < buses.length; i++) {\\n        l = iPassenger + 1;\\n        r = (l + capacity) - 1 < passengers.length ? (l + capacity) - 1 : passengers.length - 1;\\n        // iPassenger will be the last successful boarded passenger in the current bus\\n        iPassenger =  search(l, r, buses[i]); \\n        currCapacity =  iPassenger - l + 1; \\n    } \\n    // If current capacity is less than bus capacity means latest time will start from bus departure timing\\n    // else last successful passenger time - 1 is the latest time to arrive. \\n    let time = currCapacity < capacity ? buses[buses.length - 1] : passengers[iPassenger--] - 1;\\n    // as time should be unique, we need to continue shifting left until we found a unique time\\n    while(iPassenger >= 0 && time == passengers[iPassenger]){\\n        time--;\\n        iPassenger--;\\n    }  \\n    return time;   \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3729890,
                "title": "minheap-set-python3-greedy-clean-solution",
                "content": "# Complexity\\n- Time complexity: O(BlogB + PlogP), where P=len(passengers) and B=len(buses)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(P)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def latestTimeCatchTheBus(self, buses: List[int], passengers: List[int], capacity: int) -> int:\\n        \\n        minHeap = []\\n        # Complexity of building heap is O(P)\\n        for p in passengers:\\n            heapq.heappush(minHeap,p)\\n        # Complexity of sorting buses is O(BlogB)\\n        buses.sort()\\n        ans = 0\\n        temp_arr=set()\\n        # Complexity of below loop: O(B + PlogP)\\n        for bus in buses:\\n            temp_cap=0\\n            while minHeap and minHeap[0]<=bus and temp_cap<capacity:\\n                p = heapq.heappop(minHeap)\\n                temp_arr.add(p)\\n                temp_cap+=1\\n                if p-1 not in temp_arr:\\n                    ans = p-1\\n            if temp_cap<capacity and bus not in temp_arr:\\n                ans = bus\\n        return ans\\n\\n    # Total complexity: O(P)+O(BlogB)+O(B + PlogP)\\n    # Overall complexity: O(BlogB + PlogP)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def latestTimeCatchTheBus(self, buses: List[int], passengers: List[int], capacity: int) -> int:\\n        \\n        minHeap = []\\n        # Complexity of building heap is O(P)\\n        for p in passengers:\\n            heapq.heappush(minHeap,p)\\n        # Complexity of sorting buses is O(BlogB)\\n        buses.sort()\\n        ans = 0\\n        temp_arr=set()\\n        # Complexity of below loop: O(B + PlogP)\\n        for bus in buses:\\n            temp_cap=0\\n            while minHeap and minHeap[0]<=bus and temp_cap<capacity:\\n                p = heapq.heappop(minHeap)\\n                temp_arr.add(p)\\n                temp_cap+=1\\n                if p-1 not in temp_arr:\\n                    ans = p-1\\n            if temp_cap<capacity and bus not in temp_arr:\\n                ans = bus\\n        return ans\\n\\n    # Total complexity: O(P)+O(BlogB)+O(B + PlogP)\\n    # Overall complexity: O(BlogB + PlogP)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3724960,
                "title": "o-1-space-90-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& buses, vector<int>& pass, int cap) {\\n        sort(begin(buses),end(buses));\\n        sort(begin(pass),end(pass));\\n        long long i=0,j=0,n=buses.size(),m=pass.size(),ans=0,cnt;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            cnt=0;\\n            while(cnt<cap && j<m && pass[j]<=buses[i])\\n            {\\n                if(j==0||pass[j]-pass[j-1]>1)\\n                ans=pass[j]-1;\\n                \\n                j++;\\n                cnt++;\\n            }\\n            if(cnt<cap && (j==0 || pass[j-1]!=buses[i])) ans=buses[i];\\n            if(j>1ll*n*cap) break;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& buses, vector<int>& pass, int cap) {\\n        sort(begin(buses),end(buses));\\n        sort(begin(pass),end(pass));\\n        long long i=0,j=0,n=buses.size(),m=pass.size(),ans=0,cnt;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            cnt=0;\\n            while(cnt<cap && j<m && pass[j]<=buses[i])\\n            {\\n                if(j==0||pass[j]-pass[j-1]>1)\\n                ans=pass[j]-1;\\n                \\n                j++;\\n                cnt++;\\n            }\\n            if(cnt<cap && (j==0 || pass[j-1]!=buses[i])) ans=buses[i];\\n            if(j>1ll*n*cap) break;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3724780,
                "title": "kotlin",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    fun latestTimeCatchTheBus(buses: IntArray, passengers: IntArray, capacity: Int): Int {\\n        buses.sort()\\n        passengers.sort()\\n        \\n        var p = 0\\n        var ans = 1\\n        var lastP = -1\\n        for(i in 0 until buses.size){\\n            val bus = buses[i]\\n            var count = 0\\n            \\n            while(p < passengers.size && passengers[p] <= bus && count < capacity){\\n                if(lastP != passengers[p] - 1) ans = passengers[p] - 1\\n                lastP = passengers[p]\\n                p++\\n                count++\\n                \\n            }\\n            if(count < capacity && lastP != bus) ans = bus\\n            \\n        }\\n\\n        return ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun latestTimeCatchTheBus(buses: IntArray, passengers: IntArray, capacity: Int): Int {\\n        buses.sort()\\n        passengers.sort()\\n        \\n        var p = 0\\n        var ans = 1\\n        var lastP = -1\\n        for(i in 0 until buses.size){\\n            val bus = buses[i]\\n            var count = 0\\n            \\n            while(p < passengers.size && passengers[p] <= bus && count < capacity){\\n                if(lastP != passengers[p] - 1) ans = passengers[p] - 1\\n                lastP = passengers[p]\\n                p++\\n                count++\\n                \\n            }\\n            if(count < capacity && lastP != bus) ans = bus\\n            \\n        }\\n\\n        return ans\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3713001,
                "title": "easiest-approach-to-the-answer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& buses, vector<int>& passengers, int capacity) {\\n\\n        sort(buses.begin(),buses.end());\\n        sort(passengers.begin(),passengers.end());\\n        int j=0;\\n        int ans=-1,n=buses.size(),m=passengers.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            \\n            int left=capacity;\\n            while(left && j<m && passengers[j]<=buses[i])\\n            {\\n                \\n                j++;\\n                left--;\\n            }\\n            \\n            if(i==n-1)\\n            {\\n                if(j>0)\\n                j--;\\n                // cout<<j<<endl;\\n                if(left && passengers[j]!=buses[i])\\n                {\\n                    ans=buses[i];\\n                }\\n                else\\n                {\\n                    // cout<<\"hi\";\\n                    while(j-1>=0 && passengers[j]-1==passengers[j-1])j--;\\n                    ans=passengers[j]-1;\\n                }\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sort",
                    "Sorting",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& buses, vector<int>& passengers, int capacity) {\\n\\n        sort(buses.begin(),buses.end());\\n        sort(passengers.begin(),passengers.end());\\n        int j=0;\\n        int ans=-1,n=buses.size(),m=passengers.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            \\n            int left=capacity;\\n            while(left && j<m && passengers[j]<=buses[i])\\n            {\\n                \\n                j++;\\n                left--;\\n            }\\n            \\n            if(i==n-1)\\n            {\\n                if(j>0)\\n                j--;\\n                // cout<<j<<endl;\\n                if(left && passengers[j]!=buses[i])\\n                {\\n                    ans=buses[i];\\n                }\\n                else\\n                {\\n                    // cout<<\"hi\";\\n                    while(j-1>=0 && passengers[j]-1==passengers[j-1])j--;\\n                    ans=passengers[j]-1;\\n                }\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3697449,
                "title": "kotlin-comented-code-using-set",
                "content": "# Intuition\\nYou need to check from last bus departure time or last pessennger arrival time till 1. \\n# Approach\\n1. Sort the arrays\\n2. Get a set of passengers\\n3. initilize busDepartureTime and lastPassengerTime\\n4. loop over buses\\n5. set the cap = capacity at be start of loop\\n6. Loop till cap > 0 && there are pessengers \\n7. If the current pessenger arrival time is less than current bus departure time and there is capacity then reduce the cap and update lastPassengerTime and increment the currentPassengerIndex\\n8. If the above condition fails break the inner loop and go for the next bus\\n9. Once the we looped over the busses , then we will check if there is capacity was availbale in last bus , if yes then we can set  from = busDepartureTime, (largest time you can afford) else take one unit less than the last pessenger\\n10. Loop from \\'from\\' till 1 and check if the number existt in set\\n11. If the number does not exist in set return it\\n\\n\\n# Complexity\\n\\n- Space complexity:\\nO(n), where n = passengers.length\\n\\n# Code\\n```\\nclass Solution {\\n    fun latestTimeCatchTheBus(buses: IntArray, passengers: IntArray, capacity: Int): Int {\\n        // Sort the inputs, so that we can fill the bus with passengers with given constraint\\n        buses.sort()\\n        passengers.sort()\\n\\n        // Set of the arrival time of passengers\\n\\n        val passengersArrivalTimeSet = passengers.toSet()\\n        // Max pessenger length\\n        val passLen = passengers.size\\n\\n        // current passenger index\\n\\n        var currentPassengerIndex = 0\\n        var cap = capacity\\n\\n        // Max time you can take\\n        var busDepartureTime = 0\\n        // lastt pessenger time\\n        var lastPassengerTime = 0\\n        \\n        for(busIndex in 0 until buses.size ) {\\n            busDepartureTime = buses[busIndex]\\n            cap = capacity\\n            // loop till capacity is avialble and have pessenger\\n            while(cap>0 && currentPassengerIndex<passLen){\\n                // if pessenger is arrived before or at bustime\\n                if(passengers[currentPassengerIndex]<=buses[busIndex]){\\n                    // reduce the capacity , as pessenger occupied the seat\\n                    cap--\\n                    \\n                    lastPassengerTime = passengers[currentPassengerIndex]\\n                    currentPassengerIndex++\\n                }else{\\n                    // if capacity is full or there is no pessenger break the loop\\n                    break\\n                }\\n            }\\n\\n        }\\n\\n        // we need to start from the lastPassengerTime\\n        // so, initilize from with last pessenger time\\n        // if tthere is capacitty left in last bus then updatte it with busDepartureTime\\n        var from = lastPassengerTime-1\\n         if(cap>0){\\n              from = busDepartureTime\\n         }\\n\\n        // check the time at which you come and it does not collied with other pessenger \\n\\n        for(i in from downTo 1){\\n            if(!passengersArrivalTimeSet.contains(i)){\\n                return i\\n            }\\n        }\\n\\n        return -1\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun latestTimeCatchTheBus(buses: IntArray, passengers: IntArray, capacity: Int): Int {\\n        // Sort the inputs, so that we can fill the bus with passengers with given constraint\\n        buses.sort()\\n        passengers.sort()\\n\\n        // Set of the arrival time of passengers\\n\\n        val passengersArrivalTimeSet = passengers.toSet()\\n        // Max pessenger length\\n        val passLen = passengers.size\\n\\n        // current passenger index\\n\\n        var currentPassengerIndex = 0\\n        var cap = capacity\\n\\n        // Max time you can take\\n        var busDepartureTime = 0\\n        // lastt pessenger time\\n        var lastPassengerTime = 0\\n        \\n        for(busIndex in 0 until buses.size ) {\\n            busDepartureTime = buses[busIndex]\\n            cap = capacity\\n            // loop till capacity is avialble and have pessenger\\n            while(cap>0 && currentPassengerIndex<passLen){\\n                // if pessenger is arrived before or at bustime\\n                if(passengers[currentPassengerIndex]<=buses[busIndex]){\\n                    // reduce the capacity , as pessenger occupied the seat\\n                    cap--\\n                    \\n                    lastPassengerTime = passengers[currentPassengerIndex]\\n                    currentPassengerIndex++\\n                }else{\\n                    // if capacity is full or there is no pessenger break the loop\\n                    break\\n                }\\n            }\\n\\n        }\\n\\n        // we need to start from the lastPassengerTime\\n        // so, initilize from with last pessenger time\\n        // if tthere is capacitty left in last bus then updatte it with busDepartureTime\\n        var from = lastPassengerTime-1\\n         if(cap>0){\\n              from = busDepartureTime\\n         }\\n\\n        // check the time at which you come and it does not collied with other pessenger \\n\\n        for(i in from downTo 1){\\n            if(!passengersArrivalTimeSet.contains(i)){\\n                return i\\n            }\\n        }\\n\\n        return -1\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3685962,
                "title": "python-simple",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def latestTimeCatchTheBus(self, buses: List[int], passengers: List[int], capacity: int) -> int:\\n        n = len(buses)\\n        m = len(passengers)\\n        passengers.sort()\\n        buses.sort()\\n        q = []\\n        latest = 0\\n        for i in range(n):\\n            \\n            c = 0\\n            if i == n-1:\\n                maxcap = capacity - 1\\n            else:\\n                maxcap = capacity\\n            while len(passengers) > 0 and c < maxcap and passengers[0] <= buses[i]:\\n                q.append(passengers[0])\\n                passengers.pop(0)\\n                c += 1\\n        \\n        latest = buses[-1]\\n        if len(passengers) == 0:\\n            while latest in q:\\n                latest -= 1\\n        else:\\n            while latest >= passengers[0] or latest in q:\\n                latest -= 1\\n        return latest\\n        \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def latestTimeCatchTheBus(self, buses: List[int], passengers: List[int], capacity: int) -> int:\\n        n = len(buses)\\n        m = len(passengers)\\n        passengers.sort()\\n        buses.sort()\\n        q = []\\n        latest = 0\\n        for i in range(n):\\n            \\n            c = 0\\n            if i == n-1:\\n                maxcap = capacity - 1\\n            else:\\n                maxcap = capacity\\n            while len(passengers) > 0 and c < maxcap and passengers[0] <= buses[i]:\\n                q.append(passengers[0])\\n                passengers.pop(0)\\n                c += 1\\n        \\n        latest = buses[-1]\\n        if len(passengers) == 0:\\n            while latest in q:\\n                latest -= 1\\n        else:\\n            while latest >= passengers[0] or latest in q:\\n                latest -= 1\\n        return latest\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3652962,
                "title": "java-enjoy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int latestTimeCatchTheBus(int[] buses, int[] passengers, int capacity) {\\n        Arrays.sort(buses);\\n        Arrays.sort(passengers);\\n\\n        int p=0,c=0;\\n        for(int bus : buses){\\n            c=0;\\n            while(c<capacity && p<passengers.length && passengers[p]<=bus){\\n                p++;\\n                c++;\\n            }\\n        }\\n        System.out.println(p+\" \"+c);\\n        int cutOff;\\n        if(c<capacity){\\n            cutOff = buses[buses.length-1];\\n        }else{\\n            cutOff = passengers[p-1];\\n        }\\n        Set<Integer> pass = new HashSet<>();\\n        for(int pas : passengers){\\n            pass.add(pas);\\n        }\\n        while(cutOff>=2){\\n            if(!pass.contains(cutOff)){\\n                return cutOff;\\n            }\\n            cutOff--;\\n        }\\n        return passengers[0]-1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int latestTimeCatchTheBus(int[] buses, int[] passengers, int capacity) {\\n        Arrays.sort(buses);\\n        Arrays.sort(passengers);\\n\\n        int p=0,c=0;\\n        for(int bus : buses){\\n            c=0;\\n            while(c<capacity && p<passengers.length && passengers[p]<=bus){\\n                p++;\\n                c++;\\n            }\\n        }\\n        System.out.println(p+\" \"+c);\\n        int cutOff;\\n        if(c<capacity){\\n            cutOff = buses[buses.length-1];\\n        }else{\\n            cutOff = passengers[p-1];\\n        }\\n        Set<Integer> pass = new HashSet<>();\\n        for(int pas : passengers){\\n            pass.add(pas);\\n        }\\n        while(cutOff>=2){\\n            if(!pass.contains(cutOff)){\\n                return cutOff;\\n            }\\n            cutOff--;\\n        }\\n        return passengers[0]-1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3644264,
                "title": "golang-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n+m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(m+n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc latestTimeCatchTheBus(buses []int, passengers []int, capacity int) int {\\n    sort.Ints(passengers)\\n    sort.Ints(buses)\\n    c := capacity\\n    var cur int\\n    curBus := 0\\n    curTime := buses[curBus]\\n    for cur = 0; cur < len(passengers); cur ++ {\\n        if passengers[cur] <= curTime && capacity > 0 {\\n            capacity -= 1\\n            continue\\n        } \\n            curBus += 1\\n          \\n            if curBus >= len(buses) {\\n                reIndex := cur-1\\n                if reIndex < 0 {\\n                    return buses[len(buses)-1]\\n                }\\n                result := passengers[reIndex]\\n                \\n                if buses[len(buses)-1] > result && (capacity > 0 || curBus < len(buses)-1) {\\n                        result = buses[len(buses)-1]\\n                }\\n\\n                for reIndex >= 0 &&passengers[reIndex] == result {\\n                    result --\\n                    reIndex -= 1\\n                }\\n                return result\\n            } else {\\n                curTime = buses[curBus]\\n                cur-= 1\\n                capacity = c\\n            }\\n    }\\n    reIndex := cur-1\\n    if reIndex < 0 {\\n        return buses[0]\\n    }\\n    result := passengers[reIndex]\\n    if buses[len(buses)-1] > result && (capacity > 0 || curBus < len(buses)-1) {\\n        result = buses[len(buses)-1]\\n    }\\n\\n    for reIndex >= 0 &&passengers[reIndex] == result {\\n        result --\\n        reIndex -= 1\\n    }\\n    return result\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc latestTimeCatchTheBus(buses []int, passengers []int, capacity int) int {\\n    sort.Ints(passengers)\\n    sort.Ints(buses)\\n    c := capacity\\n    var cur int\\n    curBus := 0\\n    curTime := buses[curBus]\\n    for cur = 0; cur < len(passengers); cur ++ {\\n        if passengers[cur] <= curTime && capacity > 0 {\\n            capacity -= 1\\n            continue\\n        } \\n            curBus += 1\\n          \\n            if curBus >= len(buses) {\\n                reIndex := cur-1\\n                if reIndex < 0 {\\n                    return buses[len(buses)-1]\\n                }\\n                result := passengers[reIndex]\\n                \\n                if buses[len(buses)-1] > result && (capacity > 0 || curBus < len(buses)-1) {\\n                        result = buses[len(buses)-1]\\n                }\\n\\n                for reIndex >= 0 &&passengers[reIndex] == result {\\n                    result --\\n                    reIndex -= 1\\n                }\\n                return result\\n            } else {\\n                curTime = buses[curBus]\\n                cur-= 1\\n                capacity = c\\n            }\\n    }\\n    reIndex := cur-1\\n    if reIndex < 0 {\\n        return buses[0]\\n    }\\n    result := passengers[reIndex]\\n    if buses[len(buses)-1] > result && (capacity > 0 || curBus < len(buses)-1) {\\n        result = buses[len(buses)-1]\\n    }\\n\\n    for reIndex >= 0 &&passengers[reIndex] == result {\\n        result --\\n        reIndex -= 1\\n    }\\n    return result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3627252,
                "title": "solution-with-a-clear-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int latestTimeCatchTheBus(int[] buses, int[] passengers, int capacity) {\\n        Arrays.sort(buses);\\n        Arrays.sort(passengers);\\n        int n = buses.length;\\n        int m = passengers.length;\\n\\n        int index = 0;\\n        int countLast = 0;\\n        for (int i = 0; i <n; i++){\\n            int count = 0;\\n            while (index < m && count < capacity && passengers[index] <= buses[i]){\\n                index++;\\n                count++;\\n                if (i == n-1) countLast++;\\n            }\\n        }\\n\\n\\n        Set<Integer> set = new HashSet<>();\\n        for (int time : passengers){\\n            set.add(time);\\n        }\\n\\n        //index -1 is the last one get on the bus.\\n        //if I arrive before that, I will be able to get on the bus. Question: do I need to arrive before that?\\n        //if index - 1 fills the capacity, then I need to arrive before that. If index - 1 doesn\\'t fill the capacity, then buses[n-1] or some number before that;\\n        //how to check that case? Use countLast logic.\\n\\n        if (countLast < capacity) { \\n            for(int time = buses[n-1]; time >=0; time --){\\n                if (!set.contains(time)) return time;\\n            }  \\n        }\\n\\n        for(int time = passengers[index - 1] - 1; time >=0; time --){\\n            if (!set.contains(time)) return time;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int latestTimeCatchTheBus(int[] buses, int[] passengers, int capacity) {\\n        Arrays.sort(buses);\\n        Arrays.sort(passengers);\\n        int n = buses.length;\\n        int m = passengers.length;\\n\\n        int index = 0;\\n        int countLast = 0;\\n        for (int i = 0; i <n; i++){\\n            int count = 0;\\n            while (index < m && count < capacity && passengers[index] <= buses[i]){\\n                index++;\\n                count++;\\n                if (i == n-1) countLast++;\\n            }\\n        }\\n\\n\\n        Set<Integer> set = new HashSet<>();\\n        for (int time : passengers){\\n            set.add(time);\\n        }\\n\\n        //index -1 is the last one get on the bus.\\n        //if I arrive before that, I will be able to get on the bus. Question: do I need to arrive before that?\\n        //if index - 1 fills the capacity, then I need to arrive before that. If index - 1 doesn\\'t fill the capacity, then buses[n-1] or some number before that;\\n        //how to check that case? Use countLast logic.\\n\\n        if (countLast < capacity) { \\n            for(int time = buses[n-1]; time >=0; time --){\\n                if (!set.contains(time)) return time;\\n            }  \\n        }\\n\\n        for(int time = passengers[index - 1] - 1; time >=0; time --){\\n            if (!set.contains(time)) return time;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3609746,
                "title": "golang-solution-2-pointer-sorting",
                "content": "# Approach\\nUse 2 pointers, one for passenger and other tracking bus index and find the latest time based on\\n* T-1 before a passenger\\'s arrival if previous passenger isn\\'t coming at T-1\\n* If all passengers have boarded for bus and there is still capacity left then latestTime is equal to bus timing\\n* Finally if all passengers have boarded but there are still buses to come, we set the latest time to last arrival of bus\\n\\n# Complexity\\n- Time complexity:\\nO(n) + O(nlog(n)) ~= O(nlogn)\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nfunc latestTimeCatchTheBus(buses []int, passengers []int, capacity int) int {\\n    sort.Ints(buses)\\n    sort.Ints(passengers)\\n    var paxIdx, busIdx, latestTime, count, lastPass int\\n    for paxIdx < len(passengers) && busIdx < len(buses) {\\n        count = 0\\n        // Fill the bus with passengers until full capacity\\n        for count < capacity && paxIdx < len(passengers) && passengers[paxIdx] <= buses[busIdx] {\\n            // If we can come before passengers arrival update latest time, ensuring that T-1 is not previous passenger\\'s time\\n            if passengers[paxIdx] > 1 && (passengers[paxIdx] - passengers[lastPass] > 1 || paxIdx==0) {\\n                latestTime = passengers[paxIdx]-1\\n            }\\n            lastPass = paxIdx\\n            paxIdx++\\n            count++\\n        }\\n        // If no one came at bus\\'s arrival time then latest time is bus arrival time\\n        if count < capacity && passengers[lastPass] != buses[busIdx]  {\\n            latestTime = buses[busIdx]\\n        }\\n        busIdx++\\n    }\\n    // If we still have buses to come after all passengers have boarded choose the last bus time\\n    if busIdx < len(buses) && paxIdx >= len(passengers) {\\n        latestTime = buses[len(buses)-1]\\n    }\\n    return latestTime\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc latestTimeCatchTheBus(buses []int, passengers []int, capacity int) int {\\n    sort.Ints(buses)\\n    sort.Ints(passengers)\\n    var paxIdx, busIdx, latestTime, count, lastPass int\\n    for paxIdx < len(passengers) && busIdx < len(buses) {\\n        count = 0\\n        // Fill the bus with passengers until full capacity\\n        for count < capacity && paxIdx < len(passengers) && passengers[paxIdx] <= buses[busIdx] {\\n            // If we can come before passengers arrival update latest time, ensuring that T-1 is not previous passenger\\'s time\\n            if passengers[paxIdx] > 1 && (passengers[paxIdx] - passengers[lastPass] > 1 || paxIdx==0) {\\n                latestTime = passengers[paxIdx]-1\\n            }\\n            lastPass = paxIdx\\n            paxIdx++\\n            count++\\n        }\\n        // If no one came at bus\\'s arrival time then latest time is bus arrival time\\n        if count < capacity && passengers[lastPass] != buses[busIdx]  {\\n            latestTime = buses[busIdx]\\n        }\\n        busIdx++\\n    }\\n    // If we still have buses to come after all passengers have boarded choose the last bus time\\n    if busIdx < len(buses) && paxIdx >= len(passengers) {\\n        latestTime = buses[len(buses)-1]\\n    }\\n    return latestTime\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3609745,
                "title": "golang-solution-2-pointer-sorting",
                "content": "# Approach\\nUse 2 pointers, one for passenger and other tracking bus index and find the latest time based on\\n* T-1 before a passenger\\'s arrival if previous passenger isn\\'t coming at T-1\\n* If all passengers have boarded for bus and there is still capacity left then latestTime is equal to bus timing\\n* Finally if all passengers have boarded but there are still buses to come, we set the latest time to last arrival of bus\\n\\n# Complexity\\n- Time complexity:\\nO(n) + O(nlog(n)) ~= O(nlogn)\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nfunc latestTimeCatchTheBus(buses []int, passengers []int, capacity int) int {\\n    sort.Ints(buses)\\n    sort.Ints(passengers)\\n    var paxIdx, busIdx, latestTime, count, lastPass int\\n    for paxIdx < len(passengers) && busIdx < len(buses) {\\n        count = 0\\n        for count < capacity && paxIdx < len(passengers) && passengers[paxIdx] <= buses[busIdx] {\\n            if passengers[paxIdx] > 1 && (passengers[paxIdx] - passengers[lastPass] > 1 || paxIdx==0) {\\n                latestTime = passengers[paxIdx]-1\\n            }\\n            lastPass = paxIdx\\n            paxIdx++\\n            count++\\n        }\\n        if count < capacity && passengers[lastPass] != buses[busIdx]  {\\n            latestTime = buses[busIdx]\\n        }\\n        busIdx++\\n    }\\n    if busIdx < len(buses) && paxIdx >= len(passengers) {\\n        latestTime = buses[len(buses)-1]\\n    }\\n    return latestTime\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc latestTimeCatchTheBus(buses []int, passengers []int, capacity int) int {\\n    sort.Ints(buses)\\n    sort.Ints(passengers)\\n    var paxIdx, busIdx, latestTime, count, lastPass int\\n    for paxIdx < len(passengers) && busIdx < len(buses) {\\n        count = 0\\n        for count < capacity && paxIdx < len(passengers) && passengers[paxIdx] <= buses[busIdx] {\\n            if passengers[paxIdx] > 1 && (passengers[paxIdx] - passengers[lastPass] > 1 || paxIdx==0) {\\n                latestTime = passengers[paxIdx]-1\\n            }\\n            lastPass = paxIdx\\n            paxIdx++\\n            count++\\n        }\\n        if count < capacity && passengers[lastPass] != buses[busIdx]  {\\n            latestTime = buses[busIdx]\\n        }\\n        busIdx++\\n    }\\n    if busIdx < len(buses) && paxIdx >= len(passengers) {\\n        latestTime = buses[len(buses)-1]\\n    }\\n    return latestTime\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3591124,
                "title": "simple-iterative-solution-with-explanation",
                "content": "# Intuition\\n1. Sort the departure times of the buses \\n2. Sort the arrival times of passengers\\n3. Try to fill each bus beginning from the first, buses[0] with passengers. While doing this step for any intermediate bus i with departure time buses[i], check if it is possible for you to fit in the bus. Then the problem becomes iterating over the departure times of buses and chekcing for the latest possible time to board that bus.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor the ith bus\\'s departure time, \\n    - check for possible passengers i.e $$arrivalTime_{passenger} <= departureTime_{bus_i]} + space_{bus_i]} < capacity$$ \\n    - if current elligible passenger $$j$$ arrives more than 1 unit of time after the previous passenger, update your arrival time: $$passengers[j] - 1$$ \\n    - if elligible passengers don\\'t fill up the bus, check if the latest passenger is arriving at the departure time i.e. buses[i]. If so, your time is already updated. If the latest passenger arrives eralier than departure, you update your ans to buses[i]\\n\\n# Complexity\\n- Time Complexity: Sorting will take$$ O(nlogn)$$ where n = number of buses + O(mlogm) where m = number of passengers. Then you loop over each of the n buses and vist each passenger only once. Thus $$O(n + m)$$\\nHence, Total complexity: $$O(nlogn) + O(mlogm) + O(n+m)$$\\nDpending on the relative values of m and n, we can further simplity, such as if m~n, complexity = $$2*O(nlogn) +O(2n) = O(nlogn) + O(n) = O(nlogn)  $$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nNo extra space other than simple variables. Hence,$$ O(1)$$\\n# Code\\n\\n```\\nclass Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& buses, vector<int>& passengers, int capacity) {\\n        int nb = (int)buses.size();\\n        int np = (int)passengers.size();\\n\\n        // Make sure times are in order\\n        sort(buses.begin(), buses.end());\\n        sort(passengers.begin(), passengers.end());\\n\\n        // Iterate over buses\\n        // fill each bus with passengers if available\\n        // Check what is the latest possible time for your arrival\\n        int ans = 0; // your arrival time\\n        int j = 0; //passenger pointer\\n        int prev_passenger = 0; // Time of arrival of prev passenger\\n        int count;\\n        for(int i = 0; i < nb; i++) {\\n            count = 0; // Check if cpacity is recahed for buses[i]\\n            // 1. Passengers available + 2. capacity available + 3. passangers arrive before departure of buses[i]\\n            while(j < np && count < capacity && passengers[j] <= buses[i]) {\\n                if(passengers[j] - prev_passenger > 1){\\n                    ans = passengers[j] - 1; // cannot arrive at the same time\\n                }\\n                prev_passenger = passengers[j];\\n                j++;\\n                count++;\\n            }\\n            // passengers did not fill the bus i, check if passenger can arrive at the LAST MINUTE\\n            if(count < capacity && prev_passenger < buses[i]){\\n                ans = buses[i];\\n            }\\n        }\\n    \\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& buses, vector<int>& passengers, int capacity) {\\n        int nb = (int)buses.size();\\n        int np = (int)passengers.size();\\n\\n        // Make sure times are in order\\n        sort(buses.begin(), buses.end());\\n        sort(passengers.begin(), passengers.end());\\n\\n        // Iterate over buses\\n        // fill each bus with passengers if available\\n        // Check what is the latest possible time for your arrival\\n        int ans = 0; // your arrival time\\n        int j = 0; //passenger pointer\\n        int prev_passenger = 0; // Time of arrival of prev passenger\\n        int count;\\n        for(int i = 0; i < nb; i++) {\\n            count = 0; // Check if cpacity is recahed for buses[i]\\n            // 1. Passengers available + 2. capacity available + 3. passangers arrive before departure of buses[i]\\n            while(j < np && count < capacity && passengers[j] <= buses[i]) {\\n                if(passengers[j] - prev_passenger > 1){\\n                    ans = passengers[j] - 1; // cannot arrive at the same time\\n                }\\n                prev_passenger = passengers[j];\\n                j++;\\n                count++;\\n            }\\n            // passengers did not fill the bus i, check if passenger can arrive at the LAST MINUTE\\n            if(count < capacity && prev_passenger < buses[i]){\\n                ans = buses[i];\\n            }\\n        }\\n    \\n        return ans;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3579164,
                "title": "python-simulation",
                "content": "# Intuition\\n- simulate the process and find the last person who took the bus.\\n- discuss these two cases:\\n    1. 0 capacity\\n    2. bus still have capicity for us, then we just arrive on time. at buses[-1]\\n- edge case: no matter which case you currently have, if someone occupy the time you want, keep tracing time backforward to find a valid time to get on the bus\\n\\n# Complexity\\n- Time complexity:\\n $$O(nlogn)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def latestTimeCatchTheBus(self, buses: List[int], passengers: List[int], capacity: int) -> int:\\n        buses.sort()\\n        passengers.sort()\\n\\n        m, n = len(buses), len(passengers)\\n\\n        cap = j = 0\\n        for i in range(m):\\n            cap = capacity # reset current capacity\\n            while j < n and passengers[j] <= buses[i] and cap > 0:\\n                cap -= 1\\n                j += 1\\n\\n        j -= 1 # last person step into the bus\\n\\n        # if still have capacity, we can just arrive on time, i.e. buses[m-1]\\n        if cap > 0:\\n            # if someone also arrive on that time\\n            if passengers[j] == buses[m-1]:\\n                j -= 1\\n                while j >= 0 and passengers[j]+1 == passengers[j+1]:\\n                    j -= 1\\n                return passengers[j+1]-1\\n\\n            return buses[m-1]\\n\\n        while j-1 >= 0 and passengers[j]-1 == passengers[j-1]:\\n            j -= 1\\n        return passengers[j]-1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def latestTimeCatchTheBus(self, buses: List[int], passengers: List[int], capacity: int) -> int:\\n        buses.sort()\\n        passengers.sort()\\n\\n        m, n = len(buses), len(passengers)\\n\\n        cap = j = 0\\n        for i in range(m):\\n            cap = capacity # reset current capacity\\n            while j < n and passengers[j] <= buses[i] and cap > 0:\\n                cap -= 1\\n                j += 1\\n\\n        j -= 1 # last person step into the bus\\n\\n        # if still have capacity, we can just arrive on time, i.e. buses[m-1]\\n        if cap > 0:\\n            # if someone also arrive on that time\\n            if passengers[j] == buses[m-1]:\\n                j -= 1\\n                while j >= 0 and passengers[j]+1 == passengers[j+1]:\\n                    j -= 1\\n                return passengers[j+1]-1\\n\\n            return buses[m-1]\\n\\n        while j-1 >= 0 and passengers[j]-1 == passengers[j-1]:\\n            j -= 1\\n        return passengers[j]-1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3576611,
                "title": "easy-to-understand-commented-python-queue",
                "content": "# Intuition\\nThere are two places where a latest arrival can be:\\n- Right as a bus is departing\\n- Before another passenger\\n\\n# Approach\\nSort both passengers and buses, iterate through both. If a latest arrival can cut before a passenger, note it. If a latest arrival can join as a bus is departing, note it. Make sure we don\\'t step onthe toes of another passenger.\\n\\n\\n# Complexity\\n- Time complexity:\\n`O(b*log(b) + k*log(k)) when n = len(buses) and p = len(passengers)`\\nWhy? While we start with sorting each list, the rest of the agorithm just iterates through those lists. Sorting becomes the biggest time sink.\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def latestTimeCatchTheBus(self, buses: List[int], passengers: List[int], capacity: int) -> int:\\n\\n        buses.sort() # sorted by departure time\\n        passengers = collections.deque(sorted(passengers)) # queue sorted by arrival time\\n\\n        latest_arrival = None # res\\n        last_passenger = None # notes last passenger in case we want to steal spot\\n\\n        for bus_time in sorted(buses): # iterate through buses\\n\\n            seats_available = capacity\\n\\n            # add passengers if seats are available\\n            while passengers and seats_available and passengers[0] <= bus_time:\\n\\n                # last arrival can cut in line if space available before new passenger\\n                if not last_passenger or last_passenger != passengers[0]-1:\\n                    latest_arrival = passengers[0]-1\\n\\n                last_passenger = passengers.popleft()\\n                seats_available -= 1\\n\\n            # if seats_available, last arrival can arrive when bus arrives\\n            if seats_available and (not last_passenger or last_passenger < bus_time):\\n                latest_arrival = bus_time\\n        \\n        return latest_arrival\\n\\n        \\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Queue",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def latestTimeCatchTheBus(self, buses: List[int], passengers: List[int], capacity: int) -> int:\\n\\n        buses.sort() # sorted by departure time\\n        passengers = collections.deque(sorted(passengers)) # queue sorted by arrival time\\n\\n        latest_arrival = None # res\\n        last_passenger = None # notes last passenger in case we want to steal spot\\n\\n        for bus_time in sorted(buses): # iterate through buses\\n\\n            seats_available = capacity\\n\\n            # add passengers if seats are available\\n            while passengers and seats_available and passengers[0] <= bus_time:\\n\\n                # last arrival can cut in line if space available before new passenger\\n                if not last_passenger or last_passenger != passengers[0]-1:\\n                    latest_arrival = passengers[0]-1\\n\\n                last_passenger = passengers.popleft()\\n                seats_available -= 1\\n\\n            # if seats_available, last arrival can arrive when bus arrives\\n            if seats_available and (not last_passenger or last_passenger < bus_time):\\n                latest_arrival = bus_time\\n        \\n        return latest_arrival\\n\\n        \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3550673,
                "title": "one-pass-two-pointer-solution-with-pre-sorting",
                "content": "# Code\\n```\\nfunc latestTimeCatchTheBus(buses []int, passengers []int, capacity int) int {\\n    sort.Ints(buses)\\n\\tsort.Ints(passengers)\\n\\n\\tprev, res := -1, -1\\n\\ti := 0\\n\\tfor _, busDepart := range buses {\\n\\t\\tcounter := 0\\n\\t\\tfor ; i < len(passengers) && passengers[i] <= busDepart && counter < capacity; i++ {\\n\\t\\t\\tp := passengers[i]\\n\\n\\t\\t\\tif p-1 != prev && p-1 <= busDepart {\\n\\t\\t\\t\\tres = p - 1\\n\\t\\t\\t}\\n\\n\\t\\t\\tprev = p\\n\\t\\t\\tcounter++\\n\\t\\t}\\n\\n\\t\\tif counter == capacity {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\n\\t\\tif prev != busDepart {\\n\\t\\t\\tres = busDepart\\n\\t\\t}\\n\\t}\\n\\n\\treturn res\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Array",
                    "Two Pointers",
                    "Sorting",
                    "Simulation"
                ],
                "code": "```\\nfunc latestTimeCatchTheBus(buses []int, passengers []int, capacity int) int {\\n    sort.Ints(buses)\\n\\tsort.Ints(passengers)\\n\\n\\tprev, res := -1, -1\\n\\ti := 0\\n\\tfor _, busDepart := range buses {\\n\\t\\tcounter := 0\\n\\t\\tfor ; i < len(passengers) && passengers[i] <= busDepart && counter < capacity; i++ {\\n\\t\\t\\tp := passengers[i]\\n\\n\\t\\t\\tif p-1 != prev && p-1 <= busDepart {\\n\\t\\t\\t\\tres = p - 1\\n\\t\\t\\t}\\n\\n\\t\\t\\tprev = p\\n\\t\\t\\tcounter++\\n\\t\\t}\\n\\n\\t\\tif counter == capacity {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\n\\t\\tif prev != busDepart {\\n\\t\\t\\tres = busDepart\\n\\t\\t}\\n\\t}\\n\\n\\treturn res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3545777,
                "title": "approach-thinking-brute-way-but-optimal-c-greedy",
                "content": "# Intuition\\nFirst board all the passengers then according to the cases determine whether you can arrive at last bus\\'s departure time or you need to deboard some passengers to get on a bus.\\n\\n# Approach\\nWe can first board all the passengers.\\ncase 1: if last bus still have a seat then i can come at the last bus\\'s departure time.\\ncase 2: all the seats are full and no buses are available the we are having a pointer on passenger list which shows the last passenger boarded we will check whether the time just before his arrival is free if free then return the time else move to previous passenger.\\n\\nNo passenger boarded the bus means I can arrive at the last bus\\'s departure time;\\n\\n# Complexity\\n- Time complexity:\\n  O(NlogN) for sorting thats the maximum if sorted data is given then O(N) time complexity.\\n\\n- Space complexity:\\n  O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& buses, vector<int>& passengers, int capacity) {\\n        sort(buses.begin(),buses.end());\\n        sort(passengers.begin(),passengers.end());\\n        for(auto i : buses) cout<<i<<\" \";\\n        cout<<endl;\\n        for(auto i : passengers) cout<<i<<\\' \\';\\n        int b = 0;\\n        int p = 0;\\n        int nb = buses.size();\\n        int np = passengers.size();\\n        int ans = 0;\\n        int lastc = 0;\\n        while(b < nb && p < np)\\n        {\\n            int c = 0;\\n            while(c < capacity && p < np && passengers[p] <= buses[b])\\n            {\\n                p++;\\n                c++;\\n            }\\n            lastc = c;\\n            b++;\\n        }\\n        p--;\\n        p = max(p,0);\\n        if(b == nb-1) return buses[b];\\n        if(lastc < capacity)\\n        {\\n            if(passengers[p] == buses[nb-1])\\n            {\\n                while(p > 0 && passengers[p] == passengers[p-1]+1) p--;\\n                return passengers[p]-1;\\n            }\\n            return buses[nb-1];\\n        }\\n        while(p > 0)\\n        {\\n            if(passengers[p] != passengers[p-1]+1) return passengers[p]-1;\\n            p--;\\n        }\\n        return passengers[p]-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& buses, vector<int>& passengers, int capacity) {\\n        sort(buses.begin(),buses.end());\\n        sort(passengers.begin(),passengers.end());\\n        for(auto i : buses) cout<<i<<\" \";\\n        cout<<endl;\\n        for(auto i : passengers) cout<<i<<\\' \\';\\n        int b = 0;\\n        int p = 0;\\n        int nb = buses.size();\\n        int np = passengers.size();\\n        int ans = 0;\\n        int lastc = 0;\\n        while(b < nb && p < np)\\n        {\\n            int c = 0;\\n            while(c < capacity && p < np && passengers[p] <= buses[b])\\n            {\\n                p++;\\n                c++;\\n            }\\n            lastc = c;\\n            b++;\\n        }\\n        p--;\\n        p = max(p,0);\\n        if(b == nb-1) return buses[b];\\n        if(lastc < capacity)\\n        {\\n            if(passengers[p] == buses[nb-1])\\n            {\\n                while(p > 0 && passengers[p] == passengers[p-1]+1) p--;\\n                return passengers[p]-1;\\n            }\\n            return buses[nb-1];\\n        }\\n        while(p > 0)\\n        {\\n            if(passengers[p] != passengers[p-1]+1) return passengers[p]-1;\\n            p--;\\n        }\\n        return passengers[p]-1;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3531746,
                "title": "using-2-heaps-o-nlogn-solution-without-using-a-visited-set-beats-98-memory",
                "content": "as titled, just keep track of last available time slot as you fill the bus and track the last used timeslot. \\n\\n# Code\\n```\\nclass Solution:\\n    def latestTimeCatchTheBus(self, buses: List[int], passengers: List[int], capacity: int) -> int:\\n        import heapq\\n\\n        heapq.heapify(buses)\\n        heapq.heapify(passengers)\\n        lastpassenger = 0\\n        lastavailable = 1\\n\\n        while buses:\\n            currentBus = heapq.heappop(buses)\\n            if not passengers:\\n                lastavailable = currentBus\\n            else:\\n                usedcap = 0\\n                while usedcap < capacity:\\n                    if not passengers or passengers[0] > currentBus:\\n                        break\\n                    passenger = heapq.heappop(passengers)\\n                    if lastpassenger != passenger-1:\\n                        lastavailable = passenger-1\\n                    lastpassenger = passenger\\n                    usedcap += 1\\n                endtime = currentBus\\n                if usedcap < capacity and lastpassenger < currentBus:\\n                    lastavailable = currentBus\\n\\n        return lastavailable\\n\\n            \\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def latestTimeCatchTheBus(self, buses: List[int], passengers: List[int], capacity: int) -> int:\\n        import heapq\\n\\n        heapq.heapify(buses)\\n        heapq.heapify(passengers)\\n        lastpassenger = 0\\n        lastavailable = 1\\n\\n        while buses:\\n            currentBus = heapq.heappop(buses)\\n            if not passengers:\\n                lastavailable = currentBus\\n            else:\\n                usedcap = 0\\n                while usedcap < capacity:\\n                    if not passengers or passengers[0] > currentBus:\\n                        break\\n                    passenger = heapq.heappop(passengers)\\n                    if lastpassenger != passenger-1:\\n                        lastavailable = passenger-1\\n                    lastpassenger = passenger\\n                    usedcap += 1\\n                endtime = currentBus\\n                if usedcap < capacity and lastpassenger < currentBus:\\n                    lastavailable = currentBus\\n\\n        return lastavailable\\n\\n            \\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3528405,
                "title": "c-two-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\nn: size of buses, m: size of passengers\\n- Time complexity:O(nlogn + mlogm)\\n\\n- Space complexity:O(nlogn + mlogm)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& buses, vector<int>& passengers, int capacity) {\\n        priority_queue<int, vector<int>, greater<int>> pq_buses(buses.begin(), buses.end());\\n        priority_queue<int, vector<int>, greater<int>> pq_passengers(passengers.begin(), passengers.end());\\n        unordered_set<int> visited;\\n        while (pq_buses.size() > 1) {\\n            int depart = pq_buses.top();\\n            int count = 0;\\n            while (!pq_passengers.empty() && pq_passengers.top() <= depart && count < capacity) {\\n                count++;\\n                visited.insert(pq_passengers.top());\\n                pq_passengers.pop();\\n            }\\n            pq_buses.pop();\\n        }\\n        int count = 0;\\n        while (!pq_passengers.empty() && count < capacity - 1) {\\n            count++;\\n            visited.insert(pq_passengers.top());\\n            pq_passengers.pop();\\n        }\\n        int res = pq_passengers.top() > pq_buses.top() ? pq_buses.top() : (pq_passengers.empty() ? pq_buses.top() : pq_passengers.top() - 1);\\n        while (visited.find(res) != visited.end()) {\\n            res--;\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& buses, vector<int>& passengers, int capacity) {\\n        priority_queue<int, vector<int>, greater<int>> pq_buses(buses.begin(), buses.end());\\n        priority_queue<int, vector<int>, greater<int>> pq_passengers(passengers.begin(), passengers.end());\\n        unordered_set<int> visited;\\n        while (pq_buses.size() > 1) {\\n            int depart = pq_buses.top();\\n            int count = 0;\\n            while (!pq_passengers.empty() && pq_passengers.top() <= depart && count < capacity) {\\n                count++;\\n                visited.insert(pq_passengers.top());\\n                pq_passengers.pop();\\n            }\\n            pq_buses.pop();\\n        }\\n        int count = 0;\\n        while (!pq_passengers.empty() && count < capacity - 1) {\\n            count++;\\n            visited.insert(pq_passengers.top());\\n            pq_passengers.pop();\\n        }\\n        int res = pq_passengers.top() > pq_buses.top() ? pq_buses.top() : (pq_passengers.empty() ? pq_buses.top() : pq_passengers.top() - 1);\\n        while (visited.find(res) != visited.end()) {\\n            res--;\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521437,
                "title": "solution-with-comments-greedy-two-pointers",
                "content": "# Intuition\\nGreedy to take passengers for each bus \\n\\n# Approach\\nTry to arrive right before each passenger if possible \\n\\n# Complexity\\n- Time complexity:\\nSort: O(nlgn) + O(nlgm) \\ncheck: O(n+m)\\n\\n- Space complexity:\\nSpace taken during sorting only. \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& buses, vector<int>& passengers, int capacity) {\\n        int bus_num = buses.size(), pass_num = passengers.size(); \\n        if ( bus_num == 0 || pass_num == 0 )\\n            return 0;\\n        sort( buses.begin(), buses.end());\\n        sort( passengers.begin(), passengers.end());\\n        // special case where all passengers arrived after all buses departed, then the last bus departure time is the latest time for which the passenger can catch a (i.e., the last) bus. \\n        if ( passengers.front() > buses.back() )\\n            return buses.back();\\n        int i = 0, j = 0, res = passengers[0]-1;\\n        while( i < bus_num )\\n        {\\n            int cur_taken = 0;\\n            // if the current bus has room and the next passenger in the line arrived earlier than the current bus departure time\\n            // if the previous onborded passenger is not one time unit before the passenger, then we could arrive right before the\\n            // passenger, obatining a later arrive time. Otherwise, the time was already updated the same manner when processing previous passengers. \\n            while( cur_taken < capacity && j < pass_num && passengers[j] <= buses[i] )\\n            {\\n                // we find a viable later arrival time for the passenger\\n                if ( j > 0 && passengers[j-1] + 1 != passengers[j] ) \\n                {\\n                    res = passengers[j]-1;\\n                }\\n                cur_taken++;\\n                j++;\\n            }\\n            // if the above while exit due to condition that the bus was not full and the arrival time of the last onboarded passenger is earlier than buses departure time, \\n            // the we have another even later arrival time for the passenger, which is equal to the bus departure time. \\n            if ( cur_taken < capacity && j > 0 && passengers[j-1] != buses[i] )\\n                res = buses[i];\\n            i++;\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& buses, vector<int>& passengers, int capacity) {\\n        int bus_num = buses.size(), pass_num = passengers.size(); \\n        if ( bus_num == 0 || pass_num == 0 )\\n            return 0;\\n        sort( buses.begin(), buses.end());\\n        sort( passengers.begin(), passengers.end());\\n        // special case where all passengers arrived after all buses departed, then the last bus departure time is the latest time for which the passenger can catch a (i.e., the last) bus. \\n        if ( passengers.front() > buses.back() )\\n            return buses.back();\\n        int i = 0, j = 0, res = passengers[0]-1;\\n        while( i < bus_num )\\n        {\\n            int cur_taken = 0;\\n            // if the current bus has room and the next passenger in the line arrived earlier than the current bus departure time\\n            // if the previous onborded passenger is not one time unit before the passenger, then we could arrive right before the\\n            // passenger, obatining a later arrive time. Otherwise, the time was already updated the same manner when processing previous passengers. \\n            while( cur_taken < capacity && j < pass_num && passengers[j] <= buses[i] )\\n            {\\n                // we find a viable later arrival time for the passenger\\n                if ( j > 0 && passengers[j-1] + 1 != passengers[j] ) \\n                {\\n                    res = passengers[j]-1;\\n                }\\n                cur_taken++;\\n                j++;\\n            }\\n            // if the above while exit due to condition that the bus was not full and the arrival time of the last onboarded passenger is earlier than buses departure time, \\n            // the we have another even later arrival time for the passenger, which is equal to the bus departure time. \\n            if ( cur_taken < capacity && j > 0 && passengers[j-1] != buses[i] )\\n                res = buses[i];\\n            i++;\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3516854,
                "title": "c-simple-logic-cut-in-to-each-boarding-passenger",
                "content": "```\\nclass Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& buses, vector<int>& passengers, int capacity) {\\n        sort(buses.begin(), buses.end());\\n        passengers.push_back(0);\\n        sort(passengers.begin(), passengers.end());\\n        int ans = 1, p = 1, m = passengers.size();\\n        for(auto leave : buses) {\\n            int taken = 0;\\n            for(; p < m && taken < capacity && passengers[p] <= leave; ++taken, ++p) {\\n                if(passengers[p] - passengers[p-1] > 1)\\n                    ans = passengers[p] - 1;\\n            }\\n            if(taken < capacity) {\\n                if(passengers[p-1] != leave)\\n                    ans = leave;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& buses, vector<int>& passengers, int capacity) {\\n        sort(buses.begin(), buses.end());\\n        passengers.push_back(0);\\n        sort(passengers.begin(), passengers.end());\\n        int ans = 1, p = 1, m = passengers.size();\\n        for(auto leave : buses) {\\n            int taken = 0;\\n            for(; p < m && taken < capacity && passengers[p] <= leave; ++taken, ++p) {\\n                if(passengers[p] - passengers[p-1] > 1)\\n                    ans = passengers[p] - 1;\\n            }\\n            if(taken < capacity) {\\n                if(passengers[p-1] != leave)\\n                    ans = leave;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3501830,
                "title": "simple-straightforward-solution",
                "content": "# Intuition\\nFirst, of course, sort `buses` and `passengers`.\\n\\nFor each bus, find the passengers that can get on it and see when you can arrive to get on this bus. Ideally, it would be best to arrive at the same time when the bus arrives (because it\\'s the latest possible time), but the point is that passengers who arrive sooner than you go first. Therefore, if the number of passengers is less than capacity, you can try arriving at `buses[i]`; otherwise, you need to replace the last passenger by arriving a little bit sooner. When you decide when you want to arrive, you just need to find a time that is not occupied by any other passenger.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& buses, vector<int>& passengers, int capacity) {\\n        sort(buses.begin(), buses.end());\\n        sort(passengers.begin(), passengers.end());\\n        int res = 0, bs = buses.size(), ps = passengers.size();\\n        for (int i = 0, j = 0; i < bs; ++i) {\\n            int k = 0, cnt = 0;\\n            while (cnt < capacity && j < ps && passengers[j] <= buses[i]) {\\n                k = j++;\\n                ++cnt;\\n            }\\n            auto time = cnt == capacity ? passengers[k] : buses[i];\\n            while (k >= 0 && time == passengers[k]) {\\n                --time;\\n                --k;\\n            }\\n            res = max(res, time);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& buses, vector<int>& passengers, int capacity) {\\n        sort(buses.begin(), buses.end());\\n        sort(passengers.begin(), passengers.end());\\n        int res = 0, bs = buses.size(), ps = passengers.size();\\n        for (int i = 0, j = 0; i < bs; ++i) {\\n            int k = 0, cnt = 0;\\n            while (cnt < capacity && j < ps && passengers[j] <= buses[i]) {\\n                k = j++;\\n                ++cnt;\\n            }\\n            auto time = cnt == capacity ? passengers[k] : buses[i];\\n            while (k >= 0 && time == passengers[k]) {\\n                --time;\\n                --k;\\n            }\\n            res = max(res, time);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3493367,
                "title": "c-java-sort-and-use-two-pointers",
                "content": "## Intuition\\nThe problem asks us to find the latest time, we can arrive at the bus station, so that we can catch a bus and the arrival time should not be the same as any other passenger. So we simply need to **find a time which is less than the last passenger\\'s (to catch the bus) arrival time which is not the arrival time of any other passenger**. **If all the passengers could catch the bus and there\\'s still time capacity left in the last bus, then return the last bus\\'s arrival time.**\\n\\n## Explanation\\n\\nUse two pointers to keep track of the buses and the passengers and at each step until the last passenger (to catch the bus), check if the previous second of the passenger\\'s arrival time is available and update it. We can use a set to store all passengers\\' arrival time. Finally, if the last bus can be caught, we return the last bus\\' arrival time.\\n\\n## Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& buses, vector<int>& passengers, int capacity) {\\n    \\n        int l = 0, r = 0, busCount = size(buses), passCount = size(passengers), res = 0;\\n        sort(begin(buses), end(buses));\\n        sort(begin(passengers), end(passengers));\\n        unordered_set<int> passes;\\n        \\n        while(l < busCount and r < passCount){\\n            int busTime = buses[l], cap = capacity;\\n            for(int i = 0; i < capacity; i++){\\n                if(r == passCount) break;\\n                if(passengers[r] > busTime){\\n                    if(passes.count(busTime) == 0) res = busTime;\\n                    break;\\n                }\\n                passes.insert(passengers[r]);\\n                if(passes.count(passengers[r] - 1) == 0) res = passengers[r] - 1;\\n                r++, cap--;\\n            }\\n            if(cap and passes.count(busTime) == 0) res = busTime;\\n            l++;\\n        }\\n        if(l < busCount) res = buses[busCount-1];\\n        return res;\\n    }\\n};\\n```\\n```Java []\\n\\nclass Solution {\\n    public int latestTimeCatchTheBus(int[] buses, int[] passengers, int capacity) {\\n        int l = 0, r = 0, busCount = buses.length, passCount = passengers.length, res = 0;\\n        Arrays.sort(buses);\\n        Arrays.sort(passengers);\\n        Set<Integer> passes = new HashSet<>();\\n        \\n        while(l < busCount && r < passCount){\\n            int busTime = buses[l], cap = capacity;\\n            for(int i = 0; i < capacity; i++){\\n                if(r == passCount) break;\\n                if(passengers[r] > busTime){\\n                    if(!passes.contains(busTime)) res = busTime;\\n                    break;\\n                }\\n                passes.add(passengers[r]);\\n                if(!passes.contains(passengers[r] - 1)) res = passengers[r] - 1;\\n                r++; cap--;\\n            }\\n            if(cap > 0 && !passes.contains(busTime)) res = busTime;\\n            l++;\\n        }\\n        if(l < busCount) res = buses[busCount-1];\\n        return res;\\n    }\\n}\\n```\\n\\n# Complexity\\n- Time complexity: $$O(max(m,n) *log(max(m,n)))$$ [ m - no. of buses, n - no. of passengers]\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$ [n - no. of passengers]\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& buses, vector<int>& passengers, int capacity) {\\n    \\n        int l = 0, r = 0, busCount = size(buses), passCount = size(passengers), res = 0;\\n        sort(begin(buses), end(buses));\\n        sort(begin(passengers), end(passengers));\\n        unordered_set<int> passes;\\n        \\n        while(l < busCount and r < passCount){\\n            int busTime = buses[l], cap = capacity;\\n            for(int i = 0; i < capacity; i++){\\n                if(r == passCount) break;\\n                if(passengers[r] > busTime){\\n                    if(passes.count(busTime) == 0) res = busTime;\\n                    break;\\n                }\\n                passes.insert(passengers[r]);\\n                if(passes.count(passengers[r] - 1) == 0) res = passengers[r] - 1;\\n                r++, cap--;\\n            }\\n            if(cap and passes.count(busTime) == 0) res = busTime;\\n            l++;\\n        }\\n        if(l < busCount) res = buses[busCount-1];\\n        return res;\\n    }\\n};\\n```\n```Java []\\n\\nclass Solution {\\n    public int latestTimeCatchTheBus(int[] buses, int[] passengers, int capacity) {\\n        int l = 0, r = 0, busCount = buses.length, passCount = passengers.length, res = 0;\\n        Arrays.sort(buses);\\n        Arrays.sort(passengers);\\n        Set<Integer> passes = new HashSet<>();\\n        \\n        while(l < busCount && r < passCount){\\n            int busTime = buses[l], cap = capacity;\\n            for(int i = 0; i < capacity; i++){\\n                if(r == passCount) break;\\n                if(passengers[r] > busTime){\\n                    if(!passes.contains(busTime)) res = busTime;\\n                    break;\\n                }\\n                passes.add(passengers[r]);\\n                if(!passes.contains(passengers[r] - 1)) res = passengers[r] - 1;\\n                r++; cap--;\\n            }\\n            if(cap > 0 && !passes.contains(busTime)) res = busTime;\\n            l++;\\n        }\\n        if(l < busCount) res = buses[busCount-1];\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3474649,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nint compare_int( const void* a, const void* b )\\n{\\n    if( *(int*)a == *(int*)b ) return 0;\\n    return *(int*)a < *(int*)b ? -1 : 1;\\n}\\n\\nint latestTimeCatchTheBus(int* buses, int busesSize, int* passengers, int passengersSize, int capacity){\\n    qsort(buses, busesSize, sizeof(int), compare_int);\\n    qsort(passengers, passengersSize, sizeof(int), compare_int);\\n\\n    int i;\\n    int j = 0;\\n    int p = 0;\\n    int lastBoardedBus = -1;\\n    int lastBus = busesSize - 1;\\n\\n    for (i = 0; i < busesSize; i++)\\n        for (j = 0; j < capacity && p < passengersSize && passengers[p] <= buses[i]; j++)\\n        {\\n            lastBoardedBus = i;\\n            p++;\\n        }\\n   \\n    if (lastBoardedBus != lastBus)\\n        return buses[lastBus];\\n\\n    p--;\\n\\n    if ((j < capacity) &&        \\n        ((passengers[p] + 1 <= buses[lastBoardedBus])))\\n        return buses[lastBoardedBus];\\n\\n    while ((p > 0) && \\n           (passengers[p] - 1 == passengers[p - 1]))\\n        p--;\\n\\n    return passengers[p] - 1;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint compare_int( const void* a, const void* b )\\n{\\n    if( *(int*)a == *(int*)b ) return 0;\\n    return *(int*)a < *(int*)b ? -1 : 1;\\n}\\n\\nint latestTimeCatchTheBus(int* buses, int busesSize, int* passengers, int passengersSize, int capacity){\\n    qsort(buses, busesSize, sizeof(int), compare_int);\\n    qsort(passengers, passengersSize, sizeof(int), compare_int);\\n\\n    int i;\\n    int j = 0;\\n    int p = 0;\\n    int lastBoardedBus = -1;\\n    int lastBus = busesSize - 1;\\n\\n    for (i = 0; i < busesSize; i++)\\n        for (j = 0; j < capacity && p < passengersSize && passengers[p] <= buses[i]; j++)\\n        {\\n            lastBoardedBus = i;\\n            p++;\\n        }\\n   \\n    if (lastBoardedBus != lastBus)\\n        return buses[lastBus];\\n\\n    p--;\\n\\n    if ((j < capacity) &&        \\n        ((passengers[p] + 1 <= buses[lastBoardedBus])))\\n        return buses[lastBoardedBus];\\n\\n    while ((p > 0) && \\n           (passengers[p] - 1 == passengers[p - 1]))\\n        p--;\\n\\n    return passengers[p] - 1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3436226,
                "title": "c-solution-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThere\\'s a $$\\\\hat{t}$$ such that all arrival times $$t \\\\leq \\\\hat{t}$$ are able to get on a bus and all arrival times $$t > \\\\hat{t}$$ are not. This is clearly solvable via binary search with the answer being $$\\\\hat{t}$$. This is not always the case but easily fixable, see note 2.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSimulate all of the events in order (people arriving ans buses departing) and save: a) how many people were queued at time $$t_{event}$$ and b) how many seats are left at time $$t_{event}$$.\\n\\nIf you arrive at time $$t$$ and if 1 + the number of people queued at time $$t$$ is more than the number of seats left, then is not possible to take a bus. Otherwise it is possible. Considering this information, use binary search to find $$\\\\hat{t}$$.\\n\\nTo find out how many people were queued at time $$t$$, find $$t_{event}$$ such that it is the largest time saved that is smaller or equal than $$t$$. Same for the number of seats left.\\n\\n$$\\\\textbf{Note:}$$\\nMake sure to pay attention to the case where a person arrives at time $$t$$ and a bus departs at time $$t$$. The bus could have $$x$$ seats available with $$0 \\\\leq x \\\\leq capacity$$. So a person who arrives in this scenario could get a seat. Consider the following test cases for better understanding of these scenarios:\\n\\nbuses: 4\\npeople: 2 3\\ncapacity: 2 \\n\\nbuses: 3\\npeople: 2\\ncapacity: 2\\n\\n$$\\\\textbf{Note 2:}$$\\n$$\\\\hat{t}$$ could not be the accepted answer if in the input for the time of arrival of the people contains $$\\\\hat{t}$$. Just find a smaller $$t$$ not in the input.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(xlogx)$$ with $$x = max(n,m)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n + m)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    typedef long long ll;\\n\\n    void sim(map<int, ll>& qt, map<int, ll>& st, vector<int>& buses, vector<int>& passengers, int capacity) {\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n        for (int x : buses) {\\n            pq.push({x, 1});\\n        }\\n        for (int x : passengers) {\\n            pq.push({x, 0});\\n        }\\n        int peopleq = 0;\\n        ll seatsleft = capacity*buses.size();\\n        ll takenseats = 0;\\n        qt[0] = 0;\\n        st[0] = seatsleft;\\n        while (!pq.empty()) {\\n            auto x = pq.top(); pq.pop();\\n            if (x.second == 0) {\\n                peopleq++;\\n            } else if (x.second == 1) {\\n                takenseats = min(peopleq, capacity);\\n                seatsleft -= takenseats; \\n                peopleq = max(0, peopleq - capacity);\\n                if (capacity > takenseats) {\\n                    pq.push({x.first + 1, -1});\\n                }\\n            } else {\\n                seatsleft -= (capacity - takenseats);\\n            }\\n            qt[x.first] = peopleq;\\n            st[x.first] = seatsleft;\\n        }\\n    }\\n\\n    ll findpeopleq(map<int, ll>& qt, int t) {\\n        if (qt.count(t)) return qt[t];\\n        auto it = qt.upper_bound(t);\\n        it--;\\n        return it->second;\\n    }\\n\\n    ll countseats(map<int, ll>& st, int t) {\\n        if (st.count(t)) return st[t];\\n        auto it = st.upper_bound(t);\\n        it--;\\n        return it->second;\\n    }\\n\\n    int bs(map<int, ll>& qt, map<int, ll>& st, int capacity) {\\n        int l = 2;\\n        int h = 1e9 + 2;\\n        while (l <= h) {\\n            int t = l + (h - l)/2;\\n            ll peopleq = findpeopleq(qt, t) + 1;\\n            ll seatsleft = countseats(st, t);\\n            if (peopleq <= seatsleft && seatsleft > 0) {\\n                l = t+1;\\n            } else {\\n                h = t-1;\\n            }\\n        }\\n        return h;\\n    }\\n\\n    int latestTimeCatchTheBus(vector<int>& buses, vector<int>& passengers, int capacity) {\\n        map<int, ll> qt, st;\\n        sim(qt, st, buses, passengers, capacity);\\n        int t = bs(qt, st, capacity);\\n        set<int> passet;\\n        for (int i=0; i<passengers.size(); i++) {\\n            passet.insert(passengers[i]);\\n        }\\n        for (int tq = t; tq>=0; tq--) {\\n            if (!passet.count(tq)) return tq;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    typedef long long ll;\\n\\n    void sim(map<int, ll>& qt, map<int, ll>& st, vector<int>& buses, vector<int>& passengers, int capacity) {\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n        for (int x : buses) {\\n            pq.push({x, 1});\\n        }\\n        for (int x : passengers) {\\n            pq.push({x, 0});\\n        }\\n        int peopleq = 0;\\n        ll seatsleft = capacity*buses.size();\\n        ll takenseats = 0;\\n        qt[0] = 0;\\n        st[0] = seatsleft;\\n        while (!pq.empty()) {\\n            auto x = pq.top(); pq.pop();\\n            if (x.second == 0) {\\n                peopleq++;\\n            } else if (x.second == 1) {\\n                takenseats = min(peopleq, capacity);\\n                seatsleft -= takenseats; \\n                peopleq = max(0, peopleq - capacity);\\n                if (capacity > takenseats) {\\n                    pq.push({x.first + 1, -1});\\n                }\\n            } else {\\n                seatsleft -= (capacity - takenseats);\\n            }\\n            qt[x.first] = peopleq;\\n            st[x.first] = seatsleft;\\n        }\\n    }\\n\\n    ll findpeopleq(map<int, ll>& qt, int t) {\\n        if (qt.count(t)) return qt[t];\\n        auto it = qt.upper_bound(t);\\n        it--;\\n        return it->second;\\n    }\\n\\n    ll countseats(map<int, ll>& st, int t) {\\n        if (st.count(t)) return st[t];\\n        auto it = st.upper_bound(t);\\n        it--;\\n        return it->second;\\n    }\\n\\n    int bs(map<int, ll>& qt, map<int, ll>& st, int capacity) {\\n        int l = 2;\\n        int h = 1e9 + 2;\\n        while (l <= h) {\\n            int t = l + (h - l)/2;\\n            ll peopleq = findpeopleq(qt, t) + 1;\\n            ll seatsleft = countseats(st, t);\\n            if (peopleq <= seatsleft && seatsleft > 0) {\\n                l = t+1;\\n            } else {\\n                h = t-1;\\n            }\\n        }\\n        return h;\\n    }\\n\\n    int latestTimeCatchTheBus(vector<int>& buses, vector<int>& passengers, int capacity) {\\n        map<int, ll> qt, st;\\n        sim(qt, st, buses, passengers, capacity);\\n        int t = bs(qt, st, capacity);\\n        set<int> passet;\\n        for (int i=0; i<passengers.size(); i++) {\\n            passet.insert(passengers[i]);\\n        }\\n        for (int tq = t; tq>=0; tq--) {\\n            if (!passet.count(tq)) return tq;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3432559,
                "title": "python-simple-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need to find the last passenger who onboarded the last bus. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFind the last passenger who onboarded the last bus. \\n-> If the last bus capacity is full, the result will be the greatest available time less than the last passenger\\'s.\\n-> Else, it will be the last bus\\'s departure time.\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def latestTimeCatchTheBus(self, buses, passengers, capacity):\\n        \"\"\"\\n        :type buses: List[int]\\n        :type passengers: List[int]\\n        :type capacity: int\\n        :rtype: int\\n        \"\"\"\\n        bl, pl = len(buses), len(passengers)\\n\\n        buses.sort()\\n        passengers.sort()\\n        b, c, p = 0, 0, 0\\n        st = []\\n\\n        # Find the last slot\\n        while p < pl:\\n            if buses[b] < passengers[p] or c == capacity:\\n                b += 1\\n                st = [b-1, p-1, capacity - c]\\n                if b == bl:\\n                    break\\n                c = 0\\n                continue\\n            p += 1\\n            c += 1\\n\\n        if b < bl:\\n            st = [b, pl-1, capacity-c]\\n\\n        # Corner Case\\n        if b < bl-1:\\n            return buses[bl-1]\\n\\n        # Evaluate my latest time\\n        if st[2] > 0:\\n            v = buses[st[0]]\\n        else:\\n            v = passengers[st[1]]\\n        while v in set(passengers):\\n            v -= 1\\n        return v\\n\\n        \\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def latestTimeCatchTheBus(self, buses, passengers, capacity):\\n        \"\"\"\\n        :type buses: List[int]\\n        :type passengers: List[int]\\n        :type capacity: int\\n        :rtype: int\\n        \"\"\"\\n        bl, pl = len(buses), len(passengers)\\n\\n        buses.sort()\\n        passengers.sort()\\n        b, c, p = 0, 0, 0\\n        st = []\\n\\n        # Find the last slot\\n        while p < pl:\\n            if buses[b] < passengers[p] or c == capacity:\\n                b += 1\\n                st = [b-1, p-1, capacity - c]\\n                if b == bl:\\n                    break\\n                c = 0\\n                continue\\n            p += 1\\n            c += 1\\n\\n        if b < bl:\\n            st = [b, pl-1, capacity-c]\\n\\n        # Corner Case\\n        if b < bl-1:\\n            return buses[bl-1]\\n\\n        # Evaluate my latest time\\n        if st[2] > 0:\\n            v = buses[st[0]]\\n        else:\\n            v = passengers[st[1]]\\n        while v in set(passengers):\\n            v -= 1\\n        return v\\n\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3419905,
                "title": "the-latest-time-to-catch-a-bus",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int LatestTimeCatchTheBus(int[] buses, int[] passengers, int capacity) {\\n                    Array.Sort(buses);\\n            Array.Sort(passengers);\\n            Dictionary<int,int> passengersList = new Dictionary<int, int>();\\n\\n            int Answer = 0, passIndex = 0;\\n\\n            for (int i = 0; i < buses.Length; i++)\\n            {\\n                int busCapacity = 0;\\n                while ((passIndex < passengers.Length) && (busCapacity < capacity) && (passengers[passIndex] <= buses[i]))\\n                {\\n                    if (!passengersList.ContainsKey(passengers[passIndex] - 1))\\n                    {\\n                        Answer = passengers[passIndex] - 1;\\n                    }\\n                    passengersList.Add(passengers[passIndex], passengers[passIndex]);\\n                    passIndex++;\\n                    busCapacity++;\\n                }\\n\\n                if (busCapacity < capacity && !passengersList.ContainsKey(buses[i]))\\n                {\\n                    Answer = buses[i];\\n                }\\n            }\\n            return Answer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int LatestTimeCatchTheBus(int[] buses, int[] passengers, int capacity) {\\n                    Array.Sort(buses);\\n            Array.Sort(passengers);\\n            Dictionary<int,int> passengersList = new Dictionary<int, int>();\\n\\n            int Answer = 0, passIndex = 0;\\n\\n            for (int i = 0; i < buses.Length; i++)\\n            {\\n                int busCapacity = 0;\\n                while ((passIndex < passengers.Length) && (busCapacity < capacity) && (passengers[passIndex] <= buses[i]))\\n                {\\n                    if (!passengersList.ContainsKey(passengers[passIndex] - 1))\\n                    {\\n                        Answer = passengers[passIndex] - 1;\\n                    }\\n                    passengersList.Add(passengers[passIndex], passengers[passIndex]);\\n                    passIndex++;\\n                    busCapacity++;\\n                }\\n\\n                if (busCapacity < capacity && !passengersList.ContainsKey(buses[i]))\\n                {\\n                    Answer = buses[i];\\n                }\\n            }\\n            return Answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3401721,
                "title": "java-solution-with-explanation-of-edge-cases",
                "content": "# Intuition\\nSort the buses and passengers based on their time.\\n\\nIterate over the busses and try to fill them based on the passengers. In the end, there are several scenarios that have to be handled:\\n1. There are seats available in the last bus, so last time to arrive is the time of the last bus.\\n2. The last bus is full, the last time to arrive is before the last passenger seated.\\n3. If the last bus leaves before the passengers arrive, the last time to arive is the time of the last bus.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n log n) + O(m log m) + O (m) = max(O(n * m), O(m log m)) , where n = buses.length, m= passengers.length\\n\\n- Space complexity:\\nO(1)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    private int[] passengers;\\n    int passengerNo = 0;\\n\\n    private int maxDistinctTime(int maxTime) {\\n        while (passengerNo > 0 && maxTime == passengers[passengerNo - 1]) {\\n            passengerNo--;\\n            maxTime = passengers[passengerNo] - 1;\\n        }\\n\\n        return maxTime;\\n    }\\n\\n    public int latestTimeCatchTheBus(int[] buses, int[] passengers, int capacity) {\\n        Arrays.sort(buses);\\n        Arrays.sort(passengers);\\n        this.passengers = passengers;\\n\\n        int currentCapacity = 0;\\n\\n        for (int busNo = 0; busNo < buses.length; busNo++) {\\n            currentCapacity = 0;\\n\\n            while (currentCapacity < capacity && passengerNo < passengers.length && buses[busNo] >= passengers[passengerNo]) {\\n                passengerNo++;\\n                currentCapacity++;\\n            }\\n        }\\n\\n        int maxTime = 0;\\n        if (passengerNo == passengers.length && currentCapacity < capacity) {\\n            // there are still seats available in the last bus, the maxTime is the time of the last bus\\n            maxTime = buses[buses.length - 1];\\n        } else {\\n            // the last bus is full, get in front of the last passenger\\n            if (currentCapacity == capacity) {\\n                passengerNo--;\\n            }\\n            // handle the case when the last bus arrives before the passangers (i.e. bus: [5], passengers: [7,8])\\n            maxTime = Math.min(passengers[passengerNo] - 1, buses[buses.length-1]);\\n        }\\n\\n        return maxDistinctTime(maxTime);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private int[] passengers;\\n    int passengerNo = 0;\\n\\n    private int maxDistinctTime(int maxTime) {\\n        while (passengerNo > 0 && maxTime == passengers[passengerNo - 1]) {\\n            passengerNo--;\\n            maxTime = passengers[passengerNo] - 1;\\n        }\\n\\n        return maxTime;\\n    }\\n\\n    public int latestTimeCatchTheBus(int[] buses, int[] passengers, int capacity) {\\n        Arrays.sort(buses);\\n        Arrays.sort(passengers);\\n        this.passengers = passengers;\\n\\n        int currentCapacity = 0;\\n\\n        for (int busNo = 0; busNo < buses.length; busNo++) {\\n            currentCapacity = 0;\\n\\n            while (currentCapacity < capacity && passengerNo < passengers.length && buses[busNo] >= passengers[passengerNo]) {\\n                passengerNo++;\\n                currentCapacity++;\\n            }\\n        }\\n\\n        int maxTime = 0;\\n        if (passengerNo == passengers.length && currentCapacity < capacity) {\\n            // there are still seats available in the last bus, the maxTime is the time of the last bus\\n            maxTime = buses[buses.length - 1];\\n        } else {\\n            // the last bus is full, get in front of the last passenger\\n            if (currentCapacity == capacity) {\\n                passengerNo--;\\n            }\\n            // handle the case when the last bus arrives before the passangers (i.e. bus: [5], passengers: [7,8])\\n            maxTime = Math.min(passengers[passengerNo] - 1, buses[buses.length-1]);\\n        }\\n\\n        return maxDistinctTime(maxTime);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3385643,
                "title": "using-two-pointers-and-hashmap-t-c-o-n-logn",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nstep 1: sort the buses and passengers array\\n\\nstep 2 : itearte buses and passengers array and board every passengers in a bus. Maintain the lastPassenger variable at every point of iteration.\\n\\nstep 3 : create hash set and store every values from the passenger array.\\n\\nstep 4 : after boarding evry passengers we have 3 cases\\n\\n    case 1: no passengers board the bus or buses departs before every passenger arrives.In that case, return the last bus departure time as a latest arrival time of a passenger.\\n\\n    case 2 : if last bus\\'s capacity is not full(temp < capacity).\\nIn tha case, find the unique number between departure of last bus and \\n0, and return the unique number.\\n\\n    case 3: if last bus\\'s capacity is full(temp == capacity).\\nIn that case, find the unique number between lastPassenger time and 0, and return the unique number.\\n \\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(n log n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int latestTimeCatchTheBus(int[] buses, int[] passengers, int capacity) {\\n\\n        Arrays.sort(buses);\\n\\n        Arrays.sort(passengers);\\n\\n        int b = 0;\\n\\n        int p = 0;\\n\\n        int temp = 0;\\n\\n        int lastPassenger = -1;\\n\\n       while(b < buses.length){\\n\\n           temp = 0;\\n\\n           while(p < passengers.length && passengers[p] <= buses[b] && temp < capacity){\\n\\n               lastPassenger = passengers[p];\\n\\n               p++;\\n\\n               temp++;\\n\\n           }\\n\\n           b++;\\n\\n\\n\\n       }\\n\\n       //put all uniques paseneger timings in hashset;\\n\\n       HashSet <Integer> hs = new HashSet <> ();\\n\\n       for(int i = 0; i < passengers.length; i++){\\n\\n           hs.add(passengers[i]);\\n\\n       }\\n\\n       int val = 0;\\n\\n       //no one has boarded the bus\\n\\n        if(lastPassenger == -1){\\n\\n            return buses[b - 1];\\n\\n        }\\n\\n        //when bus capacity is full \\n\\n        else if(temp == capacity){\\n\\n            val = lastPassenger;\\n\\n        }\\n\\n        //when bus capacity is not full\\n\\n        else{\\n\\n            val = buses[b - 1];\\n\\n        }\\n\\n        while(val >= 0){\\n\\n            if(hs.contains(val) == false){\\n\\n                return val;\\n\\n            }\\n\\n            val--;\\n\\n        }\\n\\n        return -1;\\n\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int latestTimeCatchTheBus(int[] buses, int[] passengers, int capacity) {\\n\\n        Arrays.sort(buses);\\n\\n        Arrays.sort(passengers);\\n\\n        int b = 0;\\n\\n        int p = 0;\\n\\n        int temp = 0;\\n\\n        int lastPassenger = -1;\\n\\n       while(b < buses.length){\\n\\n           temp = 0;\\n\\n           while(p < passengers.length && passengers[p] <= buses[b] && temp < capacity){\\n\\n               lastPassenger = passengers[p];\\n\\n               p++;\\n\\n               temp++;\\n\\n           }\\n\\n           b++;\\n\\n\\n\\n       }\\n\\n       //put all uniques paseneger timings in hashset;\\n\\n       HashSet <Integer> hs = new HashSet <> ();\\n\\n       for(int i = 0; i < passengers.length; i++){\\n\\n           hs.add(passengers[i]);\\n\\n       }\\n\\n       int val = 0;\\n\\n       //no one has boarded the bus\\n\\n        if(lastPassenger == -1){\\n\\n            return buses[b - 1];\\n\\n        }\\n\\n        //when bus capacity is full \\n\\n        else if(temp == capacity){\\n\\n            val = lastPassenger;\\n\\n        }\\n\\n        //when bus capacity is not full\\n\\n        else{\\n\\n            val = buses[b - 1];\\n\\n        }\\n\\n        while(val >= 0){\\n\\n            if(hs.contains(val) == false){\\n\\n                return val;\\n\\n            }\\n\\n            val--;\\n\\n        }\\n\\n        return -1;\\n\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3385382,
                "title": "easy-approach",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& buses, vector<int>& passengers, int capacity) {\\n        sort(buses.begin(), buses.end());\\n        sort(passengers.begin(), passengers.end());\\n        map<int, int> mp;\\n\\n        for (int i : passengers)\\n             mp[i]++;\\n\\n        int i = 0, j = 0, c = 0;\\n        while (j < buses.size() - 1)\\n        {\\n            c= 0;\\n            while (i < passengers.size() && passengers[i] <= buses[j] && c < capacity)\\n            {\\n                i++;\\n                c++;\\n            }\\n            j++;\\n          \\n        }\\n\\n        int n = passengers.size();\\n\\n        if (capacity > n - i)\\n        {\\n            int val1 = buses[j];\\n            while (mp.count(val1) == 1)\\n                val1--;\\n            return val1;\\n        }\\n        else\\n        {\\n            i = i + capacity - 1;\\n            int val1 = passengers[i];\\n            int val2 = buses[j];\\n\\n            while (mp.count(val1) == 1 || val1 > val2)\\n                val1--;\\n\\n            return val1;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& buses, vector<int>& passengers, int capacity) {\\n        sort(buses.begin(), buses.end());\\n        sort(passengers.begin(), passengers.end());\\n        map<int, int> mp;\\n\\n        for (int i : passengers)\\n             mp[i]++;\\n\\n        int i = 0, j = 0, c = 0;\\n        while (j < buses.size() - 1)\\n        {\\n            c= 0;\\n            while (i < passengers.size() && passengers[i] <= buses[j] && c < capacity)\\n            {\\n                i++;\\n                c++;\\n            }\\n            j++;\\n          \\n        }\\n\\n        int n = passengers.size();\\n\\n        if (capacity > n - i)\\n        {\\n            int val1 = buses[j];\\n            while (mp.count(val1) == 1)\\n                val1--;\\n            return val1;\\n        }\\n        else\\n        {\\n            i = i + capacity - 1;\\n            int val1 = passengers[i];\\n            int val2 = buses[j];\\n\\n            while (mp.count(val1) == 1 || val1 > val2)\\n                val1--;\\n\\n            return val1;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368606,
                "title": "java-easy-solution-no-time-taken-0sec",
                "content": "# Intuition\\n![upvote.png](https://assets.leetcode.com/users/images/d2bb06fc-624f-4b49-8df5-639272009621_1680409280.9227343.png)\\n![Screenshot 2023-04-02 09.50.27.png](https://assets.leetcode.com/users/images/0ee8b979-8370-4a5b-ae57-6a9f58d4ccd3_1680409294.8050237.png)\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int latestTimeCatchTheBus(int[] buses, int[] passengers, int capacity) {\\n        Arrays.sort(buses);\\n        Arrays.sort(passengers);\\n        int blen = buses.length;\\n        int plen = passengers.length;\\n        int b = 0;\\n        int p = 0;\\n        int c = 0;\\n        // find capacity in last bus\\n        while (b < blen && p < plen) {\\n            if (passengers[p] <= buses[b] && c < capacity) {\\n                c++;\\n                p++;\\n            }\\n            if (c == capacity || (p < plen && passengers[p] > buses[b])) {\\n                if (b < (blen - 1)) {\\n                    c = 0;\\n                }\\n                b++;\\n            }\\n        }\\n        int start = 0;\\n        if (c == capacity) {\\n            // capcity is full in last bus, find time last passenger might have boarded\\n            start = Math.min(passengers[p - 1], buses[blen - 1]);\\n        } else {\\n            // capacity is not full in last bus, start with last bus departure time and check if can\\n            // board on last moment\\n            start = buses[blen - 1];\\n        }\\n        // go backward till find a slot\\n        while (p > 0 && start == passengers[p - 1]) {\\n            start--;\\n            p--;\\n        }\\n        return start;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int latestTimeCatchTheBus(int[] buses, int[] passengers, int capacity) {\\n        Arrays.sort(buses);\\n        Arrays.sort(passengers);\\n        int blen = buses.length;\\n        int plen = passengers.length;\\n        int b = 0;\\n        int p = 0;\\n        int c = 0;\\n        // find capacity in last bus\\n        while (b < blen && p < plen) {\\n            if (passengers[p] <= buses[b] && c < capacity) {\\n                c++;\\n                p++;\\n            }\\n            if (c == capacity || (p < plen && passengers[p] > buses[b])) {\\n                if (b < (blen - 1)) {\\n                    c = 0;\\n                }\\n                b++;\\n            }\\n        }\\n        int start = 0;\\n        if (c == capacity) {\\n            // capcity is full in last bus, find time last passenger might have boarded\\n            start = Math.min(passengers[p - 1], buses[blen - 1]);\\n        } else {\\n            // capacity is not full in last bus, start with last bus departure time and check if can\\n            // board on last moment\\n            start = buses[blen - 1];\\n        }\\n        // go backward till find a slot\\n        while (p > 0 && start == passengers[p - 1]) {\\n            start--;\\n            p--;\\n        }\\n        return start;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3334044,
                "title": "c-two-pointer-traversal",
                "content": "```\\nclass Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& buses, vector<int>& pass, int cap)\\n    {\\n        sort(buses.begin(), buses.end());\\n        sort(pass.begin(), pass.end());\\n\\n        int i = 0, j = 0, cand = 1;\\n\\n        while (i < buses.size() && j < pass.size())\\n        {\\n            int startj = j, seated = 0;\\n\\n            while (j < pass.size() && pass[j] <= buses[i] && seated < cap)\\n            {\\n                int passjminusone = (j >= 1) ? pass[j-1] : 0;\\n\\n                if (pass[j] - passjminusone > 1)\\n                    cand = pass[j]-1;\\n\\n                seated++;\\n                j++;\\n            }\\n\\n            int passjminusone = (j >= 1) ? pass[j-1] : 0;\\n            if (seated < cap && passjminusone != buses[i])\\n                cand = buses[i];\\n\\n            i++;\\n        }\\n\\n        if (i < buses.size())\\n            cand = buses.back();\\n\\n        return cand;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& buses, vector<int>& pass, int cap)\\n    {\\n        sort(buses.begin(), buses.end());\\n        sort(pass.begin(), pass.end());\\n\\n        int i = 0, j = 0, cand = 1;\\n\\n        while (i < buses.size() && j < pass.size())\\n        {\\n            int startj = j, seated = 0;\\n\\n            while (j < pass.size() && pass[j] <= buses[i] && seated < cap)\\n            {\\n                int passjminusone = (j >= 1) ? pass[j-1] : 0;\\n\\n                if (pass[j] - passjminusone > 1)\\n                    cand = pass[j]-1;\\n\\n                seated++;\\n                j++;\\n            }\\n\\n            int passjminusone = (j >= 1) ? pass[j-1] : 0;\\n            if (seated < cap && passjminusone != buses[i])\\n                cand = buses[i];\\n\\n            i++;\\n        }\\n\\n        if (i < buses.size())\\n            cand = buses.back();\\n\\n        return cand;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3326599,
                "title": "simple-solution-using-min-heap-python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse a heap to keep track of the remaining passengers. When a bus comes, onboard all passengers that arrived before that bus and within capacity. If a bus leaves and still have remaining capacity, and no passenger has arrives at the same time as that bus, then I can also arrive at the same time as the bus.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse a heap to store passengers.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n\\\\cdot log(n) + m\\\\cdot log(m))$$, bus need to be sorted, linear time to heapify passengers, but each passenger could be poped at most once at cost $$O(log(m))$$ for each pop.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(m)$$, assuming you can sort bus in place, then extra space is for the min heap that stores passengers.\\n\\n# Code\\n```python\\nclass Solution:\\n    def latestTimeCatchTheBus(self, buses: List[int], passengers: List[int], capacity: int) -> int:\\n        minh = list(passengers)\\n        heapify(minh)\\n        lastp, res = -1, 0\\n        for b in sorted(buses):\\n            c = capacity\\n            while minh and minh[0] <= b and c > 0:\\n                p = heappop(minh)\\n                if p - 1 != lastp:\\n                    res = p - 1\\n                lastp = p\\n                c -= 1\\n            if c > 0 and lastp != b:\\n                res = b\\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```python\\nclass Solution:\\n    def latestTimeCatchTheBus(self, buses: List[int], passengers: List[int], capacity: int) -> int:\\n        minh = list(passengers)\\n        heapify(minh)\\n        lastp, res = -1, 0\\n        for b in sorted(buses):\\n            c = capacity\\n            while minh and minh[0] <= b and c > 0:\\n                p = heappop(minh)\\n                if p - 1 != lastp:\\n                    res = p - 1\\n                lastp = p\\n                c -= 1\\n            if c > 0 and lastp != b:\\n                res = b\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3326393,
                "title": "two-pointers-solution",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n logn)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\n/**\\n * @param {number[]} buses\\n * @param {number[]} passengers\\n * @param {number} capacity\\n * @return {number}\\n */\\nvar latestTimeCatchTheBus = function (buses, passengers, capacity) {\\n  buses.sort((a, b) => a - b);\\n  passengers.sort((a, b) => a - b);\\n\\n  let pass_index = 0;\\n\\n  for (let bus_index = 0; bus_index < buses.length; bus_index++) {\\n    const bus = buses[bus_index];\\n    let bus_load = 0;\\n\\n    while (pass_index < passengers.length) {\\n      const pass = passengers[pass_index];\\n\\n      if ((pass <= bus) & (bus_load < capacity)) {\\n        bus_load++;\\n        pass_index++;\\n      } else {\\n        break;\\n      }\\n    }\\n\\n    if (bus_index == buses.length - 1) {\\n      let latest_arrival_time = 0;\\n\\n      if (pass_index == 0) {\\n        return buses[bus_index];\\n      } else {\\n        // Go to last passenger on bus.\\n        pass_index--;\\n      }\\n\\n      if (passengers[pass_index] < buses[bus_index] && bus_load < capacity) {\\n        latest_arrival_time = passengers[pass_index] + 1;\\n\\n        while (latest_arrival_time < buses[bus_index]) {\\n          latest_arrival_time++;\\n        }\\n      } else {\\n        latest_arrival_time = passengers[pass_index] - 1;\\n\\n        while (latest_arrival_time == passengers[pass_index - 1]) {\\n          pass_index--;\\n          latest_arrival_time--;\\n        }\\n      }\\n\\n      return latest_arrival_time;\\n    }\\n  }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} buses\\n * @param {number[]} passengers\\n * @param {number} capacity\\n * @return {number}\\n */\\nvar latestTimeCatchTheBus = function (buses, passengers, capacity) {\\n  buses.sort((a, b) => a - b);\\n  passengers.sort((a, b) => a - b);\\n\\n  let pass_index = 0;\\n\\n  for (let bus_index = 0; bus_index < buses.length; bus_index++) {\\n    const bus = buses[bus_index];\\n    let bus_load = 0;\\n\\n    while (pass_index < passengers.length) {\\n      const pass = passengers[pass_index];\\n\\n      if ((pass <= bus) & (bus_load < capacity)) {\\n        bus_load++;\\n        pass_index++;\\n      } else {\\n        break;\\n      }\\n    }\\n\\n    if (bus_index == buses.length - 1) {\\n      let latest_arrival_time = 0;\\n\\n      if (pass_index == 0) {\\n        return buses[bus_index];\\n      } else {\\n        // Go to last passenger on bus.\\n        pass_index--;\\n      }\\n\\n      if (passengers[pass_index] < buses[bus_index] && bus_load < capacity) {\\n        latest_arrival_time = passengers[pass_index] + 1;\\n\\n        while (latest_arrival_time < buses[bus_index]) {\\n          latest_arrival_time++;\\n        }\\n      } else {\\n        latest_arrival_time = passengers[pass_index] - 1;\\n\\n        while (latest_arrival_time == passengers[pass_index - 1]) {\\n          pass_index--;\\n          latest_arrival_time--;\\n        }\\n      }\\n\\n      return latest_arrival_time;\\n    }\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3324798,
                "title": "c-sorting-with-pseudocode-and-constraints-analysis",
                "content": "```\\nclass Solution {\\npublic:\\n    // pseudocode main idea:\\n    // for each bus\\n    //      try to load up capacity # of riders\\n    //      for each rider\\n    //          if there is a space greater than 1\\n    //          between last rider set answer to current rider - 1 (rightmost)\\n    // constraints analysis:\\n    //      can choose between using a hashtable\\n    //      vs sorting buses and passengers\\n    //      I think sorting is faster based on the constraints\\n    //      Sorting has better memory usage but hashtable can have better time complexity\\n    //      depending on input range of passengers[i]\\n   int latestTimeCatchTheBus(vector<int>& b, vector<int>& p, int c) {\\n        sort(b.begin(), b.end());\\n        sort(p.begin(), p.end());\\n        int last = 0, ans = 1, pp = 0;\\n        for (int i = 0; i < b.size(); ++i)\\n            for (int y = c; y > 0; --y){\\n                if (pp == p.size()) return b.back();\\n                else if (p[pp] > b[i]){\\n                    if (p[pp] - last != 1) ans = b[i];\\n                    break;\\n                }\\n                else{\\n                    if (p[pp] - last != 1) ans = p[pp] - 1;\\n                    last = p[pp];\\n                    if (p[pp++] == b[i]) break;\\n                }\\n            }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    // pseudocode main idea:\\n    // for each bus\\n    //      try to load up capacity # of riders\\n    //      for each rider\\n    //          if there is a space greater than 1\\n    //          between last rider set answer to current rider - 1 (rightmost)\\n    // constraints analysis:\\n    //      can choose between using a hashtable\\n    //      vs sorting buses and passengers\\n    //      I think sorting is faster based on the constraints\\n    //      Sorting has better memory usage but hashtable can have better time complexity\\n    //      depending on input range of passengers[i]\\n   int latestTimeCatchTheBus(vector<int>& b, vector<int>& p, int c) {\\n        sort(b.begin(), b.end());\\n        sort(p.begin(), p.end());\\n        int last = 0, ans = 1, pp = 0;\\n        for (int i = 0; i < b.size(); ++i)\\n            for (int y = c; y > 0; --y){\\n                if (pp == p.size()) return b.back();\\n                else if (p[pp] > b[i]){\\n                    if (p[pp] - last != 1) ans = b[i];\\n                    break;\\n                }\\n                else{\\n                    if (p[pp] - last != 1) ans = p[pp] - 1;\\n                    last = p[pp];\\n                    if (p[pp++] == b[i]) break;\\n                }\\n            }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3291871,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& b, vector<int>& p, int c)\\n    {\\n        sort(p.begin(),p.end());\\n        sort(b.begin(),b.end());\\n        int lastPerson;\\n        int spaceLeft=c;\\n        map<int,bool>mp;\\n        for (auto it: p) mp[it]=1;\\n        int n=b.size();\\n        int m=p.size();\\n        int i=0;\\n        int j=0;\\n        while(i<n && j<m)\\n        {\\n            int cc=c;\\n            while(j<m && cc && p[j]<=b[i]) lastPerson=p[j],j++,cc--;\\n            i++;\\n            spaceLeft=cc;\\n        }\\n        cout<<lastPerson<<endl;\\n        int ans=lastPerson;\\n        if(spaceLeft || i!=n) ans=b[n-1];\\n        while(mp.find(ans)!=mp.end()) ans--;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& b, vector<int>& p, int c)\\n    {\\n        sort(p.begin(),p.end());\\n        sort(b.begin(),b.end());\\n        int lastPerson;\\n        int spaceLeft=c;\\n        map<int,bool>mp;\\n        for (auto it: p) mp[it]=1;\\n        int n=b.size();\\n        int m=p.size();\\n        int i=0;\\n        int j=0;\\n        while(i<n && j<m)\\n        {\\n            int cc=c;\\n            while(j<m && cc && p[j]<=b[i]) lastPerson=p[j],j++,cc--;\\n            i++;\\n            spaceLeft=cc;\\n        }\\n        cout<<lastPerson<<endl;\\n        int ans=lastPerson;\\n        if(spaceLeft || i!=n) ans=b[n-1];\\n        while(mp.find(ans)!=mp.end()) ans--;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3270436,
                "title": "javascript-greedy-solution-with-slight-modifications",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {number[]} buses\\n * @param {number[]} passengers\\n * @param {number} capacity\\n * @return {number}\\n */\\nvar latestTimeCatchTheBus = function(buses, pass, cap) {\\n    buses = buses.sort((a,b) => a-b);\\n    pass = pass.sort((a,b) => a-b);\\n    let p = 0;\\n    for(let b = 0; b < buses.length; b++) {\\n        let c = 0;\\n        while(p < pass.length && pass[p] <= buses[b] && c < cap) {\\n            p++;\\n            c++;\\n        }\\n        if(b === buses.length-1){\\n            let t = (c === cap)? (pass[--p] -1) : buses[b];\\n            while(p>0 && pass[--p] === t){\\n                t--\\n            }\\n            return t;\\n        }\\n    }\\n    return -1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} buses\\n * @param {number[]} passengers\\n * @param {number} capacity\\n * @return {number}\\n */\\nvar latestTimeCatchTheBus = function(buses, pass, cap) {\\n    buses = buses.sort((a,b) => a-b);\\n    pass = pass.sort((a,b) => a-b);\\n    let p = 0;\\n    for(let b = 0; b < buses.length; b++) {\\n        let c = 0;\\n        while(p < pass.length && pass[p] <= buses[b] && c < cap) {\\n            p++;\\n            c++;\\n        }\\n        if(b === buses.length-1){\\n            let t = (c === cap)? (pass[--p] -1) : buses[b];\\n            while(p>0 && pass[--p] === t){\\n                t--\\n            }\\n            return t;\\n        }\\n    }\\n    return -1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3258626,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& buses, vector<int>& passengers, int capacity) {\\n        sort(buses.begin(), buses.end()) ;\\n        sort(passengers.begin(), passengers.end()) ;\\n        int busCn = buses.size() ;\\n        int personCn = passengers.size() ;\\n        int j = 0 ;\\n        int ret = -1 ;\\n        for(int i = 0; i < busCn; i++){\\n            int cap = capacity ;\\n            while(j < personCn && cap > 0 && passengers[j] <= buses[i]){\\n                if(j == 0 || passengers[j-1] != passengers[j] -1)\\n                    ret = passengers[j] -1 ;\\n                j++ ;\\n                cap-- ;\\n            } \\n            if(cap){\\n                if(j == 0 || passengers[j-1] != buses[i])\\n                    ret = buses[i] ;\\n            }\\n        }\\n            \\n        return ret ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& buses, vector<int>& passengers, int capacity) {\\n        sort(buses.begin(), buses.end()) ;\\n        sort(passengers.begin(), passengers.end()) ;\\n        int busCn = buses.size() ;\\n        int personCn = passengers.size() ;\\n        int j = 0 ;\\n        int ret = -1 ;\\n        for(int i = 0; i < busCn; i++){\\n            int cap = capacity ;\\n            while(j < personCn && cap > 0 && passengers[j] <= buses[i]){\\n                if(j == 0 || passengers[j-1] != passengers[j] -1)\\n                    ret = passengers[j] -1 ;\\n                j++ ;\\n                cap-- ;\\n            } \\n            if(cap){\\n                if(j == 0 || passengers[j-1] != buses[i])\\n                    ret = buses[i] ;\\n            }\\n        }\\n            \\n        return ret ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3253867,
                "title": "c-one-pass",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& buses, vector<int>& passengers, int capacity) {\\n        sort(begin(buses), end(buses));\\n        sort(begin(passengers), end(passengers));\\n        int res = 0, i = 0, n = passengers.size(), pre = 0;\\n        for(auto t : buses){\\n            int count=0;\\n            for(; i<n && count<capacity && passengers[i] <= t; i++, count++){\\n                int cur = passengers[i];\\n                if(cur-1 != pre) res = cur-1;  \\n                pre = cur;              \\n            }\\n            if(count<capacity && t != pre) res = t;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& buses, vector<int>& passengers, int capacity) {\\n        sort(begin(buses), end(buses));\\n        sort(begin(passengers), end(passengers));\\n        int res = 0, i = 0, n = passengers.size(), pre = 0;\\n        for(auto t : buses){\\n            int count=0;\\n            for(; i<n && count<capacity && passengers[i] <= t; i++, count++){\\n                int cur = passengers[i];\\n                if(cur-1 != pre) res = cur-1;  \\n                pre = cur;              \\n            }\\n            if(count<capacity && t != pre) res = t;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3230720,
                "title": "c-two-pointers",
                "content": "# Intuition\\nPorted from Python from: https://leetcode.com/problems/the-latest-time-to-catch-a-bus/solutions/2259200/python-just-calculate-faster-than-100-00/\\n\\n# Approach\\n\\n1) Fill the buses with exisiting passengers\\n```\\nArray.Sort(passengers);        \\nArray.Sort(buses);\\nint cur = 0;\\nint cap = 0;\\nint time1 = 0;\\nforeach(var time in buses)\\n{\\n    cap = capacity;\\n    while (cur < passengers.Length && passengers[cur] <= time && cap > 0)\\n    {\\n        cur += 1;\\n        cap -= 1;\\n    }       \\n    time1 = time;         \\n}   \\n```\\n2) If the last bus has a seat left, assign $$best$$ to it. Otherwhise, assign best to the last passenger to get in.\\n```\\nint best = cap > 0? time1 : passengers[cur - 1];\\n```\\n3) Decrement $best$ until you find a time that doesn\\'t belong to any exisitng passenger.\\n```\\nHashSet<int> passengersSet = new(passengers);\\nwhile (passengersSet.Contains(best))\\n{\\n    best -= 1;\\n}  \\n```\\n\\n# Walkthrough with an example:\\nInput:  buses = [20,30,10], passengers = [19,13,26,4,25,11,21] capacity = 2\\n\\n# 1)\\nsorted arrays:\\nbuses = [10, 20, 30], \\npassengers = [4, 11, 13, 19, 21, 25, 26],\\n\\n# 2) foreach:\\n# .) time = 10\\ncap = 2\\n\\nI)\\n```\\nwhile(0 < 6 && 4 <= 10 && 2 >0)\\n{\\n    cur = 1;\\n    cap = 1;\\n}\\n```\\nII)\\n```\\nwhile(1 < 6 && 11 <= 10 && 1>0)\\n{\\n   break\\n}\\ntime1 = 10;\\n```\\n# ..) time = 20\\ncap = 2\\n\\nI)\\n```\\nwhile(1 < 6 && 11 <= 20 && 2 >0)\\n{\\n    cur = 2;\\n    cap = 1;\\n}\\n```\\nII)\\n```\\nwhile(2 < 6 && 13 <= 20 && 1>0)\\n{\\n   cur = 3;\\n   cap = 0;\\n}\\ntime1 = 20;\\n```\\n# ...) time = 30\\ncap = 2\\n\\nI)\\n```\\nwhile(3 < 6 && 19 <= 30 && 2 >0)\\n{\\n    cur = 4;\\n    cap = 1;\\n}\\n```\\nII)\\n```\\nwhile(4 < 6 && 21 <= 30 && 1>0)\\n{\\n   cur = 5;\\n   cap = 0;\\n}\\ntime1 = 30;\\n```\\n# best\\nbest = 0 >0 ? 30 : 21\\nbest = 21\\n\\n# while\\nbest = 20 (correct answer)\\n\\n# Code\\n```\\npublic class Solution {\\n    public int LatestTimeCatchTheBus(int[] buses, int[] passengers, int capacity) {\\n        Array.Sort(passengers);        \\n        Array.Sort(buses);\\n        int cur = 0;\\n        int cap = 0;\\n        int time1 = 0;\\n        foreach(var time in buses)\\n        {\\n            cap = capacity;\\n            while (cur < passengers.Length && passengers[cur] <= time && cap > 0)\\n            {\\n                cur += 1;\\n                cap -= 1;\\n            }       \\n            time1 = time;         \\n        }            \\n\\n        int best = cap > 0? time1 : passengers[cur - 1];\\n\\n        HashSet<int> passengersSet = new(passengers);\\n        while (passengersSet.Contains(best))\\n        {\\n            best -= 1;\\n        }            \\n        return best;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Two Pointers"
                ],
                "code": "```\\nArray.Sort(passengers);        \\nArray.Sort(buses);\\nint cur = 0;\\nint cap = 0;\\nint time1 = 0;\\nforeach(var time in buses)\\n{\\n    cap = capacity;\\n    while (cur < passengers.Length && passengers[cur] <= time && cap > 0)\\n    {\\n        cur += 1;\\n        cap -= 1;\\n    }       \\n    time1 = time;         \\n}   \\n```\n```\\nint best = cap > 0? time1 : passengers[cur - 1];\\n```\n```\\nHashSet<int> passengersSet = new(passengers);\\nwhile (passengersSet.Contains(best))\\n{\\n    best -= 1;\\n}  \\n```\n```\\nwhile(0 < 6 && 4 <= 10 && 2 >0)\\n{\\n    cur = 1;\\n    cap = 1;\\n}\\n```\n```\\nwhile(1 < 6 && 11 <= 10 && 1>0)\\n{\\n   break\\n}\\ntime1 = 10;\\n```\n```\\nwhile(1 < 6 && 11 <= 20 && 2 >0)\\n{\\n    cur = 2;\\n    cap = 1;\\n}\\n```\n```\\nwhile(2 < 6 && 13 <= 20 && 1>0)\\n{\\n   cur = 3;\\n   cap = 0;\\n}\\ntime1 = 20;\\n```\n```\\nwhile(3 < 6 && 19 <= 30 && 2 >0)\\n{\\n    cur = 4;\\n    cap = 1;\\n}\\n```\n```\\nwhile(4 < 6 && 21 <= 30 && 1>0)\\n{\\n   cur = 5;\\n   cap = 0;\\n}\\ntime1 = 30;\\n```\n```\\npublic class Solution {\\n    public int LatestTimeCatchTheBus(int[] buses, int[] passengers, int capacity) {\\n        Array.Sort(passengers);        \\n        Array.Sort(buses);\\n        int cur = 0;\\n        int cap = 0;\\n        int time1 = 0;\\n        foreach(var time in buses)\\n        {\\n            cap = capacity;\\n            while (cur < passengers.Length && passengers[cur] <= time && cap > 0)\\n            {\\n                cur += 1;\\n                cap -= 1;\\n            }       \\n            time1 = time;         \\n        }            \\n\\n        int best = cap > 0? time1 : passengers[cur - 1];\\n\\n        HashSet<int> passengersSet = new(passengers);\\n        while (passengersSet.Contains(best))\\n        {\\n            best -= 1;\\n        }            \\n        return best;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3170570,
                "title": "o-log-n-solution-with-constant-space",
                "content": "# Complexity\\n- Time complexity: O(Log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& buses, vector<int>& passengers, int capacity) {\\n        sort(buses.begin() , buses.end());\\n        sort(passengers.begin() , passengers.end());\\n\\n        int b = buses.size() ;\\n        int p = passengers.size() ;\\n        int j = 0 ;\\n        int ans ;\\n        int prev = -1;\\n        \\n        \\n        for(int i=0 ; i<b ; i++)\\n        {\\n            int curr_p = 0;\\n            while(curr_p<capacity && j<p && passengers[j]<=buses[i])\\n            {\\n                if(passengers[j]-1!=prev) ans = passengers[j]-1; //it can be our possible answer\\n\\n                prev = passengers[j];\\n                curr_p++;\\n                j++;\\n            }\\n            if(curr_p<capacity && buses[i]!=prev) ans = buses[i]; //if capacity is not filled and passengers are over and also prev passenger time is not the departure time of current bus then the ans is the dept time of the buss\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& buses, vector<int>& passengers, int capacity) {\\n        sort(buses.begin() , buses.end());\\n        sort(passengers.begin() , passengers.end());\\n\\n        int b = buses.size() ;\\n        int p = passengers.size() ;\\n        int j = 0 ;\\n        int ans ;\\n        int prev = -1;\\n        \\n        \\n        for(int i=0 ; i<b ; i++)\\n        {\\n            int curr_p = 0;\\n            while(curr_p<capacity && j<p && passengers[j]<=buses[i])\\n            {\\n                if(passengers[j]-1!=prev) ans = passengers[j]-1; //it can be our possible answer\\n\\n                prev = passengers[j];\\n                curr_p++;\\n                j++;\\n            }\\n            if(curr_p<capacity && buses[i]!=prev) ans = buses[i]; //if capacity is not filled and passengers are over and also prev passenger time is not the departure time of current bus then the ans is the dept time of the buss\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3113032,
                "title": "binary-search-map",
                "content": "```\\nint latestTimeCatchTheBus(vector<int>& b, vector<int>& p, int c) {\\n\\tsort(b.begin(),b.end());\\n\\tsort(p.begin(),p.end());\\n\\tint i=0,val,m;\\n\\tfor(int x:b)\\n\\t{\\n\\t\\tint s = i,e=p.size()-1,j=s-1;\\n\\t\\twhile(s<=e)\\n\\t\\t{\\n\\t\\t\\tint mid = (s+e)/2;\\n\\t\\t\\tif(p[mid]<=x)\\n\\t\\t\\t\\tj=mid,s=mid+1;\\n\\t\\t\\telse \\n\\t\\t\\t\\te = mid-1;\\n\\t\\t}\\n\\t\\tval = min(j-i+1,c); \\n\\t\\ti+=val;\\n\\t}\\n\\tunordered_map<int,int>mapit;\\n\\tfor(int x=0;x<i;x++)\\n\\t\\tmapit[p[x]]++;\\n\\tm = val<c?b.back():p[i-1];\\n\\tfor(int k=m;k>0;k--)\\n\\t\\tif(!mapit.count(k))\\n\\t\\t\\treturn k;\\n\\treturn 0;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nint latestTimeCatchTheBus(vector<int>& b, vector<int>& p, int c) {\\n\\tsort(b.begin(),b.end());\\n\\tsort(p.begin(),p.end());\\n\\tint i=0,val,m;\\n\\tfor(int x:b)\\n\\t{\\n\\t\\tint s = i,e=p.size()-1,j=s-1;\\n\\t\\twhile(s<=e)\\n\\t\\t{\\n\\t\\t\\tint mid = (s+e)/2;\\n\\t\\t\\tif(p[mid]<=x)\\n\\t\\t\\t\\tj=mid,s=mid+1;\\n\\t\\t\\telse \\n\\t\\t\\t\\te = mid-1;\\n\\t\\t}\\n\\t\\tval = min(j-i+1,c); \\n\\t\\ti+=val;\\n\\t}\\n\\tunordered_map<int,int>mapit;\\n\\tfor(int x=0;x<i;x++)\\n\\t\\tmapit[p[x]]++;\\n\\tm = val<c?b.back():p[i-1];\\n\\tfor(int k=m;k>0;k--)\\n\\t\\tif(!mapit.count(k))\\n\\t\\t\\treturn k;\\n\\treturn 0;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3107927,
                "title": "c-two-pointer-after-sorting-great-question",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& buses, vector<int>& passengers, int capacity) {\\n        sort(buses.begin(), buses.end());\\n        sort(passengers.begin(), passengers.end());\\n        int psz = passengers.size();\\n        int bsz = buses.size();\\n        int j = 0;\\n        unordered_set<int> visitedTime;\\n        int ans = -1;\\n        for(int i = 0; i < bsz; i++) {\\n            int count = 0;\\n            for(; j < psz && count < capacity && passengers[j] <= buses[i]; j++) {\\n                if(visitedTime.count(passengers[j] - 1) == 0) {\\n                    ans = passengers[j] - 1;\\n                }\\n                visitedTime.insert(passengers[j]);\\n                count++;\\n            }\\n            if(count < capacity && visitedTime.count(buses[i]) == 0) {\\n                ans = buses[i];\\n            }\\n            // cout << buses[i] << \" - \" << count << \" - \" << capacity << \" ans = \" << ans << endl;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& buses, vector<int>& passengers, int capacity) {\\n        sort(buses.begin(), buses.end());\\n        sort(passengers.begin(), passengers.end());\\n        int psz = passengers.size();\\n        int bsz = buses.size();\\n        int j = 0;\\n        unordered_set<int> visitedTime;\\n        int ans = -1;\\n        for(int i = 0; i < bsz; i++) {\\n            int count = 0;\\n            for(; j < psz && count < capacity && passengers[j] <= buses[i]; j++) {\\n                if(visitedTime.count(passengers[j] - 1) == 0) {\\n                    ans = passengers[j] - 1;\\n                }\\n                visitedTime.insert(passengers[j]);\\n                count++;\\n            }\\n            if(count < capacity && visitedTime.count(buses[i]) == 0) {\\n                ans = buses[i];\\n            }\\n            // cout << buses[i] << \" - \" << count << \" - \" << capacity << \" ans = \" << ans << endl;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3078796,
                "title": "greedy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can process all buses and send available passengers up until the latest bus. And for the latest bus we can try to find the latest possible arrival time with the remaining passengers.\\n\\n# Complexity\\n- Time complexity: O(nlgn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int latestTimeCatchTheBus(int[] buses, int[] passengers, int capacity) {\\n        Arrays.sort(buses);\\n        Arrays.sort(passengers);\\n\\n        Set<Integer> allPassengers = Arrays.stream(passengers).boxed()\\n                .collect(Collectors.toCollection(HashSet::new));\\n\\n        int pasPtr = 0;\\n        for (int b = 0; b < buses.length-1; b++) {\\n            int departureTime = buses[b];\\n            int goingCounter = 0;\\n\\n            while (pasPtr < passengers.length && passengers[pasPtr] <= departureTime && goingCounter < capacity) {\\n                // passengers[pasPtr] is going with bus departing at departureTime\\n                pasPtr++;\\n                goingCounter++;\\n            }\\n        }\\n\\n        // we found the remaining passengers waiting for the last bus.\\n        // I will try to find the latest possible time I can go with some waiting people\\n        if (pasPtr >= passengers.length) {\\n            return buses[buses.length - 1];\\n        }\\n\\n        int lastDeparture = buses[buses.length - 1];\\n        int firstWaitingPas = passengers[pasPtr];\\n\\n        if (firstWaitingPas > lastDeparture) return lastDeparture;\\n\\n        // I could arrive before the firstWaiting, in the worst case\\n        int latest = firstWaitingPas - 1;\\n        while (allPassengers.contains(latest)) {\\n            latest--;\\n        }\\n\\n        // find an insertion location\\n        int goingCounter = 0;\\n        for (int i=firstWaitingPas+1; i <= lastDeparture && goingCounter < capacity - 1;i++) {\\n            if (!allPassengers.contains(i)) {\\n                latest = i;\\n            } else {\\n                goingCounter++;\\n            }\\n        }\\n\\n        return latest;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int latestTimeCatchTheBus(int[] buses, int[] passengers, int capacity) {\\n        Arrays.sort(buses);\\n        Arrays.sort(passengers);\\n\\n        Set<Integer> allPassengers = Arrays.stream(passengers).boxed()\\n                .collect(Collectors.toCollection(HashSet::new));\\n\\n        int pasPtr = 0;\\n        for (int b = 0; b < buses.length-1; b++) {\\n            int departureTime = buses[b];\\n            int goingCounter = 0;\\n\\n            while (pasPtr < passengers.length && passengers[pasPtr] <= departureTime && goingCounter < capacity) {\\n                // passengers[pasPtr] is going with bus departing at departureTime\\n                pasPtr++;\\n                goingCounter++;\\n            }\\n        }\\n\\n        // we found the remaining passengers waiting for the last bus.\\n        // I will try to find the latest possible time I can go with some waiting people\\n        if (pasPtr >= passengers.length) {\\n            return buses[buses.length - 1];\\n        }\\n\\n        int lastDeparture = buses[buses.length - 1];\\n        int firstWaitingPas = passengers[pasPtr];\\n\\n        if (firstWaitingPas > lastDeparture) return lastDeparture;\\n\\n        // I could arrive before the firstWaiting, in the worst case\\n        int latest = firstWaitingPas - 1;\\n        while (allPassengers.contains(latest)) {\\n            latest--;\\n        }\\n\\n        // find an insertion location\\n        int goingCounter = 0;\\n        for (int i=firstWaitingPas+1; i <= lastDeparture && goingCounter < capacity - 1;i++) {\\n            if (!allPassengers.contains(i)) {\\n                latest = i;\\n            } else {\\n                goingCounter++;\\n            }\\n        }\\n\\n        return latest;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3065655,
                "title": "201ms-54mb-greedy-2-pointer-js-my-planning-notes",
                "content": "```\\n/**\\n\\nO( lognn + mlogm )\\niterate passengers until they fill the last bus\\nif doesnt happen\\n    ans is closest lesser non conflicting time to departure\\nif it does happen  \\n    ignore rest of passengers array\\n    iterate backwards until there\\'s not a conflict the minute before any passenger\\n\\n\\n\\nsort busses\\nsort passengers\\n\\niterate busses\\n    waiting = max( 0, waiting - cap )\\n    while \\n        waiting <= cap \\n        && passenger arrives before/= current bus\\n            next passenger\\n            waiting++\\n    next bus\\n\\nchecktime = last buss departure\\nif  waiting >= cap\\n    checktime = passengers[pointer-1] - 1\\n\\niterate checktime; time--\\n    if time !== passenger[i]\\n        return time\\n    else\\n        previous passenger\\n\\n*/\\nvar latestTimeCatchTheBus = function (buses, passengers, capacity) {\\n    let pi = 0\\n    let waiting = 0\\n\\n    buses.sort((a, b) => a - b)\\n    passengers.sort((a, b) => a - b)\\n\\n    buses.forEach(departure => {\\n        waiting = Math.max(0, waiting - capacity)\\n\\n        while (\\n            waiting < capacity\\n            && passengers[pi] <= departure\\n        ) {\\n            waiting++\\n            pi++\\n        }\\n\\n        if (pi === passengers.length) return\\n    })\\n\\n    pi--\\n\\n    let lastTime = buses[buses.length - 1]\\n    if (waiting >= capacity) {\\n        lastTime = passengers[pi]\\n    }\\n\\n    for (let i = lastTime; i >= 0; i--) {\\n        if (!(pi in passengers) || i !== passengers[pi]) {\\n            return i\\n        } else {\\n            pi--\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Greedy"
                ],
                "code": "```\\n/**\\n\\nO( lognn + mlogm )\\niterate passengers until they fill the last bus\\nif doesnt happen\\n    ans is closest lesser non conflicting time to departure\\nif it does happen  \\n    ignore rest of passengers array\\n    iterate backwards until there\\'s not a conflict the minute before any passenger\\n\\n\\n\\nsort busses\\nsort passengers\\n\\niterate busses\\n    waiting = max( 0, waiting - cap )\\n    while \\n        waiting <= cap \\n        && passenger arrives before/= current bus\\n            next passenger\\n            waiting++\\n    next bus\\n\\nchecktime = last buss departure\\nif  waiting >= cap\\n    checktime = passengers[pointer-1] - 1\\n\\niterate checktime; time--\\n    if time !== passenger[i]\\n        return time\\n    else\\n        previous passenger\\n\\n*/\\nvar latestTimeCatchTheBus = function (buses, passengers, capacity) {\\n    let pi = 0\\n    let waiting = 0\\n\\n    buses.sort((a, b) => a - b)\\n    passengers.sort((a, b) => a - b)\\n\\n    buses.forEach(departure => {\\n        waiting = Math.max(0, waiting - capacity)\\n\\n        while (\\n            waiting < capacity\\n            && passengers[pi] <= departure\\n        ) {\\n            waiting++\\n            pi++\\n        }\\n\\n        if (pi === passengers.length) return\\n    })\\n\\n    pi--\\n\\n    let lastTime = buses[buses.length - 1]\\n    if (waiting >= capacity) {\\n        lastTime = passengers[pi]\\n    }\\n\\n    for (let i = lastTime; i >= 0; i--) {\\n        if (!(pi in passengers) || i !== passengers[pi]) {\\n            return i\\n        } else {\\n            pi--\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3045250,
                "title": "simple-intuituve-solution-with-priority-queue-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint findLatest(set<int> s,int i)\\n{\\n    while(1)\\n    {\\n        if(s.find(i)==s.end())\\n            return i;\\n        i-=1;\\n    }\\n    return -1;\\n}\\n    int latestTimeCatchTheBus(vector<int>& buses, vector<int>& passengers, int capacity) {\\n        sort(buses.begin(),buses.end());\\n        sort(passengers.begin(),passengers.end());\\n        priority_queue<int,vector<int>,greater<>> passQ;\\n        for(int i=0;i<passengers.size();i++)\\n            passQ.push(passengers[i]);\\n        int curr_time=0;\\n        int curr_pass=0;\\n        set<int> s;\\n        for(int i=0;i<buses.size()-1;i++)\\n        {\\n            int curr_bus=buses[i];\\n            int bus_cap=capacity;\\n            while(!passQ.empty() && passQ.top()<=curr_bus && bus_cap>0)\\n            {\\n                s.insert(passQ.top());\\n                passQ.pop();\\n                bus_cap--;\\n            }\\n        }\\n        \\n        int lastBus=buses[buses.size()-1];\\n        int cap=capacity;\\n        while(!passQ.empty() && passQ.top()<=lastBus && cap>0)\\n        {\\n            int x=passQ.top();\\n            s.insert(x);\\n            passQ.pop();\\n            cap--;\\n        }\\n        if(cap>0)\\n        {\\n            return findLatest(s,lastBus);\\n        }\\n        else\\n        {\\n            return findLatest(s,*(s.rbegin()));\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint findLatest(set<int> s,int i)\\n{\\n    while(1)\\n    {\\n        if(s.find(i)==s.end())\\n            return i;\\n        i-=1;\\n    }\\n    return -1;\\n}\\n    int latestTimeCatchTheBus(vector<int>& buses, vector<int>& passengers, int capacity) {\\n        sort(buses.begin(),buses.end());\\n        sort(passengers.begin(),passengers.end());\\n        priority_queue<int,vector<int>,greater<>> passQ;\\n        for(int i=0;i<passengers.size();i++)\\n            passQ.push(passengers[i]);\\n        int curr_time=0;\\n        int curr_pass=0;\\n        set<int> s;\\n        for(int i=0;i<buses.size()-1;i++)\\n        {\\n            int curr_bus=buses[i];\\n            int bus_cap=capacity;\\n            while(!passQ.empty() && passQ.top()<=curr_bus && bus_cap>0)\\n            {\\n                s.insert(passQ.top());\\n                passQ.pop();\\n                bus_cap--;\\n            }\\n        }\\n        \\n        int lastBus=buses[buses.size()-1];\\n        int cap=capacity;\\n        while(!passQ.empty() && passQ.top()<=lastBus && cap>0)\\n        {\\n            int x=passQ.top();\\n            s.insert(x);\\n            passQ.pop();\\n            cap--;\\n        }\\n        if(cap>0)\\n        {\\n            return findLatest(s,lastBus);\\n        }\\n        else\\n        {\\n            return findLatest(s,*(s.rbegin()));\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3020636,
                "title": "ruby-247-ms",
                "content": "```ruby\\ndef latest_time_catch_the_bus b, p, c\\n    [b, p].each(&:sort!)\\n    d = b.map do | d |\\n        t, r = 0, []\\n        while t < c && (x = p[0]) && x <= d\\n            r << p.shift\\n            t += 1\\n        end\\n        r\\n    end\\n    d.each_with_index.reverse_each do | x, i |\\n        t = b[i]\\n        return t if x.size < c && x.last != t\\n        r = x.first - 1\\n        for j in 1...x.size\\n            r = x[j] - 1 if (x[j] - x[j - 1]) > 1\\n        end\\n        return r if i < 1 || r > x.first || r != d[i - 1].last\\n    end\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\ndef latest_time_catch_the_bus b, p, c\\n    [b, p].each(&:sort!)\\n    d = b.map do | d |\\n        t, r = 0, []\\n        while t < c && (x = p[0]) && x <= d\\n            r << p.shift\\n            t += 1\\n        end\\n        r\\n    end\\n    d.each_with_index.reverse_each do | x, i |\\n        t = b[i]\\n        return t if x.size < c && x.last != t\\n        r = x.first - 1\\n        for j in 1...x.size\\n            r = x[j] - 1 if (x[j] - x[j - 1]) > 1\\n        end\\n        return r if i < 1 || r > x.first || r != d[i - 1].last\\n    end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3020494,
                "title": "o-n-and-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\ntry to onboard each bus- two options\\n1. take someone else\\'s seat if capacity if full- need to come before him\\n2. if capacity is not full, you can take one seat \\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int latestTimeCatchTheBus(int[] buses, int[] passengers, int capacity) {\\n        \\n        Arrays.sort(buses);\\n        Arrays.sort(passengers);\\n        int idx=0, latestArrivalTime=0, lastOnboarded=0;\\n\\n        for(int i=0;i<buses.length;++i){\\n            int onboarded=0;\\n            //capacity is full\\n            while(idx<passengers.length && passengers[idx]<=buses[i] && onboarded<capacity){\\n                if(lastOnboarded<passengers[idx]-1){\\n                    latestArrivalTime=passengers[idx]-1;\\n                }\\n                onboarded++;\\n                lastOnboarded=passengers[idx];\\n                ++idx;\\n            }\\n            //capacity not full, try to onboard at bus time departure\\n            if(onboarded<capacity && lastOnboarded!=buses[i]){\\n                latestArrivalTime=buses[i];\\n            }\\n        }\\n\\n        return latestArrivalTime;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int latestTimeCatchTheBus(int[] buses, int[] passengers, int capacity) {\\n        \\n        Arrays.sort(buses);\\n        Arrays.sort(passengers);\\n        int idx=0, latestArrivalTime=0, lastOnboarded=0;\\n\\n        for(int i=0;i<buses.length;++i){\\n            int onboarded=0;\\n            //capacity is full\\n            while(idx<passengers.length && passengers[idx]<=buses[i] && onboarded<capacity){\\n                if(lastOnboarded<passengers[idx]-1){\\n                    latestArrivalTime=passengers[idx]-1;\\n                }\\n                onboarded++;\\n                lastOnboarded=passengers[idx];\\n                ++idx;\\n            }\\n            //capacity not full, try to onboard at bus time departure\\n            if(onboarded<capacity && lastOnboarded!=buses[i]){\\n                latestArrivalTime=buses[i];\\n            }\\n        }\\n\\n        return latestArrivalTime;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2906281,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int> &buses, vector<int> &passengers, int capacity)\\n{\\n    sort(buses.begin(), buses.end());\\n    sort(passengers.begin(), passengers.end());\\n\\n    unordered_map<int, int> mp;\\n\\n    for (int i : passengers)\\n        mp[i]++;\\n\\n    int i = 0, j = 0, c = 0;\\n    while (j < buses.size() - 1)\\n    {\\n        while (i < passengers.size() && passengers[i] <= buses[j] && c < capacity)\\n        {\\n            i++;\\n            c++;\\n        }\\n        j++;\\n        c= 0;\\n    }\\n\\n    int n = passengers.size();\\n\\n    if (capacity > n - i)\\n    {\\n        int val1 = buses[j];\\n        while (mp.count(val1) == 1)\\n            val1--;\\n        return val1;\\n    }\\n    else\\n    {\\n        i = i + capacity - 1;\\n        int val1 = passengers[i];\\n        int val2 = buses[j];\\n\\n        while (mp.count(val1) == 1 || val1 > val2)\\n            val1--;\\n\\n        return val1;\\n    }\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int> &buses, vector<int> &passengers, int capacity)\\n{\\n    sort(buses.begin(), buses.end());\\n    sort(passengers.begin(), passengers.end());\\n\\n    unordered_map<int, int> mp;\\n\\n    for (int i : passengers)\\n        mp[i]++;\\n\\n    int i = 0, j = 0, c = 0;\\n    while (j < buses.size() - 1)\\n    {\\n        while (i < passengers.size() && passengers[i] <= buses[j] && c < capacity)\\n        {\\n            i++;\\n            c++;\\n        }\\n        j++;\\n        c= 0;\\n    }\\n\\n    int n = passengers.size();\\n\\n    if (capacity > n - i)\\n    {\\n        int val1 = buses[j];\\n        while (mp.count(val1) == 1)\\n            val1--;\\n        return val1;\\n    }\\n    else\\n    {\\n        i = i + capacity - 1;\\n        int val1 = passengers[i];\\n        int val2 = buses[j];\\n\\n        while (mp.count(val1) == 1 || val1 > val2)\\n            val1--;\\n\\n        return val1;\\n    }\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2900254,
                "title": "c-two-pointers",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& buses, vector<int>& pass, int capacity) {\\n    int n=pass.size();\\n    int m=buses.size();\\n  \\n    sort(buses.begin(),buses.end());\\n    sort(pass.begin(),pass.end());\\n\\n      int i=0,j=0,last=buses[0],hold=min(buses[0],pass[0]-1);\\n      \\n      int cap=capacity;\\n      while(j<n)\\n       {\\n           if(pass[j]<=buses[i] && cap)\\n           { \\n               if(pass[j]-last>1)\\n               hold=pass[j]-1;\\n\\n               last=pass[j];\\n               j++;\\n               cap--;\\n           }\\n           else\\n           {  \\n               if(cap && last<buses[i])\\n               {  \\n                   hold=buses[i];}\\n               i++;\\n               if(i==m)\\n               break;\\n               cap=capacity;\\n           }\\n        \\n       }\\n     \\n             if((cap && last<buses[m-1]) || i<m-1)\\n                 hold=buses[m-1];\\n        return hold;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int>& buses, vector<int>& pass, int capacity) {\\n    int n=pass.size();\\n    int m=buses.size();\\n  \\n    sort(buses.begin(),buses.end());\\n    sort(pass.begin(),pass.end());\\n\\n      int i=0,j=0,last=buses[0],hold=min(buses[0],pass[0]-1);\\n      \\n      int cap=capacity;\\n      while(j<n)\\n       {\\n           if(pass[j]<=buses[i] && cap)\\n           { \\n               if(pass[j]-last>1)\\n               hold=pass[j]-1;\\n\\n               last=pass[j];\\n               j++;\\n               cap--;\\n           }\\n           else\\n           {  \\n               if(cap && last<buses[i])\\n               {  \\n                   hold=buses[i];}\\n               i++;\\n               if(i==m)\\n               break;\\n               cap=capacity;\\n           }\\n        \\n       }\\n     \\n             if((cap && last<buses[m-1]) || i<m-1)\\n                 hold=buses[m-1];\\n        return hold;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899317,
                "title": "two-pointer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def latestTimeCatchTheBus(self, buses: List[int], passengers: List[int], capacity: int) -> int:\\n        buses.sort()\\n        passengers.sort()\\n        pass_index = 0\\n        for bus_index in range(len(buses)):\\n            count = 0\\n            while pass_index <= len(passengers)-1:\\n                if passengers[pass_index]<=buses[bus_index] and count < capacity:\\n                    pass_index+=1\\n                    count+=1\\n                else:\\n                    break\\n        print(count)\\n        if count == capacity:\\n            best = passengers[pass_index-1]-1\\n            if best in passengers:\\n                while best in passengers:\\n                    best -= 1\\n        else:\\n            best = buses[-1]\\n            if best in passengers:\\n                while best in passengers:\\n                    best-=1\\n\\n        return best\\n        \\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def latestTimeCatchTheBus(self, buses: List[int], passengers: List[int], capacity: int) -> int:\\n        buses.sort()\\n        passengers.sort()\\n        pass_index = 0\\n        for bus_index in range(len(buses)):\\n            count = 0\\n            while pass_index <= len(passengers)-1:\\n                if passengers[pass_index]<=buses[bus_index] and count < capacity:\\n                    pass_index+=1\\n                    count+=1\\n                else:\\n                    break\\n        print(count)\\n        if count == capacity:\\n            best = passengers[pass_index-1]-1\\n            if best in passengers:\\n                while best in passengers:\\n                    best -= 1\\n        else:\\n            best = buses[-1]\\n            if best in passengers:\\n                while best in passengers:\\n                    best-=1\\n\\n        return best\\n        \\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2894673,
                "title": "kotlin-runtime-1075-ms-faster-than-100-00-memory-usage-79-2-mb-less-than-100-00",
                "content": "```\\nfun latestTimeCatchTheBus(buses: IntArray, passengers: IntArray, capacity: Int): Int {\\n    buses.sort()\\n    passengers.sort()\\n\\n    var pos = -1\\n    var count = 1\\n    buses.forEach {\\n        count = 1\\n        while (count <= capacity && pos < passengers.lastIndex && passengers[pos + 1] <= it) {\\n            count++\\n            pos++\\n        }\\n    }\\n    if (pos < 0 || (count <= capacity && buses.last() > passengers[pos])) {\\n        return buses[buses.lastIndex]\\n    }\\n    while (pos > 0 && (passengers[pos] == passengers[pos - 1] + 1)) {\\n        pos--\\n    }\\n    return passengers[pos] - 1\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nfun latestTimeCatchTheBus(buses: IntArray, passengers: IntArray, capacity: Int): Int {\\n    buses.sort()\\n    passengers.sort()\\n\\n    var pos = -1\\n    var count = 1\\n    buses.forEach {\\n        count = 1\\n        while (count <= capacity && pos < passengers.lastIndex && passengers[pos + 1] <= it) {\\n            count++\\n            pos++\\n        }\\n    }\\n    if (pos < 0 || (count <= capacity && buses.last() > passengers[pos])) {\\n        return buses[buses.lastIndex]\\n    }\\n    while (pos > 0 && (passengers[pos] == passengers[pos - 1] + 1)) {\\n        pos--\\n    }\\n    return passengers[pos] - 1\\n}\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 2008572,
                "content": [
                    {
                        "username": "sameer89",
                        "content": "Let me save you some time. Latest means at late as possible :)"
                    },
                    {
                        "username": "vikasss",
                        "content": "bruh! i was figuring first example from last 15 minutes why not before 0th passenger.Thanks a lot"
                    },
                    {
                        "username": "adityag7522",
                        "content": "We can first board all the passengers.\\ncase 1: if last bus still have a seat then i can come at the last bus\\'s departure time.\\ncase 2: all the seats are full and no buses are available the we are having a pointer on passenger list which shows the last passenger boarded we will check whether the time just before his arrival is free if free then return the time else move to previous passenger.\\n\\nNo passenger boarded the bus means I can arrive at the last bus\\'s departure time;"
                    },
                    {
                        "username": "aishuarya",
                        "content": "Should the solution here be 1 ,instead 16 ?\\n\\nInput: buses = [10,20], passengers = [2,17,18,19], capacity = 2\\nOutput: 16"
                    },
                    {
                        "username": "saksham2811",
                        "content": "[@Mrinal2100](/Mrinal2100) \"Latest\" means we are lazy and we want to catch the last possible bus."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "[@Mrinal2100](/Mrinal2100)  Came across this description of the problem \\nhttps://leetcode.com/problems/the-latest-time-to-catch-a-bus/solutions/2259211/what-is-latest-time-c-java-python/"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "[@hanselkane](/hanselkane) Why not 3 or 4 or 6  or 7 or 8. He can get on the first bus"
                    },
                    {
                        "username": "hanselkane",
                        "content": "No, as it asked for the latest time (16 > 1)"
                    },
                    {
                        "username": "punnypun",
                        "content": "[5]\\n[7,8]\\n1\\nshouldn\\'t the solution here be 6?"
                    },
                    {
                        "username": "snow_jesus",
                        "content": "You can get on a bus that departs at x minutes if you arrive at y minutes where y <= x. Answer is 5."
                    },
                    {
                        "username": "Partharora_07",
                        "content": "class Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int> &buses, vector<int> &passengers, int capacity)\\n{\\n    sort(buses.begin(), buses.end());\\n    sort(passengers.begin(), passengers.end());\\n\\n    unordered_map<int, int> mp;\\n\\n    for (int i : passengers)\\n        mp[i]++;\\n\\n    int i = 0, j = 0, c = 0;\\n    while (j < buses.size() - 1)\\n    {\\n        while (i < passengers.size() && passengers[i] <= buses[j] && c < capacity)\\n        {\\n            i++;\\n            c++;\\n        }\\n        j++;\\n        c= 0;\\n    }\\n\\n    int n = passengers.size();\\n\\n    if (capacity > n - i)\\n    {\\n        int val1 = buses[j];\\n        while (mp.count(val1) == 1)\\n            val1--;\\n        return val1;\\n    }\\n    else\\n    {\\n        i = i + capacity - 1;\\n        int val1 = passengers[i];\\n        int val2 = buses[j];\\n\\n        while (mp.count(val1) == 1 || val1 > val2)\\n            val1--;\\n\\n        return val1;\\n    }\\n}\\n};"
                    },
                    {
                        "username": "haniyeka",
                        "content": "Can someone solve the problem here?\n\n```class Solution:\n    def latestTimeCatchTheBus(self, buses: List[int], passengers: List[int], capacity: int) -> int:\n        buses = sorted(buses)\n        boardedpassengers = []\n        lastminute = 0\n        for bus in buses:\n            curpassengers = [p for p in passengers if ((p <= bus) and (p not in boardedpassengers)) ]\n            curpassengers = sorted(curpassengers)\n            while len(curpassengers)>capacity:\n                curpassengers.remove(curpassengers[-1])\n            boardedpassengers = boardedpassengers + curpassengers\n            if capacity == len(curpassengers):\n                lastminute = max(curpassengers)-1\n            else:\n                lastminute = bus\n            while lastminute in boardedpassengers:\n                lastminute = lastminute - 1\n        return lastminute"
                    }
                ]
            },
            {
                "id": 1900161,
                "content": [
                    {
                        "username": "sameer89",
                        "content": "Let me save you some time. Latest means at late as possible :)"
                    },
                    {
                        "username": "vikasss",
                        "content": "bruh! i was figuring first example from last 15 minutes why not before 0th passenger.Thanks a lot"
                    },
                    {
                        "username": "adityag7522",
                        "content": "We can first board all the passengers.\\ncase 1: if last bus still have a seat then i can come at the last bus\\'s departure time.\\ncase 2: all the seats are full and no buses are available the we are having a pointer on passenger list which shows the last passenger boarded we will check whether the time just before his arrival is free if free then return the time else move to previous passenger.\\n\\nNo passenger boarded the bus means I can arrive at the last bus\\'s departure time;"
                    },
                    {
                        "username": "aishuarya",
                        "content": "Should the solution here be 1 ,instead 16 ?\\n\\nInput: buses = [10,20], passengers = [2,17,18,19], capacity = 2\\nOutput: 16"
                    },
                    {
                        "username": "saksham2811",
                        "content": "[@Mrinal2100](/Mrinal2100) \"Latest\" means we are lazy and we want to catch the last possible bus."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "[@Mrinal2100](/Mrinal2100)  Came across this description of the problem \\nhttps://leetcode.com/problems/the-latest-time-to-catch-a-bus/solutions/2259211/what-is-latest-time-c-java-python/"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "[@hanselkane](/hanselkane) Why not 3 or 4 or 6  or 7 or 8. He can get on the first bus"
                    },
                    {
                        "username": "hanselkane",
                        "content": "No, as it asked for the latest time (16 > 1)"
                    },
                    {
                        "username": "punnypun",
                        "content": "[5]\\n[7,8]\\n1\\nshouldn\\'t the solution here be 6?"
                    },
                    {
                        "username": "snow_jesus",
                        "content": "You can get on a bus that departs at x minutes if you arrive at y minutes where y <= x. Answer is 5."
                    },
                    {
                        "username": "Partharora_07",
                        "content": "class Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int> &buses, vector<int> &passengers, int capacity)\\n{\\n    sort(buses.begin(), buses.end());\\n    sort(passengers.begin(), passengers.end());\\n\\n    unordered_map<int, int> mp;\\n\\n    for (int i : passengers)\\n        mp[i]++;\\n\\n    int i = 0, j = 0, c = 0;\\n    while (j < buses.size() - 1)\\n    {\\n        while (i < passengers.size() && passengers[i] <= buses[j] && c < capacity)\\n        {\\n            i++;\\n            c++;\\n        }\\n        j++;\\n        c= 0;\\n    }\\n\\n    int n = passengers.size();\\n\\n    if (capacity > n - i)\\n    {\\n        int val1 = buses[j];\\n        while (mp.count(val1) == 1)\\n            val1--;\\n        return val1;\\n    }\\n    else\\n    {\\n        i = i + capacity - 1;\\n        int val1 = passengers[i];\\n        int val2 = buses[j];\\n\\n        while (mp.count(val1) == 1 || val1 > val2)\\n            val1--;\\n\\n        return val1;\\n    }\\n}\\n};"
                    },
                    {
                        "username": "haniyeka",
                        "content": "Can someone solve the problem here?\n\n```class Solution:\n    def latestTimeCatchTheBus(self, buses: List[int], passengers: List[int], capacity: int) -> int:\n        buses = sorted(buses)\n        boardedpassengers = []\n        lastminute = 0\n        for bus in buses:\n            curpassengers = [p for p in passengers if ((p <= bus) and (p not in boardedpassengers)) ]\n            curpassengers = sorted(curpassengers)\n            while len(curpassengers)>capacity:\n                curpassengers.remove(curpassengers[-1])\n            boardedpassengers = boardedpassengers + curpassengers\n            if capacity == len(curpassengers):\n                lastminute = max(curpassengers)-1\n            else:\n                lastminute = bus\n            while lastminute in boardedpassengers:\n                lastminute = lastminute - 1\n        return lastminute"
                    }
                ]
            },
            {
                "id": 1946780,
                "content": [
                    {
                        "username": "sameer89",
                        "content": "Let me save you some time. Latest means at late as possible :)"
                    },
                    {
                        "username": "vikasss",
                        "content": "bruh! i was figuring first example from last 15 minutes why not before 0th passenger.Thanks a lot"
                    },
                    {
                        "username": "adityag7522",
                        "content": "We can first board all the passengers.\\ncase 1: if last bus still have a seat then i can come at the last bus\\'s departure time.\\ncase 2: all the seats are full and no buses are available the we are having a pointer on passenger list which shows the last passenger boarded we will check whether the time just before his arrival is free if free then return the time else move to previous passenger.\\n\\nNo passenger boarded the bus means I can arrive at the last bus\\'s departure time;"
                    },
                    {
                        "username": "aishuarya",
                        "content": "Should the solution here be 1 ,instead 16 ?\\n\\nInput: buses = [10,20], passengers = [2,17,18,19], capacity = 2\\nOutput: 16"
                    },
                    {
                        "username": "saksham2811",
                        "content": "[@Mrinal2100](/Mrinal2100) \"Latest\" means we are lazy and we want to catch the last possible bus."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "[@Mrinal2100](/Mrinal2100)  Came across this description of the problem \\nhttps://leetcode.com/problems/the-latest-time-to-catch-a-bus/solutions/2259211/what-is-latest-time-c-java-python/"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "[@hanselkane](/hanselkane) Why not 3 or 4 or 6  or 7 or 8. He can get on the first bus"
                    },
                    {
                        "username": "hanselkane",
                        "content": "No, as it asked for the latest time (16 > 1)"
                    },
                    {
                        "username": "punnypun",
                        "content": "[5]\\n[7,8]\\n1\\nshouldn\\'t the solution here be 6?"
                    },
                    {
                        "username": "snow_jesus",
                        "content": "You can get on a bus that departs at x minutes if you arrive at y minutes where y <= x. Answer is 5."
                    },
                    {
                        "username": "Partharora_07",
                        "content": "class Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int> &buses, vector<int> &passengers, int capacity)\\n{\\n    sort(buses.begin(), buses.end());\\n    sort(passengers.begin(), passengers.end());\\n\\n    unordered_map<int, int> mp;\\n\\n    for (int i : passengers)\\n        mp[i]++;\\n\\n    int i = 0, j = 0, c = 0;\\n    while (j < buses.size() - 1)\\n    {\\n        while (i < passengers.size() && passengers[i] <= buses[j] && c < capacity)\\n        {\\n            i++;\\n            c++;\\n        }\\n        j++;\\n        c= 0;\\n    }\\n\\n    int n = passengers.size();\\n\\n    if (capacity > n - i)\\n    {\\n        int val1 = buses[j];\\n        while (mp.count(val1) == 1)\\n            val1--;\\n        return val1;\\n    }\\n    else\\n    {\\n        i = i + capacity - 1;\\n        int val1 = passengers[i];\\n        int val2 = buses[j];\\n\\n        while (mp.count(val1) == 1 || val1 > val2)\\n            val1--;\\n\\n        return val1;\\n    }\\n}\\n};"
                    },
                    {
                        "username": "haniyeka",
                        "content": "Can someone solve the problem here?\n\n```class Solution:\n    def latestTimeCatchTheBus(self, buses: List[int], passengers: List[int], capacity: int) -> int:\n        buses = sorted(buses)\n        boardedpassengers = []\n        lastminute = 0\n        for bus in buses:\n            curpassengers = [p for p in passengers if ((p <= bus) and (p not in boardedpassengers)) ]\n            curpassengers = sorted(curpassengers)\n            while len(curpassengers)>capacity:\n                curpassengers.remove(curpassengers[-1])\n            boardedpassengers = boardedpassengers + curpassengers\n            if capacity == len(curpassengers):\n                lastminute = max(curpassengers)-1\n            else:\n                lastminute = bus\n            while lastminute in boardedpassengers:\n                lastminute = lastminute - 1\n        return lastminute"
                    }
                ]
            },
            {
                "id": 1892955,
                "content": [
                    {
                        "username": "sameer89",
                        "content": "Let me save you some time. Latest means at late as possible :)"
                    },
                    {
                        "username": "vikasss",
                        "content": "bruh! i was figuring first example from last 15 minutes why not before 0th passenger.Thanks a lot"
                    },
                    {
                        "username": "adityag7522",
                        "content": "We can first board all the passengers.\\ncase 1: if last bus still have a seat then i can come at the last bus\\'s departure time.\\ncase 2: all the seats are full and no buses are available the we are having a pointer on passenger list which shows the last passenger boarded we will check whether the time just before his arrival is free if free then return the time else move to previous passenger.\\n\\nNo passenger boarded the bus means I can arrive at the last bus\\'s departure time;"
                    },
                    {
                        "username": "aishuarya",
                        "content": "Should the solution here be 1 ,instead 16 ?\\n\\nInput: buses = [10,20], passengers = [2,17,18,19], capacity = 2\\nOutput: 16"
                    },
                    {
                        "username": "saksham2811",
                        "content": "[@Mrinal2100](/Mrinal2100) \"Latest\" means we are lazy and we want to catch the last possible bus."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "[@Mrinal2100](/Mrinal2100)  Came across this description of the problem \\nhttps://leetcode.com/problems/the-latest-time-to-catch-a-bus/solutions/2259211/what-is-latest-time-c-java-python/"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "[@hanselkane](/hanselkane) Why not 3 or 4 or 6  or 7 or 8. He can get on the first bus"
                    },
                    {
                        "username": "hanselkane",
                        "content": "No, as it asked for the latest time (16 > 1)"
                    },
                    {
                        "username": "punnypun",
                        "content": "[5]\\n[7,8]\\n1\\nshouldn\\'t the solution here be 6?"
                    },
                    {
                        "username": "snow_jesus",
                        "content": "You can get on a bus that departs at x minutes if you arrive at y minutes where y <= x. Answer is 5."
                    },
                    {
                        "username": "Partharora_07",
                        "content": "class Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int> &buses, vector<int> &passengers, int capacity)\\n{\\n    sort(buses.begin(), buses.end());\\n    sort(passengers.begin(), passengers.end());\\n\\n    unordered_map<int, int> mp;\\n\\n    for (int i : passengers)\\n        mp[i]++;\\n\\n    int i = 0, j = 0, c = 0;\\n    while (j < buses.size() - 1)\\n    {\\n        while (i < passengers.size() && passengers[i] <= buses[j] && c < capacity)\\n        {\\n            i++;\\n            c++;\\n        }\\n        j++;\\n        c= 0;\\n    }\\n\\n    int n = passengers.size();\\n\\n    if (capacity > n - i)\\n    {\\n        int val1 = buses[j];\\n        while (mp.count(val1) == 1)\\n            val1--;\\n        return val1;\\n    }\\n    else\\n    {\\n        i = i + capacity - 1;\\n        int val1 = passengers[i];\\n        int val2 = buses[j];\\n\\n        while (mp.count(val1) == 1 || val1 > val2)\\n            val1--;\\n\\n        return val1;\\n    }\\n}\\n};"
                    },
                    {
                        "username": "haniyeka",
                        "content": "Can someone solve the problem here?\n\n```class Solution:\n    def latestTimeCatchTheBus(self, buses: List[int], passengers: List[int], capacity: int) -> int:\n        buses = sorted(buses)\n        boardedpassengers = []\n        lastminute = 0\n        for bus in buses:\n            curpassengers = [p for p in passengers if ((p <= bus) and (p not in boardedpassengers)) ]\n            curpassengers = sorted(curpassengers)\n            while len(curpassengers)>capacity:\n                curpassengers.remove(curpassengers[-1])\n            boardedpassengers = boardedpassengers + curpassengers\n            if capacity == len(curpassengers):\n                lastminute = max(curpassengers)-1\n            else:\n                lastminute = bus\n            while lastminute in boardedpassengers:\n                lastminute = lastminute - 1\n        return lastminute"
                    }
                ]
            },
            {
                "id": 1714868,
                "content": [
                    {
                        "username": "sameer89",
                        "content": "Let me save you some time. Latest means at late as possible :)"
                    },
                    {
                        "username": "vikasss",
                        "content": "bruh! i was figuring first example from last 15 minutes why not before 0th passenger.Thanks a lot"
                    },
                    {
                        "username": "adityag7522",
                        "content": "We can first board all the passengers.\\ncase 1: if last bus still have a seat then i can come at the last bus\\'s departure time.\\ncase 2: all the seats are full and no buses are available the we are having a pointer on passenger list which shows the last passenger boarded we will check whether the time just before his arrival is free if free then return the time else move to previous passenger.\\n\\nNo passenger boarded the bus means I can arrive at the last bus\\'s departure time;"
                    },
                    {
                        "username": "aishuarya",
                        "content": "Should the solution here be 1 ,instead 16 ?\\n\\nInput: buses = [10,20], passengers = [2,17,18,19], capacity = 2\\nOutput: 16"
                    },
                    {
                        "username": "saksham2811",
                        "content": "[@Mrinal2100](/Mrinal2100) \"Latest\" means we are lazy and we want to catch the last possible bus."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "[@Mrinal2100](/Mrinal2100)  Came across this description of the problem \\nhttps://leetcode.com/problems/the-latest-time-to-catch-a-bus/solutions/2259211/what-is-latest-time-c-java-python/"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "[@hanselkane](/hanselkane) Why not 3 or 4 or 6  or 7 or 8. He can get on the first bus"
                    },
                    {
                        "username": "hanselkane",
                        "content": "No, as it asked for the latest time (16 > 1)"
                    },
                    {
                        "username": "punnypun",
                        "content": "[5]\\n[7,8]\\n1\\nshouldn\\'t the solution here be 6?"
                    },
                    {
                        "username": "snow_jesus",
                        "content": "You can get on a bus that departs at x minutes if you arrive at y minutes where y <= x. Answer is 5."
                    },
                    {
                        "username": "Partharora_07",
                        "content": "class Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int> &buses, vector<int> &passengers, int capacity)\\n{\\n    sort(buses.begin(), buses.end());\\n    sort(passengers.begin(), passengers.end());\\n\\n    unordered_map<int, int> mp;\\n\\n    for (int i : passengers)\\n        mp[i]++;\\n\\n    int i = 0, j = 0, c = 0;\\n    while (j < buses.size() - 1)\\n    {\\n        while (i < passengers.size() && passengers[i] <= buses[j] && c < capacity)\\n        {\\n            i++;\\n            c++;\\n        }\\n        j++;\\n        c= 0;\\n    }\\n\\n    int n = passengers.size();\\n\\n    if (capacity > n - i)\\n    {\\n        int val1 = buses[j];\\n        while (mp.count(val1) == 1)\\n            val1--;\\n        return val1;\\n    }\\n    else\\n    {\\n        i = i + capacity - 1;\\n        int val1 = passengers[i];\\n        int val2 = buses[j];\\n\\n        while (mp.count(val1) == 1 || val1 > val2)\\n            val1--;\\n\\n        return val1;\\n    }\\n}\\n};"
                    },
                    {
                        "username": "haniyeka",
                        "content": "Can someone solve the problem here?\n\n```class Solution:\n    def latestTimeCatchTheBus(self, buses: List[int], passengers: List[int], capacity: int) -> int:\n        buses = sorted(buses)\n        boardedpassengers = []\n        lastminute = 0\n        for bus in buses:\n            curpassengers = [p for p in passengers if ((p <= bus) and (p not in boardedpassengers)) ]\n            curpassengers = sorted(curpassengers)\n            while len(curpassengers)>capacity:\n                curpassengers.remove(curpassengers[-1])\n            boardedpassengers = boardedpassengers + curpassengers\n            if capacity == len(curpassengers):\n                lastminute = max(curpassengers)-1\n            else:\n                lastminute = bus\n            while lastminute in boardedpassengers:\n                lastminute = lastminute - 1\n        return lastminute"
                    }
                ]
            },
            {
                "id": 1674226,
                "content": [
                    {
                        "username": "sameer89",
                        "content": "Let me save you some time. Latest means at late as possible :)"
                    },
                    {
                        "username": "vikasss",
                        "content": "bruh! i was figuring first example from last 15 minutes why not before 0th passenger.Thanks a lot"
                    },
                    {
                        "username": "adityag7522",
                        "content": "We can first board all the passengers.\\ncase 1: if last bus still have a seat then i can come at the last bus\\'s departure time.\\ncase 2: all the seats are full and no buses are available the we are having a pointer on passenger list which shows the last passenger boarded we will check whether the time just before his arrival is free if free then return the time else move to previous passenger.\\n\\nNo passenger boarded the bus means I can arrive at the last bus\\'s departure time;"
                    },
                    {
                        "username": "aishuarya",
                        "content": "Should the solution here be 1 ,instead 16 ?\\n\\nInput: buses = [10,20], passengers = [2,17,18,19], capacity = 2\\nOutput: 16"
                    },
                    {
                        "username": "saksham2811",
                        "content": "[@Mrinal2100](/Mrinal2100) \"Latest\" means we are lazy and we want to catch the last possible bus."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "[@Mrinal2100](/Mrinal2100)  Came across this description of the problem \\nhttps://leetcode.com/problems/the-latest-time-to-catch-a-bus/solutions/2259211/what-is-latest-time-c-java-python/"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "[@hanselkane](/hanselkane) Why not 3 or 4 or 6  or 7 or 8. He can get on the first bus"
                    },
                    {
                        "username": "hanselkane",
                        "content": "No, as it asked for the latest time (16 > 1)"
                    },
                    {
                        "username": "punnypun",
                        "content": "[5]\\n[7,8]\\n1\\nshouldn\\'t the solution here be 6?"
                    },
                    {
                        "username": "snow_jesus",
                        "content": "You can get on a bus that departs at x minutes if you arrive at y minutes where y <= x. Answer is 5."
                    },
                    {
                        "username": "Partharora_07",
                        "content": "class Solution {\\npublic:\\n    int latestTimeCatchTheBus(vector<int> &buses, vector<int> &passengers, int capacity)\\n{\\n    sort(buses.begin(), buses.end());\\n    sort(passengers.begin(), passengers.end());\\n\\n    unordered_map<int, int> mp;\\n\\n    for (int i : passengers)\\n        mp[i]++;\\n\\n    int i = 0, j = 0, c = 0;\\n    while (j < buses.size() - 1)\\n    {\\n        while (i < passengers.size() && passengers[i] <= buses[j] && c < capacity)\\n        {\\n            i++;\\n            c++;\\n        }\\n        j++;\\n        c= 0;\\n    }\\n\\n    int n = passengers.size();\\n\\n    if (capacity > n - i)\\n    {\\n        int val1 = buses[j];\\n        while (mp.count(val1) == 1)\\n            val1--;\\n        return val1;\\n    }\\n    else\\n    {\\n        i = i + capacity - 1;\\n        int val1 = passengers[i];\\n        int val2 = buses[j];\\n\\n        while (mp.count(val1) == 1 || val1 > val2)\\n            val1--;\\n\\n        return val1;\\n    }\\n}\\n};"
                    },
                    {
                        "username": "haniyeka",
                        "content": "Can someone solve the problem here?\n\n```class Solution:\n    def latestTimeCatchTheBus(self, buses: List[int], passengers: List[int], capacity: int) -> int:\n        buses = sorted(buses)\n        boardedpassengers = []\n        lastminute = 0\n        for bus in buses:\n            curpassengers = [p for p in passengers if ((p <= bus) and (p not in boardedpassengers)) ]\n            curpassengers = sorted(curpassengers)\n            while len(curpassengers)>capacity:\n                curpassengers.remove(curpassengers[-1])\n            boardedpassengers = boardedpassengers + curpassengers\n            if capacity == len(curpassengers):\n                lastminute = max(curpassengers)-1\n            else:\n                lastminute = bus\n            while lastminute in boardedpassengers:\n                lastminute = lastminute - 1\n        return lastminute"
                    }
                ]
            }
        ]
    },
    {
        "title": "Query Kth Smallest Trimmed Number",
        "question_content": "<p>You are given a <strong>0-indexed</strong> array of strings <code>nums</code>, where each string is of <strong>equal length</strong> and consists of only digits.</p>\n\n<p>You are also given a <strong>0-indexed</strong> 2D integer array <code>queries</code> where <code>queries[i] = [k<sub>i</sub>, trim<sub>i</sub>]</code>. For each <code>queries[i]</code>, you need to:</p>\n\n<ul>\n\t<li><strong>Trim</strong> each number in <code>nums</code> to its <strong>rightmost</strong> <code>trim<sub>i</sub></code> digits.</li>\n\t<li>Determine the <strong>index</strong> of the <code>k<sub>i</sub><sup>th</sup></code> smallest trimmed number in <code>nums</code>. If two trimmed numbers are equal, the number with the <strong>lower</strong> index is considered to be smaller.</li>\n\t<li>Reset each number in <code>nums</code> to its original length.</li>\n</ul>\n\n<p>Return <em>an array </em><code>answer</code><em> of the same length as </em><code>queries</code>,<em> where </em><code>answer[i]</code><em> is the answer to the </em><code>i<sup>th</sup></code><em> query.</em></p>\n\n<p><strong>Note</strong>:</p>\n\n<ul>\n\t<li>To trim to the rightmost <code>x</code> digits means to keep removing the leftmost digit, until only <code>x</code> digits remain.</li>\n\t<li>Strings in <code>nums</code> may contain leading zeros.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [&quot;102&quot;,&quot;473&quot;,&quot;251&quot;,&quot;814&quot;], queries = [[1,1],[2,3],[4,2],[1,2]]\n<strong>Output:</strong> [2,2,1,0]\n<strong>Explanation:</strong>\n1. After trimming to the last digit, nums = [&quot;2&quot;,&quot;3&quot;,&quot;1&quot;,&quot;4&quot;]. The smallest number is 1 at index 2.\n2. Trimmed to the last 3 digits, nums is unchanged. The 2<sup>nd</sup> smallest number is 251 at index 2.\n3. Trimmed to the last 2 digits, nums = [&quot;02&quot;,&quot;73&quot;,&quot;51&quot;,&quot;14&quot;]. The 4<sup>th</sup> smallest number is 73.\n4. Trimmed to the last 2 digits, the smallest number is 2 at index 0.\n   Note that the trimmed number &quot;02&quot; is evaluated as 2.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [&quot;24&quot;,&quot;37&quot;,&quot;96&quot;,&quot;04&quot;], queries = [[2,1],[2,2]]\n<strong>Output:</strong> [3,0]\n<strong>Explanation:</strong>\n1. Trimmed to the last digit, nums = [&quot;4&quot;,&quot;7&quot;,&quot;6&quot;,&quot;4&quot;]. The 2<sup>nd</sup> smallest number is 4 at index 3.\n   There are two occurrences of 4, but the one at index 0 is considered smaller than the one at index 3.\n2. Trimmed to the last 2 digits, nums is unchanged. The 2<sup>nd</sup> smallest number is 24.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= nums[i].length &lt;= 100</code></li>\n\t<li><code>nums[i]</code> consists of only digits.</li>\n\t<li>All <code>nums[i].length</code> are <strong>equal</strong>.</li>\n\t<li><code>1 &lt;= queries.length &lt;= 100</code></li>\n\t<li><code>queries[i].length == 2</code></li>\n\t<li><code>1 &lt;= k<sub>i</sub> &lt;= nums.length</code></li>\n\t<li><code>1 &lt;= trim<sub>i</sub> &lt;= nums[i].length</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> Could you use the <strong>Radix Sort Algorithm</strong> to solve this problem? What will be the complexity of that solution?</p>\n",
        "solutions": [
            {
                "id": 2292794,
                "title": "don-t-make-over-complicate-easy-and-simple",
                "content": "Just do as question says. Don\\'t try to overthink like saving query | thinking solution like tries or any tree, pre-computation or using priority_queue (Yes I also thought because I am fool. lol ). Just see the constrains and just do it.\\n```\\nclass Solution {\\npublic:\\n    vector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& queries) {\\n        vector<int> res;\\n        int n = nums.size();\\n        for(auto &q:queries) {\\n            vector<pair<string,int>> pq;\\n            for(int i=0;i<n; i++) {\\n                pq.push_back({(nums[i].substr(nums[i].size()-q[1])), i});\\n            }\\n            sort(pq.begin(), pq.end());\\n            res.push_back(pq[q[0]-1].second);\\n        }\\n        return res;\\n    }\\n};\\n```\\n# Note :\\n**most of us getting confused by leading 0**. So let me explain the problem, if you removed leading 0 than what you\\'ll face :\\n\\narr = [\"123\", \"092\"];\\n\\nin this case if you sort the arr you\\'ll get expected result i.e. [\"092\" , \"123\" ] but what if we removed leading 0\\n\\narr=[\"123\", \"92\"];\\nnow sort it. Boom what you get ? is this right? we\\'ll get [\"123\", \"92\"] because of alphabetical order 1 is less than 9. But once you make both string equal length than leading 0 will be always less than any number at first position.\\nStill confused? Just dry run with 2-4 numbers you\\'ll get it easily.\\n\\n**TLE for custom comperator**\\nIn general sort don\\'t preserve order but mostly it does.\\nLeetcode should have given low constraints for using custom comperator because in custom comperator comparing for each string will cast O(N) time. And till now I didn\\'t see any test cases which make false default sort. I also faced tle in contest then I realize that comparing each string takes linear time. So I removed custom comperator and it\\'s ac. Same if you used priority queue than for each heapify we have to compare string, that\\'s also too costly.\\n\\n**Time constraint is too strict. So, If you\\'re making copy or anything which cost extra time, that will cause tle. Eventhough you\\'ve correct solution, you might get tle few times. Leetcode should take care of this. And this is the only reasone for that much downvote for the questions.**\\n\\n**Please upvote if it helps.**\\n**Happy Coding!**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& queries) {\\n        vector<int> res;\\n        int n = nums.size();\\n        for(auto &q:queries) {\\n            vector<pair<string,int>> pq;\\n            for(int i=0;i<n; i++) {\\n                pq.push_back({(nums[i].substr(nums[i].size()-q[1])), i});\\n            }\\n            sort(pq.begin(), pq.end());\\n            res.push_back(pq[q[0]-1].second);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2292955,
                "title": "tle-during-contest-ac-after-contest-why",
                "content": "In this solution, I got TLE during the contest.\\n[![image](https://assets.leetcode.com/users/images/19e1f5b3-30e9-4168-b9f8-a1b89230af84_1658031005.693831.png)\\n\\nBut, when I submitted the same solution after the contest, it got accepted.\\n![image](https://assets.leetcode.com/users/images/c6c24c29-6d43-4dcf-859f-834cb9052708_1658031094.4488566.png)\\n\\nCan anyone explain why it failed during contest?\\n\\nHere is the full code,\\n```\\nclass Solution {\\npublic:\\n    vector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& queries) {\\n        vector<int> ans;\\n        for(auto &i : queries) {\\n            vector<string> temp = nums;\\n            \\n            for(int j = 0; j < temp.size() ; j++) {\\n                temp[j] = temp[j].substr(temp[j].size() - i[1]);\\n                \\n            }\\n            \\n            \\n            vector<pair<string, int>> vp;\\n            \\n            for(int j =0 ;j < temp.size() ; j++) {\\n                vp.push_back({temp[j] , j});\\n            }\\n            \\n            \\n            sort(vp.begin() , vp.end(), [&](const pair<string, int> &a , const pair<string,int> &b){\\n                if(a.first == b.first) return a.second < b.second;\\n                return a.first < b.first;\\n            });\\n            \\n            \\n            ans.push_back(vp[i[0] - 1].second);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n````\\n\\n**Update: This solution is now giving TLE for this test case,**\\n[\"827062014636550632479974843784532002147073754026017762804617371141500948283495710672431574121625567\",\"498523870707796008133782149306858052054420429079499113426037785201813694475754939237066492866882764\",\"769304870209442701857928243295577642240622076895625693746603824369142089817969163748994942140221247\",\"840572158697938686670204998986604539231495915704836218540932596251561219901524129724317981586272257\",\"317984334319925950838242332148484027449510831850589414290844653026259127547702390451078589367931377\",\"599669636125802949904225993628976741048084009412225743423277389247030080273640568449728282128574796\",\"274401814641219906197005253606187425147862611632424482543015145218838403330706996080210577947584476\",\"262096046948580278633810437942106381343060132518171464701715221422531056888762644937830582391606422\",\"336889822767890153711843286276436821301584361947628593172444702848328220980824283221250262029312859\",\"500047875833310524948882366585112081743892244523671087713907897562458046226998594653332373843090343\",\"420429242010902654144073852590270917971120406791104723970424404512964347607134154824888780629186009\",\"858978761519436329254051071292323177292198129579944505876728976508266190712188689680696386945754313\",\"317144715538106007130528773966435544139232660287334282563758399721526064508765162513048616541125099\",\"534675097859693456936861479452984314231309504747064581814642509174111206610997949333500899794763625\",\"014826776488149764119900526178165513571146692851222086368751451918437431201729985309920303036574540\",\"296275492689629687253230924951571901074463286036093893325902826021093703105778155487944573689374985\",\"570153524737638701012356521436943401426441098546077853591240033695287015008970497887984269770806901\",\"018144030491530365065244197554768448398972540308608806925409566774524786551956371339101347903638007\",\"320757414064018388195970015916911667795686356585260842849316854545495605121901548984180626768430391\",\"865647386969402340982454930311276078675650524238282463353172206537375724594610397134098889689984034\",\"458132535927656354211309974342697008714209658281997048506616458022572487426960511867664801289428660\",\"743576883891660617188559728304052924493503598449268393257455745931624323238795401530063873713725369\",\"447186823227183242474012218124649476082905452611887245807498325123735798137176514268102521954325431\",\"469821469831079020358382846623446676677074718412059657693997583434863440511563668846215535258426286\",\"152287171977154932060564320025620593267658199695470192977405993035640651597397819853345443276452513\",\"930760555099747691297123252518917908670269682837909179121777613791076673940455561861132873334937930\",\"158094589143977491572634100215310123527998286045484966537879336607507529560412002332794123114015889\",\"568693357063661219434104672770671040731875552185056903515757240290347383038145523976075173170271115\",\"605621336592563075081627776637470432763319581849819581406905418208009921334084728232209605982160763\",\"300380119413985800511393911081827187670695791329774968716039543369937275843783167064635782917249221\",\"379935267427145816865134620389071529726915966511116666851669970350163863347087101150756124809032944\",\"734711031036927980910328008707561730401991803686575521432784101155608215019909562632251344113629065\",\"708823746039875010180998550095490301873293542129462628746600747198016422463632167847533174315621943\",\"577987309542945186680042895713604021786207075733628798324063372932739180101764941356791324584085896\",\"740432450031841943802388186958803530125546478887058896429736626922661620007420155469257773801058936\",\"746043404247830347316803890127416777540433608551132651514292457648841068570366699436932093802481652\",\"561561538176602943792859311499844598443927368655129452800483408141733300755234572693610590613764438\",\"441235736879778487499589428888493896447235657575988500837195234584526413543869197812662512326936572\",\"246070953636842628378407917359768218506144254208535970320196168469669327366068774112402815566563388\",\"505357534809823701603953577616323689105309950113890599039396709474750411145175728793579856412191711\",\"088273735041931432228291349769468733691864465696326830848859988330020690462883730392449022282505977\",\"038431724622678660448703391858936635768876980594896107588570473075836656062503388644109774757238154\",\"873531014696076852619082586824352931172053700516023246499998489582668686006423324182747570231448278\",\"318324572538898961880855610404961751441662717829135189374818750779677402085734151277540201786542381\",\"552501424088216961236270517759422454762895042106958966615740732414177734662407606199261063786670922\",\"434253047582716758582951412584377717121194380745091390163843365587018335739220113488229758911339173\",\"261051253355695475086301322207910444287740455512184306754770612802727147264208933206318165289243805\",\"647846770646497672393823469232623504133404098147325806306897626746510301303393931456345149822486730\",\"679143116306731678493393081732001767065971277944921365113209394046595717336967079905954932204170637\",\"837601974553187472456118090806860444571188607177799838591979264579282486750283953045301472191704986\",\"880365191297753842293193737675924291807086288188361160695190981628594528703891478892424295393688049\",\"289165246096324917756603031175979042999613070866902519901507658306015111159941004804579206255760613\",\"139786087712140416711931940988152372435531648838627016185839616323358407860998735649993053643561095\",\"886067642259202976374168610307683933632451389089189354501257603973818384056591733780718176554986893\",\"521856398699017142877599866210140374535014223297312943825511306533549833337266916177785476371408049\",\"671052657119010198533808622588712464988829747791965158239317659755955757677805561721936824013089059\",\"572557101140237849661717490515827033408461194808970772577866913748407650108046967191786130358698523\",\"698776888727768682971067154584575137741656382232307147813340918014541665849522409625323392216319791\",\"036736323785196553921411900553102438103793086103820627642852180561002570504462731514879040396185327\",\"532205587413710462644605931853749605238440968704933812540660629414731802128823280668962631741976739\",\"110305850089366069247653392314953698691302445906142665720026229026604330510200301284358054290223473\",\"748152201624181829533123648846570227450850464017761391556703483104727074358685958438468539696849493\",\"868432034987003254985861380141151378118188175676586278604486708850620160405265820416919951196753864\",\"826992699898982650950033498383942787160835149114533024073922640663010230411351131340347164692818835\",\"349906470351761464661616684279198183712867731594456042751839113209156719570762273204238374986716514\",\"985106374653835427575398052844898992522308238685707905781452195469162427810765178982648178797368060\",\"333669190667043401252453074927027292566526204850425683102637865989921729965020266513743997490517320\",\"831959792151468155425286055921098867830364414826369040070510486980856510750237516944370181633861344\",\"625496967207293653968798200354373811345681647179620781858876421594543828856079164815425715735274233\",\"429057759866884111724970512858403552540553367608741043708346185597779599169397299190275773810473568\",\"195261564974066434200070782833608254237418011341160171421565140306165795566983760915432468412733130\",\"374056593009684622263793259648996446174692490486522160278315481163486628633536593027819950359687635\",\"510837930783351640987114338650739016570433859668079536924959132281513367302736743693068293609873100\",\"482804653959767274057891004145775036260066300832256496499413351846981955314573362650309071338227935\",\"650199862151990196765764938065652365273100568461973563462686865940808451174372100389793953879939752\",\"966446413595085682431306430479097007407153185468841053221014056776185471416864201714356587291784233\",\"093921994030900416151464730340967117376426365392576626174356165861405955279596778099169757723401747\",\"788614484929829347616901546244893446249250139960312731863974307580633295222689191235993534716127234\",\"374825338626980518930646824170113184240121910347989030182628428835112309473584312500024930760962163\",\"600667348954413754028106718025869523678127849243975272851769208351603173210118411058273655154567992\",\"567387609796495619301107921100897252497375812439535443195951498036759941435126438473732461001148275\",\"962378383535241819045716470817127811375510183901159366850775525484970997490022241577255455670112309\",\"984380476744497336963403171421526701144582143298791501538727639663651361078543749619633741311011309\",\"510630302190216830310196134824006475082414163940421398432080752201855348888745615971039281278996171\",\"569086686030109499524226289406954884500079626798261116153400221746935470248715427832508307932959830\",\"639063654784822547115282297723148401906474549229617940382800208149447402353179986713737404641402581\",\"631464323253528092549665540247157997873307345178511581009692967400679194231370388657319888787177980\",\"685391435156143240737299370950204503776705895613385872115320965127307879084905164258753541503318403\",\"363034909186085894540261833785798215611577219174983198688911445650569807906846331183731240978134090\",\"888538765471715488211395156008860746197395992922241323530871715429499209906043389878311231371312682\",\"784603123729662494601126184553913102003334113259527749648022190913881326977030433964321898251759480\",\"592633569037544888162149814449111556023981231398755130505385556908485457515452749026520295413907709\",\"232576828754347504001194260330039751560104980137690236417175557409781175643365588047933234097447375\",\"894463822415973364379247394627650974804292706478582889301910323993934986185485724599353721657199641\",\"141084813936715872350663705073360417579460816000653234002247156882757895475134351280651043543799233\",\"780454921563678496689839052273121336937745508006132373781561556413035474777205110276577172375682738\",\"859663371893481883136932899264188262363524876442806160874455816521536918295998071642459121329137445\",\"929874710357310037473134099509869860924688512321132429857404353104290842546439336171659342187518947\"]\\n[[39,79],[45,41],[33,29],[71,6],[54,39],[70,66],[78,7],[71,86],[43,19],[38,63],[85,23],[36,23],[80,68],[65,99],[37,89],[41,64],[47,69],[80,33],[95,8],[86,2],[41,1],[85,62],[64,64],[37,69],[74,53],[44,58],[19,70],[85,63],[53,98],[86,72],[13,80],[92,90],[5,44],[91,97],[17,47],[71,25],[9,41],[10,27],[44,17],[97,13],[31,37],[19,24],[93,23],[72,7],[69,45],[35,37],[93,8],[29,84],[14,88],[26,27],[1,47],[52,28],[47,57],[82,38],[11,77],[92,55],[44,84],[51,96],[63,45],[34,9],[90,38],[75,36],[42,68],[52,42],[80,94],[84,67],[75,89],[3,99],[7,15],[51,48],[51,4],[28,49],[21,5],[97,82],[46,1],[20,51],[9,51],[43,29],[1,6],[37,12],[8,45],[63,51],[1,88],[63,82],[51,92],[84,59],[19,84],[33,24],[84,48],[57,34],[41,14],[11,84],[52,64],[76,88],[28,30],[23,98]]\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& queries) {\\n        vector<int> ans;\\n        for(auto &i : queries) {\\n            vector<string> temp = nums;\\n            \\n            for(int j = 0; j < temp.size() ; j++) {\\n                temp[j] = temp[j].substr(temp[j].size() - i[1]);\\n                \\n            }\\n            \\n            \\n            vector<pair<string, int>> vp;\\n            \\n            for(int j =0 ;j < temp.size() ; j++) {\\n                vp.push_back({temp[j] , j});\\n            }\\n            \\n            \\n            sort(vp.begin() , vp.end(), [&](const pair<string, int> &a , const pair<string,int> &b){\\n                if(a.first == b.first) return a.second < b.second;\\n                return a.first < b.first;\\n            });\\n            \\n            \\n            ans.push_back(vp[i[0] - 1].second);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2292757,
                "title": "c-priority-queue-easy-code",
                "content": "Please Upvote :)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& queries) {\\n        vector<int> res;\\n        for(auto x:queries)\\n        {\\n            priority_queue<pair<string,int>> v;\\n            for(int i=0;i<nums.size();i++)\\n            {\\n                int t=nums[i].length()-x[1];\\n                string p=nums[i].substr(t,x[1]);\\n                if(v.size()<x[0])\\n                    v.push({p,i});\\n                else\\n                {\\n                    if(v.top().first > p)\\n                    {\\n                        v.pop();\\n                        v.push({p,i});\\n                    }\\n                }\\n            }\\n            int val=v.top().second;\\n            res.push_back(val);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& queries) {\\n        vector<int> res;\\n        for(auto x:queries)\\n        {\\n            priority_queue<pair<string,int>> v;\\n            for(int i=0;i<nums.size();i++)\\n            {\\n                int t=nums[i].length()-x[1];\\n                string p=nums[i].substr(t,x[1]);\\n                if(v.size()<x[0])\\n                    v.push({p,i});\\n                else\\n                {\\n                    if(v.top().first > p)\\n                    {\\n                        v.pop();\\n                        v.push({p,i});\\n                    }\\n                }\\n            }\\n            int val=v.top().second;\\n            res.push_back(val);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2292544,
                "title": "nth-element",
                "content": "I thought there is some clever solution, where we do not need to sort for each query. However, with zeros getting in the way, I finally ruled it out.\\n\\nWe need to do exactly what the problem asks, and try to make it efficient. Here, we use Nth-element instead of full sort, and avoid creating temporary strings.\\n\\n> At first, I was trying to handle zero, but then I realized that we do not need to do that.\\n\\n**C++**\\n```cpp\\nvector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& queries) {\\n    vector<int> ids(nums.size()), res;\\n    iota(begin(ids), end(ids), 0);\\n    for(auto &q : queries) {\\n        int k = q[0], start = nums[0].size() - q[1];\\n        nth_element(begin(ids), begin(ids) + k - 1, end(ids), [&](int i, int j){\\n            int cmp = nums[i].compare(start, string::npos, nums[j], start, string::npos);\\n            return cmp == 0 ? i < j : cmp < 0;\\n        });\\n        res.push_back(ids[k - 1]);\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nvector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& queries) {\\n    vector<int> ids(nums.size()), res;\\n    iota(begin(ids), end(ids), 0);\\n    for(auto &q : queries) {\\n        int k = q[0], start = nums[0].size() - q[1];\\n        nth_element(begin(ids), begin(ids) + k - 1, end(ids), [&](int i, int j){\\n            int cmp = nums[i].compare(start, string::npos, nums[j], start, string::npos);\\n            return cmp == 0 ? i < j : cmp < 0;\\n        });\\n        res.push_back(ids[k - 1]);\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2292573,
                "title": "java-hashmap-and-sorting",
                "content": "**Code:**\\n\\n    public int[] smallestTrimmedNumbers(String[] nums, int[][] queries) {\\n        HashMap<Integer, Node[]> map = new HashMap<>();\\n        int[] res = new int[queries.length];\\n        int idx = 0, len = nums[0].length();\\n\\t\\t\\n        for(int[] query : queries){\\n            if(!map.containsKey(query[1])){\\n                Node[] arr = new Node[nums.length];\\n                for(int i=0; i<nums.length; i++){\\n                    String x = nums[i].substring(len-query[1], len);\\n                    arr[i] = new Node(i, x);\\n                }\\n\\t\\t\\t\\tArrays.sort(arr, (a, b)-> a.val.compareTo(b.val));\\n                map.put(query[1], arr);\\n            }\\n            res[idx++] = map.get(query[1])[query[0]-1].index;\\n        }\\n\\t\\t\\n        return res;\\n    }\\n\\n    class Node{ int index; String val;\\n        Node(int i, String v){ this.index = i; this.val = v; } }\\n\\t\\t\\n**Logic:**\\n\\nmake the array with trimmed values, (store both index and value using a custom object class) sort it using it\\'s \"value\" variable and then put it in a hashmap with it\\'s associated trim value. Now, say we need to find the index of 4rd smallest value from nums trimmed to the 2nd rightmost value, we get the array assosiated with the trim value of 2, find the object at (4-1)th index, and get it\\'s \"index\" variable.",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "**Code:**\\n\\n    public int[] smallestTrimmedNumbers(String[] nums, int[][] queries) {\\n        HashMap<Integer, Node[]> map = new HashMap<>();\\n        int[] res = new int[queries.length];\\n        int idx = 0, len = nums[0].length();\\n\\t\\t\\n        for(int[] query : queries){\\n            if(!map.containsKey(query[1])){\\n                Node[] arr = new Node[nums.length];\\n                for(int i=0; i<nums.length; i++){\\n                    String x = nums[i].substring(len-query[1], len);\\n                    arr[i] = new Node(i, x);\\n                }\\n\\t\\t\\t\\tArrays.sort(arr, (a, b)-> a.val.compareTo(b.val));\\n                map.put(query[1], arr);\\n            }\\n            res[idx++] = map.get(query[1])[query[0]-1].index;\\n        }\\n\\t\\t\\n        return res;\\n    }\\n\\n    class Node{ int index; String val;\\n        Node(int i, String v){ this.index = i; this.val = v; } }\\n\\t\\t\\n**Logic:**\\n\\nmake the array with trimmed values, (store both index and value using a custom object class) sort it using it\\'s \"value\" variable and then put it in a hashmap with it\\'s associated trim value. Now, say we need to find the index of 4rd smallest value from nums trimmed to the 2nd rightmost value, we get the array assosiated with the trim value of 2, find the object at (4-1)th index, and get it\\'s \"index\" variable.",
                "codeTag": "Java"
            },
            {
                "id": 2292977,
                "title": "java-python-3-sort-by-trimmed-string",
                "content": "\\n```java\\n    public int[] smallestTrimmedNumbers(String[] nums, int[][] queries) {\\n        int n = queries.length, j = 0;\\n        int[] ans = new int[n];\\n        Map<Integer, String[][]> trimmed = new HashMap<>();\\n        for (int[] q : queries) {\\n            int k = q[0] - 1;\\n            int trim = q[1];\\n            if (!trimmed.containsKey(trim)) {\\n                String[][] arr = new String[nums.length][2];\\n                int i = 0;\\n                for (String num : nums) {\\n                    int sz = num.length();\\n                    arr[i] = new String[]{num.substring(sz - trim), \"\" + i++};\\n                }\\n                Arrays.sort(arr, Comparator.comparing(a -> a[0]));\\n                trimmed.put(trim, arr);\\n            }\\n            ans[j++] = Integer.parseInt(trimmed.get(trim)[k][1]);\\n        }\\n        return ans;        \\n    }\\n```\\n\\n```python\\n    def smallestTrimmedNumbers(self, nums: List[str], queries: List[List[int]]) -> List[int]:\\n        ans, trimmed = [], {}\\n        for k, trim in queries:\\n            trimmed.setdefault(trim, sorted([(num[-trim :], i) for i, num in enumerate(nums)]))\\n            ans.append(trimmed[trim][k - 1][1])\\n        return ans\\n```",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```java\\n    public int[] smallestTrimmedNumbers(String[] nums, int[][] queries) {\\n        int n = queries.length, j = 0;\\n        int[] ans = new int[n];\\n        Map<Integer, String[][]> trimmed = new HashMap<>();\\n        for (int[] q : queries) {\\n            int k = q[0] - 1;\\n            int trim = q[1];\\n            if (!trimmed.containsKey(trim)) {\\n                String[][] arr = new String[nums.length][2];\\n                int i = 0;\\n                for (String num : nums) {\\n                    int sz = num.length();\\n                    arr[i] = new String[]{num.substring(sz - trim), \"\" + i++};\\n                }\\n                Arrays.sort(arr, Comparator.comparing(a -> a[0]));\\n                trimmed.put(trim, arr);\\n            }\\n            ans[j++] = Integer.parseInt(trimmed.get(trim)[k][1]);\\n        }\\n        return ans;        \\n    }\\n```\n```python\\n    def smallestTrimmedNumbers(self, nums: List[str], queries: List[List[int]]) -> List[int]:\\n        ans, trimmed = [], {}\\n        for k, trim in queries:\\n            trimmed.setdefault(trim, sorted([(num[-trim :], i) for i, num in enumerate(nums)]))\\n            ans.append(trimmed[trim][k - 1][1])\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2292577,
                "title": "python-o-mnlogm-sort-among-single-digit-instead-of-entire-suffix-for-each-rank",
                "content": "Intuitively, we should build a table to record the ranking of all the suffixes. `d[i]` indicates the ranking for all `number[n-i:]`. `d[i][j]` will be the answer for a query `(i,j+1)`\\n`d[0]` should be `{0,1,2,...,n}` as \"between equal number, the one with the lower index is smaller\"\\nFor `d[1]`, we only rank among the last digit of all numbers. If any two digits are equal, we derive the 2nd ranking priority from `d[0]`.\\n\\nThen you will find, for `d[i]`, we don\\'t have to actually sort among `number[n-i:]`. Instead we can first rank the `n-i`th digit for all numbers. If any two digits are equal, we use a 2nd ranking priority from `d[i-1]`.\\n\\ne.g. `A = [\"915\",\"908\",\"340\",\"307\"]`, `d[0] = [0,1,2,3]`\\nTo build `d[1]`, we rank among the last digits, which is `{5,8,0,7}`. All digits are unique so `d[1] = [2,0,3,1]`\\nTo build `d[2]`, we first rank among the 2nd last digit, which is `{1,0,4,0}`. We noticed `i1` and `i3` are same, so we need the 2nd pririoty from `d[1]`. Since `i3` stands before `i1` in `d[1]` (3 in `d[1]`**[2]** while 1 in `d[1]`**[3]**), so we rank `i3` before `i1` and `d[2] = [3,1,0,2]`. Back to actual suffix, we rank `07` before `08` as we first check their first digits which are equal, then we check their previous ranking where `7` ranks higher than `8`.\\nFinally, to build `d[3]`, first we rank among the digits `{9,9,3,3}`. Then we check the previous ranking, which is ranking among `{15,08,40,07}` which is stored in `d[2]`. And it gives us `d[3] = [3,2,1,0]`. As we first rank `(i2,i3) < (i0,i1)`. Then rank `i3 < i2` due to `i3 < i2` in `d[2]` and same for ranking `i1 < i0`.\\n\\nIn such way, we only need to sort `m` single digit number for each ranking. To build table `d`, it takes `O(mnlogm)`.\\nAnd each query takes a constant time.\\n```\\ndef smallestTrimmedNumbers(A, Q): \\n    m, n = len(A[0]), len(A)\\n    d = [list(range(n))]\\n    for i in range(m-1,-1,-1):\\n        prev_rk = {x:j for j,x in enumerate(d[-1])}\\n        d.append(sorted(range(n), key=lambda x:(A[x][i],prev_rk[x])))\\n    return [d[t][k-1] for k,t in Q]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef smallestTrimmedNumbers(A, Q): \\n    m, n = len(A[0]), len(A)\\n    d = [list(range(n))]\\n    for i in range(m-1,-1,-1):\\n        prev_rk = {x:j for j,x in enumerate(d[-1])}\\n        d.append(sorted(range(n), key=lambda x:(A[x][i],prev_rk[x])))\\n    return [d[t][k-1] for k,t in Q]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2292707,
                "title": "java-clean-simple-priority-queue",
                "content": "```\\nclass Solution {\\n    public int[] smallestTrimmedNumbers(String[] nums, int[][] queries) {\\n\\n        if (nums.length == 0)\\n            return new int[0];\\n\\n        int[] result = new int[queries.length];\\n        int strLen = nums[0].length();\\n        int[] index = new int[1];\\n\\t\\t\\n        PriorityQueue<Integer> queue = new PriorityQueue<>((a, b) -> {\\n            for (int i = index[0]; i < strLen; i++) {\\n                if (nums[a].charAt(i) != nums[b].charAt(i))\\n                    return nums[b].charAt(i) - nums[a].charAt(i);\\n            }\\n\\n            return b - a;\\n        });\\n\\n        for (int i = 0; i < queries.length; i++) {\\n            index[0] = strLen - queries[i][1];\\n            queue.clear();\\n\\n            for (int j = 0; j < nums.length; j++) {\\n                queue.add(j);\\n                if (queue.size() > queries[i][0])\\n                    queue.poll();\\n            }\\n\\n            result[i] = queue.poll();\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int[] smallestTrimmedNumbers(String[] nums, int[][] queries) {\\n\\n        if (nums.length == 0)\\n            return new int[0];\\n\\n        int[] result = new int[queries.length];\\n        int strLen = nums[0].length();\\n        int[] index = new int[1];\\n\\t\\t\\n        PriorityQueue<Integer> queue = new PriorityQueue<>((a, b) -> {\\n            for (int i = index[0]; i < strLen; i++) {\\n                if (nums[a].charAt(i) != nums[b].charAt(i))\\n                    return nums[b].charAt(i) - nums[a].charAt(i);\\n            }\\n\\n            return b - a;\\n        });\\n\\n        for (int i = 0; i < queries.length; i++) {\\n            index[0] = strLen - queries[i][1];\\n            queue.clear();\\n\\n            for (int j = 0; j < nums.length; j++) {\\n                queue.add(j);\\n                if (queue.size() > queries[i][0])\\n                    queue.poll();\\n            }\\n\\n            result[i] = queue.poll();\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2293097,
                "title": "giving-tle-just-because-i-haven-t-use-substr-function-leetcode-poor-judging-system",
                "content": "It is so frustating to see that it is giving correct ans when using substr function but TLE\\n without using  substring. wtf :) \\n\\n1st solution : TLE \\n2nd solution:Passed\\n \\n This one is giving TLE \\n```\\n\\nclass Solution\\n{\\npublic:\\n    vector<int> smallestTrimmedNumbers(vector<string> &nums, vector<vector<int>> &q)\\n    {\\n\\n        vector<pair<string, int>> v;\\n\\n        vector<int> ans;\\n\\n        for (int i = 0; i < q.size(); i++)\\n        {\\n\\n            v.clear();\\n\\n            int len = q[i][1];\\n            int idx = q[i][0];\\n            int cnt = 0;\\n\\n            for (auto i : nums)\\n            {\\n\\n                string g = \"\";\\n                int leng = i.length();\\n\\n                for (int j = leng - len; j <= leng; j++)g+=i[j];\\n                    \\n\\n                v.push_back({g, cnt++});\\n            }\\n\\n            sort(v.begin(), v.end());\\n\\n            ans.push_back(v[idx - 1].second);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\\n\\nwhen used substr function, this one is passing all test cases ;)\\n```\\n \\nclass Solution {\\npublic:\\n    \\n    \\n    vector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& q) {\\n        \\n        vector<pair<string,int >>v;\\n        \\n        vector<int >ans;\\n        \\n        \\n        for( int  i=0; i<q.size() ; i++){\\n            \\n             v.clear();\\n            \\n            int  len = q[i][1];\\n            int  idx = q[i][0];\\n            int  cnt=0;\\n            \\n            for( auto i : nums){\\n           \\n                int leng=i.length();\\n            \\n                                \\n                v.push_back({i.substr(leng-len,len),cnt++});\\n                \\n            }\\n            \\n          \\n            sort(v.begin(),v.end());\\n            \\n            ans.push_back(v[idx-1].second);\\n            \\n            \\n        }\\n        \\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\n\\nclass Solution\\n{\\npublic:\\n    vector<int> smallestTrimmedNumbers(vector<string> &nums, vector<vector<int>> &q)\\n    {\\n\\n        vector<pair<string, int>> v;\\n\\n        vector<int> ans;\\n\\n        for (int i = 0; i < q.size(); i++)\\n        {\\n\\n            v.clear();\\n\\n            int len = q[i][1];\\n            int idx = q[i][0];\\n            int cnt = 0;\\n\\n            for (auto i : nums)\\n            {\\n\\n                string g = \"\";\\n                int leng = i.length();\\n\\n                for (int j = leng - len; j <= leng; j++)g+=i[j];\\n                    \\n\\n                v.push_back({g, cnt++});\\n            }\\n\\n            sort(v.begin(), v.end());\\n\\n            ans.push_back(v[idx - 1].second);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\n```\\n \\nclass Solution {\\npublic:\\n    \\n    \\n    vector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& q) {\\n        \\n        vector<pair<string,int >>v;\\n        \\n        vector<int >ans;\\n        \\n        \\n        for( int  i=0; i<q.size() ; i++){\\n            \\n             v.clear();\\n            \\n            int  len = q[i][1];\\n            int  idx = q[i][0];\\n            int  cnt=0;\\n            \\n            for( auto i : nums){\\n           \\n                int leng=i.length();\\n            \\n                                \\n                v.push_back({i.substr(leng-len,len),cnt++});\\n                \\n            }\\n            \\n          \\n            sort(v.begin(),v.end());\\n            \\n            ans.push_back(v[idx-1].second);\\n            \\n            \\n        }\\n        \\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2292836,
                "title": "sorting-trim-length-just-once-explained",
                "content": "We need to trim the numbers to the `trim_len` rightmost number.\\n\\nSome queries have the same `trim_len` rightmost number, so we don\\'t want to do that operation twice.\\n\\nThe idea is to have a dictionary of `trim_len -> sorted numbers`\\n\\nWhenever we are asked for a query with some `trim_len` and `ith` greatest position we just return that index, because the array is sorted.\\n\\n# Code\\n```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def smallestTrimmedNumbers(self, nums: List[str], queries: List[List[int]]) -> List[int]:\\n        sl = len(nums[0])\\n        len_to_sorted = defaultdict(list)\\n        ans = [0] * len(queries)\\n        \\n        for i, (k_smallest, trim_len) in enumerate(queries):\\n            if trim_len not in len_to_sorted:\\n                # have to trim\\n                for ni, num in enumerate(nums):\\n                    len_to_sorted[trim_len].append( (int(num[sl - trim_len:]), ni) )\\n\\t\\t\\t\\t\\t\\n                len_to_sorted[trim_len] = sorted(len_to_sorted[trim_len])\\n            ans[i] = len_to_sorted[trim_len][k_smallest -1][1]\\n            \\n            \\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def smallestTrimmedNumbers(self, nums: List[str], queries: List[List[int]]) -> List[int]:\\n        sl = len(nums[0])\\n        len_to_sorted = defaultdict(list)\\n        ans = [0] * len(queries)\\n        \\n        for i, (k_smallest, trim_len) in enumerate(queries):\\n            if trim_len not in len_to_sorted:\\n                # have to trim\\n                for ni, num in enumerate(nums):\\n                    len_to_sorted[trim_len].append( (int(num[sl - trim_len:]), ni) )\\n\\t\\t\\t\\t\\t\\n                len_to_sorted[trim_len] = sorted(len_to_sorted[trim_len])\\n            ans[i] = len_to_sorted[trim_len][k_smallest -1][1]\\n            \\n            \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2292752,
                "title": "python-radix-sort-o-k-n-10-q",
                "content": "# Radix Sort\\n\\nTo sort a non-negative array, there is a technique that can sort array based on digit level, which is **RadixSort**. \\n\\nWe can start from the least significant digit, for each round, we calculate and sort the current level digits. Because the digits\\' value are between [0, 9], so we can sort it by the counting sort.\\n\\n- k: length of nums[i]\\n- d=10: digit range [0, 9]\\n- time complexity: `O(k * (n + d))`, which implies we do counting sort with complexity (n + d) for k times\\n\\nIt\\'s important to emphasize d=10. In some cases, such as suffix array, digit size may be flexible while using the doubling method.\\n\\n\\n```python\\nclass Solution:\\n    def smallestTrimmedNumbers(self, nums: List[str], queries: List[List[int]]) -> List[int]:\\n        n = len(nums)\\n        maxstep = len(nums[0])\\n\\n        lookup = []\\n        cur = [i for i in range(n)]\\n        for step in range(1, maxstep + 1):\\n            counting = [0] * 10\\n            for i in cur:\\n                digit = int(nums[i][-step])\\n                counting[digit] += 1\\n            for digit in range(1, 10):\\n                counting[digit] += counting[digit - 1]\\n\\t\\t\\t# after doing the accmulative sum, counting[digit] implies the rank of the digit\\n            \\n            nxt = [0] * n\\n            for i in cur[::-1]:\\n                digit = int(nums[i][-step])\\n                nxt[counting[digit] - 1] = i\\n                counting[digit] -= 1\\n            cur = nxt\\n            lookup.append(cur)\\n\\n        return [lookup[trim - 1][rank - 1] for rank, trim in queries]    \\n```",
                "solutionTags": [
                    "Counting Sort"
                ],
                "code": "```python\\nclass Solution:\\n    def smallestTrimmedNumbers(self, nums: List[str], queries: List[List[int]]) -> List[int]:\\n        n = len(nums)\\n        maxstep = len(nums[0])\\n\\n        lookup = []\\n        cur = [i for i in range(n)]\\n        for step in range(1, maxstep + 1):\\n            counting = [0] * 10\\n            for i in cur:\\n                digit = int(nums[i][-step])\\n                counting[digit] += 1\\n            for digit in range(1, 10):\\n                counting[digit] += counting[digit - 1]\\n\\t\\t\\t# after doing the accmulative sum, counting[digit] implies the rank of the digit\\n            \\n            nxt = [0] * n\\n            for i in cur[::-1]:\\n                digit = int(nums[i][-step])\\n                nxt[counting[digit] - 1] = i\\n                counting[digit] -= 1\\n            cur = nxt\\n            lookup.append(cur)\\n\\n        return [lookup[trim - 1][rank - 1] for rank, trim in queries]    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2292629,
                "title": "using-priorityqueue-java",
                "content": "\\n\\n    class pair{\\n    String x;\\n    int y;\\n    pair(String x1,int y1){\\n        x=x1;\\n        y=y1;\\n    }\\n}\\n    \\n\\tclass Solution {\\n    public int[] smallestTrimmedNumbers(String[] nums, int[][] queries) {\\n        int n=queries.length;\\n        PriorityQueue<pair> q=new PriorityQueue<>((a,b)->(b.x.compareTo(a.x))==0?b.y-a.y:b.x.compareTo(a.x));\\n        int ans[]=new int[n];\\n        int r1=0;\\n        for(int p[]:queries){\\n            int k=p[0];\\n            int trim=p[1];\\n            int y1=0;\\n            for(String x:nums){\\n                int u=x.length();\\n                x=x.substring(u-trim);\\n                q.add(new pair(x,y1));\\n                if(q.size()>k){\\n                    q.poll();\\n                }\\n                y1++;\\n            }\\n            ans[r1++]=q.poll().y;\\n            q.clear();\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\n    public int[] smallestTrimmedNumbers(String[] nums, int[][] queries) {\\n        int n=queries.length;\\n        PriorityQueue<pair> q=new PriorityQueue<>((a,b)->(b.x.compareTo(a.x))==0?b.y-a.y:b.x.compareTo(a.x));\\n        int ans[]=new int[n];\\n        int r1=0;\\n        for(int p[]:queries){\\n            int k=p[0];\\n            int trim=p[1];\\n            int y1=0;\\n            for(String x:nums){\\n                int u=x.length();\\n                x=x.substring(u-trim);\\n                q.add(new pair(x,y1));\\n                if(q.size()>k){\\n                    q.poll();\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2292616,
                "title": "find-substring-and-sort-c",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& queries) {\\n\\t\\t\\tvector<int>res;\\n\\t\\t\\tfor(auto q:queries){\\n\\t\\t\\t\\tint k = q[0],trim = q[1];\\n\\t\\t\\t\\tvector<pair<string,int>>tmp;\\n\\t\\t\\t\\tfor(int j = 0;j<size(nums);j++){\\n\\t\\t\\t\\t\\tint n = size(nums[j]);\\n\\t\\t\\t\\t\\tstring s = nums[j].substr(n-trim);\\n\\t\\t\\t\\t\\tif(size(s)) tmp.push_back({s,j});\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tsort(begin(tmp),end(tmp));\\n\\t\\t\\t\\tres.push_back(tmp[k-1].second);\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& queries) {\\n\\t\\t\\tvector<int>res;\\n\\t\\t\\tfor(auto q:queries){\\n\\t\\t\\t\\tint k = q[0],trim = q[1];\\n\\t\\t\\t\\tvector<pair<string,int>>tmp;\\n\\t\\t\\t\\tfor(int j = 0;j<size(nums);j++){\\n\\t\\t\\t\\t\\tint n = size(nums[j]);\\n\\t\\t\\t\\t\\tstring s = nums[j].substr(n-trim);\\n\\t\\t\\t\\t\\tif(size(s)) tmp.push_back({s,j}",
                "codeTag": "Java"
            },
            {
                "id": 3065543,
                "title": "easy-soln-adobe",
                "content": "**#ReviseWithArsh #6Companies30Days Challenge 2023\\nChallenge Company 3 : Adobe\\nQ15. Kth smallest Trimmed number**\\n\\n# Complexity\\n- Time complexity: O(nqlog(m)) where n is the number of strings in the nums array, q is the number of queries, and m is the number of substrings\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nvector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& queries) {\\nvector<int> res;\\nfor(auto query : queries)\\n{\\npriority_queue<pair<string,int>> trimmedNumbers;\\nfor(int i=0;i<nums.size();i++)\\n{\\nint start = nums[i].length() - query[1];\\nstring trimmedNum = nums[i].substr(start, query[1]);\\nif(trimmedNumbers.size() < query[0])\\ntrimmedNumbers.push({trimmedNum,i});\\nelse\\n{\\nif(trimmedNumbers.top().first > trimmedNum)\\n{\\ntrimmedNumbers.pop();\\ntrimmedNumbers.push({trimmedNum,i});\\n}\\n}\\n}\\nint index = trimmedNumbers.top().second;\\nres.push_back(index);\\n}\\nreturn res;\\n}\\n};\\n//The function takes two parameters, a vector of strings \\'nums\\' and a vector of queries. Each query is represented by a vector of two integers, where the first integer is the number of smallest trimmed numbers we need to select and the second integer is the trimming length.\\n//For each query, we create a priority queue to store the trimmed numbers in ascending order of their value.\\n//We iterate through the input vector of strings and for each string, we calculate the start index of the trimming and the trimmed number.\\n//If the size of the priority queue is less than the number of smallest trimmed numbers we need to select, we push the current trimmed number to the priority queue.\\n//Otherwise, we compare the current trimmed number with the top element of the priority queue. If it is smaller, we pop the top element and push the current trimmed number to the priority queue.\\n//After processing all the strings for a query, we get the index of the top element in the priority queue, which is the index of the smallest trimmed number and store it in the result vector.\\n//Finally, we return the result vector containing the indices of the smallest trimmed numbers for all queries. The time complexity of this solution is O(nmlog(k)), where n is the number of strings, m is the number of queries and k is the number of smallest trimmed numbers we need to select for each query.\\n\\n```\\n![upvotee.jpg](https://assets.leetcode.com/users/images/5aae47e8-f853-4445-bbf3-ecb3b13ccf52_1674019944.605877.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& queries) {\\nvector<int> res;\\nfor(auto query : queries)\\n{\\npriority_queue<pair<string,int>> trimmedNumbers;\\nfor(int i=0;i<nums.size();i++)\\n{\\nint start = nums[i].length() - query[1];\\nstring trimmedNum = nums[i].substr(start, query[1]);\\nif(trimmedNumbers.size() < query[0])\\ntrimmedNumbers.push({trimmedNum,i});\\nelse\\n{\\nif(trimmedNumbers.top().first > trimmedNum)\\n{\\ntrimmedNumbers.pop();\\ntrimmedNumbers.push({trimmedNum,i});\\n}\\n}\\n}\\nint index = trimmedNumbers.top().second;\\nres.push_back(index);\\n}\\nreturn res;\\n}\\n};\\n//The function takes two parameters, a vector of strings \\'nums\\' and a vector of queries. Each query is represented by a vector of two integers, where the first integer is the number of smallest trimmed numbers we need to select and the second integer is the trimming length.\\n//For each query, we create a priority queue to store the trimmed numbers in ascending order of their value.\\n//We iterate through the input vector of strings and for each string, we calculate the start index of the trimming and the trimmed number.\\n//If the size of the priority queue is less than the number of smallest trimmed numbers we need to select, we push the current trimmed number to the priority queue.\\n//Otherwise, we compare the current trimmed number with the top element of the priority queue. If it is smaller, we pop the top element and push the current trimmed number to the priority queue.\\n//After processing all the strings for a query, we get the index of the top element in the priority queue, which is the index of the smallest trimmed number and store it in the result vector.\\n//Finally, we return the result vector containing the indices of the smallest trimmed numbers for all queries. The time complexity of this solution is O(nmlog(k)), where n is the number of strings, m is the number of queries and k is the number of smallest trimmed numbers we need to select for each query.\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2296143,
                "title": "python-o-m-n-solution-based-on-o-m-counting-sort",
                "content": "Algorithm itself is simple to understand, using counting-based sort instead of comparison-based sort to get rid of the O(lgm) part in time complexity. \\n\\nReferenced the super concise implementation from this post: https://leetcode.com/problems/query-kth-smallest-trimmed-number/discuss/2292577/Python-O(mnlogm).-Sort-among-single-digit-instead-of-entire-suffix-for-each-rank\\n\\nP.S. This algorithm has better asymptotic time complexity than most solutions shared, while I never tried them myself, I suspect \"slower\" sorting like insertion sort might perform better at small input data in real world (e.g. <= 100 for this problem).\\n\\n```\\nclass Solution:\\n  def smallestTrimmedNumbers(self, nums: List[str], queries: List[List[int]]) -> List[int]:\\n        def countingSort(indices, pos):\\n            count = [0] * 10\\n            for idx in indices:\\n                count[ord(nums[idx][pos]) - ord(\\'0\\')] += 1\\n            start_pos = list(accumulate([0] + count, add))\\n            result = [None] * len(indices)\\n            for idx in indices:\\n                digit = ord(nums[idx][pos]) - ord(\\'0\\')\\n                result[start_pos[digit]] = idx\\n                start_pos[digit] += 1\\n            return result\\n            \\n        n = len(nums)\\n        m = len(nums[0])\\n        suffix_ordered = [list(range(n))]\\n        for i in range(m - 1, -1, -1):\\n            suffix_ordered.append(countingSort(suffix_ordered[-1], i))\\n        return [suffix_ordered[t][k-1] for k, t in queries]\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Counting Sort"
                ],
                "code": "```\\nclass Solution:\\n  def smallestTrimmedNumbers(self, nums: List[str], queries: List[List[int]]) -> List[int]:\\n        def countingSort(indices, pos):\\n            count = [0] * 10\\n            for idx in indices:\\n                count[ord(nums[idx][pos]) - ord(\\'0\\')] += 1\\n            start_pos = list(accumulate([0] + count, add))\\n            result = [None] * len(indices)\\n            for idx in indices:\\n                digit = ord(nums[idx][pos]) - ord(\\'0\\')\\n                result[start_pos[digit]] = idx\\n                start_pos[digit] += 1\\n            return result\\n            \\n        n = len(nums)\\n        m = len(nums[0])\\n        suffix_ordered = [list(range(n))]\\n        for i in range(m - 1, -1, -1):\\n            suffix_ordered.append(countingSort(suffix_ordered[-1], i))\\n        return [suffix_ordered[t][k-1] for k, t in queries]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2293464,
                "title": "c-easy-priority-queue-simple-code-greedy-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:   vector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& queries) {\\n        vector<int  > ans(queries.size());\\n        int in=0;\\n         for(auto x: queries){\\n             int sz=x[1];\\n             int k=x[0];\\n            priority_queue<pair<string ,int >> pq;\\n             for(int i=0;i<nums.size();i++){\\n                  string s=nums[i].substr(nums[i].size()-sz,sz);\\n           \\n                 if(pq.size()<k) pq.push({s,i});\\n                 else{\\n                     if(pq.top().first>s){pq.pop();pq.push({s,i});}}\\n                     }\\n          \\n                     ans[in++]=pq.top().second;\\n         }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\npublic:   vector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& queries) {\\n        vector<int  > ans(queries.size());\\n        int in=0;\\n         for(auto x: queries){\\n             int sz=x[1];\\n             int k=x[0];\\n            priority_queue<pair<string ,int >> pq;\\n             for(int i=0;i<nums.size();i++){\\n                  string s=nums[i].substr(nums[i].size()-sz,sz);\\n           \\n                 if(pq.size()<k) pq.push({s,i}",
                "codeTag": "Java"
            },
            {
                "id": 2292712,
                "title": "with-explanation-c-easy-to-understand-nth-element",
                "content": "**TC:- O(n^3)** or ```O(len(q) *len(num) *len(nums))```\\n```\\n#define p pair<string,int>\\nclass Solution {\\npublic:\\n    vector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& q) {\\n        int sz=q.size();\\n        vector<int>ans;\\n        \\n        //iterate through each query\\n        for(auto & vec:q){\\n            // k,trim are variables used in question\\n            int k=vec[0],trim=vec[1];\\n            vector<p>arr;\\n            int i=0;\\n            for(auto & num:nums){\\n                // substring that we want is from startIdx to last Idx\\n                int startIdx=num.size()-trim,lastIdx=nums.size();\\n                // to remove leading zeros\\n                while(startIdx<lastIdx && num[startIdx]==\\'0\\')\\n                    startIdx++;\\n                arr.push_back({num.substr(startIdx),i});\\n                i++;\\n            }\\n            // std::nth_element()   rearranges the list in such a way such that the element at the nth position is the one which should be at that position if we sort the list.\\n            nth_element(begin(arr),begin(arr)+k-1,end(arr),[&](auto&a,auto&b){\\n                auto& [s1,idx1]=a;auto &[s2,idx2]=b;\\n                // if two string are equal then sort according to their indexes\\n                if(s1==s2)\\n                    return idx1<idx2;\\n                // if size is equal then just compare two strings\\n                if(s1.size()==s2.size())\\n                    return s1<s2;\\n                // if size is not equal then string with smaller length is smaller number then other one\\n                else\\n                    return s1.size()<s2.size();\\n            });\\n            ans.push_back(arr[k-1].second);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```\\nDo **UPVOTE** if it helps :)",
                "solutionTags": [
                    "C"
                ],
                "code": "```O(len(q) *len(num) *len(nums))```\n```\\n#define p pair<string,int>\\nclass Solution {\\npublic:\\n    vector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& q) {\\n        int sz=q.size();\\n        vector<int>ans;\\n        \\n        //iterate through each query\\n        for(auto & vec:q){\\n            // k,trim are variables used in question\\n            int k=vec[0],trim=vec[1];\\n            vector<p>arr;\\n            int i=0;\\n            for(auto & num:nums){\\n                // substring that we want is from startIdx to last Idx\\n                int startIdx=num.size()-trim,lastIdx=nums.size();\\n                // to remove leading zeros\\n                while(startIdx<lastIdx && num[startIdx]==\\'0\\')\\n                    startIdx++;\\n                arr.push_back({num.substr(startIdx),i});\\n                i++;\\n            }\\n            // std::nth_element()   rearranges the list in such a way such that the element at the nth position is the one which should be at that position if we sort the list.\\n            nth_element(begin(arr),begin(arr)+k-1,end(arr),[&](auto&a,auto&b){\\n                auto& [s1,idx1]=a;auto &[s2,idx2]=b;\\n                // if two string are equal then sort according to their indexes\\n                if(s1==s2)\\n                    return idx1<idx2;\\n                // if size is equal then just compare two strings\\n                if(s1.size()==s2.size())\\n                    return s1<s2;\\n                // if size is not equal then string with smaller length is smaller number then other one\\n                else\\n                    return s1.size()<s2.size();\\n            });\\n            ans.push_back(arr[k-1].second);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2292662,
                "title": "c-priority-queue",
                "content": "```\\n//T:O(Q*NlogN)\\n//S:O(N)\\npublic class Solution {\\n    public int[] SmallestTrimmedNumbers(string[] nums, int[][] queries) {\\n        int[] res = new int[queries.Length];\\n        \\n        for(int i = 0; i < queries.Length; i++)\\n        {\\n            int[] q = queries[i];\\n            var pq = new PriorityQueue<int, (string, int)>();\\n            for(int j = 0; j < nums.Length; j++)\\n            {                \\n                int start = nums[j].Length-q[1];                                \\n                string c = nums[j].Substring(start);\\n                pq.Enqueue(j, (c, j));\\n            }\\n            int cnt = q[0];\\n            for(int k = 1; k < cnt; k++)\\n            {\\n                pq.Dequeue();\\n            }\\n            res[i] = pq.Peek(); \\n        }\\n        \\n        return res;\\n    }\\n}```",
                "solutionTags": [
                    "String",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n//T:O(Q*NlogN)\\n//S:O(N)\\npublic class Solution {\\n    public int[] SmallestTrimmedNumbers(string[] nums, int[][] queries) {\\n        int[] res = new int[queries.Length];\\n        \\n        for(int i = 0; i < queries.Length; i++)\\n        {\\n            int[] q = queries[i];\\n            var pq = new PriorityQueue<int, (string, int)>();\\n            for(int j = 0; j < nums.Length; j++)\\n            {                \\n                int start = nums[j].Length-q[1];                                \\n                string c = nums[j].Substring(start);\\n                pq.Enqueue(j, (c, j));\\n            }\\n            int cnt = q[0];\\n            for(int k = 1; k < cnt; k++)\\n            {\\n                pq.Dequeue();\\n            }\\n            res[i] = pq.Peek(); \\n        }\\n        \\n        return res;\\n    }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 3801265,
                "title": "python-3-quick-select-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(M)$$ for each queries in Average with M is length of nums\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N * M)$$ with M is length of nums and N is length of each string\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def smallestTrimmedNumbers(self, nums: List[str], queries: List[List[int]]) -> List[int]:\\n        def partition(l: int, r: int, p: int, trim: int) -> int:\\n            tmp_trim = trim_arr[trim]\\n            pivot = tmp_trim[p]\\n            tmp_trim[p], tmp_trim[r] = tmp_trim[r], tmp_trim[p]\\n            new_p = l\\n            for i in range(l, r):\\n                if tmp_trim[i][0] < pivot[0] or \\\\\\n                   (tmp_trim[i][0] == pivot[0] and tmp_trim[i][1] < pivot[1]):\\n                    tmp_trim[i], tmp_trim[new_p] = tmp_trim[new_p], tmp_trim[i]\\n                    new_p += 1\\n            \\n            tmp_trim[r], tmp_trim[new_p] = tmp_trim[new_p], tmp_trim[r]\\n            trim_arr[trim] = tmp_trim\\n\\n            return new_p\\n        \\n        def select(l: int, r: int, k: int, trim: int) -> int:\\n            if l == r: return l\\n            p = random.randint(l, r)\\n            p = partition(l, r, p, trim)\\n            if p < k: return select(p + 1, r, k, trim)\\n            if p > k: return select(l, p - 1, k, trim)\\n            else: return p\\n        \\n        m, n = len(nums), len(nums[0])\\n        trim_arr = [[]]\\n        for i in range(n):\\n            trim_arr.append([(int(num[n - i - 1:]), j) for j, num in enumerate(nums)])\\n        \\n        res = []\\n        for k, trim in queries:\\n            i = select(0, m - 1, k - 1, trim)\\n            res.append(trim_arr[trim][i][1])\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Divide and Conquer",
                    "Quickselect"
                ],
                "code": "```\\nclass Solution:\\n    def smallestTrimmedNumbers(self, nums: List[str], queries: List[List[int]]) -> List[int]:\\n        def partition(l: int, r: int, p: int, trim: int) -> int:\\n            tmp_trim = trim_arr[trim]\\n            pivot = tmp_trim[p]\\n            tmp_trim[p], tmp_trim[r] = tmp_trim[r], tmp_trim[p]\\n            new_p = l\\n            for i in range(l, r):\\n                if tmp_trim[i][0] < pivot[0] or \\\\\\n                   (tmp_trim[i][0] == pivot[0] and tmp_trim[i][1] < pivot[1]):\\n                    tmp_trim[i], tmp_trim[new_p] = tmp_trim[new_p], tmp_trim[i]\\n                    new_p += 1\\n            \\n            tmp_trim[r], tmp_trim[new_p] = tmp_trim[new_p], tmp_trim[r]\\n            trim_arr[trim] = tmp_trim\\n\\n            return new_p\\n        \\n        def select(l: int, r: int, k: int, trim: int) -> int:\\n            if l == r: return l\\n            p = random.randint(l, r)\\n            p = partition(l, r, p, trim)\\n            if p < k: return select(p + 1, r, k, trim)\\n            if p > k: return select(l, p - 1, k, trim)\\n            else: return p\\n        \\n        m, n = len(nums), len(nums[0])\\n        trim_arr = [[]]\\n        for i in range(n):\\n            trim_arr.append([(int(num[n - i - 1:]), j) for j, num in enumerate(nums)])\\n        \\n        res = []\\n        for k, trim in queries:\\n            i = select(0, m - 1, k - 1, trim)\\n            res.append(trim_arr[trim][i][1])\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3148871,
                "title": "c-100-fastest-radix-sort-counting-sort",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n * m)$$\\n\\n- Space complexity:\\n$$O(n * m)$$\\n\\n# Code\\n```\\nclass Solution {\\n  inline int toInt(const std::string& str, const int radix) {\\n    return str[str.size() - radix] - \\'0\\';\\n  }\\n\\n public:\\n  vector<int> smallestTrimmedNumbers(vector<string>& nums,\\n                                     vector<vector<int>>& queries) {\\n    auto m = nums.size(), n = nums[0].size();\\n    std::vector<std::vector<int>> sorted_by_radix(n + 1,\\n                                                  std::vector<int>(m, 0));\\n\\n    std::iota(sorted_by_radix[0].begin(), sorted_by_radix[0].end(), 0);\\n\\n    // radix sort \\n    std::vector<int> counts(10);\\n    for (int radix = 1; radix < n + 1; ++radix) {\\n\\n      // counting sort for specific radix\\n      std::fill(counts.begin(), counts.end(), 0);\\n      for (int i = 0; i < m; ++i) ++counts[toInt(nums[i], radix)];\\n\\n      int index = 0;\\n      for (auto& count : counts) {\\n        std::swap(count, index);\\n        index += count;\\n      }\\n\\n      for (int i = 0; i < m; ++i) {\\n        auto prev_index = sorted_by_radix[radix - 1][i];\\n        auto num = toInt(nums[prev_index], radix);\\n        sorted_by_radix[radix][counts[num]] = prev_index;\\n        ++counts[num];\\n      }\\n    }\\n\\n    std::vector<int> res(queries.size());\\n    for (int i = 0; i < queries.size(); ++i) {\\n      auto k = queries[i][0];\\n      auto radix = queries[i][1];\\n      res[i] = sorted_by_radix[radix][k - 1];\\n    }\\n    return res;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Radix Sort",
                    "Counting Sort"
                ],
                "code": "```\\nclass Solution {\\n  inline int toInt(const std::string& str, const int radix) {\\n    return str[str.size() - radix] - \\'0\\';\\n  }\\n\\n public:\\n  vector<int> smallestTrimmedNumbers(vector<string>& nums,\\n                                     vector<vector<int>>& queries) {\\n    auto m = nums.size(), n = nums[0].size();\\n    std::vector<std::vector<int>> sorted_by_radix(n + 1,\\n                                                  std::vector<int>(m, 0));\\n\\n    std::iota(sorted_by_radix[0].begin(), sorted_by_radix[0].end(), 0);\\n\\n    // radix sort \\n    std::vector<int> counts(10);\\n    for (int radix = 1; radix < n + 1; ++radix) {\\n\\n      // counting sort for specific radix\\n      std::fill(counts.begin(), counts.end(), 0);\\n      for (int i = 0; i < m; ++i) ++counts[toInt(nums[i], radix)];\\n\\n      int index = 0;\\n      for (auto& count : counts) {\\n        std::swap(count, index);\\n        index += count;\\n      }\\n\\n      for (int i = 0; i < m; ++i) {\\n        auto prev_index = sorted_by_radix[radix - 1][i];\\n        auto num = toInt(nums[prev_index], radix);\\n        sorted_by_radix[radix][counts[num]] = prev_index;\\n        ++counts[num];\\n      }\\n    }\\n\\n    std::vector<int> res(queries.size());\\n    for (int i = 0; i < queries.size(); ++i) {\\n      auto k = queries[i][0];\\n      auto radix = queries[i][1];\\n      res[i] = sorted_by_radix[radix][k - 1];\\n    }\\n    return res;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2296267,
                "title": "c-radix-sort",
                "content": "```c++\\nclass Solution {\\npublic:\\n    vector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& queries) {\\n        vector<int> indice(queries.size(), 0);\\n        iota(indice.begin(), indice.end(), 0);\\n        sort(indice.begin(), indice.end(), [&](auto& i, auto& j) {\\n            return queries[i][1] < queries[j][1];\\n        });\\n        \\n        const int N = nums.size();\\n        const int M = nums[0].size();\\n        vector<int> ret(queries.size(), 0);\\n        vector<int> tmpIndice(N);\\n        vector<int> numsIndice(N);\\n        iota(numsIndice.begin(), numsIndice.end(), 0);\\n\\n        int qi = 0;\\n        for (int i = M-1; i >= 0; --i) {\\n            vector<int> cnt(10, 0);\\n            for (int j = 0; j < N; ++j) {\\n                ++cnt[nums[numsIndice[j]][i] - \\'0\\'];\\n            }\\n            \\n            for (int j = 1; j < 10; ++j) {\\n                cnt[j] += cnt[j-1];\\n            }\\n            \\n            for (int j = N-1; j >= 0; --j) {\\n                tmpIndice[cnt[nums[numsIndice[j]][i] - \\'0\\'] - 1] = numsIndice[j];\\n                --cnt[nums[numsIndice[j]][i] - \\'0\\'];\\n            }\\n            numsIndice.swap(tmpIndice);\\n            \\n            // check queries\\n            auto trim = M - i;\\n            while (qi < indice.size() && queries[indice[qi]][1] == trim) {\\n                ret[indice[qi]] = numsIndice[queries[indice[qi]][0] - 1];\\n                ++qi;\\n            }\\n            if (qi > indice.size()) {\\n                break;\\n            }\\n        }\\n        \\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    vector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& queries) {\\n        vector<int> indice(queries.size(), 0);\\n        iota(indice.begin(), indice.end(), 0);\\n        sort(indice.begin(), indice.end(), [&](auto& i, auto& j) {\\n            return queries[i][1] < queries[j][1];\\n        });\\n        \\n        const int N = nums.size();\\n        const int M = nums[0].size();\\n        vector<int> ret(queries.size(), 0);\\n        vector<int> tmpIndice(N);\\n        vector<int> numsIndice(N);\\n        iota(numsIndice.begin(), numsIndice.end(), 0);\\n\\n        int qi = 0;\\n        for (int i = M-1; i >= 0; --i) {\\n            vector<int> cnt(10, 0);\\n            for (int j = 0; j < N; ++j) {\\n                ++cnt[nums[numsIndice[j]][i] - \\'0\\'];\\n            }\\n            \\n            for (int j = 1; j < 10; ++j) {\\n                cnt[j] += cnt[j-1];\\n            }\\n            \\n            for (int j = N-1; j >= 0; --j) {\\n                tmpIndice[cnt[nums[numsIndice[j]][i] - \\'0\\'] - 1] = numsIndice[j];\\n                --cnt[nums[numsIndice[j]][i] - \\'0\\'];\\n            }\\n            numsIndice.swap(tmpIndice);\\n            \\n            // check queries\\n            auto trim = M - i;\\n            while (qi < indice.size() && queries[indice[qi]][1] == trim) {\\n                ret[indice[qi]] = numsIndice[queries[indice[qi]][0] - 1];\\n                ++qi;\\n            }\\n            if (qi > indice.size()) {\\n                break;\\n            }\\n        }\\n        \\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2293205,
                "title": "heap-of-size-k-for-kth-smallest-number-python3-similar-to-kth-smallest-element-easy-to-understand",
                "content": "\\nPlease upvote if you liked this\\n\\n**Note** :We have stored -ve index , because if we have case like in heap , we have [[4,2],[4,3]] . We want to return 3 , but if we perfrom  heapq.heappop(). We will get result 2.\\n```\\n\\nclass Solution:\\n    def smallestTrimmedNumbers(self, nums: List[str], queries: List[List[int]]) -> List[int]:\\n        answer = []\\n        for x,y in queries:\\n            li = []\\n            heapq.heapify(li)\\n            for i in range(len(nums)):\\n                \\n                n1 = nums[i][len(nums[i])-y:len(nums[i])]\\n                n1 = int(n1)\\n                \\n                if len(li) < x:\\n                    heapq.heappush(li,[-1*n1,-1*i])\\n                \\n                else:\\n                    if n1<-1*li[0][0]:\\n                        heapq.heappop(li)\\n                        heapq.heappush(li,[-1*n1,-1*i])\\n               \\n            answer.append(-1*heapq.heappop(li)[1])       \\n             \\n            \\n            \\n            \\n       \\n        return answer\\n                \\n```",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n\\nclass Solution:\\n    def smallestTrimmedNumbers(self, nums: List[str], queries: List[List[int]]) -> List[int]:\\n        answer = []\\n        for x,y in queries:\\n            li = []\\n            heapq.heapify(li)\\n            for i in range(len(nums)):\\n                \\n                n1 = nums[i][len(nums[i])-y:len(nums[i])]\\n                n1 = int(n1)\\n                \\n                if len(li) < x:\\n                    heapq.heappush(li,[-1*n1,-1*i])\\n                \\n                else:\\n                    if n1<-1*li[0][0]:\\n                        heapq.heappop(li)\\n                        heapq.heappush(li,[-1*n1,-1*i])\\n               \\n            answer.append(-1*heapq.heappop(li)[1])       \\n             \\n            \\n            \\n            \\n       \\n        return answer\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2293064,
                "title": "c-9-lines-without-custom-comparator-func-priority-queue",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    vector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& queries) {\\n        vector <int> res;\\n        for (auto q : queries) {\\n            priority_queue <pair <string, int>, vector <pair<string, int>>, greater<pair<string, int>>> pq;\\n            int k = q[0], trim = q[1];\\n            for (int i = 0; i < nums.size(); i++) pq.push({nums[i].substr(nums[i].size()-trim), i});\\n            for (int i = 1; i < k; i++) pq.pop();\\n            res.push_back(pq.top().second);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& queries) {\\n        vector <int> res;\\n        for (auto q : queries) {\\n            priority_queue <pair <string, int>, vector <pair<string, int>>, greater<pair<string, int>>> pq;\\n            int k = q[0], trim = q[1];\\n            for (int i = 0; i < nums.size(); i++) pq.push({nums[i].substr(nums[i].size()-trim), i});\\n            for (int i = 1; i < k; i++) pq.pop();\\n            res.push_back(pq.top().second);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2292935,
                "title": "c-o-n3-tle-and-accepted-on-same-solution",
                "content": "TLE-soln  https://leetcode.com/submissions/detail/749087972/\\nAccepted-soln https://leetcode.com/submissions/detail/749088853/\\n\\nCode-\\n```\\nclass Solution {\\npublic:\\n    vector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& queries) {\\n        vector<int> ans;\\n        int size = nums[0].size();\\n        for(int i=0;i<queries.size();i++){\\n            int trim = queries[i][1];\\n            int k = queries[i][0];\\n            vector<pair<string,int>> s;\\n            for(int j=0;j<nums.size();j++){\\n                string sub = nums[j].substr(size-trim);\\n                s.push_back(make_pair(sub,j));\\n            }\\n            \\n            sort(s.begin(),s.end());\\n//             for(int j=0;j<s.size();j++){\\n//                 cout<<s[j].first<<\" \"<<s[j].second<<endl;\\n                \\n//             }\\n            // cout<<s[cnt].second<<endl;\\n            \\n            ans.push_back(s[k-1].second);\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```\\nCan someone explain why? constraints are 100 so N^3 should work right??",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& queries) {\\n        vector<int> ans;\\n        int size = nums[0].size();\\n        for(int i=0;i<queries.size();i++){\\n            int trim = queries[i][1];\\n            int k = queries[i][0];\\n            vector<pair<string,int>> s;\\n            for(int j=0;j<nums.size();j++){\\n                string sub = nums[j].substr(size-trim);\\n                s.push_back(make_pair(sub,j));\\n            }\\n            \\n            sort(s.begin(),s.end());\\n//             for(int j=0;j<s.size();j++){\\n//                 cout<<s[j].first<<\" \"<<s[j].second<<endl;\\n                \\n//             }\\n            // cout<<s[cnt].second<<endl;\\n            \\n            ans.push_back(s[k-1].second);\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2292790,
                "title": "very-simple-and-easy-to-understand-c-solution",
                "content": "<b> Up Vote if you like the solution\\n```\\nclass Solution {\\npublic:\\n    //Evaluate all the sub strings and strore with its index it in  a map with its trim value as key\\n    //sort each of the pairs in the map\\n    //answer (k-1)th element from begining\\n    vector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& queries) {\\n        map<int, vector<pair<string,int>>> mp;\\n        int n = nums[0].length();\\n        for(int i = 0; i <nums.size(); ++i) mp[n].push_back({nums[i], i});\\n        sort(mp[n].begin(), mp[n].end());\\n        for(int i = n-1; i > 0; --i ){\\n            for(int j =0; j< nums.size(); j++) mp[i].push_back({nums[j].substr(n-i, i), j});\\n            sort(mp[i].begin(), mp[i].end());\\n        }\\n        vector<int> ans;\\n        for(auto q: queries){\\n            pair<string, int> p = *(mp[q[1]].begin() + q[0] -1);\\n            ans.push_back(p.second);\\n        }\\n        return ans;\\n    }\\n};\\n``` \\n",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //Evaluate all the sub strings and strore with its index it in  a map with its trim value as key\\n    //sort each of the pairs in the map\\n    //answer (k-1)th element from begining\\n    vector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& queries) {\\n        map<int, vector<pair<string,int>>> mp;\\n        int n = nums[0].length();\\n        for(int i = 0; i <nums.size(); ++i) mp[n].push_back({nums[i], i});\\n        sort(mp[n].begin(), mp[n].end());\\n        for(int i = n-1; i > 0; --i ){\\n            for(int j =0; j< nums.size(); j++) mp[i].push_back({nums[j].substr(n-i, i), j});\\n            sort(mp[i].begin(), mp[i].end());\\n        }\\n        vector<int> ans;\\n        for(auto q: queries){\\n            pair<string, int> p = *(mp[q[1]].begin() + q[0] -1);\\n            ans.push_back(p.second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2292680,
                "title": "c-min-heap-priority-queue",
                "content": "* Maintain a min heap for each query.  \\n* Subtract all the element of the numbers and store it along with it\\'s indices. \\n* Pop up the `(i-1)th` element from the min heap and store `ith` index in result array. \\n\\n```\\nclass Solution {\\nusing item=pair<string,int>;\\npublic:\\n    vector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& queries) {\\n        vector<int>res;\\n        for(auto q:queries){\\n            priority_queue<item,vector<item>,greater<item>>pq;\\n            for(int i=0;i<nums.size();i++){\\n                int ln=nums[i].size();\\n                int p=(ln-q[1])<0?0:(ln-q[1]);\\n                pq.push({nums[i].substr(p,q[1]),i});\\n            }\\n            q[0]--;\\n            while(q[0]--) pq.pop();\\n            res.push_back(pq.top().second);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\nusing item=pair<string,int>;\\npublic:\\n    vector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& queries) {\\n        vector<int>res;\\n        for(auto q:queries){\\n            priority_queue<item,vector<item>,greater<item>>pq;\\n            for(int i=0;i<nums.size();i++){\\n                int ln=nums[i].size();\\n                int p=(ln-q[1])<0?0:(ln-q[1]);\\n                pq.push({nums[i].substr(p,q[1]),i});\\n            }\\n            q[0]--;\\n            while(q[0]--) pq.pop();\\n            res.push_back(pq.top().second);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3033921,
                "title": "easy-c-solution-using-priority-queue",
                "content": "## Complexity\\n- Time complexity: $$O(q*n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n## Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& queries) {\\n        vector<int> ans;\\n        for (auto q: queries){\\n            int trim= q[1];\\n            int k= q[0];\\n            priority_queue<pair<string,int>> pq;\\n            for (int i=0; i<nums.size(); i++){\\n                string  val= nums[i];\\n                if (trim< nums[i].size()) val= nums[i].substr(nums[i].size()-trim,trim);\\n\\n                pair<string,int> val1= {val,i};\\n                if (pq.size()<k){\\n                    pq.push(val1);\\n                }\\n                else{\\n                    if (val1 < pq.top()){\\n                        pq.pop();\\n                        pq.push(val1);\\n                    }\\n                }\\n            }\\n            ans.push_back(pq.top().second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& queries) {\\n        vector<int> ans;\\n        for (auto q: queries){\\n            int trim= q[1];\\n            int k= q[0];\\n            priority_queue<pair<string,int>> pq;\\n            for (int i=0; i<nums.size(); i++){\\n                string  val= nums[i];\\n                if (trim< nums[i].size()) val= nums[i].substr(nums[i].size()-trim,trim);\\n\\n                pair<string,int> val1= {val,i};\\n                if (pq.size()<k){\\n                    pq.push(val1);\\n                }\\n                else{\\n                    if (val1 < pq.top()){\\n                        pq.pop();\\n                        pq.push(val1);\\n                    }\\n                }\\n            }\\n            ans.push_back(pq.top().second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2424696,
                "title": "radix-sort-java",
                "content": "```\\nclass Solution {\\n    public int[] smallestTrimmedNumbers(String[] nums, int[][] queries) {\\n        int maxValLen = nums[0].length();\\n        int[] ans = new int[queries.length];\\n        int finishedTask = 0;\\n        String[] sorted = Arrays.copyOf(nums, nums.length);\\n        int digit = 1;\\n        while(digit <= maxValLen && finishedTask < queries.length) {\\n            sorted = helper(sorted, maxValLen, digit);\\n            for(int i=0; i<queries.length; i++) {\\n                if(queries[i][1] == digit) {\\n                    int idx = queries[i][0];\\n                    int j = 0;\\n                    for(String n : nums) {\\n                        if(sorted[idx-1] == n)\\n                            ans[i] = j;\\n                        j++;\\n                    }\\n                    finishedTask++;\\n                }\\n            }\\n            digit++;\\n        }\\n        return ans;\\n    }\\n    \\n    private String[] helper(String[] nums, int maxValLen, int digit) {\\n        int[] counts = new int[10];\\n        String[] sorted = new String[nums.length];\\n        \\n        for(String num : nums) {\\n            int n = Character.getNumericValue(num.charAt(maxValLen-digit));\\n            counts[n] += 1;\\n        }\\n        \\n        int startIndex = 0;\\n        for(int i = 0; i<counts.length; i++) {\\n            int c = counts[i];\\n            counts[i] = startIndex;\\n            startIndex += c;\\n        }\\n        \\n        for(String num : nums) {\\n            int n = Character.getNumericValue(num.charAt(maxValLen-digit));\\n            sorted[counts[n]] = num;\\n            counts[n] += 1;\\n        }\\n        \\n        return sorted;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] smallestTrimmedNumbers(String[] nums, int[][] queries) {\\n        int maxValLen = nums[0].length();\\n        int[] ans = new int[queries.length];\\n        int finishedTask = 0;\\n        String[] sorted = Arrays.copyOf(nums, nums.length);\\n        int digit = 1;\\n        while(digit <= maxValLen && finishedTask < queries.length) {\\n            sorted = helper(sorted, maxValLen, digit);\\n            for(int i=0; i<queries.length; i++) {\\n                if(queries[i][1] == digit) {\\n                    int idx = queries[i][0];\\n                    int j = 0;\\n                    for(String n : nums) {\\n                        if(sorted[idx-1] == n)\\n                            ans[i] = j;\\n                        j++;\\n                    }\\n                    finishedTask++;\\n                }\\n            }\\n            digit++;\\n        }\\n        return ans;\\n    }\\n    \\n    private String[] helper(String[] nums, int maxValLen, int digit) {\\n        int[] counts = new int[10];\\n        String[] sorted = new String[nums.length];\\n        \\n        for(String num : nums) {\\n            int n = Character.getNumericValue(num.charAt(maxValLen-digit));\\n            counts[n] += 1;\\n        }\\n        \\n        int startIndex = 0;\\n        for(int i = 0; i<counts.length; i++) {\\n            int c = counts[i];\\n            counts[i] = startIndex;\\n            startIndex += c;\\n        }\\n        \\n        for(String num : nums) {\\n            int n = Character.getNumericValue(num.charAt(maxValLen-digit));\\n            sorted[counts[n]] = num;\\n            counts[n] += 1;\\n        }\\n        \\n        return sorted;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2317583,
                "title": "c-with-sort-without-sort-solutions-explained",
                "content": "**Method:**\\n\\n* Actually, we just have to simply follow what the question is saying\\n* for each query obtain the trimmed substring for each nums[i] and store it\\n* and then at the end return the kth smallest trimmed substring\\n* Now, we can get \\'0\\' in front while trimming the string but we don\\'t have to worry\\n* why?\\n\\t* example:\\n\\t*  nums = [\"102\",\"473\",\"251\",\"814\"]\\n\\t*  if we have query = [1,2]\\n\\t\\t*  modified nums = [\"02\",\"73\",\"51\",\"14\"]\\n\\t\\t* after sorting: [\"02\",\"14\",\"51\",\"73\"]\\n\\t\\t*  so ans = \"02\" i.e the 1st smallest\\n\\t*  but if we have removed the leading 0 then\\n\\t\\t*  modified nums = [\"2\",\"73\",\"51\",\"14\"]\\n\\t\\t*  after sorting: \"14\" will come at first place\\n\\t\\t*  ans = \"14\" which is wrong\\n\\t*  But once you make both string equal length than leading 0 will be always less than any number at first position.\\n\\n\\n**With Sort:**\\n\\n```\\nclass Solution\\n{\\npublic:\\n    typedef pair<string, int> pi;\\n    vector<int> smallestTrimmedNumbers(vector<string> &nums, vector<vector<int>> &queries)\\n    {\\n        vector<int> ans;\\n        int n = nums.size();\\n        for (auto &q : queries)\\n        {\\n            vector<pi> v;\\n            for (int i = 0; i < n; i++)\\n            {\\n                int t = q[1];\\n                int n1 = nums[i].size();\\n                string s = nums[i].substr(n1 - t);\\n                v.push_back({s, i});\\n            }\\n            sort(v.begin(), v.end());\\n            int k = q[0];\\n            ans.push_back(v[k - 1].second);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Without Sort**\\n\\n* maintain a min-heap\\n* pop out first k-1 elements at the end and return the kth element\\n\\n```\\nclass Solution\\n{\\npublic:\\n    typedef pair<string, int> pi;\\n    vector<int> smallestTrimmedNumbers(vector<string> &nums, vector<vector<int>> &queries)\\n    {\\n        vector<int> ans;\\n        int n = nums.size();\\n        for (auto &q : queries)\\n        {\\n            priority_queue<pi, vector<pi>, greater<pi>> pq;\\n            for (int i = 0; i < n; i++)\\n            {\\n                int t = q[1];\\n                int n1 = nums[i].size();\\n                string s = nums[i].substr(n1 - t);\\n                pq.push({s, i});\\n            }\\n            int k = q[0];\\n            k--;\\n            while (k--)\\n                pq.pop();\\n            auto x = pq.top().second;\\n            ans.push_back(x);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    typedef pair<string, int> pi;\\n    vector<int> smallestTrimmedNumbers(vector<string> &nums, vector<vector<int>> &queries)\\n    {\\n        vector<int> ans;\\n        int n = nums.size();\\n        for (auto &q : queries)\\n        {\\n            vector<pi> v;\\n            for (int i = 0; i < n; i++)\\n            {\\n                int t = q[1];\\n                int n1 = nums[i].size();\\n                string s = nums[i].substr(n1 - t);\\n                v.push_back({s, i});\\n            }\\n            sort(v.begin(), v.end());\\n            int k = q[0];\\n            ans.push_back(v[k - 1].second);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution\\n{\\npublic:\\n    typedef pair<string, int> pi;\\n    vector<int> smallestTrimmedNumbers(vector<string> &nums, vector<vector<int>> &queries)\\n    {\\n        vector<int> ans;\\n        int n = nums.size();\\n        for (auto &q : queries)\\n        {\\n            priority_queue<pi, vector<pi>, greater<pi>> pq;\\n            for (int i = 0; i < n; i++)\\n            {\\n                int t = q[1];\\n                int n1 = nums[i].size();\\n                string s = nums[i].substr(n1 - t);\\n                pq.push({s, i});\\n            }\\n            int k = q[0];\\n            k--;\\n            while (k--)\\n                pq.pop();\\n            auto x = pq.top().second;\\n            ans.push_back(x);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2299137,
                "title": "solution-using-priority-queue-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& q) {\\n        vector<int> ans;\\n        int size = nums[0].size();\\n        int qsize = q.size();\\n        for(int i = 0;i<qsize;i++){\\n            int q1 = q[i][0];\\n            int q2 = q[i][1];\\n            priority_queue<pair<string,int>> pq;\\n            for(int j = 0;j<nums.size();j++){\\n                pq.push({(nums[j].substr(size - q2,q2)),j});\\n                if(pq.size() > q1)\\n                    pq.pop();\\n            }\\n            ans.push_back(pq.top().second);\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& q) {\\n        vector<int> ans;\\n        int size = nums[0].size();\\n        int qsize = q.size();\\n        for(int i = 0;i<qsize;i++){\\n            int q1 = q[i][0];\\n            int q2 = q[i][1];\\n            priority_queue<pair<string,int>> pq;\\n            for(int j = 0;j<nums.size();j++){\\n                pq.push({(nums[j].substr(size - q2,q2)),j}",
                "codeTag": "Java"
            },
            {
                "id": 2294533,
                "title": "c-o-mn-q-very-detailed-optimal-radix-sort-based-solution",
                "content": "The input size could be way larger actually. In that case, we could use radix sort based solution to avoid TLE.\\n\\n#### Input size annotations:\\n**N**: nums.length\\n**M**: nums[i].length\\n**Q**: queries.length\\n\\n*Here we go!*\\n\\n## Basic Idea\\n\\nWe could handle the queries offline, group them by `trim`, calculate the result and store them during the radix sort proceture. Specifically, after we processed the i-th rightmost digit (i starts from 1) during radix sort, we could check who is the `k` th item in the current vector, and store that as the result.\\n\\n## Brief Introduction of Radix Sort\\n\\n### Algorithm\\nAssume we have an array (padding with 0) with **N** non-negative elements and every element has at most **M** digits:\\n```\\nA = [134, 231, 512, 027, 214]\\n```\\nAnd we want to sort this array in an increasing order.\\nWe first group them by the `1st` rightmost digit, notice we need to **keep the relative order when the digit is same**.\\n\\n```\\n[\\n1: [231]\\n2: [512]\\n4: [134, 214]\\n7: [027]\\n]\\n```\\n\\nThen we re-arrange them in an increasing order of `1st` rightmost digit.\\n\\n```\\n[231, 512, 134, 214, 027]\\n```\\n\\nWe could repeat this procedure for **M** times.\\n\\n**2nd**\\n\\n```\\n[\\n1: [512, 214]\\n2: [027]\\n3: [231, 134]\\n]\\n```\\n\\n```\\n[512, 214, 027, 231, 134]\\n```\\n\\n**3rd**\\n\\n```\\n[\\n0: [027]\\n1: [134]\\n2: [214, 234]\\n5: [512]\\n]\\n```\\n\\n```\\n[027, 134, 214, 234, 512]\\n```\\n\\nAnd we get the sorting result.\\n\\n### Proof of the correctness\\n\\nLet\\'s say we have two elements **a** and **b**, whereas **0 =< a < b**. Padding them with 0 on the left so that they have the same amount of digits. We will use **x[i]** to represent the i-th digit of number **x**;\\n\\nLet\\'s go from left to right, let\\'s say **i** is the first digit whereas **a[i] != b[i]**, then **a[i] < b[i]** since **a < b**;\\n\\nAfter processing this digit during the radix sort. **a** must be on the left of **b** since **a[i] < b[i]**. This relative order won\\'t change since **a[1:i-1] == b[1:i-1]**, which means in the final output, **a** is on the left of **b**.\\n\\n*Q.E.D*\\n\\n## Implementation\\n\\nFrom the output after sorting each digit, you could find the array was actually sorted by **a[i:]**, which is the exactly what we want in the problem. But there are still some details need to be noticed in the C++ code, please check them out.\\n\\n```\\nusing psi = pair<string, int>; // used to store <num, index>\\nusing pii = pair<int, int>; // used to store query <k, i-th query>\\nvector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& queries) {\\n    int q = queries.size();\\n    vector<int> res(q); // store the final result\\n    unordered_map<int, vector<pii>> queries_trim; // group the queries by trims, key: trim, value: queries with the same trim\\n    vector<psi> nums_with_index; // put num and its index together\\n    \\n    for (int i = 0; i < nums.size(); i ++) {\\n        nums_with_index.push_back({nums[i], i});\\n    }\\n    \\n    for (int i = 0; i < q; i ++) {\\n        queries_trim[queries[i][1]].push_back({queries[i][0], i});\\n    }\\n    \\n    int num_len = nums[0].size();\\n    vector<vector<psi>> container(10); // processing radix sort: container[i] means current digit is i.\\n    for (int i = 1; i <= num_len; i ++) {\\n        // radix sort\\n        for (auto && sip: nums_with_index) {\\n            container[sip.first[num_len-i] - \\'0\\'].emplace_back(move(sip)); // move constructor to avoid copy overhead, group them by the rightmost i-th digit \\n        } \\n\\n        int idx = 0;\\n        for (int j = 0; j < 10; j ++) {\\n            for (auto && sip: container[j]) {\\n                nums_with_index[idx ++] = move(sip); // move constructor to avoid copy overhead\\n            }\\n            container[j].clear();\\n        }\\n        for (auto && [k, qth]: queries_trim[i]) {\\n            res[qth] = nums_with_index[k-1].second; // put the result in its place\\n        }\\n        \\n    }\\n    return res;  \\n}\\n```\\n\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nA = [134, 231, 512, 027, 214]\\n```\n```\\n[\\n1: [231]\\n2: [512]\\n4: [134, 214]\\n7: [027]\\n]\\n```\n```\\n[231, 512, 134, 214, 027]\\n```\n```\\n[\\n1: [512, 214]\\n2: [027]\\n3: [231, 134]\\n]\\n```\n```\\n[512, 214, 027, 231, 134]\\n```\n```\\n[\\n0: [027]\\n1: [134]\\n2: [214, 234]\\n5: [512]\\n]\\n```\n```\\n[027, 134, 214, 234, 512]\\n```\n```\\nusing psi = pair<string, int>; // used to store <num, index>\\nusing pii = pair<int, int>; // used to store query <k, i-th query>\\nvector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& queries) {\\n    int q = queries.size();\\n    vector<int> res(q); // store the final result\\n    unordered_map<int, vector<pii>> queries_trim; // group the queries by trims, key: trim, value: queries with the same trim\\n    vector<psi> nums_with_index; // put num and its index together\\n    \\n    for (int i = 0; i < nums.size(); i ++) {\\n        nums_with_index.push_back({nums[i], i});\\n    }\\n    \\n    for (int i = 0; i < q; i ++) {\\n        queries_trim[queries[i][1]].push_back({queries[i][0], i});\\n    }\\n    \\n    int num_len = nums[0].size();\\n    vector<vector<psi>> container(10); // processing radix sort: container[i] means current digit is i.\\n    for (int i = 1; i <= num_len; i ++) {\\n        // radix sort\\n        for (auto && sip: nums_with_index) {\\n            container[sip.first[num_len-i] - \\'0\\'].emplace_back(move(sip)); // move constructor to avoid copy overhead, group them by the rightmost i-th digit \\n        } \\n\\n        int idx = 0;\\n        for (int j = 0; j < 10; j ++) {\\n            for (auto && sip: container[j]) {\\n                nums_with_index[idx ++] = move(sip); // move constructor to avoid copy overhead\\n            }\\n            container[j].clear();\\n        }\\n        for (auto && [k, qth]: queries_trim[i]) {\\n            res[qth] = nums_with_index[k-1].second; // put the result in its place\\n        }\\n        \\n    }\\n    return res;  \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2293236,
                "title": "tle-ac-tle-ac-and-the-unknown-story",
                "content": "During contest this solution gave TLE , I went on to try for optmization.\\nAfter failed efforts I gave one more try and this time it got accepted.\\n\\nThis has not happened for the first time , I had similar experience with https://leetcode.com/problems/lru-cache/discuss/2256808/cpp-code-giving-sometimes-tle-and-sometimes-accepted\\n\\nLeetcode should reconsider solutions and put it either on accepted or TLE.\\nDancing from TLE to AC and AC to TLE is not a good gesture from Leetcode.\\n\\nThis is the code which I submitted during contest.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& queries) {\\n        \\n        // O(n^3logn)\\n            \\n        vector<int> answer;\\n        \\n        for(auto x:queries)\\n        {\\n            int k=x[0];\\n            int trim=x[1];\\n            \\n            priority_queue<pair<string,int>> pq;   // maxheap\\n            \\n            for(int i=0;i<nums.size();i++)\\n            {\\n                int size=nums[i].size();\\n                string str=nums[i].substr(size-trim);\\n                \\n                pq.push({str,i});\\n                \\n                if(pq.size()>k)\\n                {\\n                    pq.pop();\\n                }\\n            }\\n            \\n            answer.push_back((pq.top().second));\\n        }\\n        \\n        return answer;\\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/2045cff4-45da-4e03-a020-aa188433b2f2_1658033664.2720692.png)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& queries) {\\n        \\n        // O(n^3logn)\\n            \\n        vector<int> answer;\\n        \\n        for(auto x:queries)\\n        {\\n            int k=x[0];\\n            int trim=x[1];\\n            \\n            priority_queue<pair<string,int>> pq;   // maxheap\\n            \\n            for(int i=0;i<nums.size();i++)\\n            {\\n                int size=nums[i].size();\\n                string str=nums[i].substr(size-trim);\\n                \\n                pq.push({str,i});\\n                \\n                if(pq.size()>k)\\n                {\\n                    pq.pop();\\n                }\\n            }\\n            \\n            answer.push_back((pq.top().second));\\n        }\\n        \\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2293175,
                "title": "keep-it-simple-easy-to-understand",
                "content": "class Solution {\\n    \\n    class Node {\\n        int ind;\\n        String s;\\n        Node(String s, int i) {\\n            this.s = s;\\n            this.ind = i;\\n        }\\n    }\\n    public int[] smallestTrimmedNumbers(String[] nums, int[][] q) {\\n        int res[] = new int[q.length];\\n        int itr = 0;\\n        int n = nums[0].length();\\n        for(int i = 0 ;i<q.length;i++) {\\n            ArrayList<Node> al = new ArrayList<>();\\n            int temp = q[i][1];\\n            for(int j =0;j<nums.length;j++) {\\n                al.add(new Node(nums[j].substring(n - temp), j));\\n            }\\n\\t\\t\\t\\n            Collections.sort(al, new Comparator<Node>(){\\n                public int compare(Node a, Node b) {\\n                    return (a.s).compareTo(b.s);\\n                }\\n            }); \\n\\t\\t\\t\\n            res[itr++] = al.get(q[i][0]-1).ind; \\n        }\\n        return res;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "class Solution {\\n    \\n    class Node {\\n        int ind;\\n        String s;\\n        Node(String s, int i) {\\n            this.s = s;\\n            this.ind = i;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2293169,
                "title": "c-priority-queue",
                "content": "```\\n// Bigger string on the top\\n// If same string bigger index on top\\n\\nclass Solution {\\npublic:\\n    vector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& queries) {\\n        \\n        vector<int>ans;\\n        for(auto x:queries)\\n        {\\n            int k=x[0];\\n            int change=x[1];\\n            priority_queue<pair<string,int>>pq;\\n            for(int i=0;i<nums.size();i++)\\n            {\\n                string str=nums[i].substr(nums[i].size()-change);\\n                pq.push({str,i});\\n                if(pq.size()>k)pq.pop();                \\n            }\\n            ans.push_back(pq.top().second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n// Bigger string on the top\\n// If same string bigger index on top\\n\\nclass Solution {\\npublic:\\n    vector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& queries) {\\n        \\n        vector<int>ans;\\n        for(auto x:queries)\\n        {\\n            int k=x[0];\\n            int change=x[1];\\n            priority_queue<pair<string,int>>pq;\\n            for(int i=0;i<nums.size();i++)\\n            {\\n                string str=nums[i].substr(nums[i].size()-change);\\n                pq.push({str,i});\\n                if(pq.size()>k)pq.pop();                \\n            }\\n            ans.push_back(pq.top().second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2293061,
                "title": "leetcode-make-a-proper-compiler-which-defines-tle-the-same-sometimes-shows-tle-sometimes-not",
                "content": "Leetcode make a proper compiler, which defines TLE. The same code sometimes get TLE, sometimes not.\\n",
                "solutionTags": [],
                "code": "Leetcode make a proper compiler, which defines TLE. The same code sometimes get TLE, sometimes not.\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2293045,
                "title": "javascript-string-sort-2126ms",
                "content": "```\\nconst smallestTrimmedNumbers = (a, queries) => {\\n    let res = [];\\n    for (const [k, trim] of queries) {\\n        let b = a.map((s, i) => [s.slice(s.length - trim), i]); // trim the last digit process\\n        b.sort((x, y) => {\\n            if (x[0] == y[0]) return x[1] - y[1]; // number equal, lower index is considered to be smaller\\n            return x[0].localeCompare(y[0]); // sort by number increasing in string format\\n        })\\n        res.push(b[k - 1][1]);\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nconst smallestTrimmedNumbers = (a, queries) => {\\n    let res = [];\\n    for (const [k, trim] of queries) {\\n        let b = a.map((s, i) => [s.slice(s.length - trim), i]); // trim the last digit process\\n        b.sort((x, y) => {\\n            if (x[0] == y[0]) return x[1] - y[1]; // number equal, lower index is considered to be smaller\\n            return x[0].localeCompare(y[0]); // sort by number increasing in string format\\n        })\\n        res.push(b[k - 1][1]);\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2293014,
                "title": "easy-solution-using-vector-pair-and-sorting",
                "content": "Query Kth Smallest Trimmed Number\\n```\\nclass Solution {\\npublic:\\n    vector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& q) {\\n        vector<int> ans(q.size(), 0);\\n        vector<string> tmp1;\\n        for(auto i:nums)\\n        {\\n            reverse(i.begin(), i.end());\\n            tmp1.push_back(i);\\n        }\\n        for(int i=0;i<q.size();i++)\\n        {\\n            int a=q[i][0], b=q[i][1];\\n           \\n            \\n            vector<pair<string,int>> tmp(nums.size(),{\"\",0});\\n            for(int j=0;j<tmp1.size();j++)\\n            {\\n                int ind=nums.size()-1-b;\\n                auto t=tmp1[j].substr(0, b);\\n                reverse(t.begin(), t.end());\\n                   tmp[j]={t, j};\\n                // cout<<nums[j]<<\" \"<<tmp[j].first<<\" \"<<tmp[j].second<<endl;\\n            }\\n            // for(auto k:tmp)\\n            //     cout<<k.first<<\" \"<<k.second<<endl;\\n            sort(tmp.begin(),tmp.end());\\n            ans[i]=tmp[a-1].second;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& q) {\\n        vector<int> ans(q.size(), 0);\\n        vector<string> tmp1;\\n        for(auto i:nums)\\n        {\\n            reverse(i.begin(), i.end());\\n            tmp1.push_back(i);\\n        }\\n        for(int i=0;i<q.size();i++)\\n        {\\n            int a=q[i][0], b=q[i][1];\\n           \\n            \\n            vector<pair<string,int>> tmp(nums.size(),{\"\",0});\\n            for(int j=0;j<tmp1.size();j++)\\n            {\\n                int ind=nums.size()-1-b;\\n                auto t=tmp1[j].substr(0, b);\\n                reverse(t.begin(), t.end());\\n                   tmp[j]={t, j};\\n                // cout<<nums[j]<<\" \"<<tmp[j].first<<\" \"<<tmp[j].second<<endl;\\n            }\\n            // for(auto k:tmp)\\n            //     cout<<k.first<<\" \"<<k.second<<endl;\\n            sort(tmp.begin(),tmp.end());\\n            ans[i]=tmp[a-1].second;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2292921,
                "title": "tle-during-the-contest-accepted-after",
                "content": "The judge showed tle whenever i submitted during the contest but soon after the contest, it got accepted. Haven\\'t faced such an issue before. Can anyone tell, what could be the reason for that? Do they decrease the constraints after the contest?",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2292808,
                "title": "python-commented-code-insertion-customization-for-storing-index",
                "content": "```\\nclass Solution:\\n    def smallestTrimmedNumbers(self, nums: List[str], queries: List[List[int]]) -> List[int]:\\n        a=[]                        #to store answer of queries\\n        for q in queries: \\n            ia=q[0]               #kth smallest value to be returned\\n            t=q[1]                #trim index\\n            temp=[]\\n            for n in nums:\\n                temp.append(int(n[-1*t:]))                  #using slicing just take last t elements\\n                \\n            temp1=[[temp[0],0]]                             #another list that will store sorted elements along with index\\n            for i in range(1,len(temp)):\\n                key=temp[i]\\n                j=len(temp1)-1\\n                while j>=0 and key<temp1[j][0]:        #using insertion sort, insert elements to new list also store index\\n                    j-=1\\n                temp1.insert(j+1,[key,i])\\n        \\n            a.append(temp1[ia-1][1])                     #append required index element \\n            \\n        return a\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def smallestTrimmedNumbers(self, nums: List[str], queries: List[List[int]]) -> List[int]:\\n        a=[]                        #to store answer of queries\\n        for q in queries: \\n            ia=q[0]               #kth smallest value to be returned\\n            t=q[1]                #trim index\\n            temp=[]\\n            for n in nums:\\n                temp.append(int(n[-1*t:]))                  #using slicing just take last t elements\\n                \\n            temp1=[[temp[0],0]]                             #another list that will store sorted elements along with index\\n            for i in range(1,len(temp)):\\n                key=temp[i]\\n                j=len(temp1)-1\\n                while j>=0 and key<temp1[j][0]:        #using insertion sort, insert elements to new list also store index\\n                    j-=1\\n                temp1.insert(j+1,[key,i])\\n        \\n            a.append(temp1[ia-1][1])                     #append required index element \\n            \\n        return a\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2292791,
                "title": "python-trim-once-for-each-length-dictionary-and-sort",
                "content": "Trim numbers and sort **the first time** `trim` is queued, keeping their indexes.\\n\\n```\\nclass Solution:\\n    def smallestTrimmedNumbers(self, nums: List[str], queries: List[List[int]]) -> List[int]:\\n        answer = [\"\"] * len(queries)\\n        trimmedToTheLast = {}\\n        \\n        for i, (k, trim) in enumerate(queries):\\n            if trim not in trimmedToTheLast.keys():\\n                trimmedToTheLast[trim] = sorted((num[-trim:], j) for j, num in enumerate(nums))\\n            answer[i] = trimmedToTheLast[trim][k - 1][1]\\n        \\n        return answer\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def smallestTrimmedNumbers(self, nums: List[str], queries: List[List[int]]) -> List[int]:\\n        answer = [\"\"] * len(queries)\\n        trimmedToTheLast = {}\\n        \\n        for i, (k, trim) in enumerate(queries):\\n            if trim not in trimmedToTheLast.keys():\\n                trimmedToTheLast[trim] = sorted((num[-trim:], j) for j, num in enumerate(nums))\\n            answer[i] = trimmedToTheLast[trim][k - 1][1]\\n        \\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2292747,
                "title": "c-sort-hashset",
                "content": "**Method 1: Simple (Accepted)**\\n```\\n    public int[] SmallestTrimmedNumbers(string[] nums, int[][] queries)\\n    {\\n        int[] result = new int[queries.Length];\\n        int eachNumlenght = nums[0].Length;\\n        for (int i = 0; i < queries.Length; i++)\\n        {\\n            //nums Substring - nums index\\n            List<(string, int)> values = new List<(string, int)>();\\n            for (int k = 0; k < nums.Length; k++)\\n            {\\n                values.Add((nums[k].Substring(eachNumlenght - queries[i][1]), k));\\n            }\\n            values.Sort((a, b) => a.Item1 != b.Item1 ? a.Item1.CompareTo(b.Item1) : a.Item2.CompareTo(b.Item2));\\n            result[i] = values.Skip(queries[i][0] - 1).ToList()[0].Item2;\\n        }\\n        return result;\\n    }\\n```\\n\\n**Method 2: Optimized (Accepted)**\\n```\\n    public int[] SmallestTrimmedNumbers(string[] nums, int[][] queries) \\n    {\\n        int[] result = new int[queries.Length];\\n        int eachNumlenght = nums[0].Length;\\n        HashSet<int> trimedChecked = new HashSet<int>(); \\n        for (int i = 0; i < queries.Length; i++)\\n        {\\n            if (!trimedChecked.Contains(queries[i][1]))\\n            {\\n                //nums Substring - nums index\\n                List<(string, int)> values = new List<(string, int)>();\\n                for (int k = 0; k < nums.Length; k++)\\n                {\\n                    values.Add((nums[k].Substring(eachNumlenght - queries[i][1]), k));\\n                }\\n                values.Sort((a, b) => a.Item1 != b.Item1 ? a.Item1.CompareTo(b.Item1) : a.Item2.CompareTo(b.Item2));\\n                for (int j = i; j < queries.Length; j++) //Save the result for other queries with simialr Trim size\\n                {\\n                    if (queries[j][1] == queries[i][1])\\n                       result[j] = values.Skip(queries[j][0] - 1).ToList()[0].Item2;\\n                }\\n                trimedChecked.Add(queries[i][1]);\\n            }\\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\n    public int[] SmallestTrimmedNumbers(string[] nums, int[][] queries)\\n    {\\n        int[] result = new int[queries.Length];\\n        int eachNumlenght = nums[0].Length;\\n        for (int i = 0; i < queries.Length; i++)\\n        {\\n            //nums Substring - nums index\\n            List<(string, int)> values = new List<(string, int)>();\\n            for (int k = 0; k < nums.Length; k++)\\n            {\\n                values.Add((nums[k].Substring(eachNumlenght - queries[i][1]), k));\\n            }\\n            values.Sort((a, b) => a.Item1 != b.Item1 ? a.Item1.CompareTo(b.Item1) : a.Item2.CompareTo(b.Item2));\\n            result[i] = values.Skip(queries[i][0] - 1).ToList()[0].Item2;\\n        }\\n        return result;\\n    }\\n```\n```\\n    public int[] SmallestTrimmedNumbers(string[] nums, int[][] queries) \\n    {\\n        int[] result = new int[queries.Length];\\n        int eachNumlenght = nums[0].Length;\\n        HashSet<int> trimedChecked = new HashSet<int>(); \\n        for (int i = 0; i < queries.Length; i++)\\n        {\\n            if (!trimedChecked.Contains(queries[i][1]))\\n            {\\n                //nums Substring - nums index\\n                List<(string, int)> values = new List<(string, int)>();\\n                for (int k = 0; k < nums.Length; k++)\\n                {\\n                    values.Add((nums[k].Substring(eachNumlenght - queries[i][1]), k));\\n                }\\n                values.Sort((a, b) => a.Item1 != b.Item1 ? a.Item1.CompareTo(b.Item1) : a.Item2.CompareTo(b.Item2));\\n                for (int j = i; j < queries.Length; j++) //Save the result for other queries with simialr Trim size\\n                {\\n                    if (queries[j][1] == queries[i][1])\\n                       result[j] = values.Skip(queries[j][0] - 1).ToList()[0].Item2;\\n                }\\n                trimedChecked.Add(queries[i][1]);\\n            }\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2292679,
                "title": "easy-solution-c",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    vector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& queries) {\\n        int n=nums[0].size();\\n        vector<int> ans;\\n        for(int i=0;i<queries.size();i++){\\n            int k=queries[i][0];\\n            int trim=queries[i][1];\\n            vector<pair<string,int>> v;\\n            for(int j=0;j<nums.size();j++){\\n                string str=nums[j].substr(n-1-trim+1,trim);\\n                v.push_back({str,j});\\n            }\\n            sort(v.begin(),v.end());\\n            ans.push_back(v[k-1].second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    vector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& queries) {\\n        int n=nums[0].size();\\n        vector<int> ans;\\n        for(int i=0;i<queries.size();i++){\\n            int k=queries[i][0];\\n            int trim=queries[i][1];\\n            vector<pair<string,int>> v;\\n            for(int j=0;j<nums.size();j++){\\n                string str=nums[j].substr(n-1-trim+1,trim);\\n                v.push_back({str,j});\\n            }\\n            sort(v.begin(),v.end());\\n            ans.push_back(v[k-1].second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2292590,
                "title": "c-commented-easy-solution-using-max-heap-time-o-n-m-len",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestTrimmedNumbers(vector<string>& a, vector<vector<int>>& t) {\\n        \\n        \\n        vector<int> ans; // For storing final output\\n        priority_queue<pair<string,int>> q;  // For finding kth smallest string\\n        \\n        \\n        int res , len;\\n        \\n        string h;\\n        \\n        for(int i=0;i<t.size();i++)   // Traverse the query array.\\n        {\\n            len = a[0].size();    // Length is equal \\n            for(int j=0;j<a.size();j++)\\n            {\\n                \\n                h = a[j].substr(len-t[i][1],t[i][1]);  // Sub string after trim\\n                \\n                q.push({h,j});             // Pushing into Max heap (Queue)\\n                \\n                if(q.size()>t[i][0])    // If q size greater than k, pop element from the queue. To get the Kth smallest element on top of the queue.\\n                    q.pop();\\n            }\\n            \\n            res  = q.top().second;  // Kth smallest element index.\\n            \\n            while(!q.empty())   // Empty the queue.\\n                q.pop();\\n             ans.push_back(res);  // Push in output array.\\n        }\\n        \\n        return ans;\\n        \\n        \\n    }\\n};\\n\\n\\n\\n```\\n\\n**Upvote if you like it !!**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestTrimmedNumbers(vector<string>& a, vector<vector<int>>& t) {\\n        \\n        \\n        vector<int> ans; // For storing final output\\n        priority_queue<pair<string,int>> q;  // For finding kth smallest string\\n        \\n        \\n        int res , len;\\n        \\n        string h;\\n        \\n        for(int i=0;i<t.size();i++)   // Traverse the query array.\\n        {\\n            len = a[0].size();    // Length is equal \\n            for(int j=0;j<a.size();j++)\\n            {\\n                \\n                h = a[j].substr(len-t[i][1],t[i][1]);  // Sub string after trim\\n                \\n                q.push({h,j});             // Pushing into Max heap (Queue)\\n                \\n                if(q.size()>t[i][0])    // If q size greater than k, pop element from the queue. To get the Kth smallest element on top of the queue.\\n                    q.pop();\\n            }\\n            \\n            res  = q.top().second;  // Kth smallest element index.\\n            \\n            while(!q.empty())   // Empty the queue.\\n                q.pop();\\n             ans.push_back(res);  // Push in output array.\\n        }\\n        \\n        return ans;\\n        \\n        \\n    }\\n};\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3848767,
                "title": "using-min-heap-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& queries) {\\n        vector<int>ans;\\n        for(int i=0;i<queries.size();i++){\\n            int k=queries[i][0];\\n            int trim=queries[i][1];\\n            priority_queue<pair<string,int>,vector<pair<string,int>>,greater<pair<string,int>>>pq;\\n            for(int j=0;j<nums.size();j++){\\n                string temp=nums[j];\\n                string res;\\n                for(int l=temp.size()-trim;l<temp.size();l++)\\n                    res+=temp[l];\\n                pq.push({res,j});\\n            }\\n            int top;\\n            while(!pq.empty() && k-- ){\\n                top=pq.top().second;\\n                pq.pop();\\n            }\\n            ans.push_back(top);\\n            \\n            \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& queries) {\\n        vector<int>ans;\\n        for(int i=0;i<queries.size();i++){\\n            int k=queries[i][0];\\n            int trim=queries[i][1];\\n            priority_queue<pair<string,int>,vector<pair<string,int>>,greater<pair<string,int>>>pq;\\n            for(int j=0;j<nums.size();j++){\\n                string temp=nums[j];\\n                string res;\\n                for(int l=temp.size()-trim;l<temp.size();l++)\\n                    res+=temp[l];\\n                pq.push({res,j});\\n            }\\n            int top;\\n            while(!pq.empty() && k-- ){\\n                top=pq.top().second;\\n                pq.pop();\\n            }\\n            ans.push_back(top);\\n            \\n            \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3260713,
                "title": "trim-smallest-number-with-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse the `zfill` method\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIn this code, we first initialize an empty dictionary trimmed to store the trimmed numbers. For each query, we check if the key trimi is already in trimmed. If not, we create a new entry in trimmed with key trimi and value as a sorted list of tuples containing the trimmed number and its index in nums.\\n\\nWe then append the index of the k-th smallest trimmed number in nums to the ans list. We access the corresponding value in the trimmed dictionary using trimmed[trimi] and then retrieve the k-th smallest number using trimmed[trimi][k-1]. Finally, we append the index of the number (trimmed[trimi][k-1][1]) to the ans list.\\n\\n# Code\\n```\\nclass Solution:\\n    def smallestTrimmedNumbers(self, nums: List[str], queries: List[List[int]]) -> List[int]:\\n        ans, trimmed = [], {}\\n        for k, trimi in queries:\\n            if trimi not in trimmed:\\n                trimmed[trimi] = sorted([(num[-trimi:], i) for i, num in enumerate(nums)])\\n            ans.append(trimmed[trimi][k-1][1])\\n        return ans\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def smallestTrimmedNumbers(self, nums: List[str], queries: List[List[int]]) -> List[int]:\\n        ans, trimmed = [], {}\\n        for k, trimi in queries:\\n            if trimi not in trimmed:\\n                trimmed[trimi] = sorted([(num[-trimi:], i) for i, num in enumerate(nums)])\\n            ans.append(trimmed[trimi][k-1][1])\\n        return ans\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3257828,
                "title": "java-solution-with-counting-radix-sort",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[] smallestTrimmedNumbers(String[] nums, int[][] queries) {\\n        int n = nums[0].length();\\n        String[][] sortedArrays = new String[n+1][nums.length];\\n        sortedArrays[0] = nums;\\n        for (int i = 1; i <= n; i++){\\n            sortedArrays[i] = countingSort(sortedArrays[i-1], i);\\n        }\\n        int[] result = new int[queries.length];\\n        for (int i = 0; i < queries.length; i++){\\n            int subRes=0;\\n            int numOfEqualsDigits=0;\\n            for (int j = 0; j < nums.length; j++){\\n                if (nums[j].equals(sortedArrays[queries[i][1]][queries[i][0]-1])){\\n                    subRes = j;\\n                    numOfEqualsDigits++;\\n                    if (numOfEqualsDigits == queries[i][0]) break;\\n                }\\n            }\\n            result[i]=subRes;\\n        }\\n        return result;\\n    }\\n\\n    private String[] countingSort(String[] nums, int byRank){\\n        int n = nums[0].length();\\n        int[] digits = new int[10];\\n        for (String num : nums){\\n            digits[num.charAt(n-byRank) - \\'0\\']++;\\n        }\\n        for (int i = 1; i < 10; i++){\\n            digits[i] = digits[i] + digits[i - 1];\\n        }\\n        for (int i = 9; i > 0; i--){\\n            digits[i] = digits[i-1];\\n        }\\n        digits[0] = 0;\\n        String[] result = new String[nums.length];\\n        for (String num : nums){\\n            result[digits[num.charAt(n-byRank) - \\'0\\']] = num;\\n            digits[num.charAt(n-byRank) - \\'0\\']++;   \\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] smallestTrimmedNumbers(String[] nums, int[][] queries) {\\n        int n = nums[0].length();\\n        String[][] sortedArrays = new String[n+1][nums.length];\\n        sortedArrays[0] = nums;\\n        for (int i = 1; i <= n; i++){\\n            sortedArrays[i] = countingSort(sortedArrays[i-1], i);\\n        }\\n        int[] result = new int[queries.length];\\n        for (int i = 0; i < queries.length; i++){\\n            int subRes=0;\\n            int numOfEqualsDigits=0;\\n            for (int j = 0; j < nums.length; j++){\\n                if (nums[j].equals(sortedArrays[queries[i][1]][queries[i][0]-1])){\\n                    subRes = j;\\n                    numOfEqualsDigits++;\\n                    if (numOfEqualsDigits == queries[i][0]) break;\\n                }\\n            }\\n            result[i]=subRes;\\n        }\\n        return result;\\n    }\\n\\n    private String[] countingSort(String[] nums, int byRank){\\n        int n = nums[0].length();\\n        int[] digits = new int[10];\\n        for (String num : nums){\\n            digits[num.charAt(n-byRank) - \\'0\\']++;\\n        }\\n        for (int i = 1; i < 10; i++){\\n            digits[i] = digits[i] + digits[i - 1];\\n        }\\n        for (int i = 9; i > 0; i--){\\n            digits[i] = digits[i-1];\\n        }\\n        digits[0] = 0;\\n        String[] result = new String[nums.length];\\n        for (String num : nums){\\n            result[digits[num.charAt(n-byRank) - \\'0\\']] = num;\\n            digits[num.charAt(n-byRank) - \\'0\\']++;   \\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3220304,
                "title": "crisp-n-clear-o-n-javascript-memory-94-72-meaningful-vars",
                "content": "```\\nfunction radixSort(nums) {\\n\\tconst biggestLength = (function() {\\n\\t\\tlet len = 0;\\n\\t\\tfor (const { num } of nums) {\\n\\t\\t\\tif (String(num).length > len) {\\n\\t\\t\\t\\tlen = String(num).length;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn len;\\n\\t})();\\n\\tnums = nums.map((value) => {\\n\\t\\tlet currLength = String(value.num).length;\\n\\t\\tlet str = ``;\\n\\t\\tif (currLength < biggestLength) {\\n\\t\\t\\twhile (biggestLength - currLength > 0) {\\n\\t\\t\\t\\tcurrLength++;\\n\\t\\t\\t\\tstr += \\'0\\';\\n\\t\\t\\t}\\n\\t\\t\\treturn { num: `${str}${value.num}`, index: value.index };\\n\\t\\t}\\n\\t\\treturn { index: value.index, num: String(value.num) };\\n\\t});\\n\\n\\tfor (let index = biggestLength - 1; index >= 0; index--) {\\n\\t\\tconst arr = new Array(10);\\n\\t\\tfor (const { num, index: internalIndex } of nums) {\\n\\t\\t\\tconst place = num[index];\\n\\t\\t\\tif (!arr[place]) {\\n\\t\\t\\t\\tarr[place] = [];\\n\\t\\t\\t}\\n\\t\\t\\tarr[place].push({ num, index: internalIndex });\\n\\t\\t}\\n\\t\\tnums = (function() {\\n\\t\\t\\tconst newArr = [];\\n\\t\\t\\tfor (let index = 0; index < arr.length; index++) {\\n\\t\\t\\t\\tif (arr[index] && arr[index].length) {\\n\\t\\t\\t\\t\\tfor (const childIterator of arr[index]) {\\n\\t\\t\\t\\t\\t\\tnewArr.push(childIterator);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn newArr;\\n\\t\\t})();\\n\\t}\\n\\treturn nums;\\n}\\n\\nfunction smallestTrimmedNumbers(nums, queries) {\\n\\tconst output = [];\\n\\tconst len = nums[0].length;\\n\\tfor (const [ k, trim ] of queries) {\\n\\t\\tconst newArray = (function() {\\n\\t\\t\\tconst arr = [];\\n\\t\\t\\tfor (let index = 0; index < nums.length; index++) {\\n\\t\\t\\t\\tconst iterator = nums[index];\\n\\t\\t\\t\\tarr.push({ num: iterator.substring(len - trim), index });\\n\\t\\t\\t}\\n\\t\\t\\treturn arr;\\n\\t\\t})();\\n\\t\\tconst radixSorted = radixSort(newArray);\\n\\t\\tconst smallesKthNumber = radixSorted[k - 1];\\n\\n\\t\\toutput.push(smallesKthNumber.index);\\n\\t}\\n\\treturn output;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction radixSort(nums) {\\n\\tconst biggestLength = (function() {\\n\\t\\tlet len = 0;\\n\\t\\tfor (const { num } of nums) {\\n\\t\\t\\tif (String(num).length > len) {\\n\\t\\t\\t\\tlen = String(num).length;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn len;\\n\\t})();\\n\\tnums = nums.map((value) => {\\n\\t\\tlet currLength = String(value.num).length;\\n\\t\\tlet str = ``;\\n\\t\\tif (currLength < biggestLength) {\\n\\t\\t\\twhile (biggestLength - currLength > 0) {\\n\\t\\t\\t\\tcurrLength++;\\n\\t\\t\\t\\tstr += \\'0\\';\\n\\t\\t\\t}\\n\\t\\t\\treturn { num: `${str}${value.num}`, index: value.index };\\n\\t\\t}\\n\\t\\treturn { index: value.index, num: String(value.num) };\\n\\t});\\n\\n\\tfor (let index = biggestLength - 1; index >= 0; index--) {\\n\\t\\tconst arr = new Array(10);\\n\\t\\tfor (const { num, index: internalIndex } of nums) {\\n\\t\\t\\tconst place = num[index];\\n\\t\\t\\tif (!arr[place]) {\\n\\t\\t\\t\\tarr[place] = [];\\n\\t\\t\\t}\\n\\t\\t\\tarr[place].push({ num, index: internalIndex });\\n\\t\\t}\\n\\t\\tnums = (function() {\\n\\t\\t\\tconst newArr = [];\\n\\t\\t\\tfor (let index = 0; index < arr.length; index++) {\\n\\t\\t\\t\\tif (arr[index] && arr[index].length) {\\n\\t\\t\\t\\t\\tfor (const childIterator of arr[index]) {\\n\\t\\t\\t\\t\\t\\tnewArr.push(childIterator);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn newArr;\\n\\t\\t})();\\n\\t}\\n\\treturn nums;\\n}\\n\\nfunction smallestTrimmedNumbers(nums, queries) {\\n\\tconst output = [];\\n\\tconst len = nums[0].length;\\n\\tfor (const [ k, trim ] of queries) {\\n\\t\\tconst newArray = (function() {\\n\\t\\t\\tconst arr = [];\\n\\t\\t\\tfor (let index = 0; index < nums.length; index++) {\\n\\t\\t\\t\\tconst iterator = nums[index];\\n\\t\\t\\t\\tarr.push({ num: iterator.substring(len - trim), index });\\n\\t\\t\\t}\\n\\t\\t\\treturn arr;\\n\\t\\t})();\\n\\t\\tconst radixSorted = radixSort(newArray);\\n\\t\\tconst smallesKthNumber = radixSorted[k - 1];\\n\\n\\t\\toutput.push(smallesKthNumber.index);\\n\\t}\\n\\treturn output;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2837948,
                "title": "c-radix-sort-o-nm-q",
                "content": "Don\\'t think the followup was available in the contest, but here\\'s the suggested solution\\n\\nComplexity: O(m\\\\*n+q), m=number of nums, n=length of numbers, q=queries length\\nSpace: O(m\\\\*n), as we are saving order for each trim\\n```\\nclass Solution {\\npublic:\\n    vector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& queries) {\\n        int m = nums.size();\\n        int n = nums[0].size();\\n        \\n        // memorize the order for each trim\\n        vector<vector<int>> memo(n+1);\\n        \\n        // initial order\\n        vector<int> v(m);\\n        iota(v.begin(), v.end(), 0);\\n        \\n        memo[0] = v;\\n        \\n        // sort by n-t\\'s digit\\n        for (int t = 1; t <= n; ++t) {\\n            int i = n-t;\\n            vector<vector<int>> bucket(10);\\n\\n            // bucket sort\\n            for (int j = 0; j < m; ++j) {\\n                int c = nums[v[j]][i] - \\'0\\';\\n\\n                bucket[c].push_back(v[j]);\\n            }\\n            \\n            // obtain the order\\n            int cnt = 0;\\n            for (auto &row: bucket) {\\n                for (auto col: row) {\\n                    v[cnt++] = col;\\n                }\\n            }\\n            \\n            memo[t] = v;\\n        }\\n        \\n        // fill answer\\n        vector<int> res;\\n        for (auto &q: queries) {\\n            int k = q[0], t = q[1];\\n            res.push_back(memo[t][k-1]);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& queries) {\\n        int m = nums.size();\\n        int n = nums[0].size();\\n        \\n        // memorize the order for each trim\\n        vector<vector<int>> memo(n+1);\\n        \\n        // initial order\\n        vector<int> v(m);\\n        iota(v.begin(), v.end(), 0);\\n        \\n        memo[0] = v;\\n        \\n        // sort by n-t\\'s digit\\n        for (int t = 1; t <= n; ++t) {\\n            int i = n-t;\\n            vector<vector<int>> bucket(10);\\n\\n            // bucket sort\\n            for (int j = 0; j < m; ++j) {\\n                int c = nums[v[j]][i] - \\'0\\';\\n\\n                bucket[c].push_back(v[j]);\\n            }\\n            \\n            // obtain the order\\n            int cnt = 0;\\n            for (auto &row: bucket) {\\n                for (auto col: row) {\\n                    v[cnt++] = col;\\n                }\\n            }\\n            \\n            memo[t] = v;\\n        }\\n        \\n        // fill answer\\n        vector<int> res;\\n        for (auto &q: queries) {\\n            int k = q[0], t = q[1];\\n            res.push_back(memo[t][k-1]);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2829590,
                "title": "naive-solution-with-radix-sort",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can solve this problem by radix sort, for more detail about radix sort, check this https://en.wikipedia.org/wiki/Radix_sort\\nAs the problem saying, we can regard trim as radix sort at kth time, and k as index in original nums.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSince we use LSD radix sort, we start from last number (index length - 1) to first number (index 0), we need to remember the according index of each k, after we finish a sort, we can use **HashMap**.\\nSince we need to use index in original nums, we also have to remember the relation between index and each number, cause there will be multi same number, so we use **Pair** here.\\n\\n1. Memory what we mentioned above.\\n2. Radix Sort from last number to first number, if there is same trim exists in **HashMap**, then we keep it in corresponding ans.\\n\\n\\n# Complexity\\n- Time complexity: **O(M+LN)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nHere **N** as the length of nums, **M** as the length of queries, **L** as the length of each number.\\nFirst we use **M+N** to keep the info we need, then we start **L** times radix sort, in each sort we spend **(N+N)** and **M** times to put to answer.\\n\\n- Space complexity: **O(M+N)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nWe use **Map** and the array of **Pair** to keep info, which use **M** and **N** space complexity respectively.\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] smallestTrimmedNumbers(String[] nums, int[][] queries) \\n        // record index of every query\\n        // trim(queries[i][1]) -> index in queries\\n        Map<Integer, List<Integer>> record = new HashMap<>();\\n        // we need to record the index of every string for radix sort\\n        Pair<String, Integer>[] indexs = new Pair[nums.length];\\n        for(int i = 0; i < nums.length; i++) {\\n            indexs[i] = new Pair<>(nums[i], i);\\n        }\\n        for(int i = 0; i < queries.length; i++) {\\n            int trim = queries[i][1];\\n            if(!record.containsKey(trim)) {\\n                record.put(trim, new ArrayList<>());\\n            }\\n            record.get(trim).add(i);\\n        }\\n        int len = nums[0].length();\\n        int[] ans = new int[queries.length];\\n        // conduct the radix sort\\n        for(int i = 1; i <= len; i++) {\\n            radixSort(indexs, len - i);\\n            if(!record.containsKey(i)) {\\n                continue;\\n            }\\n            for(int index : record.get(i)) {\\n                int k = queries[index][0];\\n                ans[index] = indexs[k - 1].getValue();\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    void radixSort(Pair<String, Integer>[] nums, int index) {\\n        List<Pair<String, Integer>>[] radixs = new ArrayList[10];\\n        for(var num : nums) {\\n            int i = num.getKey().charAt(index) - \\'0\\';\\n            if(radixs[i] == null) {\\n                radixs[i] = new ArrayList<>();\\n            }\\n            radixs[i].add(num);\\n        }\\n        int i = 0;\\n        for(var radix : radixs) {\\n            if(radix == null) {\\n                continue;\\n            }\\n            for(var n : radix) {\\n                nums[i++] = n;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] smallestTrimmedNumbers(String[] nums, int[][] queries) \\n        // record index of every query\\n        // trim(queries[i][1]) -> index in queries\\n        Map<Integer, List<Integer>> record = new HashMap<>();\\n        // we need to record the index of every string for radix sort\\n        Pair<String, Integer>[] indexs = new Pair[nums.length];\\n        for(int i = 0; i < nums.length; i++) {\\n            indexs[i] = new Pair<>(nums[i], i);\\n        }\\n        for(int i = 0; i < queries.length; i++) {\\n            int trim = queries[i][1];\\n            if(!record.containsKey(trim)) {\\n                record.put(trim, new ArrayList<>());\\n            }\\n            record.get(trim).add(i);\\n        }\\n        int len = nums[0].length();\\n        int[] ans = new int[queries.length];\\n        // conduct the radix sort\\n        for(int i = 1; i <= len; i++) {\\n            radixSort(indexs, len - i);\\n            if(!record.containsKey(i)) {\\n                continue;\\n            }\\n            for(int index : record.get(i)) {\\n                int k = queries[index][0];\\n                ans[index] = indexs[k - 1].getValue();\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    void radixSort(Pair<String, Integer>[] nums, int index) {\\n        List<Pair<String, Integer>>[] radixs = new ArrayList[10];\\n        for(var num : nums) {\\n            int i = num.getKey().charAt(index) - \\'0\\';\\n            if(radixs[i] == null) {\\n                radixs[i] = new ArrayList<>();\\n            }\\n            radixs[i].add(num);\\n        }\\n        int i = 0;\\n        for(var radix : radixs) {\\n            if(radix == null) {\\n                continue;\\n            }\\n            for(var n : radix) {\\n                nums[i++] = n;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2607152,
                "title": "c-solution",
                "content": "```\\npublic class Solution {\\n    public int[] SmallestTrimmedNumbers(string[] nums, int[][] queries) {\\n        //Radix sort\\n        int[] result = new int[queries.Length];\\n        for (int i = 0; i < queries.Length; i++) {\\n            result[i] = RadixSort(nums, queries[i][1], queries[i][0]);\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private int RadixSort(string[] nums, int trim, int k) {\\n        string[] sorted = new string[nums.Length];\\n        nums.CopyTo(sorted, 0);\\n        \\n        int[] origIndices = new int[nums.Length];\\n        \\n        for (int i = 0; i < nums.Length; i++) {\\n            origIndices[i] = i;\\n        }\\n\\n        \\n        for (int i = 1; i <= trim; i++) {\\n            sorted = RadixSortPrivate(sorted, i, origIndices);\\n        }\\n        \\n        return origIndices[k-1];\\n    }\\n    \\n    private string[] RadixSortPrivate(string[] nums, int rightIndex, int[] origIndices) {\\n        int[] counts = new int[10];\\n        int offset = nums[0].Length - rightIndex;\\n\\n        //Create counts\\n        for (int i = 0; i < nums.Length; i++) {\\n            int val = nums[i][offset] - \\'0\\';\\n            ++counts[val];\\n        }\\n        \\n        //Update counts with starting indices\\n        int startingIndex = 0;\\n        for (int i = 0; i < 10; i++) {\\n            int thisCount = counts[i];\\n            counts[i] = startingIndex;\\n            startingIndex += thisCount;\\n        }\\n        \\n        //Use started indices to create sorted array\\n        string[] sortedArray = new string[nums.Length];\\n        int[] sortedIndices = new int[nums.Length];\\n        for (int i = 0; i < nums.Length; i++) {\\n            int val = nums[i][offset] - \\'0\\';\\n            sortedArray[counts[val]] = nums[i];\\n            sortedIndices[counts[val]] = origIndices[i];\\n            ++counts[val];\\n        }\\n\\n        for (int i = 0; i < nums.Length; i++) {\\n            origIndices[i] = sortedIndices[i];\\n        }\\n\\n        return sortedArray;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int[] SmallestTrimmedNumbers(string[] nums, int[][] queries) {\\n        //Radix sort\\n        int[] result = new int[queries.Length];\\n        for (int i = 0; i < queries.Length; i++) {\\n            result[i] = RadixSort(nums, queries[i][1], queries[i][0]);\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private int RadixSort(string[] nums, int trim, int k) {\\n        string[] sorted = new string[nums.Length];\\n        nums.CopyTo(sorted, 0);\\n        \\n        int[] origIndices = new int[nums.Length];\\n        \\n        for (int i = 0; i < nums.Length; i++) {\\n            origIndices[i] = i;\\n        }\\n\\n        \\n        for (int i = 1; i <= trim; i++) {\\n            sorted = RadixSortPrivate(sorted, i, origIndices);\\n        }\\n        \\n        return origIndices[k-1];\\n    }\\n    \\n    private string[] RadixSortPrivate(string[] nums, int rightIndex, int[] origIndices) {\\n        int[] counts = new int[10];\\n        int offset = nums[0].Length - rightIndex;\\n\\n        //Create counts\\n        for (int i = 0; i < nums.Length; i++) {\\n            int val = nums[i][offset] - \\'0\\';\\n            ++counts[val];\\n        }\\n        \\n        //Update counts with starting indices\\n        int startingIndex = 0;\\n        for (int i = 0; i < 10; i++) {\\n            int thisCount = counts[i];\\n            counts[i] = startingIndex;\\n            startingIndex += thisCount;\\n        }\\n        \\n        //Use started indices to create sorted array\\n        string[] sortedArray = new string[nums.Length];\\n        int[] sortedIndices = new int[nums.Length];\\n        for (int i = 0; i < nums.Length; i++) {\\n            int val = nums[i][offset] - \\'0\\';\\n            sortedArray[counts[val]] = nums[i];\\n            sortedIndices[counts[val]] = origIndices[i];\\n            ++counts[val];\\n        }\\n\\n        for (int i = 0; i < nums.Length; i++) {\\n            origIndices[i] = sortedIndices[i];\\n        }\\n\\n        return sortedArray;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2587035,
                "title": "c-90-faster-than-all-easy-to-undersatnd",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& queries) {\\n        // Create data to record only results that we need, during radix sort\\n        //data[trimming level][order after trimming & sorting (k)] = what we should record\\n        unordered_map<int, unordered_map<int, int>> data;\\n        int tmax = -1; // most significant digit that we need to sort by\\n        for (auto& q : queries) {\\n            data[q[1]][q[0]] = 0;\\n            tmax = max(tmax, q[1]);\\n        }\\n        \\n        vector<int> inds(nums.size());     // indices of numbers in nums after each sorting step\\n        iota(inds.begin(), inds.end(), 0); // indices are initially 0, 1, 2, ...\\n        const int len = nums[0].length();\\n        for (int t=1; t<=tmax; t++) {\\n            // we are going to put indices of numbers in nums in the buckets\\n            // depending on their t-th digit\\n            vector<vector<int>> buckets(10);\\n            \\n            // Put indices in buckests\\n            // indice \"i\" goes into bucket b where b is the t-th digit of nums[i], i.e. nums[i][len - t]-\\'0\\']\\n            for (auto& i : inds) {\\n                buckets[nums[i][len - t]-\\'0\\'].push_back(i);\\n            }\\n            \\n            // Reorder vector of indices by getting them out of buckets in order\\n            int cnt = 0;\\n            for (auto& b : buckets) {\\n                for (auto& i : b) {\\n                    inds[cnt++] = i;\\n                }\\n            }\\n            \\n            // Now numbers are sorted by t-th digit\\n            // Record results for this trimming level\\n            if (data.find(t) != data.end()) {\\n                for (auto& q : data[t]) {\\n                    q.second = inds[q.first-1];\\n                }\\n            }\\n        }\\n        \\n        // Convert recorded data to requested format\\n        vector<int> out(queries.size());\\n        for (int i=0; i<queries.size(); i++) {\\n            out[i] = data[queries[i][1]][queries[i][0]];\\n        }\\n        \\n        return out;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& queries) {\\n        // Create data to record only results that we need, during radix sort\\n        //data[trimming level][order after trimming & sorting (k)] = what we should record\\n        unordered_map<int, unordered_map<int, int>> data;\\n        int tmax = -1; // most significant digit that we need to sort by\\n        for (auto& q : queries) {\\n            data[q[1]][q[0]] = 0;\\n            tmax = max(tmax, q[1]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2539980,
                "title": "c-beats-98-time-92-memory-radix-sort",
                "content": "We can run a radix sort on nums:\\n 1- we divide nums into buckets based on their first digit in a stable way; i.e. if a and b have the same first digit m, and a comes before b in vector nums, a comes before b in the bucket corresponding to m.\\n 2- We iterate over buckets in order and collect numbers in them (in order).\\n 3- At this stage, numbers are sorted by first digit, so if we have any query with trim=1, we can easily find the result corresponding to that query.\\n 4- No we repeat the process using the second digit (instead of the first).\\n 5- We repeat until we have covered the largest requested digit in queries.\\n \\n Time complexity O(n * t). n: nums.size(), t: max reuested trimming\\n Each sorting takes O(n), we repeat it t times to process up-to t digits. We aldo need O(queries.size()) to process the queries, but assuming k<<n, we can ignore that.\\n \\n Space complexity: O(n) to store values in buckest. Each value is stored once only.\\n \\nPlease see the comments in the code:\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& queries) {\\n        // Create data to record only results that we need, during radix sort\\n        //data[trimming level][order after trimming & sorting (k)] = what we should record\\n        unordered_map<int, unordered_map<int, int>> data;\\n        int tmax = -1; // most significant digit that we need to sort by\\n        for (auto& q : queries) {\\n            data[q[1]][q[0]] = 0;\\n            tmax = max(tmax, q[1]);\\n        }\\n        \\n        vector<int> inds(nums.size());     // indices of numbers in nums after each sorting step\\n        iota(inds.begin(), inds.end(), 0); // indices are initially 0, 1, 2, ...\\n        const int len = nums[0].length();\\n        for (int t=1; t<=tmax; t++) {\\n            // we are going to put indices of numbers in nums in the buckets\\n            // depending on their t-th digit\\n            vector<vector<int>> buckets(10);\\n            \\n            // Put indices in buckests\\n            // indice \"i\" goes into bucket b where b is the t-th digit of nums[i], i.e. nums[i][len - t]-\\'0\\']\\n            for (auto& i : inds) {\\n                buckets[nums[i][len - t]-\\'0\\'].push_back(i);\\n            }\\n            \\n            // Reorder vector of indices by getting them out of buckets in order\\n            int cnt = 0;\\n            for (auto& b : buckets) {\\n                for (auto& i : b) {\\n                    inds[cnt++] = i;\\n                }\\n            }\\n            \\n            // Now numbers are sorted by t-th digit\\n            // Record results for this trimming level\\n            if (data.find(t) != data.end()) {\\n                for (auto& q : data[t]) {\\n                    q.second = inds[q.first-1];\\n                }\\n            }\\n        }\\n        \\n        // Convert recorded data to requested format\\n        vector<int> out(queries.size());\\n        for (int i=0; i<queries.size(); i++) {\\n            out[i] = data[queries[i][1]][queries[i][0]];\\n        }\\n        \\n        return out;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& queries) {\\n        // Create data to record only results that we need, during radix sort\\n        //data[trimming level][order after trimming & sorting (k)] = what we should record\\n        unordered_map<int, unordered_map<int, int>> data;\\n        int tmax = -1; // most significant digit that we need to sort by\\n        for (auto& q : queries) {\\n            data[q[1]][q[0]] = 0;\\n            tmax = max(tmax, q[1]);\\n        }\\n        \\n        vector<int> inds(nums.size());     // indices of numbers in nums after each sorting step\\n        iota(inds.begin(), inds.end(), 0); // indices are initially 0, 1, 2, ...\\n        const int len = nums[0].length();\\n        for (int t=1; t<=tmax; t++) {\\n            // we are going to put indices of numbers in nums in the buckets\\n            // depending on their t-th digit\\n            vector<vector<int>> buckets(10);\\n            \\n            // Put indices in buckests\\n            // indice \"i\" goes into bucket b where b is the t-th digit of nums[i], i.e. nums[i][len - t]-\\'0\\']\\n            for (auto& i : inds) {\\n                buckets[nums[i][len - t]-\\'0\\'].push_back(i);\\n            }\\n            \\n            // Reorder vector of indices by getting them out of buckets in order\\n            int cnt = 0;\\n            for (auto& b : buckets) {\\n                for (auto& i : b) {\\n                    inds[cnt++] = i;\\n                }\\n            }\\n            \\n            // Now numbers are sorted by t-th digit\\n            // Record results for this trimming level\\n            if (data.find(t) != data.end()) {\\n                for (auto& q : data[t]) {\\n                    q.second = inds[q.first-1];\\n                }\\n            }\\n        }\\n        \\n        // Convert recorded data to requested format\\n        vector<int> out(queries.size());\\n        for (int i=0; i<queries.size(); i++) {\\n            out[i] = data[queries[i][1]][queries[i][0]];\\n        }\\n        \\n        return out;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2444183,
                "title": "this-kind-of-problem-is-the-most-meaningless-question-on-leetcode",
                "content": "This is the first comment I left on LeetCode, I just want to say this kind of question is totally meaningless and just wasting my time:\\n1. NO ONE will ask you this in inview, because:\\n\\t2. It takes 15 mins to explain the problem\\n\\t3. It cannot help judge the interviewee\\'s coding skill, because\\n\\t\\t4. Simply brutal force solution works well\\n5. I spent 15 mins just to read and understand this problem, then figure out:\\n\\t6. You won\\'t face simply problem in real world at all, or\\n\\t7. You can just use brutal force to resolve it, so it cannot help me to improve my coding skill at all",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2372118,
                "title": "priority-queue-easy-and-clear-python",
                "content": "Just do what the question says.\\nMost of us are stuck in leading zeros. The hack is to convert elements into an integer and add them into the max heap (of size k). The answer will be at the top of the heap.\\n\\n```\\nclass Solution:\\n    def smallestTrimmedNumbers(self, arr: List[str], queries: List[List[int]]) -> List[int]:\\n        ans = []\\n        for k, trim in queries:\\n\\n            heap = []\\n            for i,ele in enumerate(arr):\\n                heapq.heappush(heap, (-int(ele[-trim:]), -i))\\n\\n                if len(heap) > k:\\n                    heapq.heappop(heap)\\n\\n            ans.append(heapq.heappop(heap)[1]*-1)\\n\\n        return ans\\n\\n\\n```\\nPlease upvote if you find this helpful :)\\n",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def smallestTrimmedNumbers(self, arr: List[str], queries: List[List[int]]) -> List[int]:\\n        ans = []\\n        for k, trim in queries:\\n\\n            heap = []\\n            for i,ele in enumerate(arr):\\n                heapq.heappush(heap, (-int(ele[-trim:]), -i))\\n\\n                if len(heap) > k:\\n                    heapq.heappop(heap)\\n\\n            ans.append(heapq.heappop(heap)[1]*-1)\\n\\n        return ans\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2345988,
                "title": "java-radix-sort",
                "content": "# Radix Sort\\n\\n**[\"102\",\"473\",\"251\",\"814\"]**\\n**Trim 0** [0, 1, 2, 3] -> 102, 473, 251, 814, input of trim1\\n**Trim 1** [2, 0, 1, 4] -> 25**1**, 10**2**, 47**3**, 81**4**, input of trim 2\\n**Trim 2** [0, 3, 2, 1] -> 1**02**, 8**14**, 2**51**, 4**73**, input of trim 3\\n**Trim 3** [0, 2, 1, 4] -> **102**, **473**, **251**, **814**\\n\\n**[\"9415\",\"5908\",\"1840\",\"5307\"]**\\n**Trim 0** [0, 1, 2, 3] -> 9415, 5908, 1840, 5307, input of trim1\\n**Trim 1** [2, 0, 3, 1] -> 184**0**, 941**5**, 530**7**, 590**8**, input of trim 2\\n**Trim 2** [3, 1, 0, 2] -> 53**07**, 59**08**, 94**15**, 18**40**, input of trim 3\\n**Trim 3** [3, 0, 2, 1] -> 5**307**, 9**415**, 1**840**, 5**908**, input of trim 4\\n**Trim 4** [3, 0, 2, 1] -> **1840**, **5307**, **5908**, **9415**\\n\\n```\\nclass Solution {\\n    public int[] smallestTrimmedNumbers(String[] nums, int[][] queries) {\\n        int d = nums[0].length();\\n        int n = nums.length;\\n        char[][] chars = new char[n][d];\\n        for (int i = 0; i < n; i++) chars[i] = nums[i].toCharArray();\\n        List<Integer>[] radix = new List[10];\\n        int[][] sort = new int[d+1][n];\\n        for (int i = 0; i < n; i++) sort[0][i] = i;\\n        \\n        for (int i = 1; i <= d; i++) {\\n            int c = d-i;\\n            Arrays.fill(radix, null);\\n            for (int j = 0; j < n; j++) {\\n                int idx = sort[i-1][j];\\n                int key = chars[idx][c]-\\'0\\';\\n                if (radix[key] == null) radix[key] = new ArrayList<>();\\n                radix[key].add(idx);\\n            }\\n            int o = 0;\\n            for (int j = 0; j < 10; j++) if (radix[j] != null) for (int k = 0; k < radix[j].size(); k++) sort[i][o++] = radix[j].get(k);\\n        }\\n        \\n        int[] result = new int[queries.length];\\n        for (int i = 0; i < queries.length; i++) result[i] = sort[queries[i][1]][queries[i][0]-1];\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] smallestTrimmedNumbers(String[] nums, int[][] queries) {\\n        int d = nums[0].length();\\n        int n = nums.length;\\n        char[][] chars = new char[n][d];\\n        for (int i = 0; i < n; i++) chars[i] = nums[i].toCharArray();\\n        List<Integer>[] radix = new List[10];\\n        int[][] sort = new int[d+1][n];\\n        for (int i = 0; i < n; i++) sort[0][i] = i;\\n        \\n        for (int i = 1; i <= d; i++) {\\n            int c = d-i;\\n            Arrays.fill(radix, null);\\n            for (int j = 0; j < n; j++) {\\n                int idx = sort[i-1][j];\\n                int key = chars[idx][c]-\\'0\\';\\n                if (radix[key] == null) radix[key] = new ArrayList<>();\\n                radix[key].add(idx);\\n            }\\n            int o = 0;\\n            for (int j = 0; j < 10; j++) if (radix[j] != null) for (int k = 0; k < radix[j].size(); k++) sort[i][o++] = radix[j].get(k);\\n        }\\n        \\n        int[] result = new int[queries.length];\\n        for (int i = 0; i < queries.length; i++) result[i] = sort[queries[i][1]][queries[i][0]-1];\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2339310,
                "title": "java-basic-appraoch-o-n-m-log-n-time-o-n-time",
                "content": "class Solution {\\n    \\n    class pair{             // creating custome class..\\n        \\n        int index;\\n        String num;\\n        \\n        public pair(int index,String num){\\n            this.index=index;\\n            this.num=num;\\n        }\\n    }\\n    \\n    public int[] smallestTrimmedNumbers(String[] nums, int[][] queries) {\\n       \\n        List<Integer> al=new ArrayList<>();\\n        \\n       \\n        PriorityQueue<pair> pq=new PriorityQueue<>(new Comparator<pair>(){  // minHeap of type pair...with custome implimentation\\n            \\n            public int compare(pair a,pair b){\\n                \\n                if(a.num.equals(b.num)) return  (a.index-b.index);  // If string is equal then compare index\\n                \\n                else return (a.num.compareTo(b.num));\\n                \\n            }\\n        });\\n        \\n      \\n            for(int []a:queries){      // for performing each query\\n                \\n               \\n                \\n                for(int i=0;i<nums.length;i++){     // perform given operation on nums each element.\\n                    \\n                    String t=nums[i].substring(nums[i].length()-a[1]);\\n                    \\n                    pq.add(new pair(i,t));\\n              \\n                }\\n               \\n             \\n             \\n                \\n                \\n              while(a[0]>1){   // remove k-1 form minHeap and then take peek();\\n                  \\n                  pq.poll();\\n                  a[0]--;\\n              }\\n                al.add(pq.peek().index);\\n                pq.clear();\\n        \\n            }\\n              \\n                \\n        // Convert List into array.        \\n        int ans[]=new int[al.size()];\\n         int k=0;\\n        for(Integer i:al) ans[k++]=i;   \\n        \\n        return ans;\\n        \\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n    class pair{             // creating custome class..\\n        \\n        int index;\\n        String num;\\n        \\n        public pair(int index,String num){\\n            this.index=index;\\n            this.num=num;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2323969,
                "title": "python-radix-sort",
                "content": "```\\ndef smallestTrimmedNumbers(self, nums: List[str], queries: List[List[int]]) -> List[int]:\\n        n, q_len = len(nums[0]), len(queries)\\n        buckets, res = [deque() for _ in range(10)], [0]*q_len\\n        queries = [(q[1],q[0],idx) for idx,q in enumerate(queries)]\\n        queries.sort()\\n        nums = [[int(num), idx] for idx,num in enumerate(nums)]\\n        q_idx = 0\\n        for i in range(n):\\n            for info in nums:\\n                idx = info[0]%10\\n                info[0] //= 10\\n                buckets[idx].appendleft(info)\\n            index = 0\\n            for j in range(10):\\n                while buckets[j]:\\n                    nums[index] = buckets[j].pop()\\n                    index+=1\\n            while q_idx<q_len and queries[q_idx][0] == i+1:\\n                res[queries[q_idx][2]] = nums[queries[q_idx][1]-1][1]\\n                q_idx+=1\\n            if q_idx == q_len:\\n                break\\n        return res",
                "solutionTags": [],
                "code": "```\\ndef smallestTrimmedNumbers(self, nums: List[str], queries: List[List[int]]) -> List[int]:\\n        n, q_len = len(nums[0]), len(queries)\\n        buckets, res = [deque() for _ in range(10)], [0]*q_len\\n        queries = [(q[1],q[0],idx) for idx,q in enumerate(queries)]\\n        queries.sort()\\n        nums = [[int(num), idx] for idx,num in enumerate(nums)]\\n        q_idx = 0\\n        for i in range(n):\\n            for info in nums:\\n                idx = info[0]%10\\n                info[0] //= 10\\n                buckets[idx].appendleft(info)\\n            index = 0\\n            for j in range(10):\\n                while buckets[j]:\\n                    nums[index] = buckets[j].pop()\\n                    index+=1\\n            while q_idx<q_len and queries[q_idx][0] == i+1:\\n                res[queries[q_idx][2]] = nums[queries[q_idx][1]-1][1]\\n                q_idx+=1\\n            if q_idx == q_len:\\n                break\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 2319935,
                "title": "swift-one-liner-fully-explained",
                "content": "**One-Liner Solution** ***(accepted answer)***\\n```\\nclass Solution {\\n    func smallestTrimmedNumbers(_ nums: [String], _ queries: [[Int]]) -> [Int] {\\n        queries.reduce(into: [Int]()) { result, query in result.append(nums.map({ String($0.suffix(query[1])) }).enumerated().sorted(by: {$0.element < $1.element})[query[0]-1].offset) }\\n    }\\n}\\n```\\n\\n**SOLUTION EXPLAINED**\\n\\n```\\nqueries.reduce(into: [Int]()) { result, query in \\n\\tresult.append(nums\\n\\t\\t.map({ String($0.suffix(query[1])) })  // Operation 1 - Create temp array of trimmed numbers\\n\\t\\t.enumerated().sorted(by: {$0.element < $1.element})  // Operation 2 - Sort trimmed numbers+indexes \\n\\t\\t[query[0]-1].offset   // Operation 3 - Return the index of the kth smallest number\\n\\t) \\n}\\n```\\n\\n**Operation 1: Create temp array of trimmed numbers**\\n```\\n.map({ String($0.suffix(query[1])) })\\n```\\nThis operation is straightforward. We create a temporary array of Strings from the input `nums` array, where each element is trimmed to the `suffix()` number of digits. In Swift, the `suffix()` function is much faster than converting to an array of Character, creating to an ArraySlice, then back to a String (such as `String(chars[num[0].count - query[1]))`). To do that, we\\'d have to convert`nums` from array of `String` to array of `[Character]` before the `reduce`, then in each iteration, create the `ArraySlice<String>`, and use a custom `ArraySlice<String>` comparator for the sort. This is much more code, and `suffix()` is simpler and faster. \\n\\n**Operation 2: Sort trimmed numbers+indexes**\\n```\\n.enumerated().sorted(by: {$0.element < $1.element})\\n```\\nAlso straightforward. The `enumerated()` operator creates a sequence of named tuples in the form `(offset: x, element: y)`. The `sorted` operator takes a custom comparator closure to sort these tuples, performing a simple string sort on the `element` part of the tuple.\\n\\n**Note:** Instead of using the tuple `element` label, we could use the tuple index 1 here.\\n\\n**Operation 3: Return the index of the kth smallest number**\\n```\\n[query[0]-1].offset\\n```\\nThis simply evaluates the query\\'s `kth smallest number` field, offsets it by one to make it zero-indexed, and returns the `offset` tuple element from that zero-indexed element, which was the pre-sorted array\\'s index of that element. \\n\\n**Note:** Instead of using the tuple `offset` label, we could use the tuple index 0 here.\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func smallestTrimmedNumbers(_ nums: [String], _ queries: [[Int]]) -> [Int] {\\n        queries.reduce(into: [Int]()) { result, query in result.append(nums.map({ String($0.suffix(query[1])) }).enumerated().sorted(by: {$0.element < $1.element})[query[0]-1].offset) }\\n    }\\n}\\n```\n```\\nqueries.reduce(into: [Int]()) { result, query in \\n\\tresult.append(nums\\n\\t\\t.map({ String($0.suffix(query[1])) })  // Operation 1 - Create temp array of trimmed numbers\\n\\t\\t.enumerated().sorted(by: {$0.element < $1.element})  // Operation 2 - Sort trimmed numbers+indexes \\n\\t\\t[query[0]-1].offset   // Operation 3 - Return the index of the kth smallest number\\n\\t) \\n}\\n```\n```\\n.map({ String($0.suffix(query[1])) })\\n```\n```\\n.enumerated().sorted(by: {$0.element < $1.element})\\n```\n```\\n[query[0]-1].offset\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2308124,
                "title": "brute-force-c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& q) {\\n        int sz = nums[0].size();\\n        int m = q.size();\\n        int n = nums.size();\\n        vector<int>v;\\n        for(int i = 0; i < m; i++){\\n            priority_queue<pair<string,int>,vector<pair<string,int>>,greater<pair<string,int>>>pq;\\n            for(int j = 0; j < n; j++){\\n                int ind = sz-q[i][1];\\n                int len = q[i][1];\\n                string s = nums[j].substr(ind,len);\\n                pq.push({s,j});\\n            }\\n            int k = q[i][0];\\n            while(k>1){\\n                pq.pop();\\n                k--;\\n            }\\n            v.push_back(pq.top().second);\\n            while(!pq.empty()){\\n                pq.pop();\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& q) {\\n        int sz = nums[0].size();\\n        int m = q.size();\\n        int n = nums.size();\\n        vector<int>v;\\n        for(int i = 0; i < m; i++){\\n            priority_queue<pair<string,int>,vector<pair<string,int>>,greater<pair<string,int>>>pq;\\n            for(int j = 0; j < n; j++){\\n                int ind = sz-q[i][1];\\n                int len = q[i][1];\\n                string s = nums[j].substr(ind,len);\\n                pq.push({s,j});\\n            }\\n            int k = q[i][0];\\n            while(k>1){\\n                pq.pop();\\n                k--;\\n            }\\n            v.push_back(pq.top().second);\\n            while(!pq.empty()){\\n                pq.pop();\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2304774,
                "title": "c-radix-sort-short-solution",
                "content": "```\\n    vector<int> smallestTrimmedNumbers(vector<string>& v, vector<vector<int>>& queries) {\\n        vector<int> res;\\n        for(auto & q : queries) {\\n            vector<int> init;\\n            for(int i = 0; i < v.size(); i++) init.push_back(i);\\n            res.push_back(helper(v, q, init));\\n        }\\n        return res;\\n    }\\n    \\n    int helper(vector<string>& v, vector<int>& q, vector<int>& subset) {\\n        vector<int> mp[10];\\n        for(auto i : subset) mp[v[i].at(v[i].length()-q[1])-\\'0\\'].push_back(i);\\n        \\n        q[1]--;\\n        for(int j = 0; j <= 9; j++) {\\n            if(q[0] > mp[j].size()) {\\n                q[0] -= mp[j].size();\\n             } else if(q[1] == 0) {\\n                return mp[j][q[0]-1];\\n            } else {\\n                return helper(v, q, mp[j]);\\n            }\\n        }\\n        return -1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    vector<int> smallestTrimmedNumbers(vector<string>& v, vector<vector<int>>& queries) {\\n        vector<int> res;\\n        for(auto & q : queries) {\\n            vector<int> init;\\n            for(int i = 0; i < v.size(); i++) init.push_back(i);\\n            res.push_back(helper(v, q, init));\\n        }\\n        return res;\\n    }\\n    \\n    int helper(vector<string>& v, vector<int>& q, vector<int>& subset) {\\n        vector<int> mp[10];\\n        for(auto i : subset) mp[v[i].at(v[i].length()-q[1])-\\'0\\'].push_back(i);\\n        \\n        q[1]--;\\n        for(int j = 0; j <= 9; j++) {\\n            if(q[0] > mp[j].size()) {\\n                q[0] -= mp[j].size();\\n             } else if(q[1] == 0) {\\n                return mp[j][q[0]-1];\\n            } else {\\n                return helper(v, q, mp[j]);\\n            }\\n        }\\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2300840,
                "title": "c-very-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestTrimmedNumbers(vector<string>& a, vector<vector<int>>& quaries) {\\n        vector<int> ans;\\n        int n=a[0].size();\\n        \\n        for(auto& v:quaries){\\n            priority_queue<pair<string,int>,vector<pair<string,int>>,greater<pair<string,int>>> pq;\\n            for(int i=0; i<a.size(); i++){\\n                pq.push({a[i].substr(n-v[1]),i});\\n            }\\n            int k=v[0];\\n            while(k>1){\\n                pq.pop();\\n                k--;\\n            }\\n            ans.push_back(pq.top().second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestTrimmedNumbers(vector<string>& a, vector<vector<int>>& quaries) {\\n        vector<int> ans;\\n        int n=a[0].size();\\n        \\n        for(auto& v:quaries){\\n            priority_queue<pair<string,int>,vector<pair<string,int>>,greater<pair<string,int>>> pq;\\n            for(int i=0; i<a.size(); i++){\\n                pq.push({a[i].substr(n-v[1]),i});\\n            }\\n            int k=v[0];\\n            while(k>1){\\n                pq.pop();\\n                k--;\\n            }\\n            ans.push_back(pq.top().second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2299177,
                "title": "funny-solution-i-was-not-able-to-do-it-during-the-contest",
                "content": "```\\nfunc smallestTrimmedNumbers(nums []string, queries [][]int) []int {\\n\\tresult := make([]int, len(queries))\\n\\n\\tvar toInt func(string) int\\n\\ttoInt = func(s string) int {\\n\\t\\tres, err := strconv.Atoi(s)\\n\\n\\t\\tif err != nil {\\n\\t\\t\\tpanic(err)\\n\\t\\t}\\n\\n\\t\\treturn res\\n\\t}\\n\\n\\tvar isSmaller func(string, string) bool\\n\\tisSmaller = func(s1 string, s2 string) bool {\\n        if len(s1) < len(s2) {\\n            return true\\n        }\\n        \\n        if len(s1) > len(s2) {\\n            return false\\n        }\\n\\n\\t\\tfor i := 0; i < len(s1); i++ {\\n\\t\\t\\tif s1[i] < s2[i] {\\n\\t\\t\\t\\treturn true\\n\\t\\t\\t} else if s1[i] > s2[i] {\\n\\t\\t\\t\\treturn false\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn true\\n\\t}\\n\\n\\tfor i, query := range queries {\\n\\t\\tvar currentNums [][2]string\\n\\n\\t\\ttrim := query[1]\\n\\t\\tindex := query[0]\\n\\n\\t\\tfor numIdx, num := range nums {\\n\\t\\t\\tcurrentNums = append(currentNums, [2]string{num[len(num)-trim:], fmt.Sprintf(\"%v\", numIdx)})\\n\\t\\t}\\n\\n\\t\\tsort.Slice(currentNums, func(i, j int) bool {\\n\\t\\t\\tif currentNums[i][0] != currentNums[j][0] {\\n\\t\\t\\t\\treturn isSmaller(currentNums[i][0], currentNums[j][0])\\n\\t\\t\\t} else {\\n                return isSmaller(currentNums[i][1], currentNums[j][1])\\n\\t\\t\\t}\\n\\t\\t})\\n\\n\\t\\tresult[i] = toInt(currentNums[index-1][1])\\n\\n\\t}\\n\\n\\treturn result\\n}\\n\\n```",
                "solutionTags": [
                    "Go",
                    "Sorting"
                ],
                "code": "```\\nfunc smallestTrimmedNumbers(nums []string, queries [][]int) []int {\\n\\tresult := make([]int, len(queries))\\n\\n\\tvar toInt func(string) int\\n\\ttoInt = func(s string) int {\\n\\t\\tres, err := strconv.Atoi(s)\\n\\n\\t\\tif err != nil {\\n\\t\\t\\tpanic(err)\\n\\t\\t}\\n\\n\\t\\treturn res\\n\\t}\\n\\n\\tvar isSmaller func(string, string) bool\\n\\tisSmaller = func(s1 string, s2 string) bool {\\n        if len(s1) < len(s2) {\\n            return true\\n        }\\n        \\n        if len(s1) > len(s2) {\\n            return false\\n        }\\n\\n\\t\\tfor i := 0; i < len(s1); i++ {\\n\\t\\t\\tif s1[i] < s2[i] {\\n\\t\\t\\t\\treturn true\\n\\t\\t\\t} else if s1[i] > s2[i] {\\n\\t\\t\\t\\treturn false\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn true\\n\\t}\\n\\n\\tfor i, query := range queries {\\n\\t\\tvar currentNums [][2]string\\n\\n\\t\\ttrim := query[1]\\n\\t\\tindex := query[0]\\n\\n\\t\\tfor numIdx, num := range nums {\\n\\t\\t\\tcurrentNums = append(currentNums, [2]string{num[len(num)-trim:], fmt.Sprintf(\"%v\", numIdx)})\\n\\t\\t}\\n\\n\\t\\tsort.Slice(currentNums, func(i, j int) bool {\\n\\t\\t\\tif currentNums[i][0] != currentNums[j][0] {\\n\\t\\t\\t\\treturn isSmaller(currentNums[i][0], currentNums[j][0])\\n\\t\\t\\t} else {\\n                return isSmaller(currentNums[i][1], currentNums[j][1])\\n\\t\\t\\t}\\n\\t\\t})\\n\\n\\t\\tresult[i] = toInt(currentNums[index-1][1])\\n\\n\\t}\\n\\n\\treturn result\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2298056,
                "title": "c-brute-force",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& queries) {\\n        vector<int> ans ;\\n        vector<string> spare = nums ;\\n        \\n        for(auto &x : queries){\\n            int k = x[0] , trim = x[1] ;\\n            priority_queue<pair<string,int>> pq ;\\n            \\n            for(int i = 0 ; i < nums.size() ; ++i ){\\n                string &s = nums[i] ; //take by reference\\n                pq.push({s.substr(s.size()-trim),i}); //take last trime digits only\\n                if(pq.size() > k) pq.pop() ; //filter larger numbers\\n            }\\n            nums = spare ; //reset nums\\n            ans.push_back(pq.top().second) ;\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& queries) {\\n        vector<int> ans ;\\n        vector<string> spare = nums ;\\n        \\n        for(auto &x : queries){\\n            int k = x[0] , trim = x[1] ;\\n            priority_queue<pair<string,int>> pq ;\\n            \\n            for(int i = 0 ; i < nums.size() ; ++i ){\\n                string &s = nums[i] ; //take by reference\\n                pq.push({s.substr(s.size()-trim),i}); //take last trime digits only\\n                if(pq.size() > k) pq.pop() ; //filter larger numbers\\n            }\\n            nums = spare ; //reset nums\\n            ans.push_back(pq.top().second) ;\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2297439,
                "title": "simple-easy-solution-in-c-for-beginners",
                "content": "```\\n// E.g. nums = [\"24\",\"37\",\"96\",\"04\"], queries = [[2,1],[2,2]]\\nclass Solution {\\npublic:\\n    vector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& queries) {\\n        int q = queries.size();\\n        vector<int> ans;\\n        for(int i=0; i<q; i++){\\n            \\n            vector<pair<string,int>> trimString;\\n             // This trimString vector will store all the trim strings and their indexes according to query, then sort the array\\n            // 4->0 4->3 6->2 7->1 \\n            // 04->3 24->0 37->1 96->2 \\n\\n            for(int j=0; j<nums.size(); j++){\\n                string trimNum = nums[j].substr(nums[0].size()-queries[i][1],queries[i][1]);\\n                trimString.push_back({trimNum, j});\\n            }\\n            sort(trimString.begin(), trimString.end());\\n            \\n            // Access whichever smallest element is needed\\n            ans.push_back(trimString[queries[i][0]-1].second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n// E.g. nums = [\"24\",\"37\",\"96\",\"04\"], queries = [[2,1],[2,2]]\\nclass Solution {\\npublic:\\n    vector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& queries) {\\n        int q = queries.size();\\n        vector<int> ans;\\n        for(int i=0; i<q; i++){\\n            \\n            vector<pair<string,int>> trimString;\\n             // This trimString vector will store all the trim strings and their indexes according to query, then sort the array\\n            // 4->0 4->3 6->2 7->1 \\n            // 04->3 24->0 37->1 96->2 \\n\\n            for(int j=0; j<nums.size(); j++){\\n                string trimNum = nums[j].substr(nums[0].size()-queries[i][1],queries[i][1]);\\n                trimString.push_back({trimNum, j});\\n            }\\n            sort(trimString.begin(), trimString.end());\\n            \\n            // Access whichever smallest element is needed\\n            ans.push_back(trimString[queries[i][0]-1].second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2296817,
                "title": "c-caching",
                "content": "We can sort indexes for given `trim` and *cache* them: \\n\\n```\\npublic class Solution {\\n    \\n    private readonly Dictionary<int, List<int>> m_Known = new();\\n    \\n    public int[] SmallestTrimmedNumbers(string[] nums, int[][] queries) {\\n     int[] result = new int[queries.Length];\\n\\n      for (int qIndex = 0; qIndex < queries.Length; ++qIndex) {\\n        int k = queries[qIndex][0];\\n        int trim = queries[qIndex][1];\\n\\n        if (m_Known.TryGetValue(trim, out var knownList)) {\\n          result[qIndex] = knownList[k - 1];\\n\\n          continue;\\n        }\\n\\n        List<int> list = nums\\n            .Select((item, index) => (value: item[^trim..], index: index))\\n            .OrderBy(item => item.value)\\n            .ThenBy(item => item.index)\\n            .Select(item => item.index)\\n            .ToList();\\n\\n        m_Known.Add(trim, list);\\n\\n        result[qIndex] = list[k - 1];\\n      }\\n\\n      return result;\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    \\n    private readonly Dictionary<int, List<int>> m_Known = new();\\n    \\n    public int[] SmallestTrimmedNumbers(string[] nums, int[][] queries) {\\n     int[] result = new int[queries.Length];\\n\\n      for (int qIndex = 0; qIndex < queries.Length; ++qIndex) {\\n        int k = queries[qIndex][0];\\n        int trim = queries[qIndex][1];\\n\\n        if (m_Known.TryGetValue(trim, out var knownList)) {\\n          result[qIndex] = knownList[k - 1];\\n\\n          continue;\\n        }\\n\\n        List<int> list = nums\\n            .Select((item, index) => (value: item[^trim..], index: index))\\n            .OrderBy(item => item.value)\\n            .ThenBy(item => item.index)\\n            .Select(item => item.index)\\n            .ToList();\\n\\n        m_Known.Add(trim, list);\\n\\n        result[qIndex] = list[k - 1];\\n      }\\n\\n      return result;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2296808,
                "title": "scala-concise-functional-solution",
                "content": "```\\n  def smallestTrimmedNumbers(nums: Array[String], queries: Array[Array[Int]]): Array[Int] =\\n    queries.map { case Array(k, trim) =>\\n      nums\\n        .map(_.takeRight(trim))\\n        .zipWithIndex\\n        .sorted\\n        .apply(k - 1)\\n        ._2\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n  def smallestTrimmedNumbers(nums: Array[String], queries: Array[Array[Int]]): Array[Int] =\\n    queries.map { case Array(k, trim) =>\\n      nums\\n        .map(_.takeRight(trim))\\n        .zipWithIndex\\n        .sorted\\n        .apply(k - 1)\\n        ._2\\n    }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2296592,
                "title": "c-accepted-efficient-code-easy-to-understand",
                "content": "```\\n vector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& queries) {\\n        vector <int> v;\\n        vector<pair<string,int>> v1;\\n        int n=nums.size();\\n        long int l=0;\\n        if(n>0)l=nums[0].length();\\n        for(auto q:queries)\\n        {\\n            int ki=q[0];\\n            int ti=q[1];\\n            for(int i=0;i<n;i++)\\n            {\\n                v1.push_back({nums[i].substr(l-ti,l),i});\\n            }\\n            sort(v1.begin(),v1.end());\\n            v.push_back(v1[ki-1].second);\\n            v1.clear();\\n        }\\n        return v;\\n        \\n    }\\n\\t",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\n vector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& queries) {\\n        vector <int> v;\\n        vector<pair<string,int>> v1;\\n        int n=nums.size();\\n        long int l=0;\\n        if(n>0)l=nums[0].length();\\n        for(auto q:queries)\\n        {\\n            int ki=q[0];\\n            int ti=q[1];\\n            for(int i=0;i<n;i++)\\n            {\\n                v1.push_back({nums[i].substr(l-ti,l),i});\\n            }\\n            sort(v1.begin(),v1.end());\\n            v.push_back(v1[ki-1].second);\\n            v1.clear();\\n        }\\n        return v;\\n        \\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 2296474,
                "title": "javascript-bucket-sort-o-mn-200-250ms",
                "content": "**TLDR:** Sort the queries by ```trim``` ascending. We\\'ll bucket sort by nth digit from the right until we reach ```trim```, then return the kth index. Since they want the index of the number instead of the number itself, we\\'ll keep an intermediate array of indices and keep sorting that instead of nums.\\n\\n**Full Explanation:**\\nSuppose we have these inputs\\n\\n```\\nconst nums = [\\n  \"65461289\",\\n  \"15640616\",\\n  \"89765543\",\\n  \"55312314\",\\n]\\nconst queries = [[4,3],[3,1],[1,5]]\\n```\\n\\nThis means we\\'re being asked to slice nums along these columns and return the num at these rows\\n```\\n         3   1   2\\n3 \"6 5 4 6 1 2 8 9\"\\n  \"1 5 6 4 0 6 1 6\"\\n2 \"8 9 7 6 5 5 4 3\"\\n1 \"5 5 3 1 2 3 1 4\"\\n```\\n\\nOne solution would be to just sort all the nums for every query in ```O(m * n log n)``` time.\\n\\nIf we didn\\'t have to think about the queries at all, a better way to sort these nums would be with a bucket sort in ```O (m * n)``` time. We would throw all the nums into buckets by digit starting from the right-most digit, and in each iteration we re-build the nums array starting from the lowest bucket (0 - 9). The ordering would look like:\\n```\\n     ... 5 4 3 2 1\\n  \"6 5 4 6 1 2 8 9\"\\n  \"1 5 6 4 0 6 1 6\"\\n  \"8 9 7 6 5 5 4 3\"\\n  \"5 5 3 1 2 3 1 4\"\\n```\\n\\nSo how about we re-arrange our queries so they line up with the order we would bucket sort these nums, and then sort until we reach the next column we\\'re supposed to query.\\n```\\n         3   2   1\\n3 \"6 5 4 6 1 2 8 9\"\\n  \"1 5 6 4 0 6 1 6\"\\n1 \"8 9 7 6 5 5 4 3\"\\n2 \"5 5 3 1 2 3 1 4\"\\n```\\n\\nOk but we have to return our answer in the same order our queries came in, and we also have to return the original index of the kth number from each query (not the number itself). So we\\'ll use two arrays which map to the queries and numbers and sort those instead of the queries and nums themselves.\\n\\n```\\nvar smallestTrimmedNumbers = function (nums, queries) {\\n  // create query index mapping and sort it to match the direction of our bucket sort\\n  const queriesByTrimLength = queries\\n    .map((_, i) => i)\\n    .sort((a, b) => queries[a][1] - queries[b][1]);\\n  \\n  // num mapping which we\\'ll bucket sort and use to fill in our answer with indices\\n  const numIndices = nums.map((_, i) => i);\\n  const numLength = nums[0].length;\\n  // index of the current digit we\\'re sorting\\n  let digit = 0;\\n\\n  return queriesByTrimLength.reduce((queryAnswers, queryIdx) => {\\n    const [k, trim] = queries[queryIdx];\\n\\n    // sort until we reach the index they want us to query\\n    while (trim > digit) {\\n      digit += 1;\\n      bucketSort(numIndices, nums, numLength - digit);\\n    }\\n\\n    queryAnswers[queryIdx] = numIndices[k - 1];\\n    return queryAnswers;\\n  }, queries.map(() => 0));\\n};\\n\\nconst bucketSort = (indices, nums, digit) => {\\n  const buckets = new Array(10).fill(0).map(() => []);\\n\\n  for (const idx of indices) buckets[+nums[idx][digit]].push(idx);\\n\\n  let current = 0;\\n  for (const bucket of buckets) {\\n    for (const idx of bucket) {\\n      indices[current] = idx;\\n      current += 1;\\n    }\\n  }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Bucket Sort"
                ],
                "code": "```trim```\n```trim```\n```\\nconst nums = [\\n  \"65461289\",\\n  \"15640616\",\\n  \"89765543\",\\n  \"55312314\",\\n]\\nconst queries = [[4,3],[3,1],[1,5]]\\n```\n```\\n         3   1   2\\n3 \"6 5 4 6 1 2 8 9\"\\n  \"1 5 6 4 0 6 1 6\"\\n2 \"8 9 7 6 5 5 4 3\"\\n1 \"5 5 3 1 2 3 1 4\"\\n```\n```O(m * n log n)```\n```O (m * n)```\n```\\n     ... 5 4 3 2 1\\n  \"6 5 4 6 1 2 8 9\"\\n  \"1 5 6 4 0 6 1 6\"\\n  \"8 9 7 6 5 5 4 3\"\\n  \"5 5 3 1 2 3 1 4\"\\n```\n```\\n         3   2   1\\n3 \"6 5 4 6 1 2 8 9\"\\n  \"1 5 6 4 0 6 1 6\"\\n1 \"8 9 7 6 5 5 4 3\"\\n2 \"5 5 3 1 2 3 1 4\"\\n```\n```\\nvar smallestTrimmedNumbers = function (nums, queries) {\\n  // create query index mapping and sort it to match the direction of our bucket sort\\n  const queriesByTrimLength = queries\\n    .map((_, i) => i)\\n    .sort((a, b) => queries[a][1] - queries[b][1]);\\n  \\n  // num mapping which we\\'ll bucket sort and use to fill in our answer with indices\\n  const numIndices = nums.map((_, i) => i);\\n  const numLength = nums[0].length;\\n  // index of the current digit we\\'re sorting\\n  let digit = 0;\\n\\n  return queriesByTrimLength.reduce((queryAnswers, queryIdx) => {\\n    const [k, trim] = queries[queryIdx];\\n\\n    // sort until we reach the index they want us to query\\n    while (trim > digit) {\\n      digit += 1;\\n      bucketSort(numIndices, nums, numLength - digit);\\n    }\\n\\n    queryAnswers[queryIdx] = numIndices[k - 1];\\n    return queryAnswers;\\n  }, queries.map(() => 0));\\n};\\n\\nconst bucketSort = (indices, nums, digit) => {\\n  const buckets = new Array(10).fill(0).map(() => []);\\n\\n  for (const idx of indices) buckets[+nums[idx][digit]].push(idx);\\n\\n  let current = 0;\\n  for (const bucket of buckets) {\\n    for (const idx of bucket) {\\n      indices[current] = idx;\\n      current += 1;\\n    }\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2295930,
                "title": "c-solution-using-priority-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& queries) {\\n        \\n        vector<int> vc;\\n        for(int i=0;i<queries.size();++i)\\n        {\\n            int x=queries[i][0];\\n            int y=queries[i][1];\\n            priority_queue<pair<string,int>, vector <pair<string, int>>, greater<pair<string, int>>> pq;\\n            int j=0;\\n            for(auto s:nums)\\n            {\\n               pq.push({s.substr(s.length()-y,s.length()),j});\\n               j++;\\n            }\\n            int k=1;\\n            while(k<x)\\n            {\\n                pq.pop();\\n                k++;\\n            }\\n            vc.push_back(pq.top().second);\\n        }\\n        return vc;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& queries) {\\n        \\n        vector<int> vc;\\n        for(int i=0;i<queries.size();++i)\\n        {\\n            int x=queries[i][0];\\n            int y=queries[i][1];\\n            priority_queue<pair<string,int>, vector <pair<string, int>>, greater<pair<string, int>>> pq;\\n            int j=0;\\n            for(auto s:nums)\\n            {\\n               pq.push({s.substr(s.length()-y,s.length()),j});\\n               j++;\\n            }\\n            int k=1;\\n            while(k<x)\\n            {\\n                pq.pop();\\n                k++;\\n            }\\n            vc.push_back(pq.top().second);\\n        }\\n        return vc;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2294878,
                "title": "python3-simplest-naive-approach",
                "content": "```\\nfrom bisect import insort\\nclass Solution:\\n    def smallestTrimmedNumbers(self, nums: List[str], queries: List[List[int]]) -> List[int]:\\n        dp = {}\\n        \\n        output = []\\n        \\n        for k, trim in queries:\\n            if (k,trim) not in dp:\\n                x = []\\n                for i in range(len(nums)):\\n                    trimed = nums[i][-trim:]\\n                    insort(x,(int(trimed),i))\\n                dp[(k,trim)] = x[k-1][1]\\n            output.append(dp[(k,trim)])\\n        \\n        return output\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom bisect import insort\\nclass Solution:\\n    def smallestTrimmedNumbers(self, nums: List[str], queries: List[List[int]]) -> List[int]:\\n        dp = {}\\n        \\n        output = []\\n        \\n        for k, trim in queries:\\n            if (k,trim) not in dp:\\n                x = []\\n                for i in range(len(nums)):\\n                    trimed = nums[i][-trim:]\\n                    insort(x,(int(trimed),i))\\n                dp[(k,trim)] = x[k-1][1]\\n            output.append(dp[(k,trim)])\\n        \\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2294775,
                "title": "tree-map-java",
                "content": "```\\nclass Solution {\\n    public int[] smallestTrimmedNumbers(String[] nums, int[][] queries) {\\n        \\n        int[] ans = new int[queries.length];\\n        for(int i=0; i<queries.length; i++){\\n           int a = queries[i][0];\\n           int b = queries[i][1];\\n           Map<String, List<Integer>> map = new TreeMap<>();\\n           for(int j=0; j<nums.length; j++){\\n             String num = nums[j].substring(nums[j].length() - b);\\n             if(!map.containsKey(num)){\\n               List li = new ArrayList<>();\\n               li.add(j);\\n               map.put(num, li);\\n             }else{\\n               List<Integer> list = map.get(num);\\n               list.add(j);\\n               map.put(num, list);\\n             }\\n           }\\n           boolean isSuccess = false;\\n          int k = 1;\\n         for(Map.Entry<String, List<Integer>> entry: map.entrySet()){\\n             List<Integer> li = entry.getValue();\\n             for(int m: li){\\n               if(k==a){\\n                 ans[i] = m;\\n                 isSuccess = true;\\n                 break;\\n               }\\n               k++;\\n             }\\n           if(isSuccess) break;\\n          }\\n        }\\n      return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int[] smallestTrimmedNumbers(String[] nums, int[][] queries) {\\n        \\n        int[] ans = new int[queries.length];\\n        for(int i=0; i<queries.length; i++){\\n           int a = queries[i][0];\\n           int b = queries[i][1];\\n           Map<String, List<Integer>> map = new TreeMap<>();\\n           for(int j=0; j<nums.length; j++){\\n             String num = nums[j].substring(nums[j].length() - b);\\n             if(!map.containsKey(num)){\\n               List li = new ArrayList<>();\\n               li.add(j);\\n               map.put(num, li);\\n             }else{\\n               List<Integer> list = map.get(num);\\n               list.add(j);\\n               map.put(num, list);\\n             }\\n           }\\n           boolean isSuccess = false;\\n          int k = 1;\\n         for(Map.Entry<String, List<Integer>> entry: map.entrySet()){\\n             List<Integer> li = entry.getValue();\\n             for(int m: li){\\n               if(k==a){\\n                 ans[i] = m;\\n                 isSuccess = true;\\n                 break;\\n               }\\n               k++;\\n             }\\n           if(isSuccess) break;\\n          }\\n        }\\n      return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2294682,
                "title": "tle-during-contest-while-same-solution-accepted-after-contest",
                "content": "I submitted the entire same code after the contest and it got accepted, however during the contest, it gave a TLE. But for Ranking purpose my finish time will be considered as the last accepted solution. Cherry on top: Penalty of 5 mins. per wrong submission. If there are some **test cases added**, each and every **solution is re-evaluated**, so why not now when OJ had some sort of runtime problem during the contest. I ask the admin to **re-evaluate all the submitted** solutions for this question and **re calulate the ranks** according to the minimum time when it got accepted\\n![image](https://assets.leetcode.com/users/images/1962e7d4-056d-4e86-8cc2-84bb1a8dd356_1658051776.392467.jpeg)\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "I submitted the entire same code after the contest and it got accepted, however during the contest, it gave a TLE. But for Ranking purpose my finish time will be considered as the last accepted solution. Cherry on top: Penalty of 5 mins. per wrong submission. If there are some **test cases added**, each and every **solution is re-evaluated**, so why not now when OJ had some sort of runtime problem during the contest. I ask the admin to **re-evaluate all the submitted** solutions for this question and **re calulate the ranks** according to the minimum time when it got accepted\\n![image](https://assets.leetcode.com/users/images/1962e7d4-056d-4e86-8cc2-84bb1a8dd356_1658051776.392467.jpeg)\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2294546,
                "title": "tle-earlier-now-getting-accepted-quite-comfortably",
                "content": "My answer\\nEarlier: Same code then- ![image](https://assets.leetcode.com/users/images/f8a501e2-944f-4abd-9a90-d2faaf28b37e_1658050024.565158.png)\\n\\nSame code now after contest-\\n![image](https://assets.leetcode.com/users/images/bd848724-1474-4de1-bdd4-bde9f9e1d8b3_1658050091.8814394.png)\\n\\nSome other code that i wrote during contest got accepted at even worse time complexity so  complexity can\\'t be a problem here.\\n![image](https://assets.leetcode.com/users/images/6881e86e-6642-4d55-9422-2617eeca64e8_1658050349.3831856.png)\\n\\n\\n```\\n#define ll long long\\n#define pi (3.141592653589)\\n#define mod 1000000007\\n#define float double\\n#define pb push_back\\n#define mp make_pair\\n#define ff first\\n#define ss second\\n#define all(c) c.begin(), c.end()\\n#define min3(a, b, c) min(c, min(a, b))\\n#define min4(a, b, c, d) min(d, min(c, min(a, b)))\\n#define rrep(i, n) for(int i=n-1;i>=0;i--)\\n#define rep(i,n) for(int i=0;i<n;i++)\\nclass Solution {\\n    \\n    bool myComp(const pair<int, int>& a, const pair<int, int>& b){ if (a.ff != b.ff)  return a.first < b.first;  return a.second < b.second;}\\n    \\npublic:\\n    vector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& queries) {\\n        \\n        int n=nums[0].size();\\n        \\n        map<int, vector<pair<string,int>>>m;\\n        vector<int> ans;\\n        \\n        for(int i=1;i<=n;i++){\\n            \\n            rep(j, nums.size()){\\n                \\n                string now= nums[j].substr(n-i, i);\\n                m[i].pb(mp(now, j));\\n            }\\n        }\\n        \\n        for(auto it= m.begin(); it!=m.end(); it++){\\n            sort(all(it->second));\\n        }\\n        \\n        int x=queries.size();\\n    \\n        \\n        rep(i, x){\\n            string k= m[queries[i][1]][queries[i][0]-1].ff;\\n            \\n            int mi= m[queries[i][1]][queries[i][0]-1].ss;\\n            \\n      \\n            \\n            ans.pb(mi);\\n        }\\n        \\n        \\n        return ans;\\n    }\\n\\nGave me tle during contest on test case 235. Now, it is passing with 1700ms. That is quite alright in terms of complexity. I don\\'t know what to say about this charade.",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "class Solution {\\n    \\n    bool myComp(const pair<int, int>& a, const pair<int, int>& b){ if (a.ff != b.ff)  return a.first < b.first;  return a.second < b.second;}",
                "codeTag": "Java"
            },
            {
                "id": 2294209,
                "title": "c-solution-easy-to-understand-using-sorting",
                "content": "```\\nclass Solution {\\npublic:\\n    static bool compare(pair<string, int>& a, pair<string, int>& b) {\\n        if(a.first==b.first) return a.second<b.second;\\n        return a.first<b.first;\\n    }\\n    vector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& queries) {\\n        vector<int> ans(queries.size(), 0);\\n        for(int i=0; i<queries.size(); ++i) {\\n            vector<pair<string,int>> curr(nums.size(), {\"\", 0});\\n            for(int j=0; j<nums.size(); ++j) {\\n                curr[j]={nums[j].substr(nums[0].size()-queries[i][1], queries[i][1]), j};\\n            }\\n            sort(curr.begin(), curr.end(), compare);\\n         ans[i]=curr[queries[i][0]-1].second;\\n        }\\n     return ans;\\n    }\\n};\\n/**\\nif(find helpful) {\\ndo upvote(); // thanks:)\\n}\\n*/\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool compare(pair<string, int>& a, pair<string, int>& b) {\\n        if(a.first==b.first) return a.second<b.second;\\n        return a.first<b.first;\\n    }\\n    vector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& queries) {\\n        vector<int> ans(queries.size(), 0);\\n        for(int i=0; i<queries.size(); ++i) {\\n            vector<pair<string,int>> curr(nums.size(), {\"\", 0});\\n            for(int j=0; j<nums.size(); ++j) {\\n                curr[j]={nums[j].substr(nums[0].size()-queries[i][1], queries[i][1]), j};\\n            }\\n            sort(curr.begin(), curr.end(), compare);\\n         ans[i]=curr[queries[i][0]-1].second;\\n        }\\n     return ans;\\n    }\\n};\\n/**\\nif(find helpful) {\\ndo upvote(); // thanks:)\\n}\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2293983,
                "title": "explained-c-set-easy",
                "content": "The idea used -\\nIterate over queries for all queries - \\n* use substr (stl) to get the trimmed string for all string.\\n* put the strings in set of pair where at first string is present and at second it\\'s indices as we have to return index of ans.\\n* Now as we know set itself have elements in sorted order and we require kth smallest element and if set size becomes bigger than k so we know we can remove last element. (For opitmiztion). \\n* then as our set is of size k we take the last element of set and put the index in answer.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& q) {\\n        vector<int> ans; \\n        for(int i=0; i<q.size(); i++){\\n            int trim= q[i][1],k=q[i][0];\\n            set<pair<string,int>> st;\\n            for(int j=0; j<nums.size(); j++){\\n                int n= nums[j].length();\\n                st.insert({nums[j].substr(n-trim,n),j});\\n                if(st.size()>k){\\n                    auto it= --st.end();\\n                    st.erase(it);\\n                }\\n            }\\n            auto it= --st.end();\\n            ans.push_back(it->second);\\n        }\\n        return ans;\\n    }\\n};\\n```\\nHope you liked it ^_^",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& q) {\\n        vector<int> ans; \\n        for(int i=0; i<q.size(); i++){\\n            int trim= q[i][1],k=q[i][0];\\n            set<pair<string,int>> st;\\n            for(int j=0; j<nums.size(); j++){\\n                int n= nums[j].length();\\n                st.insert({nums[j].substr(n-trim,n),j});\\n                if(st.size()>k){\\n                    auto it= --st.end();\\n                    st.erase(it);\\n                }\\n            }\\n            auto it= --st.end();\\n            ans.push_back(it->second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2293917,
                "title": "pipeline",
                "content": "Brute Force with pipeline in Javascript.\\n\\nSo for each query, do this steps:\\n1. trim\\n2. add its index\\n3. sort \\n4. return `Kth - 1` smallest index\\n\\nDone :D\\n\\n Tricks:\\n1. You don\\'t need to convert nums string to BigInt. Just sort the string\\n\\n**Javascript**\\n```\\nfunction smallestTrimmedNumbers(nums, queries) {\\n  const len = nums[0].length;\\n  return queries.map(([Kth, trim]) => {\\n    const sorted = nums\\n      .map((num) => num.slice(len - trim, len))\\n      .map((num, idx) => [num, idx])\\n      .sort((a, b) => a[0].localeCompare(b[0]));\\n\\n    return sorted[Kth - 1][1];\\n  });\\n}\\n```\\n\\n**Notes :**\\nThe below code doesn\\'t has a significant performance with previous code. I prefer a more readable code when use pipeline.\\n```\\nfunction smallestTrimmedNumbers(nums, queries) {\\n  const len = nums[0].length;\\n  return queries.map(([Kth, trim]) => {\\n    const sorted = nums\\n      .map((num, idx) => [num.slice(len - trim, len), idx])\\n      .sort((a, b) => a[0].localeCompare(b[0]));\\n\\n    return sorted[Kth - 1][1];\\n  });\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Sorting"
                ],
                "code": "```\\nfunction smallestTrimmedNumbers(nums, queries) {\\n  const len = nums[0].length;\\n  return queries.map(([Kth, trim]) => {\\n    const sorted = nums\\n      .map((num) => num.slice(len - trim, len))\\n      .map((num, idx) => [num, idx])\\n      .sort((a, b) => a[0].localeCompare(b[0]));\\n\\n    return sorted[Kth - 1][1];\\n  });\\n}\\n```\n```\\nfunction smallestTrimmedNumbers(nums, queries) {\\n  const len = nums[0].length;\\n  return queries.map(([Kth, trim]) => {\\n    const sorted = nums\\n      .map((num, idx) => [num.slice(len - trim, len), idx])\\n      .sort((a, b) => a[0].localeCompare(b[0]));\\n\\n    return sorted[Kth - 1][1];\\n  });\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2293908,
                "title": "like-suffix-array",
                "content": "```\\nclass Solution:\\n    def smallestTrimmedNumbers(self, nums: List[str], queries: List[List[int]]) -> List[int]:\\n        n = len(nums)\\n        m = len(nums[0])\\n        rank = [[0] * (m + 1) for _ in range(n)]\\n        q = defaultdict(set)\\n        for i in range(len(queries)):\\n            q[queries[i][1]].add(i)\\n        ans = [-1] * len(queries)\\n        for l in range(1, m + 1):\\n            arr = [(rank[i][l-1] + int(nums[i][-l]) * n, i) for i in range(n)]\\n            arr.sort()\\n            r = -1\\n            pre = -1\\n            for score, idx in arr:\\n                if score != pre:\\n                    r += 1\\n                rank[idx][l] = r    \\n                pre = score\\n            for k in q[l]:\\n                ans[k] = arr[queries[k][0] - 1][1]\\n        return ans\\n                \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def smallestTrimmedNumbers(self, nums: List[str], queries: List[List[int]]) -> List[int]:\\n        n = len(nums)\\n        m = len(nums[0])\\n        rank = [[0] * (m + 1) for _ in range(n)]\\n        q = defaultdict(set)\\n        for i in range(len(queries)):\\n            q[queries[i][1]].add(i)\\n        ans = [-1] * len(queries)\\n        for l in range(1, m + 1):\\n            arr = [(rank[i][l-1] + int(nums[i][-l]) * n, i) for i in range(n)]\\n            arr.sort()\\n            r = -1\\n            pre = -1\\n            for score, idx in arr:\\n                if score != pre:\\n                    r += 1\\n                rank[idx][l] = r    \\n                pre = score\\n            for k in q[l]:\\n                ans[k] = arr[queries[k][0] - 1][1]\\n        return ans\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2293860,
                "title": "javascript-preprocess-trims",
                "content": "I hate questions that rely on BigInt \\n```\\nvar smallestTrimmedNumbers = function(nums, queries) {\\n  let n = nums[0].length;\\n  nums = nums.map((num, i) => [BigInt(num), i]);\\n  let trimmed = Array.from(Array(n + 1), () => []);\\n  for (let trim = n; trim >= 1; trim--) {\\n    for (let [num, i] of nums)\\n      trimmed[trim].push([num % (BigInt(10) ** BigInt(trim)), i]);\\n    trimmed[trim].sort((a,b) => a[0] === b[0] ? a[1] - b[1] : Number(a[0] - b[0]));\\n  }\\n  \\n  return queries.map(([k, trim]) => trimmed[trim][k - 1][1]);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar smallestTrimmedNumbers = function(nums, queries) {\\n  let n = nums[0].length;\\n  nums = nums.map((num, i) => [BigInt(num), i]);\\n  let trimmed = Array.from(Array(n + 1), () => []);\\n  for (let trim = n; trim >= 1; trim--) {\\n    for (let [num, i] of nums)\\n      trimmed[trim].push([num % (BigInt(10) ** BigInt(trim)), i]);\\n    trimmed[trim].sort((a,b) => a[0] === b[0] ? a[1] - b[1] : Number(a[0] - b[0]));\\n  }\\n  \\n  return queries.map(([k, trim]) => trimmed[trim][k - 1][1]);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2293756,
                "title": "java-c-sorting",
                "content": "**Java**\\nRuntime: 341 ms, faster than 25.00% of Java online submissions for Query Kth Smallest Trimmed Number.\\nMemory Usage: 50.6 MB, less than 87.50% of Java online submissions for Query Kth Smallest Trimmed Number.\\n```\\npublic class Pair implements Comparable<Pair> {\\n  public int id;\\n  public String s;\\n\\n  public Pair(String s, int id){\\n    this.id = id;\\n    this.s  = s;\\n  }\\n\\n  @Override\\n  public int compareTo(Pair other) {                                      //comparator for sorting\\n    if(this.s.compareTo(other.s) == 0) return this.id - other.id; \\n    return this.s.compareTo(other.s);                                     //in increasing order \\n  }\\n}\\n\\nclass Solution {\\n  public int[] smallestTrimmedNumbers(String[] nums, int[][] queries) {\\n    Pair table[][] = new Pair[nums[0].length() + 1][nums.length];\\n    int ans[] = new int[queries.length];\\n    \\n    for(int i = 0; i != nums.length; i++)\\n      for(int j = nums[i].length() - 1, k = 1; j >=0; j--, k++)\\n        table[k][i] = new Pair(nums[i].substring(j), i);\\n    \\n    for(int i = 1; i != table.length; i++)\\n      Arrays.sort(table[i]);\\n   \\n    for(int i = 0; i != queries.length; i++)\\n      ans[i] = table[queries[i][1]][queries[i][0]-1].id;\\n    \\n    return ans;\\n  }\\n}\\n```\\n**C++**\\nRuntime: 1287 ms, faster than 22.22% of C++ online submissions for Query Kth Smallest Trimmed Number.\\nMemory Usage: 240.2 MB, less than 11.11% of C++ online submissions for Query Kth Smallest Trimmed Number.\\n```  \\nclass Solution {\\npublic:\\n  vector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& queries) {\\n    vector<vector<pair<string,int>>> table(nums[0].size() + 1, vector<pair<string,int>>(nums.size() ));\\n    vector<int> ans(queries.size());\\n    \\n    for(int i = 0; i != nums.size(); i++)\\n      for(int j = nums[i].size() - 1, k = 1; j >=0; j--, k++)\\n        table[k][i] = {nums[i].substr(j, k), i};\\n    \\n    for(int i = 1; i != nums[0].size() + 1; i++)\\n      sort(table[i].begin(), table[i].end(), [](pair<string,int> &a, pair<string,int> &b)\\n            {return a.first == b.first ? a.second < b.second : a.first < b.first;});\\n   \\n    for(int i = 0; i != queries.size(); i++)\\n      ans[i] = table[queries[i][1]][queries[i][0]-1].second;\\n    \\n    return ans;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C"
                ],
                "code": "```\\npublic class Pair implements Comparable<Pair> {\\n  public int id;\\n  public String s;\\n\\n  public Pair(String s, int id){\\n    this.id = id;\\n    this.s  = s;\\n  }\\n\\n  @Override\\n  public int compareTo(Pair other) {                                      //comparator for sorting\\n    if(this.s.compareTo(other.s) == 0) return this.id - other.id; \\n    return this.s.compareTo(other.s);                                     //in increasing order \\n  }\\n}\\n\\nclass Solution {\\n  public int[] smallestTrimmedNumbers(String[] nums, int[][] queries) {\\n    Pair table[][] = new Pair[nums[0].length() + 1][nums.length];\\n    int ans[] = new int[queries.length];\\n    \\n    for(int i = 0; i != nums.length; i++)\\n      for(int j = nums[i].length() - 1, k = 1; j >=0; j--, k++)\\n        table[k][i] = new Pair(nums[i].substring(j), i);\\n    \\n    for(int i = 1; i != table.length; i++)\\n      Arrays.sort(table[i]);\\n   \\n    for(int i = 0; i != queries.length; i++)\\n      ans[i] = table[queries[i][1]][queries[i][0]-1].id;\\n    \\n    return ans;\\n  }\\n}\\n```\n```  \\nclass Solution {\\npublic:\\n  vector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& queries) {\\n    vector<vector<pair<string,int>>> table(nums[0].size() + 1, vector<pair<string,int>>(nums.size() ));\\n    vector<int> ans(queries.size());\\n    \\n    for(int i = 0; i != nums.size(); i++)\\n      for(int j = nums[i].size() - 1, k = 1; j >=0; j--, k++)\\n        table[k][i] = {nums[i].substr(j, k), i};\\n    \\n    for(int i = 1; i != nums[0].size() + 1; i++)\\n      sort(table[i].begin(), table[i].end(), [](pair<string,int> &a, pair<string,int> &b)\\n            {return a.first == b.first ? a.second < b.second : a.first < b.first;});\\n   \\n    for(int i = 0; i != queries.size(); i++)\\n      ans[i] = table[queries[i][1]][queries[i][0]-1].second;\\n    \\n    return ans;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2293653,
                "title": "c-radix-sort-only-once-o-nd-q",
                "content": "Proprocess the Radix Sort once. For each processed x-th digit, we can memorize it as a x-th trims \\ne.g.1 after do Radix Sort on most right digit, it is the same as we trim until it remain 1 digit and then sort.\\ne.g.3 after do Radix Sort on last 3 digits, it is the same as we trim until it remain 3 digit and then sort.\\n\\nAnd then we can query from the preprocessed array.\\n\\nO(nd + q)\\nn is the length of nums\\nd is the length of each string (nums[j].length)\\nq is number of queries\\n\\nHope this will help!\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& queries) {\\n        vector<int> answer;\\n        vector<vector<int>> mem(110, vector<int>());\\n        vector<int> v, temp;\\n        for(int i = 0; i < nums.size(); i++) v.push_back(i);\\n        vector<vector<int>> b(10, vector<int>());\\n        for (int d = (int)nums[0].length() - 1; d >= 0; d--) {\\n            for (int p = 0; p < v.size(); p++) {\\n                b[nums[v[p]][d] - \\'0\\'].push_back(v[p]);\\n            }\\n            for (int di = 0; di <= 9; di++) {\\n                for (int p = 0; p < b[di].size(); p++) {\\n                    temp.push_back(b[di][p]);\\n                }\\n                b[di].clear();\\n            }\\n            v = temp;\\n            temp.clear();\\n            mem[d] = v;\\n        }\\n        for (int i = 0; i < queries.size(); i++) {\\n            int l = (int)nums[0].length();\\n            answer.push_back(mem[l - queries[i][1]][queries[i][0] - 1]);\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& queries) {\\n        vector<int> answer;\\n        vector<vector<int>> mem(110, vector<int>());\\n        vector<int> v, temp;\\n        for(int i = 0; i < nums.size(); i++) v.push_back(i);\\n        vector<vector<int>> b(10, vector<int>());\\n        for (int d = (int)nums[0].length() - 1; d >= 0; d--) {\\n            for (int p = 0; p < v.size(); p++) {\\n                b[nums[v[p]][d] - \\'0\\'].push_back(v[p]);\\n            }\\n            for (int di = 0; di <= 9; di++) {\\n                for (int p = 0; p < b[di].size(); p++) {\\n                    temp.push_back(b[di][p]);\\n                }\\n                b[di].clear();\\n            }\\n            v = temp;\\n            temp.clear();\\n            mem[d] = v;\\n        }\\n        for (int i = 0; i < queries.size(); i++) {\\n            int l = (int)nums[0].length();\\n            answer.push_back(mem[l - queries[i][1]][queries[i][0] - 1]);\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2293379,
                "title": "c-linq-one-liner-7-lines-o-q-n-l-time-o-n-l-space",
                "content": "O(q * n * L) time, O(n * L) space\\nq - number of queries.\\nn - number of strings,\\nL - max length of a string\\n```\\npublic class Solution \\n{\\n    public int[] SmallestTrimmedNumbers(string[] nums, int[][] queries) => queries\\n        .Aggregate(Enumerable.Empty<int>(), \\n                   (ans, query) => ans.Append(nums\\n                                              .Select((s, index) => (s, index))\\n                                              .OrderBy(p => (p.s[^query[1]..], p.index))\\n                                              .ElementAt(query[0] - 1)\\n                                              .index),\\n                   ans => ans.ToArray());\\n}\\n```\\n****\\n**Why O((q * n) * L) and not O((q * n * log(n)) * L)?**\\nOrderBy() time complexity is O(n * q + k * q * log k) where k is the number of consecutive elements we take from sequence, n - number of elements, q - time to make one comparison.\\n(*I am 90% sure of this*)\\n\\nThis means time complexity of \\n```\\n.OrderBy(p => (p.s[^query[1]..], p.index))\\n.ElementAt(query[0] - 1)\\n```\\nis O(q * n + 1 * q * log 1) = O(q * n)\\n \\n****\\n[OrderedEnumerable implementation](https://github.com/dotnet/corefx/blob/master/src/System.Linq/src/System/Linq/OrderedEnumerable.cs)",
                "solutionTags": [],
                "code": "```\\npublic class Solution \\n{\\n    public int[] SmallestTrimmedNumbers(string[] nums, int[][] queries) => queries\\n        .Aggregate(Enumerable.Empty<int>(), \\n                   (ans, query) => ans.Append(nums\\n                                              .Select((s, index) => (s, index))\\n                                              .OrderBy(p => (p.s[^query[1]..], p.index))\\n                                              .ElementAt(query[0] - 1)\\n                                              .index),\\n                   ans => ans.ToArray());\\n}\\n```\n```\\n.OrderBy(p => (p.s[^query[1]..], p.index))\\n.ElementAt(query[0] - 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2293366,
                "title": "java-clean-simple-quickselect-algorithm",
                "content": "```\\nclass Solution {\\n\\n    class Pair implements Comparable<Pair> {\\n        String s;\\n        int index;\\n\\n        public Pair(String s, int index) {\\n            this.s = s;\\n            this.index = index;\\n        }\\n\\n        public int compareTo(Pair o) {\\n            if (this.s.equals(o.s)) return Integer.compare(this.index, o.index);\\n            return this.s.compareTo(o.s);\\n        }\\n    }\\n\\n    public int[] smallestTrimmedNumbers(String[] nums, int[][] queries) {\\n        int[] result = new int[queries.length];\\n        int resultIndex = 0;\\n        Map<Integer, String[]> trimToArray = new HashMap<>();\\n        for (int[] q : queries) {\\n            int trim = q[1];\\n            if (!trimToArray.containsKey(trim)) {\\n                trimToArray.put(trim, trim(nums, trim));\\n            }\\n            String[] trimmedArr = trimToArray.get(trim);\\n            Pair[] pairs = new Pair[trimmedArr.length];\\n            for (int i = 0; i < trimmedArr.length; i++) {\\n                pairs[i] = new Pair(trimmedArr[i], i);\\n            }\\n            Pair found = findKthSmallest(pairs, q[0]);\\n            result[resultIndex++] = found.index;\\n        }\\n        return result;\\n    }\\n\\n    public String[] trim(String[] nums, int trim) {\\n        int fullLength = nums[0].length();\\n        if (trim == fullLength) return nums;\\n        String[] trimmed = new String[nums.length];\\n        for (int i = 0; i < nums.length; i++) {\\n            trimmed[i] = nums[i].substring(fullLength - trim);\\n        }\\n        return trimmed;\\n    }\\n\\n    public Pair findKthSmallest(Pair[] pairs, int k) {\\n        k = k - 1;\\n        int l = 0;\\n        int r = pairs.length - 1;\\n        while (l < r) {\\n            int index = partition(pairs, l, r);\\n            if (index == k) return pairs[k];\\n            else if (index < k) l = index + 1;\\n            else r = index - 1;\\n        }\\n        return pairs[k];\\n    }\\n\\n    int partition(Pair[] pairs, int l, int r) {\\n        int m = l + (r - l) / 2;\\n        swap(pairs, m, r);\\n        Pair pivot = pairs[r];\\n        int i = l;\\n        int j = l;\\n        while (j < r) {\\n            if (pairs[j].compareTo(pivot) <= 0) {\\n                swap(pairs, i, j);\\n                i++;\\n            }\\n            j++;\\n        }\\n        swap(pairs, i, r);\\n        return i;\\n    }\\n\\n    void swap(Pair[] pairs, int i, int j) {\\n        Pair temp = pairs[i];\\n        pairs[i] = pairs[j];\\n        pairs[j] = temp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Quickselect"
                ],
                "code": "```\\nclass Solution {\\n\\n    class Pair implements Comparable<Pair> {\\n        String s;\\n        int index;\\n\\n        public Pair(String s, int index) {\\n            this.s = s;\\n            this.index = index;\\n        }\\n\\n        public int compareTo(Pair o) {\\n            if (this.s.equals(o.s)) return Integer.compare(this.index, o.index);\\n            return this.s.compareTo(o.s);\\n        }\\n    }\\n\\n    public int[] smallestTrimmedNumbers(String[] nums, int[][] queries) {\\n        int[] result = new int[queries.length];\\n        int resultIndex = 0;\\n        Map<Integer, String[]> trimToArray = new HashMap<>();\\n        for (int[] q : queries) {\\n            int trim = q[1];\\n            if (!trimToArray.containsKey(trim)) {\\n                trimToArray.put(trim, trim(nums, trim));\\n            }\\n            String[] trimmedArr = trimToArray.get(trim);\\n            Pair[] pairs = new Pair[trimmedArr.length];\\n            for (int i = 0; i < trimmedArr.length; i++) {\\n                pairs[i] = new Pair(trimmedArr[i], i);\\n            }\\n            Pair found = findKthSmallest(pairs, q[0]);\\n            result[resultIndex++] = found.index;\\n        }\\n        return result;\\n    }\\n\\n    public String[] trim(String[] nums, int trim) {\\n        int fullLength = nums[0].length();\\n        if (trim == fullLength) return nums;\\n        String[] trimmed = new String[nums.length];\\n        for (int i = 0; i < nums.length; i++) {\\n            trimmed[i] = nums[i].substring(fullLength - trim);\\n        }\\n        return trimmed;\\n    }\\n\\n    public Pair findKthSmallest(Pair[] pairs, int k) {\\n        k = k - 1;\\n        int l = 0;\\n        int r = pairs.length - 1;\\n        while (l < r) {\\n            int index = partition(pairs, l, r);\\n            if (index == k) return pairs[k];\\n            else if (index < k) l = index + 1;\\n            else r = index - 1;\\n        }\\n        return pairs[k];\\n    }\\n\\n    int partition(Pair[] pairs, int l, int r) {\\n        int m = l + (r - l) / 2;\\n        swap(pairs, m, r);\\n        Pair pivot = pairs[r];\\n        int i = l;\\n        int j = l;\\n        while (j < r) {\\n            if (pairs[j].compareTo(pivot) <= 0) {\\n                swap(pairs, i, j);\\n                i++;\\n            }\\n            j++;\\n        }\\n        swap(pairs, i, r);\\n        return i;\\n    }\\n\\n    void swap(Pair[] pairs, int i, int j) {\\n        Pair temp = pairs[i];\\n        pairs[i] = pairs[j];\\n        pairs[j] = temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2293277,
                "title": "accepted-priority-queue-solution",
                "content": "```c++\\nclass Data {\\npublic:\\n    int index;\\n    string val;\\n    \\n    Data(int index, string val) {\\n        this->index = index;\\n        this->val = val;\\n    }\\n};\\n\\nclass compare {\\npublic:\\n    bool operator()(Data &a, Data &b) {\\n        if(a.val == b.val) return a.index < b.index;\\n        return a.val < b.val;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& queries) {\\n        vector<int> ans;\\n        int n = nums.size();\\n        \\n        for(vector<int>& query : queries) {\\n            int trimSize = query[1];\\n            int k = query[0];\\n            \\n            priority_queue<Data,vector<Data>,compare> pq;\\n            \\n            for(int i = 0 ; i<n ; i++) {\\n                string val = nums[i];\\n                int size = val.size() - trimSize;\\n                string num = val.substr(size,val.size());\\n                \\n                if(pq.size() >= k) {\\n                    if(pq.top().val > num) {\\n                        pq.pop();\\n                        Data value(i,num);\\n                        pq.push(value);\\n                    }\\n                } else {\\n                    Data value(i,num);\\n                    pq.push(value);\\n                }\\n            }\\n            ans.push_back(pq.top().index);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```c++\\nclass Data {\\npublic:\\n    int index;\\n    string val;\\n    \\n    Data(int index, string val) {\\n        this->index = index;\\n        this->val = val;\\n    }\\n};\\n\\nclass compare {\\npublic:\\n    bool operator()(Data &a, Data &b) {\\n        if(a.val == b.val) return a.index < b.index;\\n        return a.val < b.val;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& queries) {\\n        vector<int> ans;\\n        int n = nums.size();\\n        \\n        for(vector<int>& query : queries) {\\n            int trimSize = query[1];\\n            int k = query[0];\\n            \\n            priority_queue<Data,vector<Data>,compare> pq;\\n            \\n            for(int i = 0 ; i<n ; i++) {\\n                string val = nums[i];\\n                int size = val.size() - trimSize;\\n                string num = val.substr(size,val.size());\\n                \\n                if(pq.size() >= k) {\\n                    if(pq.top().val > num) {\\n                        pq.pop();\\n                        Data value(i,num);\\n                        pq.push(value);\\n                    }\\n                } else {\\n                    Data value(i,num);\\n                    pq.push(value);\\n                }\\n            }\\n            ans.push_back(pq.top().index);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2293258,
                "title": "python-caching-and-quickselect-better-time-complexity-than-sorting",
                "content": "When computing Kth smallest for first time, use quickselect (O(n), better time complexity than sorting which is O(n log n). Cache results and trimmed lists.\\n\\n```\\nclass Solution:\\n    def smallestTrimmedNumbers(self, nums: List[str], queries: List[List[int]]) -> List[int]:\\n        \\n        trim_cache = {}\\n        result_cache = {}\\n        \\n        output = []\\n        \\n        def quickselect(lst, l, r, k):\\n            if l == r:\\n                return lst[k - 1]\\n            pi = partition(lst, l, r)\\n            if k - 1 < pi:\\n                return quickselect(lst, l, pi - 1, k)\\n            elif k - 1 > pi:\\n                return quickselect(lst, pi + 1, r, k)\\n            else:\\n                return lst[k - 1]\\n        \\n        def partition(lst, l, r):\\n            p = randint(l, r)\\n            lst[p], lst[r] = lst[r], lst[p]\\n            i = l\\n            for j in range(l, r):\\n                if lst[j][0] < lst[r][0] or (lst[j][0] == lst[r][0] and lst[j][1] < lst[r][1]):\\n                    lst[j], lst[i] = lst[i], lst[j]\\n                    i += 1\\n            lst[r], lst[i] = lst[i], lst[r]\\n            return i\\n        \\n        for k, trim in queries:\\n            if trim not in trim_cache:\\n                trim_cache[trim] = [(int(nums[i][-trim:]), i) for i in range(len(nums))]\\n            if (k, trim) not in result_cache:\\n                result_cache[(k, trim)] =  quickselect(trim_cache[trim], 0, len(nums) - 1, k)[1]\\n            output.append(result_cache[(k, trim)])\\n        \\n        return output\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def smallestTrimmedNumbers(self, nums: List[str], queries: List[List[int]]) -> List[int]:\\n        \\n        trim_cache = {}\\n        result_cache = {}\\n        \\n        output = []\\n        \\n        def quickselect(lst, l, r, k):\\n            if l == r:\\n                return lst[k - 1]\\n            pi = partition(lst, l, r)\\n            if k - 1 < pi:\\n                return quickselect(lst, l, pi - 1, k)\\n            elif k - 1 > pi:\\n                return quickselect(lst, pi + 1, r, k)\\n            else:\\n                return lst[k - 1]\\n        \\n        def partition(lst, l, r):\\n            p = randint(l, r)\\n            lst[p], lst[r] = lst[r], lst[p]\\n            i = l\\n            for j in range(l, r):\\n                if lst[j][0] < lst[r][0] or (lst[j][0] == lst[r][0] and lst[j][1] < lst[r][1]):\\n                    lst[j], lst[i] = lst[i], lst[j]\\n                    i += 1\\n            lst[r], lst[i] = lst[i], lst[r]\\n            return i\\n        \\n        for k, trim in queries:\\n            if trim not in trim_cache:\\n                trim_cache[trim] = [(int(nums[i][-trim:]), i) for i in range(len(nums))]\\n            if (k, trim) not in result_cache:\\n                result_cache[(k, trim)] =  quickselect(trim_cache[trim], 0, len(nums) - 1, k)[1]\\n            output.append(result_cache[(k, trim)])\\n        \\n        return output\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2293204,
                "title": "easy-simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& queries) {\\n        int size = nums[0].size();\\n        vector<int> ans;\\n        for(int i = 0; i < queries.size(); i++) {\\n            priority_queue<pair<string, int>> pq;\\n            int k = queries[i][1];\\n            for(int j = 0; j < nums.size(); j++) {\\n                string s1 = nums[j].substr(size - k, k);\\n                pq.push({s1, j}); \\n                if(pq.size() > queries[i][0]) {\\n                    pq.pop();\\n                }\\n            }\\n            ans.push_back(pq.top().second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& queries) {\\n        int size = nums[0].size();\\n        vector<int> ans;\\n        for(int i = 0; i < queries.size(); i++) {\\n            priority_queue<pair<string, int>> pq;\\n            int k = queries[i][1];\\n            for(int j = 0; j < nums.size(); j++) {\\n                string s1 = nums[j].substr(size - k, k);\\n                pq.push({s1, j}); \\n                if(pq.size() > queries[i][0]) {\\n                    pq.pop();\\n                }\\n            }\\n            ans.push_back(pq.top().second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2293174,
                "title": "javascript",
                "content": "```\\nvar smallestTrimmedNumbers = function(nums, queries) {\\n    let res = [];\\n    for (let [k, trim] of queries) {\\n        const arr = nums.map((e,i) => {\\n            return {index:i,  e: e.slice(e.length - trim)};\\n        }).sort((a,b) => {\\n            if(a.e === b.e) {\\n                return a.index - b.index;\\n            }\\n            return a.e.localeCompare(b.e);\\n        });\\n        res.push(arr[k-1].index)\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar smallestTrimmedNumbers = function(nums, queries) {\\n    let res = [];\\n    for (let [k, trim] of queries) {\\n        const arr = nums.map((e,i) => {\\n            return {index:i,  e: e.slice(e.length - trim)};\\n        }).sort((a,b) => {\\n            if(a.e === b.e) {\\n                return a.index - b.index;\\n            }\\n            return a.e.localeCompare(b.e);\\n        });\\n        res.push(arr[k-1].index)\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2293153,
                "title": "javascript-simple-loop-1050ms",
                "content": "```\\n/**\\n * @param {string[]} nums\\n * @param {number[][]} queries\\n * @return {number[]}\\n */\\nvar smallestTrimmedNumbers = function(nums, queries) {\\n    let result = [], tempArray = [];\\n    for (let query of queries) {\\n        tempArray = nums.map((data,index) => {\\n            return {\\n                data: BigInt(`${data}`.substr(`${data}`.length-query[1], query[1])),\\n                index\\n            };\\n        }).sort((a,b)=> Number(a.data-b.data) || a.index-b.index);\\n        result.push(tempArray[query[0]-1].index);\\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} nums\\n * @param {number[][]} queries\\n * @return {number[]}\\n */\\nvar smallestTrimmedNumbers = function(nums, queries) {\\n    let result = [], tempArray = [];\\n    for (let query of queries) {\\n        tempArray = nums.map((data,index) => {\\n            return {\\n                data: BigInt(`${data}`.substr(`${data}`.length-query[1], query[1])),\\n                index\\n            };\\n        }).sort((a,b)=> Number(a.data-b.data) || a.index-b.index);\\n        result.push(tempArray[query[0]-1].index);\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2293107,
                "title": "javascript-priority-queue",
                "content": "The idea is simple, trim the number, put it into a heap, then substract the kth element.\\nNote that the order of indices is also impotant, so add that condition to the priority queue.\\n\\n```js\\n/**\\n * @param {string[]} nums\\n * @param {number[][]} queries\\n * @return {number[]}\\n */\\nvar smallestTrimmedNumbers = function(nums, queries) {\\n    const l = nums[0].length;\\n    const res = [];\\n    for(const q of queries) {\\n        const [k,trim] = q;\\n        const pq = new MinPriorityQueue({\\n            compare: (a,b) => {\\n                if(a[0] - b[0] !== 0n) return a[0] - b[0];\\n                return a[1] - b[1];\\n            }\\n        });\\n        \\n        for(let i = 0 ; i < nums.length; i++) {\\n            const n = nums[i];\\n            pq.enqueue([BigInt(n.substring(l-trim)),i]);\\n        }\\n        for(let i = 1 ; i < k; i++) \\n            pq.dequeue();\\n        \\n        res.push(pq.dequeue()[1]);\\n    }\\n    return res;\\n};\\n```\\n\\nAs always I\\'m willing to answer any questions. This was my contest submition, so the code can be cleaner.",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```js\\n/**\\n * @param {string[]} nums\\n * @param {number[][]} queries\\n * @return {number[]}\\n */\\nvar smallestTrimmedNumbers = function(nums, queries) {\\n    const l = nums[0].length;\\n    const res = [];\\n    for(const q of queries) {\\n        const [k,trim] = q;\\n        const pq = new MinPriorityQueue({\\n            compare: (a,b) => {\\n                if(a[0] - b[0] !== 0n) return a[0] - b[0];\\n                return a[1] - b[1];\\n            }\\n        });\\n        \\n        for(let i = 0 ; i < nums.length; i++) {\\n            const n = nums[i];\\n            pq.enqueue([BigInt(n.substring(l-trim)),i]);\\n        }\\n        for(let i = 1 ; i < k; i++) \\n            pq.dequeue();\\n        \\n        res.push(pq.dequeue()[1]);\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2293038,
                "title": "i-have-some-question-i-use-for-loop-get-the-tle",
                "content": "this get the TLE\\n```\\nclass Solution {\\npublic:\\n    vector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& queries) {\\n        vector<int> ans;\\n        for(auto i : queries)\\n        {\\n            vector<pair<string,int>> tmp;\\n            int count = 0;\\n            for(auto j : nums)\\n            {\\n                string s=\"\";\\n                for(int k =j.length()-i[1];k<j.length();k++)\\n                {\\n                    s+=j[k];\\n                }\\n                tmp.push_back(make_pair(s,count++));\\n                \\n            }\\n            sort(tmp.begin(),tmp.end());\\n            ans.push_back(tmp[i[0]-1].second);\\n        }\\n        return ans;\\n    }\\n};\\n```\\nwhile this accept\\n```\\nclass Solution {\\npublic:\\n    vector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& queries) {\\n        vector<int> ans;\\n        for(auto i : queries)\\n        {\\n            vector<pair<string,int>> tmp;\\n            int count = 0;\\n            for(auto j : nums)\\n            {\\n                tmp.push_back(make_pair(j.substr(j.length()-i[1],i[1]),count++));\\n                \\n            }\\n            sort(tmp.begin(),tmp.end());\\n            ans.push_back(tmp[i[0]-1].second);\\n        }\\n        return ans;\\n    }\\n};\\n```\\nshouldn\\'t they have the same time complexity?\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& queries) {\\n        vector<int> ans;\\n        for(auto i : queries)\\n        {\\n            vector<pair<string,int>> tmp;\\n            int count = 0;\\n            for(auto j : nums)\\n            {\\n                string s=\"\";\\n                for(int k =j.length()-i[1];k<j.length();k++)\\n                {\\n                    s+=j[k];\\n                }\\n                tmp.push_back(make_pair(s,count++));\\n                \\n            }\\n            sort(tmp.begin(),tmp.end());\\n            ans.push_back(tmp[i[0]-1].second);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& queries) {\\n        vector<int> ans;\\n        for(auto i : queries)\\n        {\\n            vector<pair<string,int>> tmp;\\n            int count = 0;\\n            for(auto j : nums)\\n            {\\n                tmp.push_back(make_pair(j.substr(j.length()-i[1],i[1]),count++));\\n                \\n            }\\n            sort(tmp.begin(),tmp.end());\\n            ans.push_back(tmp[i[0]-1].second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2292975,
                "title": "clean-and-concise-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& queries) {\\n        vector<int> ans;\\n        unordered_map<int, vector<pair<string, int>> > m;\\n        \\n        for (int i=0; i<queries.size(); i++)  {\\n            if (m.count(queries[i][1])) {\\n                ans.push_back(m[queries[i][1]][queries[i][0]-1].second);\\n                continue;\\n            }\\n\\n            for (int j=0; j<nums.size(); j++) {\\n                string cur = nums[j].substr(nums[j].size() - queries[i][1]);\\n                m[queries[i][1]].push_back({cur, j});\\n            }\\n            sort(m[queries[i][1]].begin(), m[queries[i][1]].end());\\n            \\n            ans.push_back(m[queries[i][1]][queries[i][0]-1].second);\\n        }\\n        \\n        return ans;\\n\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& queries) {\\n        vector<int> ans;\\n        unordered_map<int, vector<pair<string, int>> > m;\\n        \\n        for (int i=0; i<queries.size(); i++)  {\\n            if (m.count(queries[i][1])) {\\n                ans.push_back(m[queries[i][1]][queries[i][0]-1].second);\\n                continue;\\n            }\\n\\n            for (int j=0; j<nums.size(); j++) {\\n                string cur = nums[j].substr(nums[j].size() - queries[i][1]);\\n                m[queries[i][1]].push_back({cur, j});\\n            }\\n            sort(m[queries[i][1]].begin(), m[queries[i][1]].end());\\n            \\n            ans.push_back(m[queries[i][1]][queries[i][0]-1].second);\\n        }\\n        \\n        return ans;\\n\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2292970,
                "title": "c-easy-to-understand-solution",
                "content": "\\n \\n    vector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& queries) {\\n         vector<int> ans;\\n        \\n        for(int i=0;i<queries.size();i++){\\n\\t\\t\\n            //Create a min priority_queue with pair(element(trimmed),index)\\n            priority_queue<pair<string,int>,vector<pair<string,int>>,greater<pair<string,int>>> pq;\\n            \\n            //Put pairs in priority_queue\\n            for(int j=0;j<nums.size();j++){\\n                    pq.push({nums[j].substr(nums[j].size()-queries[i][1]),j});\\n            }\\n            \\n            //Pop to get the required smallest element\\n            int k=1;\\n            while(k!=queries[i][0]){\\n                pq.pop();\\n                k++;\\n            }  \\n            //Push the required element\\'s index\\n            ans.push_back(pq.top().second);\\n        }\\n        return ans;   \\n    }",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "\\n \\n    vector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& queries) {\\n         vector<int> ans;\\n        \\n        for(int i=0;i<queries.size();i++){\\n\\t\\t\\n            //Create a min priority_queue with pair(element(trimmed),index)\\n            priority_queue<pair<string,int>,vector<pair<string,int>>,greater<pair<string,int>>> pq;\\n            \\n            //Put pairs in priority_queue\\n            for(int j=0;j<nums.size();j++){\\n                    pq.push({nums[j].substr(nums[j].size()-queries[i][1]),j});\\n            }\\n            \\n            //Pop to get the required smallest element\\n            int k=1;\\n            while(k!=queries[i][0]){\\n                pq.pop();\\n                k++;\\n            }  \\n            //Push the required element\\'s index\\n            ans.push_back(pq.top().second);\\n        }\\n        return ans;   \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2292915,
                "title": "same-idea-with-the-same-approach-but-got-tle-leetcode-why-is-like-this",
                "content": "this code got TLE:\\n\\n`vector<int> result;\\n        int len = nums[0].length();\\n        \\n        for (vector<int> v : queries) {\\n            multimap<string, int> mp;\\n            int k = v[0];\\n            for (int i = 0; i < nums.size(); i++) {\\n                string number = nums[i].substr(len-v[1]);\\n                mp.insert({number, i});\\n            }\\n            \\n            auto it = mp.begin();\\n            int i = 0;\\n            \\n            while (it != mp.end()) {\\n                if (i == k-1) {\\n                    result.push_back(it->second);\\n                    break;\\n                }\\n                i++;\\n                ++it;\\n            }\\n            \\n            \\n        }\\n        \\n        return result;\\n``\\n\\nbut this got accepted:\\n\\nint N = nums.size();\\n        int Q = queries.size();\\n        vector<int> res;\\n        for (int i = 0; i < Q; ++i) {\\n            int trimC = queries[i][1], kth = queries[i][0];\\n            multiset<pair<string, int>> st;\\n            for (int j = 0; j < N; ++j) {\\n                st.insert({nums[j].substr(nums[j].size() - trimC), j});\\n            }\\n            auto it = st.begin();\\n            int cnt = 1;\\n            while (it != st.end()) {\\n                if (cnt == kth) {\\n                    res.push_back(it->second);\\n                    break;\\n                }\\n                ++it;\\n                ++cnt;\\n            }\\n        }\\n        return res;\\n\\n\\n\\nWhat is the diff in this two approaches?",
                "solutionTags": [],
                "code": "this code got TLE:\\n\\n`vector<int> result;\\n        int len = nums[0].length();\\n        \\n        for (vector<int> v : queries) {\\n            multimap<string, int> mp;\\n            int k = v[0];\\n            for (int i = 0; i < nums.size(); i++) {\\n                string number = nums[i].substr(len-v[1]);\\n                mp.insert({number, i});\\n            }\\n            \\n            auto it = mp.begin();\\n            int i = 0;\\n            \\n            while (it != mp.end()) {\\n                if (i == k-1) {\\n                    result.push_back(it->second);\\n                    break;\\n                }\\n                i++;\\n                ++it;\\n            }\\n            \\n            \\n        }\\n        \\n        return result;\\n``\\n\\nbut this got accepted:\\n\\nint N = nums.size();\\n        int Q = queries.size();\\n        vector<int> res;\\n        for (int i = 0; i < Q; ++i) {\\n            int trimC = queries[i][1], kth = queries[i][0];\\n            multiset<pair<string, int>> st;\\n            for (int j = 0; j < N; ++j) {\\n                st.insert({nums[j].substr(nums[j].size() - trimC), j});\\n            }\\n            auto it = st.begin();\\n            int cnt = 1;\\n            while (it != st.end()) {\\n                if (cnt == kth) {\\n                    res.push_back(it->second);\\n                    break;\\n                }\\n                ++it;\\n                ++cnt;\\n            }\\n        }\\n        return res;\\n\\n\\n\\nWhat is the diff in this two approaches?",
                "codeTag": "Unknown"
            },
            {
                "id": 2292877,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int f(vector<string>& nums,int k,int trim) {\\n        priority_queue<pair<string,int>> pq;\\n        int n=nums[0].size();\\n        for (int i=0;i<nums.size();i++) {\\n            pq.push({nums[i].substr(n-trim,trim),i});\\n            if (pq.size()>k) pq.pop();\\n        }\\n        return pq.top().second;\\n    }\\n    vector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& queries) {\\n        vector<int> ans;\\n        for (auto i:queries) {\\n            ans.push_back(f(nums,i[0],i[1]));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int f(vector<string>& nums,int k,int trim) {\\n        priority_queue<pair<string,int>> pq;\\n        int n=nums[0].size();\\n        for (int i=0;i<nums.size();i++) {\\n            pq.push({nums[i].substr(n-trim,trim),i});\\n            if (pq.size()>k) pq.pop();\\n        }\\n        return pq.top().second;\\n    }\\n    vector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& queries) {\\n        vector<int> ans;\\n        for (auto i:queries) {\\n            ans.push_back(f(nums,i[0],i[1]));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2292708,
                "title": "quick-select-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& q) {\\n        int N=nums.size(), M=q.size();\\n        vector<int> ret(M, 0);\\n        \\n        typedef pair<string_view ,int> Pair;\\n        \\n        vector<Pair> v; v.reserve(N);\\n        for(int i=0; i<N; ++i) {\\n            v.emplace_back(nums[i], i);\\n        }\\n        \\n        auto trim = [](string_view& s, int k) {\\n            if(k==s.size()) { return string_view(s); }\\n            return string_view(s.data()+s.size()-k, k);\\n        };\\n        \\n        for(int j=0; j<M; ++j) {\\n            int k=q[j][0], t=q[j][1];\\n            \\n            nth_element(v.begin(), v.begin()+(k-1), v.end(), [&t,&trim](auto& v1, auto& v2){\\n                auto a=trim(v1.first, t), b=trim(v2.first, t);                \\n                return a==b ? v1.second<v2.second : a<b;\\n            });\\n            \\n            ret[j] = v[k-1].second;\\n        }\\n        \\n        return move(ret);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& q) {\\n        int N=nums.size(), M=q.size();\\n        vector<int> ret(M, 0);\\n        \\n        typedef pair<string_view ,int> Pair;\\n        \\n        vector<Pair> v; v.reserve(N);\\n        for(int i=0; i<N; ++i) {\\n            v.emplace_back(nums[i], i);\\n        }\\n        \\n        auto trim = [](string_view& s, int k) {\\n            if(k==s.size()) { return string_view(s); }\\n            return string_view(s.data()+s.size()-k, k);\\n        };\\n        \\n        for(int j=0; j<M; ++j) {\\n            int k=q[j][0], t=q[j][1];\\n            \\n            nth_element(v.begin(), v.begin()+(k-1), v.end(), [&t,&trim](auto& v1, auto& v2){\\n                auto a=trim(v1.first, t), b=trim(v2.first, t);                \\n                return a==b ? v1.second<v2.second : a<b;\\n            });\\n            \\n            ret[j] = v[k-1].second;\\n        }\\n        \\n        return move(ret);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4093445,
                "title": "java-radix-sort-n-m-time-complexity-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nradix sort\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(m*n)   ,  m=length of the string \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] smallestTrimmedNumbers(String[] nums, int[][] queries) {\\n        int n=nums.length;\\n        int l=nums[0].length();\\n        Map<Integer,List<Integer>> mp=new HashMap<>();\\n        for(int i=0;i<queries.length;i++)\\n            mp.computeIfAbsent(queries[i][1],k->new ArrayList<>()).add(i);\\n        int[] ans=new int[queries.length];\\n        Pair[] pairs=new Pair[n];\\n        for(int i=0;i<n;i++)\\n            pairs[i]=new Pair(nums[i],i);\\n        for(int i=l-1;i>=0;i--){\\n            pairs=sort(pairs,i);\\n            // for( Pair p:pairs){\\n            //     System.out.print(p.val+\",\"+p.key+\" \");\\n            // }\\n            // System.out.println();\\n            for(int ind:mp.getOrDefault(l-i,new ArrayList<>()))\\n                ans[ind]=pairs[queries[ind][0]-1].key;\\n        }\\n        return ans;\\n    }\\n    Pair[] sort(Pair[] pairs,int l){\\n        int[] count=new int[10];\\n        for(Pair p:pairs){\\n            int placeVal=p.val.charAt(l)-\\'0\\';\\n            count[placeVal]++;\\n        }\\n        for(int i=1;i<count.length;i++)\\n            count[i]+=count[i-1];\\n        int n=pairs.length;\\n        Pair[] sortedPairs=new Pair[n];\\n        for(int i=n-1;i>=0;i--){\\n            Pair p=pairs[i];\\n            int placeVal=p.val.charAt(l)-\\'0\\';\\n            int newInd=--count[placeVal];\\n            sortedPairs[newInd]=p;\\n        }\\n        return sortedPairs;        \\n    }\\n    class Pair{\\n        String val;\\n        int key;\\n        Pair(String val,int key){\\n            this.val=val;\\n            this.key=key;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] smallestTrimmedNumbers(String[] nums, int[][] queries) {\\n        int n=nums.length;\\n        int l=nums[0].length();\\n        Map<Integer,List<Integer>> mp=new HashMap<>();\\n        for(int i=0;i<queries.length;i++)\\n            mp.computeIfAbsent(queries[i][1],k->new ArrayList<>()).add(i);\\n        int[] ans=new int[queries.length];\\n        Pair[] pairs=new Pair[n];\\n        for(int i=0;i<n;i++)\\n            pairs[i]=new Pair(nums[i],i);\\n        for(int i=l-1;i>=0;i--){\\n            pairs=sort(pairs,i);\\n            // for( Pair p:pairs){\\n            //     System.out.print(p.val+\",\"+p.key+\" \");\\n            // }\\n            // System.out.println();\\n            for(int ind:mp.getOrDefault(l-i,new ArrayList<>()))\\n                ans[ind]=pairs[queries[ind][0]-1].key;\\n        }\\n        return ans;\\n    }\\n    Pair[] sort(Pair[] pairs,int l){\\n        int[] count=new int[10];\\n        for(Pair p:pairs){\\n            int placeVal=p.val.charAt(l)-\\'0\\';\\n            count[placeVal]++;\\n        }\\n        for(int i=1;i<count.length;i++)\\n            count[i]+=count[i-1];\\n        int n=pairs.length;\\n        Pair[] sortedPairs=new Pair[n];\\n        for(int i=n-1;i>=0;i--){\\n            Pair p=pairs[i];\\n            int placeVal=p.val.charAt(l)-\\'0\\';\\n            int newInd=--count[placeVal];\\n            sortedPairs[newInd]=p;\\n        }\\n        return sortedPairs;        \\n    }\\n    class Pair{\\n        String val;\\n        int key;\\n        Pair(String val,int key){\\n            this.val=val;\\n            this.key=key;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3979977,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private class Pair{\\n        String s;\\n        int index;\\n        Pair(String s, int index){\\n            this.s = s;\\n            this.index = index;\\n        }\\n    }\\n    public int[] smallestTrimmedNumbers(String[] nums, int[][] queries) {\\n        Map<Integer,List<Pair>> map = new HashMap<>();\\n        for(int i=0;i<nums.length;i++){\\n            String str = nums[i];\\n            int n = nums[i].length();\\n            int l = n;\\n            for(int j=0;j<n;j++){\\n                map.putIfAbsent(l, new ArrayList<>());\\n                Pair pair = new Pair(str.substring(j),i);\\n                map.get(l--).add(pair);\\n            }\\n        }\\n        int[] ans = new int[queries.length];\\n        int idx =0;\\n        for(int[] query: queries){\\n            int kthele = query[0];\\n            int key = query[1];\\n\\n            List<Pair> list = map.get(key);\\n            Collections.sort(list, (p1, p2) -> p1.s.equals(p2.s)?p1.index - p2.index: p1.s.compareTo(p2.s));\\n            //     if(p1.s.equals(p2.s))\\n            //         return p1.index -p2.index;\\n            //     return p1.s.compareTo(p2.s);\\n            // });\\n            ans[idx++] = list.get(kthele-1).index;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private class Pair{\\n        String s;\\n        int index;\\n        Pair(String s, int index){\\n            this.s = s;\\n            this.index = index;\\n        }\\n    }\\n    public int[] smallestTrimmedNumbers(String[] nums, int[][] queries) {\\n        Map<Integer,List<Pair>> map = new HashMap<>();\\n        for(int i=0;i<nums.length;i++){\\n            String str = nums[i];\\n            int n = nums[i].length();\\n            int l = n;\\n            for(int j=0;j<n;j++){\\n                map.putIfAbsent(l, new ArrayList<>());\\n                Pair pair = new Pair(str.substring(j),i);\\n                map.get(l--).add(pair);\\n            }\\n        }\\n        int[] ans = new int[queries.length];\\n        int idx =0;\\n        for(int[] query: queries){\\n            int kthele = query[0];\\n            int key = query[1];\\n\\n            List<Pair> list = map.get(key);\\n            Collections.sort(list, (p1, p2) -> p1.s.equals(p2.s)?p1.index - p2.index: p1.s.compareTo(p2.s));\\n            //     if(p1.s.equals(p2.s))\\n            //         return p1.index -p2.index;\\n            //     return p1.s.compareTo(p2.s);\\n            // });\\n            ans[idx++] = list.get(kthele-1).index;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3929951,
                "title": "easy-java-solution-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public static class Point{\\n        String str;\\n        int idx;\\n\\n        Point(String str, int idx){\\n            this.str = str;\\n            this.idx = idx;\\n        }\\n\\n    }\\n\\n    public static class PointComparator implements Comparator<Point>{\\n        public int compare(Point p1, Point p2){\\n            if(p1.str.compareTo(p2.str)>0) return 1;\\n            else if(p1.str.compareTo(p2.str)<0) return -1;\\n            else {\\n                return p1.idx - p2.idx;\\n            }\\n        }\\n    }\\n    public int[] smallestTrimmedNumbers(String[] arr, int[][] q) {\\n       \\n\\n        int[] ans = new int[q.length];\\n\\n        for(int i=0; i<q.length; i++){\\n            int n = arr[0].length();\\n            int k = q[i][1];\\n\\n             PriorityQueue<Point> pq = new PriorityQueue<>(new PointComparator());\\n\\n            for(int j=0; j<arr.length; j++){\\n                String s = arr[j].substring(n-k);\\n                pq.add(new Point(s,j));\\n            }\\n\\n            int x = q[i][0];\\n            if(x==1){\\n                ans[i] = pq.peek().idx;\\n            }else{\\n                while(x!=1){\\n                    pq.remove();\\n                    x--;\\n                }\\n                ans[i] = pq.peek().idx;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    public static class Point{\\n        String str;\\n        int idx;\\n\\n        Point(String str, int idx){\\n            this.str = str;\\n            this.idx = idx;\\n        }\\n\\n    }\\n\\n    public static class PointComparator implements Comparator<Point>{\\n        public int compare(Point p1, Point p2){\\n            if(p1.str.compareTo(p2.str)>0) return 1;\\n            else if(p1.str.compareTo(p2.str)<0) return -1;\\n            else {\\n                return p1.idx - p2.idx;\\n            }\\n        }\\n    }\\n    public int[] smallestTrimmedNumbers(String[] arr, int[][] q) {\\n       \\n\\n        int[] ans = new int[q.length];\\n\\n        for(int i=0; i<q.length; i++){\\n            int n = arr[0].length();\\n            int k = q[i][1];\\n\\n             PriorityQueue<Point> pq = new PriorityQueue<>(new PointComparator());\\n\\n            for(int j=0; j<arr.length; j++){\\n                String s = arr[j].substring(n-k);\\n                pq.add(new Point(s,j));\\n            }\\n\\n            int x = q[i][0];\\n            if(x==1){\\n                ans[i] = pq.peek().idx;\\n            }else{\\n                while(x!=1){\\n                    pq.remove();\\n                    x--;\\n                }\\n                ans[i] = pq.peek().idx;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3926066,
                "title": "python-build-a-cache-beats-98-28",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def smallestTrimmedNumbers(self, nums: List[str], queries: List[List[int]]) -> List[int]:\\n        cache={}\\n        res=[]\\n        for k,t in queries:\\n            if t not in cache:\\n                cache[t]=sorted([(n[-t:],i) for i,n in enumerate(nums)])\\n            res.append(cache[t][k-1][1])\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def smallestTrimmedNumbers(self, nums: List[str], queries: List[List[int]]) -> List[int]:\\n        cache={}\\n        res=[]\\n        for k,t in queries:\\n            if t not in cache:\\n                cache[t]=sorted([(n[-t:],i) for i,n in enumerate(nums)])\\n            res.append(cache[t][k-1][1])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3910605,
                "title": "c-max-heap-priority-queue",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(n * p * log p)\\n\\n- Space complexity:\\nO(k + n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& queries) {\\n        vector<int> ans;\\n        for(auto it:queries){\\n            int tr=it[1];\\n            int k=it[0];\\n            int x;\\n            priority_queue<pair<string,int>> maxh;\\n            for(int i=0;i<nums.size();i++){\\n                string s=nums[i];\\n                if(tr<nums[i].size()){\\n                    s=nums[i].substr(nums[i].size()-tr,tr);\\n                }\\n                maxh.push({s,i});\\n                if(maxh.size()>k){\\n                    x=maxh.top().second;\\n                    maxh.pop();\\n                }\\n            }\\n            ans.push_back(maxh.top().second);\\n        }        \\n        return ans;\\n    }\\n\\n\\n\\n\\n\\n\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& queries) {\\n        vector<int> ans;\\n        for(auto it:queries){\\n            int tr=it[1];\\n            int k=it[0];\\n            int x;\\n            priority_queue<pair<string,int>> maxh;\\n            for(int i=0;i<nums.size();i++){\\n                string s=nums[i];\\n                if(tr<nums[i].size()){\\n                    s=nums[i].substr(nums[i].size()-tr,tr);\\n                }\\n                maxh.push({s,i});\\n                if(maxh.size()>k){\\n                    x=maxh.top().second;\\n                    maxh.pop();\\n                }\\n            }\\n            ans.push_back(maxh.top().second);\\n        }        \\n        return ans;\\n    }\\n\\n\\n\\n\\n\\n\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3907870,
                "title": "swift-100-faster-quickselect",
                "content": "```\\nclass Solution {\\n    func smallestTrimmedNumbers(_ nums: [String], _ queries: [[Int]]) -> [Int] {\\n        queries.map { query in\\n            let (k, trim) = (query[0], query[1])\\n            let trimmed = nums.enumerated().map { (String($1.suffix(trim)), $0) }\\n            let kthSmallest = findKthSmallest(nums: trimmed, k: k)\\n            return kthSmallest.1\\n        }\\n    }\\n\\n    // quickselect\\n    func findKthSmallest(nums: [(String, Int)], k: Int) -> (String, Int) {\\n        let pivot = nums.randomElement()!\\n        let (lesser, equal, greater) = nums\\n            .reduce(into: ([(String, Int)](), [(String, Int)](), [(String, Int)]())) { res, num in\\n            if num < pivot {\\n                res.0.append(num) // elements less than the pivot\\n            } else if num > pivot {\\n                res.2.append(num) // elements greater than the pivot\\n            } else {\\n                res.1.append(num) // elements equal to the pivot\\n            }\\n        }\\n        if k <= lesser.count {\\n            return findKthSmallest(nums: lesser, k: k)\\n        } else if k > lesser.count + equal.count {\\n            return findKthSmallest(nums: greater, k: k - (lesser.count + equal.count))\\n        }\\n        return pivot\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Quickselect"
                ],
                "code": "```\\nclass Solution {\\n    func smallestTrimmedNumbers(_ nums: [String], _ queries: [[Int]]) -> [Int] {\\n        queries.map { query in\\n            let (k, trim) = (query[0], query[1])\\n            let trimmed = nums.enumerated().map { (String($1.suffix(trim)), $0) }\\n            let kthSmallest = findKthSmallest(nums: trimmed, k: k)\\n            return kthSmallest.1\\n        }\\n    }\\n\\n    // quickselect\\n    func findKthSmallest(nums: [(String, Int)], k: Int) -> (String, Int) {\\n        let pivot = nums.randomElement()!\\n        let (lesser, equal, greater) = nums\\n            .reduce(into: ([(String, Int)](), [(String, Int)](), [(String, Int)]())) { res, num in\\n            if num < pivot {\\n                res.0.append(num) // elements less than the pivot\\n            } else if num > pivot {\\n                res.2.append(num) // elements greater than the pivot\\n            } else {\\n                res.1.append(num) // elements equal to the pivot\\n            }\\n        }\\n        if k <= lesser.count {\\n            return findKthSmallest(nums: lesser, k: k)\\n        } else if k > lesser.count + equal.count {\\n            return findKthSmallest(nums: greater, k: k - (lesser.count + equal.count))\\n        }\\n        return pivot\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3844018,
                "title": "python3-2-lines",
                "content": "```\\nclass Solution:\\n    def smallestTrimmedNumbers(self, nums: List[str], queries: List[List[int]]) -> List[int]:\\n        t = {}\\n        return [t.setdefault(trim, sorted((N[-trim:], j) for j, N in enumerate(nums)))[kth - 1][1] for kth, trim in queries]\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def smallestTrimmedNumbers(self, nums: List[str], queries: List[List[int]]) -> List[int]:\\n        t = {}\\n        return [t.setdefault(trim, sorted((N[-trim:], j) for j, N in enumerate(nums)))[kth - 1][1] for kth, trim in queries]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3827642,
                "title": "o-wordlen-n-time-and-space-clear-radix-sort",
                "content": "![image](https://assets.leetcode.com/users/images/b9418ecd-1a40-4cb7-ab6d-32368d512d40_1690531386.7409518.png)\\n\\n    def smallestTrimmedNumbers(self, nums: List[str], queries: List[List[int]]) -> List[int]:\\n        \"\"\" O(W(N+K))T O(N+K)S \"\"\"\\n\\n        def counting_sort(arr, key):\\n            d = {k: [] for k in range(10)}\\n            for n in arr:\\n                d[key(n)] += n,\\n            return sum(d.values(), [])\\n\\n        search, idx = {}, list(range(len(nums)))\\n\\n        for i in range(1, len(nums[0]) + 1):\\n            fn = lambda n: int(nums[n][-i])\\n            idx = counting_sort(idx, fn)\\n            search[i] = idx\\n\\n        return [search[i][k - 1] for k, i in queries]\\n",
                "solutionTags": [],
                "code": "![image](https://assets.leetcode.com/users/images/b9418ecd-1a40-4cb7-ab6d-32368d512d40_1690531386.7409518.png)\\n\\n    def smallestTrimmedNumbers(self, nums: List[str], queries: List[List[int]]) -> List[int]:\\n        \"\"\" O(W(N+K))T O(N+K)S \"\"\"\\n\\n        def counting_sort(arr, key):\\n            d = {k: [] for k in range(10)}\\n            for n in arr:\\n                d[key(n)] += n,\\n            return sum(d.values(), [])\\n\\n        search, idx = {}, list(range(len(nums)))\\n\\n        for i in range(1, len(nums[0]) + 1):\\n            fn = lambda n: int(nums[n][-i])\\n            idx = counting_sort(idx, fn)\\n            search[i] = idx\\n\\n        return [search[i][k - 1] for k, i in queries]\\n",
                "codeTag": "Python3"
            },
            {
                "id": 3707223,
                "title": "using-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] smallestTrimmedNumbers(String[] nums, int[][] queries) {\\n\\n        if (nums.length == 0)\\n            return new int[0];\\n\\n        int[] result = new int[queries.length];\\n        int strLen = nums[0].length();\\n        int[] index = new int[1];\\n\\t\\t\\n        PriorityQueue<Integer> queue = new PriorityQueue<>((a, b) -> {\\n            for (int i = index[0]; i < strLen; i++) {\\n                if (nums[a].charAt(i) != nums[b].charAt(i))\\n                    return nums[b].charAt(i) - nums[a].charAt(i);\\n            }\\n\\n            return b - a;\\n        });\\n\\n        for (int i = 0; i < queries.length; i++) {\\n            index[0] = strLen - queries[i][1];\\n            queue.clear();\\n\\n            for (int j = 0; j < nums.length; j++) {\\n                queue.add(j);\\n                if (queue.size() > queries[i][0])\\n                    queue.poll();\\n            }\\n\\n            result[i] = queue.poll();\\n        }\\n\\n        return result;\\n    }\\n}\\n\\n/*\\nclass Pair {\\n    int first;\\n    int second;\\n\\n    public Pair(int first, int second) {\\n        this.first = first;\\n        this.second = second;\\n    }\\n}\\n\\nclass PairComparator implements Comparator<Pair> {\\n    @Override\\n    public int compare(Pair p1, Pair p2) {\\n        return Integer.compare(p1.first, p2.first);\\n    }\\n}\\n\\nclass Solution {\\n    public int[] smallestTrimmedNumbers(String[] nums, int[][] queries) {\\n        int[] ans = new int[queries.length];\\n        for(int i=0; i<ans.length; i++){\\n            // PriorityQueue<Integer> pq = new PriorityQueue<>();\\n            PriorityQueue<Pair> pq = new PriorityQueue<>(new PairComparator());\\n            int trimLength = queries[i][1];\\n            int smallestIdx = queries[i][0];\\n\\n            for(int j=0; j<nums.length; j++){\\n                int num = trimLength>nums[j].length() ? Integer.parseInt(nums[j]) : Integer.parseInt(nums[j].substring(nums[j].length()-trimLength,nums[j].length()));\\n                pq.add(new Pair(num,j));\\n            }\\n\\n            int count = 1;\\n            while(!pq.isEmpty()){\\n                Pair choose = pq.remove();\\n                if(count==smallestIdx){\\n                    ans[i] = choose.second;\\n                    break;\\n                }\\n                count++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] smallestTrimmedNumbers(String[] nums, int[][] queries) {\\n\\n        if (nums.length == 0)\\n            return new int[0];\\n\\n        int[] result = new int[queries.length];\\n        int strLen = nums[0].length();\\n        int[] index = new int[1];\\n\\t\\t\\n        PriorityQueue<Integer> queue = new PriorityQueue<>((a, b) -> {\\n            for (int i = index[0]; i < strLen; i++) {\\n                if (nums[a].charAt(i) != nums[b].charAt(i))\\n                    return nums[b].charAt(i) - nums[a].charAt(i);\\n            }\\n\\n            return b - a;\\n        });\\n\\n        for (int i = 0; i < queries.length; i++) {\\n            index[0] = strLen - queries[i][1];\\n            queue.clear();\\n\\n            for (int j = 0; j < nums.length; j++) {\\n                queue.add(j);\\n                if (queue.size() > queries[i][0])\\n                    queue.poll();\\n            }\\n\\n            result[i] = queue.poll();\\n        }\\n\\n        return result;\\n    }\\n}\\n\\n/*\\nclass Pair {\\n    int first;\\n    int second;\\n\\n    public Pair(int first, int second) {\\n        this.first = first;\\n        this.second = second;\\n    }\\n}\\n\\nclass PairComparator implements Comparator<Pair> {\\n    @Override\\n    public int compare(Pair p1, Pair p2) {\\n        return Integer.compare(p1.first, p2.first);\\n    }\\n}\\n\\nclass Solution {\\n    public int[] smallestTrimmedNumbers(String[] nums, int[][] queries) {\\n        int[] ans = new int[queries.length];\\n        for(int i=0; i<ans.length; i++){\\n            // PriorityQueue<Integer> pq = new PriorityQueue<>();\\n            PriorityQueue<Pair> pq = new PriorityQueue<>(new PairComparator());\\n            int trimLength = queries[i][1];\\n            int smallestIdx = queries[i][0];\\n\\n            for(int j=0; j<nums.length; j++){\\n                int num = trimLength>nums[j].length() ? Integer.parseInt(nums[j]) : Integer.parseInt(nums[j].substring(nums[j].length()-trimLength,nums[j].length()));\\n                pq.add(new Pair(num,j));\\n            }\\n\\n            int count = 1;\\n            while(!pq.isEmpty()){\\n                Pair choose = pq.remove();\\n                if(count==smallestIdx){\\n                    ans[i] = choose.second;\\n                    break;\\n                }\\n                count++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3674136,
                "title": "kotlin-simple-solution-beats-all-100-memory-and-100-speed",
                "content": "# Intuition\\nJust go step by step over description\\n\\n# Approach\\n1. Trimming string and converting to `BigInteger` since `1 <= nums[i].length <= 100`\\n2. Than save trimmed version in `val map = mutableMapOf<Int, List<BigInteger>>()` to avoid doing same operation on array\\n3. Sort `(item to index)` array each time I do a querry\\n4. Taking k-th idx from sorted array\\n\\n# Code\\n```\\nclass Solution {\\n    fun smallestTrimmedNumbers(nums: Array<String>, queries: Array<IntArray>): IntArray {\\n        val map = mutableMapOf<Int, List<BigInteger>>()\\n        return queries.map {\\n            val k = it[0]\\n            val trim = it[1]\\n            // trim all numbers\\n            val tnums = map[trim] ?: nums.map {\\n                BigInteger(it.takeLast(if (trim <= it.length) trim else it.length))\\n            }.apply {\\n                map[trim] = this\\n            }\\n            // println(tnums)\\n\\n            tnums\\n                .mapIndexed { idx, it ->\\n                    it to idx\\n                }.sortedBy { it.first }[k - 1].second\\n        }.toIntArray()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun smallestTrimmedNumbers(nums: Array<String>, queries: Array<IntArray>): IntArray {\\n        val map = mutableMapOf<Int, List<BigInteger>>()\\n        return queries.map {\\n            val k = it[0]\\n            val trim = it[1]\\n            // trim all numbers\\n            val tnums = map[trim] ?: nums.map {\\n                BigInteger(it.takeLast(if (trim <= it.length) trim else it.length))\\n            }.apply {\\n                map[trim] = this\\n            }\\n            // println(tnums)\\n\\n            tnums\\n                .mapIndexed { idx, it ->\\n                    it to idx\\n                }.sortedBy { it.first }[k - 1].second\\n        }.toIntArray()\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3658605,
                "title": "simple-priority-queue-solution",
                "content": "```\\nclass Solution {\\n    \\npublic:\\n    vector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& queries) {\\n        vector<int> ans;\\n        for(auto &query:queries) {\\n            int k = query[0];\\n            int trimLen = query[1];\\n            priority_queue<pair<string, int>, vector<pair<string, int>>, greater<pair<string, int>>> pq;\\n            for(int i = 0; i < nums.size(); i++) {\\n                string temp = nums[i];\\n                \\n                temp = temp.substr(temp.size() - trimLen);\\n                \\n                pq.push({ temp, i });\\n            }\\n            while(k-- > 1) pq.pop();\\n            ans.push_back(pq.top().second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    \\npublic:\\n    vector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& queries) {\\n        vector<int> ans;\\n        for(auto &query:queries) {\\n            int k = query[0];\\n            int trimLen = query[1];\\n            priority_queue<pair<string, int>, vector<pair<string, int>>, greater<pair<string, int>>> pq;\\n            for(int i = 0; i < nums.size(); i++) {\\n                string temp = nums[i];\\n                \\n                temp = temp.substr(temp.size() - trimLen);\\n                \\n                pq.push({ temp, i });\\n            }\\n            while(k-- > 1) pq.pop();\\n            ans.push_back(pq.top().second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3627483,
                "title": "my-ac-java-radix-sort",
                "content": "```\\npublic int[] smallestTrimmedNumbers(String[] nums, int[][] queries) {\\n\\t\\t\\n    int numLen = nums[0].length();\\n\\t// After each sort, we need to rearrange the elements of the array in increasing order. \\n\\t// However, we cannot modify the original array directly as it would disrupt the indices. \\n\\t// To address this, we utilize the \"numIdx\" array to keep track of the indices of \\n\\t// each element in \"nums\" after each sort.\\n\\tint[] numIdx = new int[nums.length];\\n\\tfor (int i = 0; i < nums.length; i++)\\n\\t\\tnumIdx[i] = i;\\n\\n\\t// Create a 2D array to store the sorted indices\\n\\tint[][] sorted = new int[numLen][nums.length];\\n\\tint idx = 0;\\n\\twhile (numLen > 0) {\\n\\t\\t// We update the numIdx array after each sort\\n\\t\\tnumIdx = radix(nums, numLen - 1, numIdx);\\n\\t\\t// Then store it\\n\\t\\tsorted[idx++] = numIdx;\\n\\t\\tnumLen--;\\n\\t}\\n\\n\\t// Retrieve the smallest trimmed numbers based on queries\\n\\tint[] res = new int[queries.length];\\n\\tfor (int i = 0; i < queries.length; i++) {\\n\\t\\tint k = queries[i][0] - 1;\\n\\t\\tint trim = queries[i][1] - 1;\\n\\t\\tres[i] = sorted[trim][k];\\n\\t}\\n\\n\\treturn res;\\n}\\n\\nprivate int[] radix(String[] nums, int numLen, int[] numIdx) {\\n\\tint[] counts = new int[10];\\n\\n\\tfor (String num : nums) {\\n\\t\\tint n = num.charAt(numLen) - \\'0\\';\\n\\t\\tcounts[n]++;\\n\\t}\\n\\n\\tint startingIndex = 0;\\n\\tfor (int i = 0; i < counts.length; i++) {\\n\\t\\tint count = counts[i];\\n\\t\\tcounts[i] = startingIndex;\\n\\t\\tstartingIndex += count;\\n\\t}\\n\\n\\tint[] sorted = new int[nums.length];\\n\\tfor (int i = 0; i < nums.length; i++) {\\n\\t\\tint n = nums[numIdx[i]].charAt(numLen) - \\'0\\';\\n\\t\\tsorted[counts[n]] = numIdx[i];\\n\\t\\tcounts[n]++;\\n\\t}\\n\\treturn sorted;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[] smallestTrimmedNumbers(String[] nums, int[][] queries) {\\n\\t\\t\\n    int numLen = nums[0].length();\\n\\t// After each sort, we need to rearrange the elements of the array in increasing order. \\n\\t// However, we cannot modify the original array directly as it would disrupt the indices. \\n\\t// To address this, we utilize the \"numIdx\" array to keep track of the indices of \\n\\t// each element in \"nums\" after each sort.\\n\\tint[] numIdx = new int[nums.length];\\n\\tfor (int i = 0; i < nums.length; i++)\\n\\t\\tnumIdx[i] = i;\\n\\n\\t// Create a 2D array to store the sorted indices\\n\\tint[][] sorted = new int[numLen][nums.length];\\n\\tint idx = 0;\\n\\twhile (numLen > 0) {\\n\\t\\t// We update the numIdx array after each sort\\n\\t\\tnumIdx = radix(nums, numLen - 1, numIdx);\\n\\t\\t// Then store it\\n\\t\\tsorted[idx++] = numIdx;\\n\\t\\tnumLen--;\\n\\t}\\n\\n\\t// Retrieve the smallest trimmed numbers based on queries\\n\\tint[] res = new int[queries.length];\\n\\tfor (int i = 0; i < queries.length; i++) {\\n\\t\\tint k = queries[i][0] - 1;\\n\\t\\tint trim = queries[i][1] - 1;\\n\\t\\tres[i] = sorted[trim][k];\\n\\t}\\n\\n\\treturn res;\\n}\\n\\nprivate int[] radix(String[] nums, int numLen, int[] numIdx) {\\n\\tint[] counts = new int[10];\\n\\n\\tfor (String num : nums) {\\n\\t\\tint n = num.charAt(numLen) - \\'0\\';\\n\\t\\tcounts[n]++;\\n\\t}\\n\\n\\tint startingIndex = 0;\\n\\tfor (int i = 0; i < counts.length; i++) {\\n\\t\\tint count = counts[i];\\n\\t\\tcounts[i] = startingIndex;\\n\\t\\tstartingIndex += count;\\n\\t}\\n\\n\\tint[] sorted = new int[nums.length];\\n\\tfor (int i = 0; i < nums.length; i++) {\\n\\t\\tint n = nums[numIdx[i]].charAt(numLen) - \\'0\\';\\n\\t\\tsorted[counts[n]] = numIdx[i];\\n\\t\\tcounts[n]++;\\n\\t}\\n\\treturn sorted;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3620123,
                "title": "swift-straightforward-radix-sort-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    func smallestTrimmedNumbers(_ nums: [String], _ queries: [[Int]]) -> [Int] {\\n        var result = [Int]()\\n        result.reserveCapacity(queries.count)\\n        var cache = [Int: [String]]()\\n        for query in queries {\\n            var k = query[0]\\n            let trim = query[1]\\n            let sortedNums = cache[trim] ?? nums.radixSorted(suffixCount: trim)\\n            cache[trim] = sortedNums\\n            let kthNum = sortedNums[k-1]\\n            var index = 0\\n            for (i, num) in nums.enumerated() {\\n                if kthNum == num, k > 0 {\\n                    index = i\\n                    k -= 1\\n                }\\n            }\\n            result.append(index)\\n        }\\n        return result\\n    }\\n}\\n\\nextension Array where Element == String {\\n    fileprivate func radixSorted(suffixCount: Int) -> Self {\\n        guard count > 0 else { return self }\\n        let alphabetCount = 10\\n        var result = self\\n        var charIndex = first!.endIndex\\n        for _ in 0..<suffixCount {\\n            charIndex = first!.index(before: charIndex)\\n            var counts = [Int](repeating: 0, count: alphabetCount)\\n            for word in self {\\n                let digit = word[charIndex].wholeNumberValue!\\n                counts[digit] += 1\\n            }\\n            var startingIndex = 0\\n            for i in 0..<counts.count {\\n                let count = counts[i]\\n                counts[i] = startingIndex\\n                startingIndex += count\\n            }\\n            var sorted = [String](repeating: \"\", count: count)\\n            for word in result {\\n                let digit = word[charIndex].wholeNumberValue!\\n                let position = counts[digit]\\n                sorted[position] = word\\n                counts[digit] += 1\\n            }\\n            result = sorted\\n        }\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Sorting",
                    "Radix Sort"
                ],
                "code": "```\\nclass Solution {\\n    func smallestTrimmedNumbers(_ nums: [String], _ queries: [[Int]]) -> [Int] {\\n        var result = [Int]()\\n        result.reserveCapacity(queries.count)\\n        var cache = [Int: [String]]()\\n        for query in queries {\\n            var k = query[0]\\n            let trim = query[1]\\n            let sortedNums = cache[trim] ?? nums.radixSorted(suffixCount: trim)\\n            cache[trim] = sortedNums\\n            let kthNum = sortedNums[k-1]\\n            var index = 0\\n            for (i, num) in nums.enumerated() {\\n                if kthNum == num, k > 0 {\\n                    index = i\\n                    k -= 1\\n                }\\n            }\\n            result.append(index)\\n        }\\n        return result\\n    }\\n}\\n\\nextension Array where Element == String {\\n    fileprivate func radixSorted(suffixCount: Int) -> Self {\\n        guard count > 0 else { return self }\\n        let alphabetCount = 10\\n        var result = self\\n        var charIndex = first!.endIndex\\n        for _ in 0..<suffixCount {\\n            charIndex = first!.index(before: charIndex)\\n            var counts = [Int](repeating: 0, count: alphabetCount)\\n            for word in self {\\n                let digit = word[charIndex].wholeNumberValue!\\n                counts[digit] += 1\\n            }\\n            var startingIndex = 0\\n            for i in 0..<counts.count {\\n                let count = counts[i]\\n                counts[i] = startingIndex\\n                startingIndex += count\\n            }\\n            var sorted = [String](repeating: \"\", count: count)\\n            for word in result {\\n                let digit = word[charIndex].wholeNumberValue!\\n                let position = counts[digit]\\n                sorted[position] = word\\n                counts[digit] += 1\\n            }\\n            result = sorted\\n        }\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3593727,
                "title": "simple-radix-sort-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] smallestTrimmedNumbers(String[] nums, int[][] queries) {\\n        int n = queries.length, finished = 0, res[] = new int[n], count[] = new int[10];\\n        String[] src = Arrays.copyOf(nums, nums.length);\\n        for (int d = 1; d <= nums[0].length() && finished < n; d++) {\\n            src = radixsort(src, nums[0].length() - d);\\n            for (int i = 0; i < n; i++) {\\n                if (queries[i][1] == d) {\\n                    for (int j = 0; j < nums.length; j++) {\\n                        if (src[queries[i][0] - 1] == nums[j]) {\\n                            res[i] = j;\\n                            finished++;\\n                            break;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n\\n    String[] radixsort(String[] src, int pos) {\\n        String[] dst = new String[src.length];\\n        int[] count = new int[10];\\n        for (String s : src) {\\n            count[s.charAt(pos) - \\'0\\']++;\\n        }\\n        for (int i = 1; i < count.length; i++) {\\n            count[i] += count[i - 1];\\n        }\\n        for (int i = src.length - 1; i >= 0; i--) {\\n            dst[--count[src[i].charAt(pos) - \\'0\\']] = src[i];\\n        }\\n        return dst;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] smallestTrimmedNumbers(String[] nums, int[][] queries) {\\n        int n = queries.length, finished = 0, res[] = new int[n], count[] = new int[10];\\n        String[] src = Arrays.copyOf(nums, nums.length);\\n        for (int d = 1; d <= nums[0].length() && finished < n; d++) {\\n            src = radixsort(src, nums[0].length() - d);\\n            for (int i = 0; i < n; i++) {\\n                if (queries[i][1] == d) {\\n                    for (int j = 0; j < nums.length; j++) {\\n                        if (src[queries[i][0] - 1] == nums[j]) {\\n                            res[i] = j;\\n                            finished++;\\n                            break;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n\\n    String[] radixsort(String[] src, int pos) {\\n        String[] dst = new String[src.length];\\n        int[] count = new int[10];\\n        for (String s : src) {\\n            count[s.charAt(pos) - \\'0\\']++;\\n        }\\n        for (int i = 1; i < count.length; i++) {\\n            count[i] += count[i - 1];\\n        }\\n        for (int i = src.length - 1; i >= 0; i--) {\\n            dst[--count[src[i].charAt(pos) - \\'0\\']] = src[i];\\n        }\\n        return dst;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3576895,
                "title": "brute-force",
                "content": "# Approach\\nTrim the strings, and determine kth smallest int by heap.\\n\\n# Code\\n```\\nclass Solution:\\n    def smallestTrimmedNumbers(self, nums: List[str], queries: List[List[int]]) -> List[int]:\\n        n = len(nums[0])\\n        ret = []\\n\\n        for k, trim in queries:\\n            L = [(int(s[n-trim:]), i) for i, s in enumerate(nums)]\\n            heapify(L)\\n            ret.append(nsmallest(k, L)[-1][1])\\n        \\n        return ret\\n        \\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def smallestTrimmedNumbers(self, nums: List[str], queries: List[List[int]]) -> List[int]:\\n        n = len(nums[0])\\n        ret = []\\n\\n        for k, trim in queries:\\n            L = [(int(s[n-trim:]), i) for i, s in enumerate(nums)]\\n            heapify(L)\\n            ret.append(nsmallest(k, L)[-1][1])\\n        \\n        return ret\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3539189,
                "title": "speedy-result-at-the-expense-of-memory",
                "content": "# Intuition\\nRather than find the original elements in the list, create broken down lists for each trim with a backreference to the original index.\\n\\n# Approach\\n1. Create a dictionary of trims (reusable, to minimize time!) of varying digits off the base.\\n2. The value for each dictionary is a list of tuples, where the tuple is the original index and the trimmed string.\\n3. Sort the list by the trimmed string.\\n4. The return value for the kth smallest number is simply the index value of the tuple of the (k-1)th record in the list for the relevant trim size.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$, because there\\'s one pass and one sort of each list for each data size.\\n\\n- Space complexity:\\nThis is like a $$O(n \\\\times m)$$ space complexity, because there are lists for each different trim size in the queries list.\\n\\n# Code\\n```\\nclass Solution:\\n    def smallestTrimmedNumbers(self, nums: List[str], queries: List[List[int]]) -> List[int]:\\n        trims = {}\\n        for k in set(q[1] for q in queries):\\n            trims[k] = list(enumerate([s[-k:] for s in nums]))\\n            trims[k].sort(key=lambda k: k[1])\\n        return [int(trims[q][i - 1][0]) for i, q in queries]\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def smallestTrimmedNumbers(self, nums: List[str], queries: List[List[int]]) -> List[int]:\\n        trims = {}\\n        for k in set(q[1] for q in queries):\\n            trims[k] = list(enumerate([s[-k:] for s in nums]))\\n            trims[k].sort(key=lambda k: k[1])\\n        return [int(trims[q][i - 1][0]) for i, q in queries]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3512326,
                "title": "java-solution-with-priority-queue",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int[] smallestTrimmedNumbers(String[] nums, int[][] queries) {\\n\\n        if (nums.length == 0)\\n            return new int[0];\\n\\n        int[] result = new int[queries.length];\\n        int strLen = nums[0].length();\\n        int[] index = new int[1];\\n\\t\\t\\n        PriorityQueue<Integer> queue = new PriorityQueue<>((a, b) -> {\\n            for (int i = index[0]; i < strLen; i++) {\\n                if (nums[a].charAt(i) != nums[b].charAt(i))\\n                    return nums[b].charAt(i) - nums[a].charAt(i);\\n            }\\n\\n            return b - a;\\n        });\\n\\n        for (int i = 0; i < queries.length; i++) {\\n            index[0] = strLen - queries[i][1];\\n            queue.clear();\\n\\n            for (int j = 0; j < nums.length; j++) {\\n                queue.add(j);\\n                if (queue.size() > queries[i][0])\\n                    queue.poll();\\n            }\\n\\n            result[i] = queue.poll();\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] smallestTrimmedNumbers(String[] nums, int[][] queries) {\\n\\n        if (nums.length == 0)\\n            return new int[0];\\n\\n        int[] result = new int[queries.length];\\n        int strLen = nums[0].length();\\n        int[] index = new int[1];\\n\\t\\t\\n        PriorityQueue<Integer> queue = new PriorityQueue<>((a, b) -> {\\n            for (int i = index[0]; i < strLen; i++) {\\n                if (nums[a].charAt(i) != nums[b].charAt(i))\\n                    return nums[b].charAt(i) - nums[a].charAt(i);\\n            }\\n\\n            return b - a;\\n        });\\n\\n        for (int i = 0; i < queries.length; i++) {\\n            index[0] = strLen - queries[i][1];\\n            queue.clear();\\n\\n            for (int j = 0; j < nums.length; j++) {\\n                queue.add(j);\\n                if (queue.size() > queries[i][0])\\n                    queue.poll();\\n            }\\n\\n            result[i] = queue.poll();\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3476197,
                "title": "radix-sort-beats-73-time-clean-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBy asking for \"trimming\" some digits, it motivate thinking about what is the sorting algorithm that relate to this idea?\\nRight, it\\'s Radix sort!\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe key observation here is to notice that if you tried to answer each query independently, this will give a TLE.\\n\\nSo, a smart trick is to make them dependent.. but how?\\nSimply by sorting them based on `trim`, now you just apply the radix sort on each digit exactly once.\\nBut notice, the order of the queries matters.. so keep the `original index`.\\n# Complexity\\nAssume that `d = nums[i].length` and `n = nums.length` and `q = queries.length` then:\\n- Time complexity: $$O(d * n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Space complexity: $$O(n + q)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    vector<string> nums;\\n    int n, len;\\n\\n    vector<int> idxArr;\\n    int last_digit;\\n\\npublic:\\n    void count_sort(int key, vector<int>& indices) {\\n        int count[10] = {0};\\n        // fill count:\\n        for (int i = 0; i < n; ++i) {\\n            string num = nums[indices[i]];\\n            count[num[key] - \\'0\\']++;\\n        }\\n        // accumulate count:\\n        for (int i = 1; i < 10; ++i) {\\n            count[i] += count[i-1];\\n        }\\n\\n        vector<int> output(n);\\n        for (int i = n - 1; i >= 0; --i) {\\n            int idx = indices[i];\\n            string num = nums[idx];\\n            output[--count[num[key] - \\'0\\']] = idx;\\n        }\\n\\n        indices = output; // update \\'indices\\' to use it in the next pass\\n    }\\n    int radix_sort(int trim, int k) { \\n        for (; last_digit >= len - trim; --last_digit)\\n            count_sort(last_digit, idxArr);\\n        return idxArr[k-1]; // k-1 => 0-based\\n    }\\n    vector<int> smallestTrimmedNumbers(vector<string>& _nums, vector<vector<int>>& queries) { // O(d * n)\\n        nums = _nums;\\n        n = nums.size(), len = nums[0].size();\\n\\n        idxArr = vector<int>(n);\\n        iota(idxArr.begin(), idxArr.end(), 0); // initialize with {0, 1, 2, ... , n-1}\\n        last_digit = len - 1;\\n\\n        /// sorted queries\\n        // the idea is to sort the queries based on \\'trim\\' to avoid TLE\\n        // by sorting it, we just do the count sort for each digit at most once\\n\\n        int q = queries.size();\\n        vector< vector<int> > sorted_queries(q);\\n        for (int i = 0; i < q; ++i) {\\n            sorted_queries[i] = {queries[i][1], queries[i][0], i}; // {trim, k, original index}\\n        }\\n        sort(sorted_queries.begin(), sorted_queries.end());\\n\\n        vector<int> answer(q);\\n        for (int i = 0; i < q; ++i) {\\n            vector<int> query = sorted_queries[i];\\n            int q_ans = radix_sort(query[0], query[1]);\\n            answer[query[2]] = q_ans; // query[2] = original index\\n        }\\n        return answer;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting",
                    "Radix Sort",
                    "Counting Sort"
                ],
                "code": "```\\nclass Solution {\\n    vector<string> nums;\\n    int n, len;\\n\\n    vector<int> idxArr;\\n    int last_digit;\\n\\npublic:\\n    void count_sort(int key, vector<int>& indices) {\\n        int count[10] = {0};\\n        // fill count:\\n        for (int i = 0; i < n; ++i) {\\n            string num = nums[indices[i]];\\n            count[num[key] - \\'0\\']++;\\n        }\\n        // accumulate count:\\n        for (int i = 1; i < 10; ++i) {\\n            count[i] += count[i-1];\\n        }\\n\\n        vector<int> output(n);\\n        for (int i = n - 1; i >= 0; --i) {\\n            int idx = indices[i];\\n            string num = nums[idx];\\n            output[--count[num[key] - \\'0\\']] = idx;\\n        }\\n\\n        indices = output; // update \\'indices\\' to use it in the next pass\\n    }\\n    int radix_sort(int trim, int k) { \\n        for (; last_digit >= len - trim; --last_digit)\\n            count_sort(last_digit, idxArr);\\n        return idxArr[k-1]; // k-1 => 0-based\\n    }\\n    vector<int> smallestTrimmedNumbers(vector<string>& _nums, vector<vector<int>>& queries) { // O(d * n)\\n        nums = _nums;\\n        n = nums.size(), len = nums[0].size();\\n\\n        idxArr = vector<int>(n);\\n        iota(idxArr.begin(), idxArr.end(), 0); // initialize with {0, 1, 2, ... , n-1}\\n        last_digit = len - 1;\\n\\n        /// sorted queries\\n        // the idea is to sort the queries based on \\'trim\\' to avoid TLE\\n        // by sorting it, we just do the count sort for each digit at most once\\n\\n        int q = queries.size();\\n        vector< vector<int> > sorted_queries(q);\\n        for (int i = 0; i < q; ++i) {\\n            sorted_queries[i] = {queries[i][1], queries[i][0], i}; // {trim, k, original index}\\n        }\\n        sort(sorted_queries.begin(), sorted_queries.end());\\n\\n        vector<int> answer(q);\\n        for (int i = 0; i < q; ++i) {\\n            vector<int> query = sorted_queries[i];\\n            int q_ans = radix_sort(query[0], query[1]);\\n            answer[query[2]] = q_ans; // query[2] = original index\\n        }\\n        return answer;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3458463,
                "title": "240ms-beats-100-my-code-is-91ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe Radix LSD (Least Significant Digit) algorithm sorts everything by the last digit, then the second to last digit, and so on until everything is sorted. We can use this to find the kth smallest number for the smaller trims first, then work our way up to the biggest trims.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo understand how Radix LSD works, imagine you have an array `arr` and 10 boxes labeled 0-9. \\n1) First, look at the last (rightmost) digit of each number in `arr` and put it into the matching box.\\n2) Put the numbers in Box 0 back into the array without changing the order of the numbers in the box, then do the same for Box 1, Box 2, and so on for the rest of the boxes.\\n3) Repeat steps 1 and 2, this time looking at the 2nd to last digit. Do the same for the 3rd to last digit, and so on until everything is sorted.\\n\\n#### Here\\'s an example of Radix LSD in action:\\n\\n```\\nboxes: 0[] 1[] 2[] 3[] 4[] 5[] 6[] 7[] 8[] 9[]\\narr: [5,28,17,37,27,33,102]\\n\\nPass 1:\\n0[] 1[] 2[102] 3[33] 4[] 5[5] 6[] 7[17,37,27] 8[28] 9[]\\n[102,33,5,17,37,27,28]\\n\\nPass 2:\\n0[102,05] 1[17] 2[27,28] 3[33,37] 4[] 5[] 6[] 7[] 8[] 9[]\\n[102,5,17,27,28,33,37]\\n\\nPass 3:\\n0[005,017,027,028,033,037] 1[102] 2[] 3[] 4[] 5[] 6[] 7[] 8[] 9[]\\n[5,17,27,28,33,37,102]\\n\\n```\\nUsing this, we can find all the answers where `queries[i][1] = 1` after Pass 1, then the answers where `queries[i][1] = 2` after Pass 2, and so on until we have all the answers.\\n\\nThe trickiest part of this is keeping track of the original order of both the queries and the nums, since the `answer` array needs to be in the original `queries` order, returning indices for an unsorted `nums`. The simplest solution is to make arrays of the indices of `queries` and `nums`, and sort those instead.\\n\\n#### Here\\'s an example of sorting the indices:\\n```\\nBefore sorting:\\nnums=[5,8,16,2,38,408,22,6]\\nnIndices=[0,1,2,3,4,5,6,7]\\n\\nAfter sorting:\\nnums=[5,8,16,2,38,408,22,6]\\nnIndices=[1,3,4,0,6,7,5,2]\\n```\\nTo do this, just compare the numbers the indices are pointing to, instead of the indices themselves.\\n\\nNow that we have all the tools we need, the approach is actually really simple!\\n1) Sort (the indices of) `queries` from smallest trim to largest.\\n2) Do Pass 1 of Radix LSD for (the indices of) `nums`.\\n3) Fill in the items of `answers` for the `queries` where `trim = Pass #`.\\n4) Repeat for Pass 2, Pass 3, etc. until all the `queries` have been solved.\\n\\n# Complexity\\n- Time complexity: $$O(n*m)$$ where $$m$$ is the highest trim.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nint** loadList;\\nint cmp(const void* a, const void* b){\\n    return (loadList[*(int*)a][1]-loadList[*(int*)b][1]);\\n}\\nint* smallestTrimmedNumbers(char ** nums, int numsSize, int** queries, int queriesSize, int* queriesColSize, int* returnSize){\\n    *returnSize=queriesSize;\\n    int* answer=malloc(queriesSize*4);\\n    int* qIndices=malloc(queriesSize*4);//queries indices\\n    for (int i=0;i<queriesSize;i++) qIndices[i]=i;\\n    loadList=queries;\\n    qsort(qIndices,queriesSize,4,cmp);\\n    char len=strlen(*nums);\\n    char digit=len-1;\\n    char qInd=0;//queriesInd\\n    char LSD[10][100];\\n    char LSDlens[10];//aka \"LSDColSize\"\\n    char nIndices[numsSize];//nums indices\\n    for (char i=0;i<numsSize;i++) nIndices[i]=i;\\n    do{\\n        memset(LSDlens,0,10);\\n        for (char i=0,temp;i<numsSize;i++){\\n            temp=nums[nIndices[i]][digit]-\\'0\\';\\n            LSD[temp][(LSDlens[temp])++]=nIndices[i];\\n        }\\n        for (char i=0,ind=0;i<10;i++){\\n            for (char j=0;j<LSDlens[i];j++){\\n                nIndices[ind++]=LSD[i][j];\\n            }\\n        }\\n        while(qInd<queriesSize && queries[qIndices[qInd]][1]==len-digit){\\n            answer[qIndices[qInd]]=nIndices[queries[qIndices[qInd]][0]-1];\\n            qInd++;\\n        }\\n        digit--;\\n    } while(qInd<queriesSize);\\n    return(answer);\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nboxes: 0[] 1[] 2[] 3[] 4[] 5[] 6[] 7[] 8[] 9[]\\narr: [5,28,17,37,27,33,102]\\n\\nPass 1:\\n0[] 1[] 2[102] 3[33] 4[] 5[5] 6[] 7[17,37,27] 8[28] 9[]\\n[102,33,5,17,37,27,28]\\n\\nPass 2:\\n0[102,05] 1[17] 2[27,28] 3[33,37] 4[] 5[] 6[] 7[] 8[] 9[]\\n[102,5,17,27,28,33,37]\\n\\nPass 3:\\n0[005,017,027,028,033,037] 1[102] 2[] 3[] 4[] 5[] 6[] 7[] 8[] 9[]\\n[5,17,27,28,33,37,102]\\n\\n```\n```\\nBefore sorting:\\nnums=[5,8,16,2,38,408,22,6]\\nnIndices=[0,1,2,3,4,5,6,7]\\n\\nAfter sorting:\\nnums=[5,8,16,2,38,408,22,6]\\nnIndices=[1,3,4,0,6,7,5,2]\\n```\n```\\nint** loadList;\\nint cmp(const void* a, const void* b){\\n    return (loadList[*(int*)a][1]-loadList[*(int*)b][1]);\\n}\\nint* smallestTrimmedNumbers(char ** nums, int numsSize, int** queries, int queriesSize, int* queriesColSize, int* returnSize){\\n    *returnSize=queriesSize;\\n    int* answer=malloc(queriesSize*4);\\n    int* qIndices=malloc(queriesSize*4);//queries indices\\n    for (int i=0;i<queriesSize;i++) qIndices[i]=i;\\n    loadList=queries;\\n    qsort(qIndices,queriesSize,4,cmp);\\n    char len=strlen(*nums);\\n    char digit=len-1;\\n    char qInd=0;//queriesInd\\n    char LSD[10][100];\\n    char LSDlens[10];//aka \"LSDColSize\"\\n    char nIndices[numsSize];//nums indices\\n    for (char i=0;i<numsSize;i++) nIndices[i]=i;\\n    do{\\n        memset(LSDlens,0,10);\\n        for (char i=0,temp;i<numsSize;i++){\\n            temp=nums[nIndices[i]][digit]-\\'0\\';\\n            LSD[temp][(LSDlens[temp])++]=nIndices[i];\\n        }\\n        for (char i=0,ind=0;i<10;i++){\\n            for (char j=0;j<LSDlens[i];j++){\\n                nIndices[ind++]=LSD[i][j];\\n            }\\n        }\\n        while(qInd<queriesSize && queries[qIndices[qInd]][1]==len-digit){\\n            answer[qIndices[qInd]]=nIndices[queries[qIndices[qInd]][0]-1];\\n            qInd++;\\n        }\\n        digit--;\\n    } while(qInd<queriesSize);\\n    return(answer);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3448604,
                "title": "typescript-radix-sort-and-cached-sort-results-no-unnecessary-work",
                "content": "# Intuition\\n\\n1. For a query like `[1, 3]`, we will sort the numbers by the 3rd digit from the right, and take the 1st element from the sorted array. \\n2. To avoid wasting effort, cache all intermediate sorting results: `nums` sorted by the 1st digit from the right, 2nd digit from the right, and 3rd digit from the right. Radix sort is ideally suited for that because in order to sort the numbers by the third digit, you first need to sort them by the 1st and 2nd digit (from the right).\\n3. In the answer, we should provide the index of a number, not the number itself. That means instead of working on an array of numbers, we will work on an array of objects like `{ num: \\'1234\\', index: 0 }`. \\n\\n# Code\\n```\\ntype SortCache = Record<number, ValueNode[]>;\\ntype ValueNode = { num: string; index: number };\\n\\nfunction smallestTrimmedNumbers(nums: string[], queries: number[][]): number[] {\\n    const sortedStages: SortCache = {};\\n\\n    // Convert a simple array of numbers into an array of objects\\n    // with both the number and its index in the original array:\\n    const values: ValueNode[] = nums.map((num, i) => ({ num, index: i }));\\n\\n    // Process each query one by one:\\n    return queries.map(query => {\\n        const [kth, trimTo] = query;\\n        const sorted = getSortedNums(trimTo, values, sortedStages);\\n        const kthNode = sorted[kth - 1]; // kth starts from 1, not from 0\\n\\n        return kthNode.index;\\n    });\\n};\\n\\nfunction getSortedNums(trimTo: number, nums: ValueNode[], sortedStages: SortCache): ValueNode[] {\\n    // For example: if we already sorted numbers trimmed to 3 characters\\n    // before, then just return them from cache. Otherwise, sort numbers\\n    // by trim levels 1, 2 and 3, and cache these three sorted arrays.\\n    const cached = sortedStages[trimTo];\\n    if (cached) {\\n        return cached;\\n    }\\n\\n    for (let trimStage = 1; trimStage <= trimTo; trimStage++) {\\n        if (sortedStages[trimStage]) {\\n            continue;\\n        }\\n\\n        const sorted = [];\\n        const buckets = Array(10).fill(0);\\n        const prevSorted = trimStage === 1\\n            ? nums\\n            : sortedStages[trimStage - 1];\\n\\n        for (let j = 0; j < prevSorted.length; j++) {\\n            const node = prevSorted[j];\\n            const sortChar = cutChar(node.num, trimStage);\\n            buckets[sortChar]++;\\n        }\\n        buckets.unshift(0);\\n\\n        // Convert data in buckets from counts by digit into a running total array:        \\n        for (let i = 1; i < buckets.length; i++) {\\n            buckets[i] = buckets[i] + buckets[i - 1];\\n        }\\n\\n        // Thanks to the running totals, we will know where to insert\\n        // each item in the result array:\\n        for (let j = 0; j < prevSorted.length; j++) {\\n            const node = prevSorted[j];\\n            const sortChar = cutChar(node.num, trimStage);\\n            const insertAt = buckets[sortChar];\\n            sorted[insertAt] = node;\\n            buckets[sortChar]++;\\n        }\\n\\n        sortedStages[trimStage] = sorted;\\n    }\\n\\n    return sortedStages[trimTo];\\n}\\n\\n\\nfunction cutChar(str: string, positionFromEnd: number) {\\n    return str.at(-1 * positionFromEnd);\\n}\\n\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype SortCache = Record<number, ValueNode[]>;\\ntype ValueNode = { num: string; index: number };\\n\\nfunction smallestTrimmedNumbers(nums: string[], queries: number[][]): number[] {\\n    const sortedStages: SortCache = {};\\n\\n    // Convert a simple array of numbers into an array of objects\\n    // with both the number and its index in the original array:\\n    const values: ValueNode[] = nums.map((num, i) => ({ num, index: i }));\\n\\n    // Process each query one by one:\\n    return queries.map(query => {\\n        const [kth, trimTo] = query;\\n        const sorted = getSortedNums(trimTo, values, sortedStages);\\n        const kthNode = sorted[kth - 1]; // kth starts from 1, not from 0\\n\\n        return kthNode.index;\\n    });\\n};\\n\\nfunction getSortedNums(trimTo: number, nums: ValueNode[], sortedStages: SortCache): ValueNode[] {\\n    // For example: if we already sorted numbers trimmed to 3 characters\\n    // before, then just return them from cache. Otherwise, sort numbers\\n    // by trim levels 1, 2 and 3, and cache these three sorted arrays.\\n    const cached = sortedStages[trimTo];\\n    if (cached) {\\n        return cached;\\n    }\\n\\n    for (let trimStage = 1; trimStage <= trimTo; trimStage++) {\\n        if (sortedStages[trimStage]) {\\n            continue;\\n        }\\n\\n        const sorted = [];\\n        const buckets = Array(10).fill(0);\\n        const prevSorted = trimStage === 1\\n            ? nums\\n            : sortedStages[trimStage - 1];\\n\\n        for (let j = 0; j < prevSorted.length; j++) {\\n            const node = prevSorted[j];\\n            const sortChar = cutChar(node.num, trimStage);\\n            buckets[sortChar]++;\\n        }\\n        buckets.unshift(0);\\n\\n        // Convert data in buckets from counts by digit into a running total array:        \\n        for (let i = 1; i < buckets.length; i++) {\\n            buckets[i] = buckets[i] + buckets[i - 1];\\n        }\\n\\n        // Thanks to the running totals, we will know where to insert\\n        // each item in the result array:\\n        for (let j = 0; j < prevSorted.length; j++) {\\n            const node = prevSorted[j];\\n            const sortChar = cutChar(node.num, trimStage);\\n            const insertAt = buckets[sortChar];\\n            sorted[insertAt] = node;\\n            buckets[sortChar]++;\\n        }\\n\\n        sortedStages[trimStage] = sorted;\\n    }\\n\\n    return sortedStages[trimTo];\\n}\\n\\n\\nfunction cutChar(str: string, positionFromEnd: number) {\\n    return str.at(-1 * positionFromEnd);\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3402448,
                "title": "c-string-view-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& queries) {\\n        int n=nums.size();\\n        vector<int> v(n,0);\\n        for(int i=0;i<n;++i){\\n            v[i]=i;\\n        }\\n        int nn=nums[0].size();\\n        vector<int> ans(queries.size());\\n        map<int,vector<pair<int,int>>> mp;\\n        for(int i=0;i<queries.size();++i){\\n            mp[nn-queries[i][1]].push_back({queries[i][0]-1,i});\\n        }\\n        vector<string_view> nums_sv{nums.begin(),nums.end()};\\n        for(auto [trim,idx]:mp){\\n            int i=trim;\\n            sort(v.begin(),v.end(),[&](int a,int b){\\n                return nums_sv[a].substr(i)==nums_sv[b].substr(i)?a<b:nums_sv[a].substr(i)<nums_sv[b].substr(i);\\n            });\\n            for(auto [f,s]:idx){\\n                ans[s]=v[f];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& queries) {\\n        int n=nums.size();\\n        vector<int> v(n,0);\\n        for(int i=0;i<n;++i){\\n            v[i]=i;\\n        }\\n        int nn=nums[0].size();\\n        vector<int> ans(queries.size());\\n        map<int,vector<pair<int,int>>> mp;\\n        for(int i=0;i<queries.size();++i){\\n            mp[nn-queries[i][1]].push_back({queries[i][0]-1,i});\\n        }\\n        vector<string_view> nums_sv{nums.begin(),nums.end()};\\n        for(auto [trim,idx]:mp){\\n            int i=trim;\\n            sort(v.begin(),v.end(),[&](int a,int b){\\n                return nums_sv[a].substr(i)==nums_sv[b].substr(i)?a<b:nums_sv[a].substr(i)<nums_sv[b].substr(i);\\n            });\\n            for(auto [f,s]:idx){\\n                ans[s]=v[f];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3386806,
                "title": "100-radix-sort-golang-detailed-explanation-with-examples",
                "content": "# Intuition\\nThe idea is to sort the original array by the least rightmost `trim` digits. This points to a **Radix Sort** solution.\\n\\nBecause we\\'ll have many queries for different trims, we\\'ll sort the `nums` array for all the `trim`s up to the maximum found in the queries.\\n\\nThis is basically doing Radix Sort, while storing each step of the process everytime we move to the next digit.\\n\\nBut because we need to return the index of the element in the original array, we need to keep this. That\\'s why for every sort step, we don\\'t keep the sorted array, but only their indexes in the original array. \\n\\n\\n# Approach\\nThe approach is to create a matrix where each row shows the index of the `nums` elements, sorted by  the rightmost `trim` digits.\\n\\nHere\\'s an example for `nums:[\"102\", \"473\", \"251\", \"814\"]`. \\n\\n |`trim`|102|473|251|814|\\n |---|---|---|---|---|\\n |`0`|0|1|2|3|\\n |`1`|2|0|1|3|\\n |`2`|0|3|2|1|\\n |`3`|0|2|1|3|\\n\\nEg: The first row (`0`) will just be `0, 1, 2 ... n` as this is the original unsorted `nums` \\n\\nEach row `i` will be sorting the previous row, using count sorting on the corresponding rightmost `trim` digit. \\n\\nAfter that, is just a matter of iterating over the queries and directly getting the `kth` smaller value for the corresponding `trim`.\\n     \\n\\n# Complexity\\n\\n**PLEASE help me improve or correct this section**\\n\\nThe running time requires a few parameters:\\n\\n$$W$$: maximum digit length within the list of integers (`maxTrim`)\\n$$N$$: size of the original string array `nums`\\n$$K$$: 10, since we are using counting sort and we have and alphabet size of 10 (digits)\\n$$Q$$: Number of queries\\n\\n- Time complexity:\\n    - $$O(Q + W(N+K))$$\\n        - Iterate $$Q$$ to get the `maxTrim`, and at the end to address the queries\\n        - Running time of LSD radix sort is $$O(W(N+K))$$ as a result of at most $$W$$ calls to counting sort.\\n\\n\\n- Space complexity:\\n    - $$O(K+(W*N)+Q)$$\\n        - The matrix table uses $$W*N$$\\n        - During counting sort, we use an extra array to count $$K$$ digits\\n        - Return $$Q$$ result elements. \\n\\n# Code\\n\\n## Algorithm\\n\\n* Iterate over the queries to find the maximum `trim` (`maxTrim`) requested\\n* Create an empty matrix where each row will hold the index of `nums` elements, sorted by `trim` rightmost digits\\n    * Initialize row `0` with 0 -> n for the unsorted indexes row.\\n    * For each `trim` (from 1 -> `maxTrim`), sort the `nums` array using the indexes from the **previous row** (Radix Sort), and add it to the matrix.\\n        * Sorting for each step is done with **Counting Sort**, using the indirection of the indexes to reach the `nums` element\\'s digit to count.\\n* We now just use all the calculations to address all queries\\n \\n\\n```\\nfunc smallestTrimmedNumbers(nums []string, queries [][]int) []int {\\n    // we\\'ll do radix sort until the highest trim requested in the queries\\n    maxTrim := -1\\n    for _, q := range queries {\\n        if q[1] > maxTrim {\\n            maxTrim = q[1]\\n        }\\n    }\\n\\n    // Create a matrix where each row shows the index of the nums, sorted by trim number \\n    // eg: The first row will just be 0, 1, 2 ... n as this is the original unsorted nums \\n    // The row i will be sorting the previous row, using count sorting on the corresponding rightmost digit. \\n    indexesOfSortedByTrim := make([][]int, maxTrim + 1)\\n\\n    // Initialize with unsorted\\n    indexesOfSortedByTrim[0] = make([]int, len(nums))\\n    for i:=0; i < len(nums); i++ {\\n        indexesOfSortedByTrim[0][i] = i\\n    }\\n\\n    // Now keep adding the sorted by trim lines \\n    for i := 1; i <= maxTrim; i++ {\\n        indexesOfSortedByTrim[i] = sortIndexesForTrim(nums, indexesOfSortedByTrim[i-1], i)\\n    }\\n    \\n    result := make([]int, len(queries))\\n\\n    // We now just use all the calculations to address all queries\\n    for i, q := range queries {\\n        result[i] = indexesOfSortedByTrim[q[1]][q[0]-1]\\n    }\\n\\n    return result\\n}\\n\\nfunc sortIndexesForTrim(nums []string, indexes []int, trim int) []int {\\n\\n    stringLen := len(nums[0]) // they are all the same \\n\\n    // let\\'s count the digts (0-9)\\n    counts := make([]int, 10)\\n\\n    for _, index := range indexes {\\n        digit := nums[index][stringLen-trim] - 48 // this converts the ascii char to its number\\n        counts[digit] ++\\n    }\\n\\n    // we now overwrite our original counts with the starting index\\n    // of each element in the final sorted array\\n    startingIndex := 0\\n    for i := 0; i < 10; i++ {\\n        count := counts[i]\\n        counts[i] = startingIndex\\n        startingIndex = startingIndex + count\\n    }\\n\\n    // Now iterate over indexes, and once again use the corresponding digit and use the starting index to place and reduce it\\n    sortedArray := make([]int, len(indexes))\\n\\n    for _, index := range indexes {\\n        digit := nums[index][stringLen-trim] - 48 // this converts the ascii char to its number\\n\\n        sortedArray[counts[digit]] = index\\n        // since we have placed an item in index counts[elem], we need to\\n        // increment counts[elem] index by 1 so the next duplicate element\\n        // is placed in appropriate index\\n        counts[digit] ++\\n    }\\n\\n    return sortedArray\\n\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Memoization",
                    "Sorting",
                    "Radix Sort",
                    "Counting Sort"
                ],
                "code": "```\\nfunc smallestTrimmedNumbers(nums []string, queries [][]int) []int {\\n    // we\\'ll do radix sort until the highest trim requested in the queries\\n    maxTrim := -1\\n    for _, q := range queries {\\n        if q[1] > maxTrim {\\n            maxTrim = q[1]\\n        }\\n    }\\n\\n    // Create a matrix where each row shows the index of the nums, sorted by trim number \\n    // eg: The first row will just be 0, 1, 2 ... n as this is the original unsorted nums \\n    // The row i will be sorting the previous row, using count sorting on the corresponding rightmost digit. \\n    indexesOfSortedByTrim := make([][]int, maxTrim + 1)\\n\\n    // Initialize with unsorted\\n    indexesOfSortedByTrim[0] = make([]int, len(nums))\\n    for i:=0; i < len(nums); i++ {\\n        indexesOfSortedByTrim[0][i] = i\\n    }\\n\\n    // Now keep adding the sorted by trim lines \\n    for i := 1; i <= maxTrim; i++ {\\n        indexesOfSortedByTrim[i] = sortIndexesForTrim(nums, indexesOfSortedByTrim[i-1], i)\\n    }\\n    \\n    result := make([]int, len(queries))\\n\\n    // We now just use all the calculations to address all queries\\n    for i, q := range queries {\\n        result[i] = indexesOfSortedByTrim[q[1]][q[0]-1]\\n    }\\n\\n    return result\\n}\\n\\nfunc sortIndexesForTrim(nums []string, indexes []int, trim int) []int {\\n\\n    stringLen := len(nums[0]) // they are all the same \\n\\n    // let\\'s count the digts (0-9)\\n    counts := make([]int, 10)\\n\\n    for _, index := range indexes {\\n        digit := nums[index][stringLen-trim] - 48 // this converts the ascii char to its number\\n        counts[digit] ++\\n    }\\n\\n    // we now overwrite our original counts with the starting index\\n    // of each element in the final sorted array\\n    startingIndex := 0\\n    for i := 0; i < 10; i++ {\\n        count := counts[i]\\n        counts[i] = startingIndex\\n        startingIndex = startingIndex + count\\n    }\\n\\n    // Now iterate over indexes, and once again use the corresponding digit and use the starting index to place and reduce it\\n    sortedArray := make([]int, len(indexes))\\n\\n    for _, index := range indexes {\\n        digit := nums[index][stringLen-trim] - 48 // this converts the ascii char to its number\\n\\n        sortedArray[counts[digit]] = index\\n        // since we have placed an item in index counts[elem], we need to\\n        // increment counts[elem] index by 1 so the next duplicate element\\n        // is placed in appropriate index\\n        counts[digit] ++\\n    }\\n\\n    return sortedArray\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3300113,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& queries) {\\n        int m = nums[0].size() ;\\n        int n = nums.size() ;\\n        vector<vector<int>>dp(m+1, vector<int>(n)) ;\\n        for(int i = 0; i < n; i++)\\n            dp[0][i] = i ;\\n        for(int i = 1; i <= m; i++)\\n        {\\n            vector<vector<int>>buckets(10) ;\\n            for(int j = 0; j < n; j++)\\n            {\\n                int idx = dp[i-1][j] ;\\n                buckets[nums[idx][m-i] - \\'0\\'].push_back(idx) ;\\n            }\\n            int j = 0 ;\\n            for(int b = 0; b < 10; b++)\\n            {\\n                for(auto& idx : buckets[b]){\\n                    dp[i][j] = idx ;\\n                    j++ ;\\n                }\\n            }\\n        }\\n\\n        vector<int>ret ;\\n        for(auto& q : queries)\\n        {\\n            ret.push_back(dp[q[1]][q[0]-1]) ;\\n        }\\n        return ret ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& queries) {\\n        int m = nums[0].size() ;\\n        int n = nums.size() ;\\n        vector<vector<int>>dp(m+1, vector<int>(n)) ;\\n        for(int i = 0; i < n; i++)\\n            dp[0][i] = i ;\\n        for(int i = 1; i <= m; i++)\\n        {\\n            vector<vector<int>>buckets(10) ;\\n            for(int j = 0; j < n; j++)\\n            {\\n                int idx = dp[i-1][j] ;\\n                buckets[nums[idx][m-i] - \\'0\\'].push_back(idx) ;\\n            }\\n            int j = 0 ;\\n            for(int b = 0; b < 10; b++)\\n            {\\n                for(auto& idx : buckets[b]){\\n                    dp[i][j] = idx ;\\n                    j++ ;\\n                }\\n            }\\n        }\\n\\n        vector<int>ret ;\\n        for(auto& q : queries)\\n        {\\n            ret.push_back(dp[q[1]][q[0]-1]) ;\\n        }\\n        return ret ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3280849,
                "title": "c-golang-radix-sort-straight-forward-and-space-optimised",
                "content": "# Code\\n```\\n// C++\\nclass Solution {\\npublic:\\n    vector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& queries) {\\n        int n = nums.size();\\n        vector<pair<string, int>> num_index(n);\\n        for(int i = 0; i < n; i++) {\\n            num_index[i] = {nums[i], i};\\n        }\\n        int d = nums[0].length();\\n        vector<int> ans(queries.size());\\n        for(int i = 0; i < d; i++) {\\n            vector<pair<string, int>> queues[10];\\n            for(int j = 0; j < n; j++) {\\n                queues[num_index[j].first[d - i - 1] - \\'0\\'].push_back(num_index[j]);\\n            }\\n            int p = 0;\\n            for(int j = 0; j < 10; j++) {\\n                for(pair<string, int> s: queues[j]) {\\n                    num_index[p++] = s;\\n                }\\n            }\\n            for(int j = 0; j < queries.size(); j++) {\\n                if(i == queries[j][1] - 1)\\n                    ans[j] = num_index[queries[j][0] - 1].second;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\nOR\\n\\n// Space Optimized\\nclass Solution {\\npublic:\\n    vector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& queries) {\\n        int n = nums.size();\\n        int d = nums[0].length();\\n        vector<int> index(n);\\n        iota(index.begin(), index.end(), 0);\\n        vector<int> ans(queries.size());\\n        for(int i = 0; i < d; i++) {\\n            vector<int> queues[10];\\n            for(int j = 0; j < n; j++) {\\n                queues[nums[index[j]][d - i - 1] - \\'0\\'].push_back(index[j]);\\n            }\\n            int p = 0;\\n            for(int j = 0; j < 10; j++) {\\n                for(int s: queues[j]) {\\n                    index[p++] = s;\\n                }\\n            }\\n            for(int j = 0; j < queries.size(); j++) {\\n                if(i == queries[j][1] - 1)\\n                    ans[j] = index[queries[j][0] - 1];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n-------------------------------------------------------\\n\\n// Golang\\n// Space Optimised\\nfunc smallestTrimmedNumbers(nums []string, queries [][]int) []int {\\n    n := len(nums)\\n    d := len(nums[0])\\n    index := make([]int, n)\\n    for i := 0; i < n; i++ {\\n        index[i] = i\\n    }\\n    ans := make([]int, len(queries))\\n    for i := 0; i < d; i++ {\\n        queues := make([][]int, 10)\\n        for j := 0; j < n; j++ {\\n            queues[nums[index[j]][d - i - 1] - \\'0\\'] = append(queues[nums[index[j]][d - i - 1] - \\'0\\'], index[j])\\n        }\\n        var p int = 0\\n        for j := 0; j < 10; j++ {\\n            for _, s := range queues[j] {\\n                index[p] = s\\n                p++\\n            }\\n        }\\n        for j := 0; j < len(queries); j++ {\\n            if i == queries[j][1] - 1 {\\n                ans[j] = index[queries[j][0] - 1]\\n            }\\n        }\\n    }\\n    return ans\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Go",
                    "String",
                    "Sorting",
                    "Radix Sort"
                ],
                "code": "```\\n// C++\\nclass Solution {\\npublic:\\n    vector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& queries) {\\n        int n = nums.size();\\n        vector<pair<string, int>> num_index(n);\\n        for(int i = 0; i < n; i++) {\\n            num_index[i] = {nums[i], i};\\n        }\\n        int d = nums[0].length();\\n        vector<int> ans(queries.size());\\n        for(int i = 0; i < d; i++) {\\n            vector<pair<string, int>> queues[10];\\n            for(int j = 0; j < n; j++) {\\n                queues[num_index[j].first[d - i - 1] - \\'0\\'].push_back(num_index[j]);\\n            }\\n            int p = 0;\\n            for(int j = 0; j < 10; j++) {\\n                for(pair<string, int> s: queues[j]) {\\n                    num_index[p++] = s;\\n                }\\n            }\\n            for(int j = 0; j < queries.size(); j++) {\\n                if(i == queries[j][1] - 1)\\n                    ans[j] = num_index[queries[j][0] - 1].second;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\nOR\\n\\n// Space Optimized\\nclass Solution {\\npublic:\\n    vector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& queries) {\\n        int n = nums.size();\\n        int d = nums[0].length();\\n        vector<int> index(n);\\n        iota(index.begin(), index.end(), 0);\\n        vector<int> ans(queries.size());\\n        for(int i = 0; i < d; i++) {\\n            vector<int> queues[10];\\n            for(int j = 0; j < n; j++) {\\n                queues[nums[index[j]][d - i - 1] - \\'0\\'].push_back(index[j]);\\n            }\\n            int p = 0;\\n            for(int j = 0; j < 10; j++) {\\n                for(int s: queues[j]) {\\n                    index[p++] = s;\\n                }\\n            }\\n            for(int j = 0; j < queries.size(); j++) {\\n                if(i == queries[j][1] - 1)\\n                    ans[j] = index[queries[j][0] - 1];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n-------------------------------------------------------\\n\\n// Golang\\n// Space Optimised\\nfunc smallestTrimmedNumbers(nums []string, queries [][]int) []int {\\n    n := len(nums)\\n    d := len(nums[0])\\n    index := make([]int, n)\\n    for i := 0; i < n; i++ {\\n        index[i] = i\\n    }\\n    ans := make([]int, len(queries))\\n    for i := 0; i < d; i++ {\\n        queues := make([][]int, 10)\\n        for j := 0; j < n; j++ {\\n            queues[nums[index[j]][d - i - 1] - \\'0\\'] = append(queues[nums[index[j]][d - i - 1] - \\'0\\'], index[j])\\n        }\\n        var p int = 0\\n        for j := 0; j < 10; j++ {\\n            for _, s := range queues[j] {\\n                index[p] = s\\n                p++\\n            }\\n        }\\n        for j := 0; j < len(queries); j++ {\\n            if i == queries[j][1] - 1 {\\n                ans[j] = index[queries[j][0] - 1]\\n            }\\n        }\\n    }\\n    return ans\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3278877,
                "title": "simple-c-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> smallestTrimmedNumbers(vector<string>& a, vector<vector<int>>& queries) {\\n        int i,n=a.size();\\n        vector<int>ans;\\n        for(auto it:queries){\\n            vector<pair<string,int>>v;\\n            int y=a[0].size();\\n            for(i=0;i<n;i++){\\n                string s=a[i];\\n                v.push_back({s.substr(y-it[1]),i});\\n            }\\n            sort(v.begin(),v.end());\\n            ans.push_back(v[it[0]-1].second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestTrimmedNumbers(vector<string>& a, vector<vector<int>>& queries) {\\n        int i,n=a.size();\\n        vector<int>ans;\\n        for(auto it:queries){\\n            vector<pair<string,int>>v;\\n            int y=a[0].size();\\n            for(i=0;i<n;i++){\\n                string s=a[i];\\n                v.push_back({s.substr(y-it[1]),i});\\n            }\\n            sort(v.begin(),v.end());\\n            ans.push_back(v[it[0]-1].second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3251913,
                "title": "precompute-the-answer-for-every-trim-and-kth-value-o-n-q",
                "content": "```\\nclass Solution {\\npublic:\\n    // Radix Sort\\n    vector<vector<int>> order;      // order of indices ( precomputed answer)\\n    void radixSort(vector<pair<string, int>>& a){\\n        int n = a.size();\\n        int len = a[0].first.size();\\n        for(int i = len - 1; i >= 0; --i){\\n            vector<vector<int>> ind(10);         // for every column ( indices ) we store the indices of the sorted array ( helps in stable sorting ) \\n\\t\\t\\t\\n            for(int it = 0; it < n; ++it){\\n                auto& str = a[it].first;\\n                ind[str[i] - \\'0\\'].push_back(it);\\n            }\\n            \\n            vector<pair<string, int>> tmp(n);\\n            vector<int> ord(n);         // storing answer for ith rightmost digit \\n            int j = 0;\\n            for(int it = 0; it < 10; ++it){\\n                for(int& val : ind[it]){\\n                    tmp[j] = a[val];\\n                    ord[j] = a[val].second;\\n                    j++;\\n                }\\n            }\\n            order.push_back(ord);\\n            swap(tmp, a);\\n        }\\n        return;\\n    }\\n\\t\\n    vector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& queries) {\\n        // use radix sort to sort the numbers digit by digit and simulatenously store the answer for every digit\\n\\t\\t\\n        int n = nums.size();\\n        vector<pair<string, int>> a(n);\\n        for(int i = 0; i < n; ++i){\\n            a[i] = {nums[i], i};\\n        }\\n        radixSort(a);\\n        \\n        vector<int> ans;\\n        for(auto& q : queries){\\n            int kth = q[0], trim = q[1];\\n            ans.push_back(order[trim - 1][kth - 1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Radix Sort\\n    vector<vector<int>> order;      // order of indices ( precomputed answer)\\n    void radixSort(vector<pair<string, int>>& a){\\n        int n = a.size();\\n        int len = a[0].first.size();\\n        for(int i = len - 1; i >= 0; --i){\\n            vector<vector<int>> ind(10);         // for every column ( indices ) we store the indices of the sorted array ( helps in stable sorting ) \\n\\t\\t\\t\\n            for(int it = 0; it < n; ++it){\\n                auto& str = a[it].first;\\n                ind[str[i] - \\'0\\'].push_back(it);\\n            }\\n            \\n            vector<pair<string, int>> tmp(n);\\n            vector<int> ord(n);         // storing answer for ith rightmost digit \\n            int j = 0;\\n            for(int it = 0; it < 10; ++it){\\n                for(int& val : ind[it]){\\n                    tmp[j] = a[val];\\n                    ord[j] = a[val].second;\\n                    j++;\\n                }\\n            }\\n            order.push_back(ord);\\n            swap(tmp, a);\\n        }\\n        return;\\n    }\\n\\t\\n    vector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& queries) {\\n        // use radix sort to sort the numbers digit by digit and simulatenously store the answer for every digit\\n\\t\\t\\n        int n = nums.size();\\n        vector<pair<string, int>> a(n);\\n        for(int i = 0; i < n; ++i){\\n            a[i] = {nums[i], i};\\n        }\\n        radixSort(a);\\n        \\n        vector<int> ans;\\n        for(auto& q : queries){\\n            int kth = q[0], trim = q[1];\\n            ans.push_back(order[trim - 1][kth - 1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3216702,
                "title": "c-o-n-m-q-solution",
                "content": "# Intuition\\nStore the index of element in original array at the sorted position for every place of element in radix sort.\\n\\n# Approach\\n1. Sort array using radix sort\\n2. at every radix/place of element store the index of original array at the next sorted radix array position.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n * d)$$\\n    - where d is maximum digits/length of element of array \\n    \\n\\n- Space complexity:\\n$$O(n*d)$$\\n    - n is size of array\\n    - d is maximum size of element of array\\n\\n# Code\\n```\\nclass Solution {\\n\\npublic:\\n\\n    template<typename T>\\n    void print_arr(vector<T> &v)\\n    {\\n        for(auto &x: v)\\n            cout<<x<<\" \";\\n        cout<<endl;\\n    }\\n\\n    void radix_sort(vector<vector<int>> &memo, vector<string> &nums, int n)\\n    {\\n       \\n        vector<int> freq(10);\\n        vector<string> next(nums.begin(), nums.end());\\n        vector<string> curr(nums.begin(), nums.end());\\n       \\n        for(int i=0; i < n; i++)\\n        {\\n            std::fill(freq.begin(), freq.end(), 0);\\n\\n            int place = curr[0].size() - 1 - i;\\n            \\n          \\n            char base = \\'0\\';\\n\\n            // count occurence of digit for given place in array\\n            for(auto &x: curr)\\n            {\\n                int digit = (x[place] - base);\\n               \\n                freq[digit]++;\\n            }\\n\\n            //print_arr(freq);\\n\\n            // find next available index for place\\'s digit in sorted array\\n            auto next_idx = 0;\\n            for(int i = 0; i<freq.size(); i++)\\n            {\\n                int count = freq[i];\\n                freq[i] = next_idx;\\n                next_idx += count;\\n            }\\n\\n            //print_arr(freq);\\n\\n            \\n\\n            // sort array\\n            for(int j=0; j<curr.size(); j++)\\n            {\\n                auto x = curr[j];\\n                int digit = (x[place] - base);\\n\\n                // get index for digit\\n                int idx = freq[digit];\\n\\n                // store the index of original element to next sorted position\\n                memo[i+1][idx] = memo[i][j];\\n                next[idx] = x;\\n\\n                // increase index for next time digit happen\\n                freq[digit]++; \\n            }\\n            \\n            curr = next;\\n        }\\n  \\n    \\n    }\\n\\n\\n    vector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& queries) {\\n        \\n        auto n = nums[0].size();\\n        vector<vector<int>> memo(n+1, vector<int>(nums.size()));\\n       \\n        for(int i=0;i<nums.size(); i++)\\n          memo[0][i] = i;\\n       \\n\\n        radix_sort(memo, nums,  n);\\n\\n        vector<int> res(queries.size());\\n\\n        \\n        \\n        int i=0;\\n        for(auto &q: queries)\\n        {\\n            auto k = q[0];\\n            auto t = q[1];\\n\\n            res[i++] = memo[t][k-1];\\n        }\\n\\n        return res;\\n    }\\n\\n \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n\\npublic:\\n\\n    template<typename T>\\n    void print_arr(vector<T> &v)\\n    {\\n        for(auto &x: v)\\n            cout<<x<<\" \";\\n        cout<<endl;\\n    }\\n\\n    void radix_sort(vector<vector<int>> &memo, vector<string> &nums, int n)\\n    {\\n       \\n        vector<int> freq(10);\\n        vector<string> next(nums.begin(), nums.end());\\n        vector<string> curr(nums.begin(), nums.end());\\n       \\n        for(int i=0; i < n; i++)\\n        {\\n            std::fill(freq.begin(), freq.end(), 0);\\n\\n            int place = curr[0].size() - 1 - i;\\n            \\n          \\n            char base = \\'0\\';\\n\\n            // count occurence of digit for given place in array\\n            for(auto &x: curr)\\n            {\\n                int digit = (x[place] - base);\\n               \\n                freq[digit]++;\\n            }\\n\\n            //print_arr(freq);\\n\\n            // find next available index for place\\'s digit in sorted array\\n            auto next_idx = 0;\\n            for(int i = 0; i<freq.size(); i++)\\n            {\\n                int count = freq[i];\\n                freq[i] = next_idx;\\n                next_idx += count;\\n            }\\n\\n            //print_arr(freq);\\n\\n            \\n\\n            // sort array\\n            for(int j=0; j<curr.size(); j++)\\n            {\\n                auto x = curr[j];\\n                int digit = (x[place] - base);\\n\\n                // get index for digit\\n                int idx = freq[digit];\\n\\n                // store the index of original element to next sorted position\\n                memo[i+1][idx] = memo[i][j];\\n                next[idx] = x;\\n\\n                // increase index for next time digit happen\\n                freq[digit]++; \\n            }\\n            \\n            curr = next;\\n        }\\n  \\n    \\n    }\\n\\n\\n    vector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& queries) {\\n        \\n        auto n = nums[0].size();\\n        vector<vector<int>> memo(n+1, vector<int>(nums.size()));\\n       \\n        for(int i=0;i<nums.size(); i++)\\n          memo[0][i] = i;\\n       \\n\\n        radix_sort(memo, nums,  n);\\n\\n        vector<int> res(queries.size());\\n\\n        \\n        \\n        int i=0;\\n        for(auto &q: queries)\\n        {\\n            auto k = q[0];\\n            auto t = q[1];\\n\\n            res[i++] = memo[t][k-1];\\n        }\\n\\n        return res;\\n    }\\n\\n \\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3212017,
                "title": "c-20-priority-queue-string-view-with-memoization",
                "content": "# Explanation\\nThe solution is pretty run-of-the-mill, except intermediate results from string trimming are stored and memoized in a light string view. The idea is to form string views of the trimmed strings, then lexicographically compare and sort them into a priority queue to form a heap and using the original index as a tie-breaker per the problem spec.\\n\\n\\n# Code\\n```\\n// Pair with comparison ops implemented for the purposes of this problem\\nstruct FunkyPair {\\n    std::string_view first;\\n\\n    int second;\\n\\n    friend bool operator>(const FunkyPair& l, const FunkyPair& r) {\\n        if(l.first == r.first)\\n            return l.second < r.second;\\n\\n        return l.first < r.first;\\n    }\\n\\n    friend bool operator<(const FunkyPair& l, const FunkyPair& r) {\\n        if(l.first == r.first)\\n            return l.second > r.second;\\n\\n        return l.first > r.first;\\n    }\\n\\n    friend bool operator==(const FunkyPair& l, const FunkyPair& r) {\\n        return (l.first == r.first) && (l.second == r.second);\\n    }\\n};\\n\\nclass Solution {\\n    /* cache pre-sorted arrays, keyed by trim length */\\n    std::map<std::size_t, std::priority_queue<FunkyPair>> cache_;\\npublic:\\n    vector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& queries) {\\n        std::vector<int> ans;\\n        for(const auto& q : queries) {\\n            const auto& k_i = q.front(), trim_i = q.back();\\n\\n            // Trim vector to the length, form a priority queue, and memoize that queue returning a copy\\n            auto pq = trim_vector(nums, trim_i);\\n\\n            // Skip first k-1\\n            for(int j = 1; j < k_i; ++j)\\n                pq.pop();\\n\\n            // push kth\\n            ans.push_back(pq.top().second);\\n        }\\n        \\n        return ans;\\n    }\\n\\n    std::priority_queue<FunkyPair> trim_vector(const std::vector<string>& nums, int trim_i) {\\n        if(cache_.count(trim_i))\\n            return cache_[trim_i];\\n\\n        // default construct a new pq\\n        auto& pq = cache_[trim_i];\\n\\n        int i = 0;\\n        for(const auto& snum : nums) {\\n            const auto& base = snum.c_str() + (snum.size() - trim_i);\\n            pq.emplace(\\n                FunkyPair{\\n                    std::string_view(base, trim_i),\\n                    i++\\n                }\\n            );\\n        }\\n\\n        return pq;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Memoization"
                ],
                "code": "```\\n// Pair with comparison ops implemented for the purposes of this problem\\nstruct FunkyPair {\\n    std::string_view first;\\n\\n    int second;\\n\\n    friend bool operator>(const FunkyPair& l, const FunkyPair& r) {\\n        if(l.first == r.first)\\n            return l.second < r.second;\\n\\n        return l.first < r.first;\\n    }\\n\\n    friend bool operator<(const FunkyPair& l, const FunkyPair& r) {\\n        if(l.first == r.first)\\n            return l.second > r.second;\\n\\n        return l.first > r.first;\\n    }\\n\\n    friend bool operator==(const FunkyPair& l, const FunkyPair& r) {\\n        return (l.first == r.first) && (l.second == r.second);\\n    }\\n};\\n\\nclass Solution {\\n    /* cache pre-sorted arrays, keyed by trim length */\\n    std::map<std::size_t, std::priority_queue<FunkyPair>> cache_;\\npublic:\\n    vector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& queries) {\\n        std::vector<int> ans;\\n        for(const auto& q : queries) {\\n            const auto& k_i = q.front(), trim_i = q.back();\\n\\n            // Trim vector to the length, form a priority queue, and memoize that queue returning a copy\\n            auto pq = trim_vector(nums, trim_i);\\n\\n            // Skip first k-1\\n            for(int j = 1; j < k_i; ++j)\\n                pq.pop();\\n\\n            // push kth\\n            ans.push_back(pq.top().second);\\n        }\\n        \\n        return ans;\\n    }\\n\\n    std::priority_queue<FunkyPair> trim_vector(const std::vector<string>& nums, int trim_i) {\\n        if(cache_.count(trim_i))\\n            return cache_[trim_i];\\n\\n        // default construct a new pq\\n        auto& pq = cache_[trim_i];\\n\\n        int i = 0;\\n        for(const auto& snum : nums) {\\n            const auto& base = snum.c_str() + (snum.size() - trim_i);\\n            pq.emplace(\\n                FunkyPair{\\n                    std::string_view(base, trim_i),\\n                    i++\\n                }\\n            );\\n        }\\n\\n        return pq;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3211786,
                "title": "simple-python3-solution-beats-86-12-runtime",
                "content": "My python3 solution; beats 86.12% runtime\\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def smallestTrimmedNumbers(self, nums: List[str], queries: List[List[int]]) -> List[int]:\\n        result = []\\n        for index, trim in queries:\\n            # save trimmed and original index to list of tuples\\n            trimmed = [ (val[-trim: ], i)  for i,val in enumerate(nums) ]\\n            # sort by the trimmed key\\n            trimmed.sort(key=lambda x:x[0])\\n            # 2nd element of the tuple is the result index\\n            res_index = trimmed[index-1][1]\\n            result.append(res_index)\\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def smallestTrimmedNumbers(self, nums: List[str], queries: List[List[int]]) -> List[int]:\\n        result = []\\n        for index, trim in queries:\\n            # save trimmed and original index to list of tuples\\n            trimmed = [ (val[-trim: ], i)  for i,val in enumerate(nums) ]\\n            # sort by the trimmed key\\n            trimmed.sort(key=lambda x:x[0])\\n            # 2nd element of the tuple is the result index\\n            res_index = trimmed[index-1][1]\\n            result.append(res_index)\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3183415,
                "title": "c-use-stable-sort",
                "content": "I did a google search and found stable_sort. I think that solves the problem.\\n```\\nclass Solution {\\npublic:\\n    vector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& queries) {\\n        vector<pair<string,int>> original, current;\\n        for (int i = 0; i < nums.size(); ++i)\\n            original.push_back({nums[i], i});\\n        current = original;\\n        vector<int> ans;\\n        for (auto& v : queries){\\n            for (auto& [f,s] : current)\\n                f = f.substr(f.size() - v[1]);\\n            stable_sort(current.begin(), current.end());\\n            ans.push_back(current[v[0] - 1].second);\\n            current = original;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& queries) {\\n        vector<pair<string,int>> original, current;\\n        for (int i = 0; i < nums.size(); ++i)\\n            original.push_back({nums[i], i});\\n        current = original;\\n        vector<int> ans;\\n        for (auto& v : queries){\\n            for (auto& [f,s] : current)\\n                f = f.substr(f.size() - v[1]);\\n            stable_sort(current.begin(), current.end());\\n            ans.push_back(current[v[0] - 1].second);\\n            current = original;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3175690,
                "title": "solution-using-quickselect",
                "content": "# Intuition\\nFirst for each query I created trimmed number, that is take last n characters and store it in a pair along side it\\'s index.\\nAnd then sort only that part where the solution lies, that is upto the kth position.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nQuickSelect approach is to based on quicksort, but in quickselect we sort an array only in the part where the solution lies, for example if my pivot is (left + right / 2) and say i need kth smallest number and k < pivot. Then after running applying Hoare or Lomuto partitioning algorithm on current state that is [left, right] will just call the quicksort on the part [left, pivot) else if k > pivot i will call quicksort on part (pivot, left] not on both.\\nThere is also nth_element function in cpp https://en.cppreference.com/w/cpp/algorithm/nth_element if you want to read more on this.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: Worst case complexity is O(N^2) but average case is O(N) for each query, So if M query are there than O(M^N) average case.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N) space is used to store the trimmed elements.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    // pair of index , trimmed number\\n\\tvector<pair<int, string>> numsTrimmed;\\n\\n\\tint partition(int left, int right) {\\n        // lomuto partition algorithm\\n\\t\\tif(left == right)\\n\\t\\t\\treturn left;\\n\\t\\tint pivot = (left + right) / 2;\\n\\t\\tint swapPos = left, i = left;\\n\\t\\tswap(numsTrimmed[pivot], numsTrimmed[right]);\\n\\t\\tfor(; i < right; ++i){\\n            // if current element is less then pivot value\\n            // move to left of correct pivot position\\n            // or if value are same but index is less\\n            // then also move to left pivot position.\\n\\t\\t\\tif(numsTrimmed[i].second < numsTrimmed[right].second)\\n\\t\\t\\t\\tswap(numsTrimmed[i], numsTrimmed[swapPos++]);\\n\\t\\t\\telse if(numsTrimmed[i].second == numsTrimmed[right].second \\n\\t\\t\\t\\tand numsTrimmed[i].first < numsTrimmed[right].first)\\n\\t\\t\\t\\tswap(numsTrimmed[i], numsTrimmed[swapPos++]);\\n\\t\\t}\\n\\t\\tswap(numsTrimmed[swapPos], numsTrimmed[right]);\\n\\t\\treturn swapPos;\\n\\t}\\n\\n\\tvoid quickSelect(int left, int right, int k) {\\n\\t\\tif(left >= right)\\n\\t\\t\\treturn;\\n\\t\\tint pivot = partition(left, right);\\n        // if partitioned index is k we found the value\\n\\t\\tif(pivot == k)\\treturn;\\n        // if pivot < k search in right subarray of pivot\\n\\t\\tif(pivot < k)\\tquickSelect(pivot + 1, right, k);\\n        // else search in left subarray of pivot\\n\\t\\telse \\t\\t\\tquickSelect(left, pivot - 1, k);\\n\\t}\\npublic:\\n    vector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& queries) {\\n        int size = nums.size(), i, temp;\\n        numsTrimmed = vector<pair<int, string>> (size);\\n        vector<int> answer;\\n        for(auto &vec : queries) {\\n            for(i = 0; i < size;++i){\\n            \\ttemp = nums[i].size();\\n                // pair of index and trimmed number.\\n                numsTrimmed[i] = {i, nums[i].substr(temp - vec[1], vec[1])};\\n            }\\n            quickSelect(0, size - 1, vec[0] - 1);\\n            answer.emplace_back(numsTrimmed[vec[0] - 1].first);\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    // pair of index , trimmed number\\n\\tvector<pair<int, string>> numsTrimmed;\\n\\n\\tint partition(int left, int right) {\\n        // lomuto partition algorithm\\n\\t\\tif(left == right)\\n\\t\\t\\treturn left;\\n\\t\\tint pivot = (left + right) / 2;\\n\\t\\tint swapPos = left, i = left;\\n\\t\\tswap(numsTrimmed[pivot], numsTrimmed[right]);\\n\\t\\tfor(; i < right; ++i){\\n            // if current element is less then pivot value\\n            // move to left of correct pivot position\\n            // or if value are same but index is less\\n            // then also move to left pivot position.\\n\\t\\t\\tif(numsTrimmed[i].second < numsTrimmed[right].second)\\n\\t\\t\\t\\tswap(numsTrimmed[i], numsTrimmed[swapPos++]);\\n\\t\\t\\telse if(numsTrimmed[i].second == numsTrimmed[right].second \\n\\t\\t\\t\\tand numsTrimmed[i].first < numsTrimmed[right].first)\\n\\t\\t\\t\\tswap(numsTrimmed[i], numsTrimmed[swapPos++]);\\n\\t\\t}\\n\\t\\tswap(numsTrimmed[swapPos], numsTrimmed[right]);\\n\\t\\treturn swapPos;\\n\\t}\\n\\n\\tvoid quickSelect(int left, int right, int k) {\\n\\t\\tif(left >= right)\\n\\t\\t\\treturn;\\n\\t\\tint pivot = partition(left, right);\\n        // if partitioned index is k we found the value\\n\\t\\tif(pivot == k)\\treturn;\\n        // if pivot < k search in right subarray of pivot\\n\\t\\tif(pivot < k)\\tquickSelect(pivot + 1, right, k);\\n        // else search in left subarray of pivot\\n\\t\\telse \\t\\t\\tquickSelect(left, pivot - 1, k);\\n\\t}\\npublic:\\n    vector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& queries) {\\n        int size = nums.size(), i, temp;\\n        numsTrimmed = vector<pair<int, string>> (size);\\n        vector<int> answer;\\n        for(auto &vec : queries) {\\n            for(i = 0; i < size;++i){\\n            \\ttemp = nums[i].size();\\n                // pair of index and trimmed number.\\n                numsTrimmed[i] = {i, nums[i].substr(temp - vec[1], vec[1])};\\n            }\\n            quickSelect(0, size - 1, vec[0] - 1);\\n            answer.emplace_back(numsTrimmed[vec[0] - 1].first);\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3155812,
                "title": "java-not-easy-lol-explained-with-example",
                "content": "# Code\\n```\\n// Input: nums = [\"102\",\"473\",\"251\",\"814\"], queries = [[1,1],[2,3],[4,2],[1,2]]\\n// res = [ , , , ]\\n\\n// For first query trim all the num in nums\\n// add all the trimmed nums with their index in the list\\n// sort all the trimmed nums - so that we can find the Kth smallest number and add its index to the res.\\n// Repeat this process for every query \\n\\n// while(!query.isFinished){\\n// query --> trim --> sort --> findKthSmall --> addItsIndextoresArr\\n// }\\n// return res\\n\\n// there are 4 query so we get only 4 res\\n// I\\'m explaining only for query1 rest you can practice\\n// query1 = [1,1]\\n// query1[0] is k and query1[1] is trim \\n// so trim all the nums nums[j].substr(len - trim) = nums[j].substr(3 - 1) = nums[j].substr(2);\\n// trimming - [2,3,1,4]\\n// add in the list with their indexes [{\"2\",0},{\"3\",1},{\"1\",2},{\"4\",3}]\\n// after sorting - [{\"1\",2},{\"2\",0},{\"3\",1},{\"4\",3}]\\n// k is 1 so we have to find the index of 1st smallest trimmed number i.e {\"1\",2} --> 2.\\n// res = {2}\\n// final output -> res -> [2,2,1,0]\\n\\nclass Solution{\\npublic int[] smallestTrimmedNumbers(String[] nums, int[][] queries) {\\n    int[] res = new int[queries.length];\\n    for (int i = 0; i < queries.length; i++) {\\n        List<Pair<String, Integer>> list = new ArrayList<>();\\n        // Trimming each number to its rightmost trim(i) digits\\n        for (int j = 0; j < nums.length; j++) {\\n            list.add(new Pair(nums[j].substring(nums[j].length() - queries[i][1]), j));\\n        }\\n        // Sorting\\n        Collections.sort(list, (a, b) -> a.getKey().compareTo(b.getKey()));\\n        \\n        //  Store the index of Kth smallest no. in res array \\n        res[i] = list.get(queries[i][0] - 1).getValue();\\n    }\\n    return res;\\n}\\n}\\n```\\n## Please upvote if you found this post helpful :)",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String",
                    "Sorting"
                ],
                "code": "```\\n// Input: nums = [\"102\",\"473\",\"251\",\"814\"], queries = [[1,1],[2,3],[4,2],[1,2]]\\n// res = [ , , , ]\\n\\n// For first query trim all the num in nums\\n// add all the trimmed nums with their index in the list\\n// sort all the trimmed nums - so that we can find the Kth smallest number and add its index to the res.\\n// Repeat this process for every query \\n\\n// while(!query.isFinished){\\n// query --> trim --> sort --> findKthSmall --> addItsIndextoresArr\\n// }\\n// return res\\n\\n// there are 4 query so we get only 4 res\\n// I\\'m explaining only for query1 rest you can practice\\n// query1 = [1,1]\\n// query1[0] is k and query1[1] is trim \\n// so trim all the nums nums[j].substr(len - trim) = nums[j].substr(3 - 1) = nums[j].substr(2);\\n// trimming - [2,3,1,4]\\n// add in the list with their indexes [{\"2\",0},{\"3\",1},{\"1\",2},{\"4\",3}]\\n// after sorting - [{\"1\",2},{\"2\",0},{\"3\",1},{\"4\",3}]\\n// k is 1 so we have to find the index of 1st smallest trimmed number i.e {\"1\",2} --> 2.\\n// res = {2}\\n// final output -> res -> [2,2,1,0]\\n\\nclass Solution{\\npublic int[] smallestTrimmedNumbers(String[] nums, int[][] queries) {\\n    int[] res = new int[queries.length];\\n    for (int i = 0; i < queries.length; i++) {\\n        List<Pair<String, Integer>> list = new ArrayList<>();\\n        // Trimming each number to its rightmost trim(i) digits\\n        for (int j = 0; j < nums.length; j++) {\\n            list.add(new Pair(nums[j].substring(nums[j].length() - queries[i][1]), j));\\n        }\\n        // Sorting\\n        Collections.sort(list, (a, b) -> a.getKey().compareTo(b.getKey()));\\n        \\n        //  Store the index of Kth smallest no. in res array \\n        res[i] = list.get(queries[i][0] - 1).getValue();\\n    }\\n    return res;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3059293,
                "title": "c-soln-without-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& queries) {\\n        int n = nums.size();\\n        int m = nums[0].size();\\n        vector<int> v;\\n        for(int i=0;i<queries.size();i++){\\n            int x = queries[i][0];\\n            int y= queries[i][1];\\n            int z = m-y;\\n            priority_queue<pair<string,int>> pq;\\n            for(int j=0;j<n;j++){\\n                string s = nums[j].substr(z);//get trimmed string\\n                pq.push({s,j});\\n                if(pq.size()>x) pq.pop();//if size greater than x then pop so that we get xth smallest no on top\\n            }\\n            int a = pq.top().second;//get index of xth smallest no\\n            v.push_back(a);//push it in vector\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& queries) {\\n        int n = nums.size();\\n        int m = nums[0].size();\\n        vector<int> v;\\n        for(int i=0;i<queries.size();i++){\\n            int x = queries[i][0];\\n            int y= queries[i][1];\\n            int z = m-y;\\n            priority_queue<pair<string,int>> pq;\\n            for(int j=0;j<n;j++){\\n                string s = nums[j].substr(z);//get trimmed string\\n                pq.push({s,j});\\n                if(pq.size()>x) pq.pop();//if size greater than x then pop so that we get xth smallest no on top\\n            }\\n            int a = pq.top().second;//get index of xth smallest no\\n            v.push_back(a);//push it in vector\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3053822,
                "title": "easy-c-solution-brute-force-using-vector-vector-pair-string-int",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& queries) {\\n        vector<vector<pair<string,int>>> v; //storing {substring, index}\\n        for(int i=nums[0].size()-1;i>=0;i--) {\\n            vector<pair<string, int>> temp;\\n            for(int j=0;j<nums.size();j++) {\\n                string st(nums[j].begin()+i, nums[j].end());\\n                temp.push_back({st, j});\\n            }\\n            sort(temp.begin(), temp.end()); //sort each substring \\n            v.push_back(temp);\\n        }\\n        vector<int> ans;\\n        for(auto i: queries) {\\n            ans.push_back(v[i[1]-1][i[0]-1].second); //k = i[0]th smallest trimmed to i[1] = trim number\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& queries) {\\n        vector<vector<pair<string,int>>> v; //storing {substring, index}\\n        for(int i=nums[0].size()-1;i>=0;i--) {\\n            vector<pair<string, int>> temp;\\n            for(int j=0;j<nums.size();j++) {\\n                string st(nums[j].begin()+i, nums[j].end());\\n                temp.push_back({st, j});\\n            }\\n            sort(temp.begin(), temp.end()); //sort each substring \\n            v.push_back(temp);\\n        }\\n        vector<int> ans;\\n        for(auto i: queries) {\\n            ans.push_back(v[i[1]-1][i[0]-1].second); //k = i[0]th smallest trimmed to i[1] = trim number\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3053368,
                "title": "easy-to-understand-java-hashmap-60companies30dayschallenge",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// Here we are taking a map which is storing an array corresponding to trimi, i.e. query[1]\\n// The array is of type node that contains index and val(substring of each element of queries len-auery[i],len)\\n// after this we sort the array based on val and find out the index corresponding to val\\n// 1->[(0,2),(1,3),(2,1),(3,4)](unsorted) -> [(2,1),(0,2),(1,3),(3,4)]\\n// 3->[(0,102),(2,251),(3,473),(4,814)]\\n// 2->[(0,02),(3,14),(2,51),(1,73)]\\n\\n\\n\\nclass Solution {\\n    public int[] smallestTrimmedNumbers(String[] nums, int[][] queries) {\\n         HashMap<Integer,Node[]>map=new HashMap<>();\\n         int idx=0;\\n         int[] res=new int[queries.length];\\n         for(int[] query:queries){\\n             Node []arr=new Node[nums.length];\\n             int key=query[1];\\n             if(!map.containsKey(key)){\\n                 int len=nums[0].length();\\n                 for(int i=0;i<nums.length;i++){\\n                     String s=nums[i].substring(len-key,len);\\n                     arr[i]=new Node(i,s);\\n                 }\\n                 Arrays.sort(arr,(a,b)->a.val.compareTo(b.val));\\n                 map.put(key,arr);\\n             }\\n             res[idx++]=map.get(key)[query[0]-1].index;\\n         }\\n         return res;\\n    }\\n    class Node{\\n        int index;\\n        String val;\\n        Node(int index,String val){\\n            this.index=index;\\n            this.val=val;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// Here we are taking a map which is storing an array corresponding to trimi, i.e. query[1]\\n// The array is of type node that contains index and val(substring of each element of queries len-auery[i],len)\\n// after this we sort the array based on val and find out the index corresponding to val\\n// 1->[(0,2),(1,3),(2,1),(3,4)](unsorted) -> [(2,1),(0,2),(1,3),(3,4)]\\n// 3->[(0,102),(2,251),(3,473),(4,814)]\\n// 2->[(0,02),(3,14),(2,51),(1,73)]\\n\\n\\n\\nclass Solution {\\n    public int[] smallestTrimmedNumbers(String[] nums, int[][] queries) {\\n         HashMap<Integer,Node[]>map=new HashMap<>();\\n         int idx=0;\\n         int[] res=new int[queries.length];\\n         for(int[] query:queries){\\n             Node []arr=new Node[nums.length];\\n             int key=query[1];\\n             if(!map.containsKey(key)){\\n                 int len=nums[0].length();\\n                 for(int i=0;i<nums.length;i++){\\n                     String s=nums[i].substring(len-key,len);\\n                     arr[i]=new Node(i,s);\\n                 }\\n                 Arrays.sort(arr,(a,b)->a.val.compareTo(b.val));\\n                 map.put(key,arr);\\n             }\\n             res[idx++]=map.get(key)[query[0]-1].index;\\n         }\\n         return res;\\n    }\\n    class Node{\\n        int index;\\n        String val;\\n        Node(int index,String val){\\n            this.index=index;\\n            this.val=val;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3050948,
                "title": "easy-5-line-code-python",
                "content": "# Intuition\\nDon\\'t get confused, just go as the question says line by line.\\nHere \\'02\\' is considered as 2. So, remove the 0 by converting into integer.\\nFor example - [\\'02\\',\\'14\\',\\'23\\']\\nSimply remove the zero - [2,14,23]\\nNOTE - If you keep numbers as string only, then it will be like this (after sorting) [\\'14\\',\\'2\\',\\'23\\']. This will be wrong, thus convert nums into int.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTake a list, which stores the list of [trimmed list of int(num), index of that num] .... here num is element in nums list\\n\\nExample, l= [[2,0],[3,1],[1,2],[4,3]], here \"2\",\"3\",\"1\",\"4\" are trimmed part and 0,1,2,3 are indexes of respective num.\\n\\nNow sort the list and it will look like, l= [[1,2],[2,0],[3,1],[4,3]]\\nAs k-1 index of l is the required ans [1,2], which implies that 1 is the k-1 smallest number and 2 is the index of 1.\\n\\nStore the l[k-1][1] into final ans. As index is required.\\n\\nNOTE - Store elements in list as $$int(num)$$ for num in nums\\n\\n# Complexity\\n- Time complexity: $$O(n*log(n))$$ \\nN for traversal in queries * (N for traversal in nums * Log(n) for sorting list)\\nAs len(nums)<=100 , thus ~n(log(n))\\n\\n- Space complexity: $$O(n)$$\\nTo store the list, which has to be returned, where n=len(queries)\\n\\n# Code\\n```\\nclass Solution:\\n    def smallestTrimmedNumbers(self, nums: List[str], queries: List[List[int]]) -> List[int]:\\n        size,ans = len(nums[0]),[]\\n        for k,trim in queries:\\n            # store the trimmed numbers in list as -> list of int of number and its index\\n            # example, l= [[2,0],[3,1],[1,2],[4,3]], here \"2\",\"3\",\"1\",\"4\" are trimmed part and 0,1,2,3 are indexes\\n            # starting index for trim will be [len(nums[i])-trim :]\\n            l = sorted([[int(i[size-trim:]),ind] for ind,i in enumerate(nums)])\\n            # after sorting the list append the k-1\\'s [1] index from sorted list\\n            ans.append(l[k-1][1])\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def smallestTrimmedNumbers(self, nums: List[str], queries: List[List[int]]) -> List[int]:\\n        size,ans = len(nums[0]),[]\\n        for k,trim in queries:\\n            # store the trimmed numbers in list as -> list of int of number and its index\\n            # example, l= [[2,0],[3,1],[1,2],[4,3]], here \"2\",\"3\",\"1\",\"4\" are trimmed part and 0,1,2,3 are indexes\\n            # starting index for trim will be [len(nums[i])-trim :]\\n            l = sorted([[int(i[size-trim:]),ind] for ind,i in enumerate(nums)])\\n            # after sorting the list append the k-1\\'s [1] index from sorted list\\n            ans.append(l[k-1][1])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3049911,
                "title": "solution-in-9-lines-runtime-491-ms-faster-than-96-77",
                "content": "```\\nclass Solution:\\n    def smallestTrimmedNumbers(self, nums: List[str], queries: List[List[int]]) -> List[int]:\\n        result = list()\\n        mydict = dict()\\n        for n_smallest, trimmed in queries:\\n            if trimmed not in mydict:\\n                temp_list = [(num[-trimmed:], idx) for idx, num in enumerate(nums)]\\n                temp_list.sort()\\n                mydict[trimmed] = temp_list \\n            result.append(mydict[trimmed][n_smallest-1][1])\\n        return result         \\n```\\n![image.png](https://assets.leetcode.com/users/images/9d3b7c8d-4710-43fd-a580-723ac35a78fa_1673698866.7689838.png)\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def smallestTrimmedNumbers(self, nums: List[str], queries: List[List[int]]) -> List[int]:\\n        result = list()\\n        mydict = dict()\\n        for n_smallest, trimmed in queries:\\n            if trimmed not in mydict:\\n                temp_list = [(num[-trimmed:], idx) for idx, num in enumerate(nums)]\\n                temp_list.sort()\\n                mydict[trimmed] = temp_list \\n            result.append(mydict[trimmed][n_smallest-1][1])\\n        return result         \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3048691,
                "title": "easy-java-solution-using-trimming-sorting",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[] smallestTrimmedNumbers(String[] nums, int[][] queries) {\\n        int n= nums.length;\\n        int m= queries.length;\\n        int p= nums[0].length();\\n\\n        int[] ans= new int[m];\\n\\n        List<String[]> temp;\\n        for(int i=0; i<m; i++){\\n            temp= new ArrayList<>();\\n            for(int j=0; j<n; j++){\\n                String[] data= new String[2];\\n                data[0]= nums[j].substring(p-queries[i][1]);\\n                data[1]= Integer.toString(j);\\n                temp.add(data);\\n            }\\n\\n            Collections.sort(temp, (arr1, arr2) ->{\\n                if( arr1[0].compareTo(arr2[0]) >0){\\n                    return 1;\\n                }\\n                else if(arr1[0].compareTo(arr2[0]) <0){\\n                    return -1;\\n                }\\n                else if(arr1[0].compareTo(arr2[0]) ==0){\\n                    if( Integer.parseInt(arr1[1]) > Integer.parseInt(arr1[1]) ){\\n                        return 1;\\n                    }\\n                    else if(Integer.parseInt(arr1[1]) < Integer.parseInt(arr1[1])){\\n                        return -1;\\n                    }\\n                    else{\\n                        return 0;\\n                    }\\n                }else{\\n                    return 0;\\n                }\\n            });\\n            \\n            String[] array= temp.get(queries[i][0]-1);\\n            ans[i]= Integer.parseInt(array[1]);\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int[] smallestTrimmedNumbers(String[] nums, int[][] queries) {\\n        int n= nums.length;\\n        int m= queries.length;\\n        int p= nums[0].length();\\n\\n        int[] ans= new int[m];\\n\\n        List<String[]> temp;\\n        for(int i=0; i<m; i++){\\n            temp= new ArrayList<>();\\n            for(int j=0; j<n; j++){\\n                String[] data= new String[2];\\n                data[0]= nums[j].substring(p-queries[i][1]);\\n                data[1]= Integer.toString(j);\\n                temp.add(data);\\n            }\\n\\n            Collections.sort(temp, (arr1, arr2) ->{\\n                if( arr1[0].compareTo(arr2[0]) >0){\\n                    return 1;\\n                }\\n                else if(arr1[0].compareTo(arr2[0]) <0){\\n                    return -1;\\n                }\\n                else if(arr1[0].compareTo(arr2[0]) ==0){\\n                    if( Integer.parseInt(arr1[1]) > Integer.parseInt(arr1[1]) ){\\n                        return 1;\\n                    }\\n                    else if(Integer.parseInt(arr1[1]) < Integer.parseInt(arr1[1])){\\n                        return -1;\\n                    }\\n                    else{\\n                        return 0;\\n                    }\\n                }else{\\n                    return 0;\\n                }\\n            });\\n            \\n            String[] array= temp.get(queries[i][0]-1);\\n            ans[i]= Integer.parseInt(array[1]);\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3047168,
                "title": "c-best-soln",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& queries) {\\n        //just simply solve as given\\n        vector<int>ans;\\n        int n=nums.size();\\n        for(auto q:queries)\\n        {\\n            int k=q[0];\\n            int trim=q[1];//it is from right side\\n            vector<pair<string,int>>arr;\\n            for(int i=0;i<n;i++)\\n            {\\n                // if(trim>nums.size())trim=0;\\n                arr.push_back({(nums[i].substr(nums[i].size()-trim)),i});\\n                \\n            }\\n            sort(arr.begin(),arr.end());\\n            ans.push_back(arr[k-1].second);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& queries) {\\n        //just simply solve as given\\n        vector<int>ans;\\n        int n=nums.size();\\n        for(auto q:queries)\\n        {\\n            int k=q[0];\\n            int trim=q[1];//it is from right side\\n            vector<pair<string,int>>arr;\\n            for(int i=0;i<n;i++)\\n            {\\n                // if(trim>nums.size())trim=0;\\n                arr.push_back({(nums[i].substr(nums[i].size()-trim)),i});\\n                \\n            }\\n            sort(arr.begin(),arr.end());\\n            ans.push_back(arr[k-1].second);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3041025,
                "title": "easy-100-fast-java-solution-using-radix-sort",
                "content": "# Intuition\\nUsing Radix Sort \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nStoring the indexes of the strings in nums in list[i] after sorting till i\\'th index from s-1 th index. \\nWhere list[i-1] stores the sorted indexes from last index to i-1 th index. And for i th index Radix Sort sorts the indexes(index of the strings in nums) of list[i-1] and stores in list[i].\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(s*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(s*n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n- s = nums[0].length, n= nums.length\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] smallestTrimmedNumbers(String[] nums, int[][] queries) {\\n        int n = nums.length;\\n        int len = nums[0].length();\\n        int[][] list = new int[len][n];\\n        RadixSort.radixSort(list, nums);\\n        int[] ans = new int[queries.length];\\n        int i = 0;\\n        for(int[] query:queries){\\n            ans[i++] = list[query[1]-1][query[0]-1];\\n        }\\n        return ans;\\n    }\\n}\\nclass RadixSort{\\n    public static void radixSort(int[][] list, String[] nums){\\n        int n = nums[0].length();\\n        int[] index = new int[nums.length];\\n        for(int i=0; i<nums.length; i++)  \\n            index[i] = i;\\n        list[0] = countingSort(index, nums, n-1);\\n        for(int i=1; i<n; i++){\\n            list[i] = countingSort(list[i-1], nums, n-1-i);\\n        }\\n    }\\n    public static int[] countingSort(int[] index, String[] nums, int idx){\\n        int n = nums.length;\\n        int[] sorted = new int[n];\\n        int[] count = new int[10];\\n        for(String s:nums)\\n            count[s.charAt(idx)-\\'0\\']++;\\n        for(int i=1; i<10; i++)\\n            count[i] += count[i-1];\\n        for(int i=n-1; i>=0; i--){\\n            sorted[count[nums[index[i]].charAt(idx)-\\'0\\']-- -1] = index[i];\\n            // count[nums[index[i]].charAt(idx)-\\'0\\']--;\\n        }\\n        return sorted;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] smallestTrimmedNumbers(String[] nums, int[][] queries) {\\n        int n = nums.length;\\n        int len = nums[0].length();\\n        int[][] list = new int[len][n];\\n        RadixSort.radixSort(list, nums);\\n        int[] ans = new int[queries.length];\\n        int i = 0;\\n        for(int[] query:queries){\\n            ans[i++] = list[query[1]-1][query[0]-1];\\n        }\\n        return ans;\\n    }\\n}\\nclass RadixSort{\\n    public static void radixSort(int[][] list, String[] nums){\\n        int n = nums[0].length();\\n        int[] index = new int[nums.length];\\n        for(int i=0; i<nums.length; i++)  \\n            index[i] = i;\\n        list[0] = countingSort(index, nums, n-1);\\n        for(int i=1; i<n; i++){\\n            list[i] = countingSort(list[i-1], nums, n-1-i);\\n        }\\n    }\\n    public static int[] countingSort(int[] index, String[] nums, int idx){\\n        int n = nums.length;\\n        int[] sorted = new int[n];\\n        int[] count = new int[10];\\n        for(String s:nums)\\n            count[s.charAt(idx)-\\'0\\']++;\\n        for(int i=1; i<10; i++)\\n            count[i] += count[i-1];\\n        for(int i=n-1; i>=0; i--){\\n            sorted[count[nums[index[i]].charAt(idx)-\\'0\\']-- -1] = index[i];\\n            // count[nums[index[i]].charAt(idx)-\\'0\\']--;\\n        }\\n        return sorted;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3018888,
                "title": "c-solution-using-bucket-sort",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHere we are asked to push the index( of original array) of kth Largest element from array of last ith digits of each element of nums. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere we are told to get kth largest element from array of last ith digits of each element of nums.\\n\\nCreate one array which store the array of last ith digits of each element of nums in sorted way. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\nWe are sorting the array of length nums for nums[0].length() means ( length of digits) time , which takes time O( NLogN * length )\\nAnd we create the new array of last ith digits from nums array for nums[0].length means ( length of digits time )  , which take time O(N * N * length)\\n\\nSo Our Total time complexity is O(length * ( NLogN + N^2 )) , which can also written as O( Length * N ^ 2 ).\\nHere\\nN = Length of nums array\\nLength = nums[0].length(). \\n\\n- Space complexity: O(N * Length)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\n    private:\\n    void bucket_sort(vector<string>&nums , vector<vector<pair<string,int>>> &mp , int index) {\\n        int n = nums.size();\\n        vector<pair<string ,int>> temp;\\n        for(int i =0 ; i <n ; i++) {\\n            string str = nums[i].substr(index);\\n          temp.push_back({str, i});\\n        }\\n        sort(temp.begin() , temp.end());\\n        mp.push_back(temp);\\n    }\\n\\npublic:\\n    vector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& queries) {\\n        vector<vector<pair<string,int>>> mp;\\n        int n = nums.size();\\n        int m = queries.size();\\n        vector<int>ans;\\n        int length = nums[0].length() - 1;\\n        for(int i = length; i >= 0 ; i--) bucket_sort(nums , mp ,i );\\n\\n        for(int i = 0 ; i < m ; i++) {\\n            int k = queries[i][0];\\n            int index = queries[i][1];\\n            ans.push_back(mp[index - 1][k - 1].second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bucket Sort"
                ],
                "code": "```\\nclass Solution {\\n    private:\\n    void bucket_sort(vector<string>&nums , vector<vector<pair<string,int>>> &mp , int index) {\\n        int n = nums.size();\\n        vector<pair<string ,int>> temp;\\n        for(int i =0 ; i <n ; i++) {\\n            string str = nums[i].substr(index);\\n          temp.push_back({str, i});\\n        }\\n        sort(temp.begin() , temp.end());\\n        mp.push_back(temp);\\n    }\\n\\npublic:\\n    vector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& queries) {\\n        vector<vector<pair<string,int>>> mp;\\n        int n = nums.size();\\n        int m = queries.size();\\n        vector<int>ans;\\n        int length = nums[0].length() - 1;\\n        for(int i = length; i >= 0 ; i--) bucket_sort(nums , mp ,i );\\n\\n        for(int i = 0 ; i < m ; i++) {\\n            int k = queries[i][0];\\n            int index = queries[i][1];\\n            ans.push_back(mp[index - 1][k - 1].second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3016081,
                "title": "python-written-in-3-lines-80-80",
                "content": "# Intuition\\nPerfect instance to use dictionaries since you\\'re relating index to value.\\n\\n# Approach\\nSince index doesn\\'t repeat, this can be made the key. Then use the last index of the smallest heap. The query is going to give the keys in order for the nth smallest value. So just get the last one (which will be both the maximum and the first key).\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def smallestTrimmedNumbers(self, nums: List[str], queries: List[List[int]]) -> List[int]:\\n        for idx,[k,trim] in enumerate(queries):\\n            res = {i:val[-trim:] for i,val in enumerate(nums)}\\n            queries[idx] = nsmallest(k,res,key=res.get)[-1]\\n        return queries\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def smallestTrimmedNumbers(self, nums: List[str], queries: List[List[int]]) -> List[int]:\\n        for idx,[k,trim] in enumerate(queries):\\n            res = {i:val[-trim:] for i,val in enumerate(nums)}\\n            queries[idx] = nsmallest(k,res,key=res.get)[-1]\\n        return queries\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3001928,
                "title": "5-lines-of-python-code-clean-and-beginner-friendly",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def smallestTrimmedNumbers(self, nums: List[str], queries: List[List[int]]) -> List[int]:\\n        l = []\\n        for pos , trim in queries:\\n            ans = [[ nums[i][-trim:] , i] for i in range(len(nums))]\\n            l.append(sorted(ans)[pos-1][1])\\n        return l\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "String",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def smallestTrimmedNumbers(self, nums: List[str], queries: List[List[int]]) -> List[int]:\\n        l = []\\n        for pos , trim in queries:\\n            ans = [[ nums[i][-trim:] , i] for i in range(len(nums))]\\n            l.append(sorted(ans)[pos-1][1])\\n        return l\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2975370,
                "title": "python-solution-quick-select",
                "content": "# Quickselect solution.\\nRefarding quickselect, see [Kth Largest Element in an Array (Solution) Approach 2: Quickselect\\n](https://leetcode.com/problems/kth-largest-element-in-an-array/solutions/214469/kth-largest-element-in-an-array/?orderBy=most_relevant) for detail.\\n\\n**Quickselect complexity**\\n\\n- Time complexity : O(N) in the average case, O(N^2) in the worst case.\\n- Space complexity : O(1)\\n\\nTherefore, complexities are:\\n\\n(Q: queries size)\\n- Time complexity : O(N * Q) in the average case, O(Q * N^2) in the worst case.\\n- Space complexity : O(Q)\\n\\n```\\nclass Solution:\\n    def smallestTrimmedNumbers(self, nums: List[str], queries: List[List[int]]) -> List[int]:\\n        def partition(arr, left, right):\\n            pivot = random.randint(left, right)\\n            pivot_val = arr[pivot]\\n\\n            arr[pivot], arr[right] = arr[right], arr[pivot]\\n\\n            index = left\\n            for i in range(left, right):\\n                if arr[i] < pivot_val:\\n                    arr[index], arr[i] = arr[i], arr[index]\\n                    index += 1\\n            \\n            arr[index], arr[right] = arr[right], arr[index]\\n            return index\\n\\n        def k_th_index(arr, left, right, k):\\n            if left >= right:\\n                return arr[left][1]\\n            \\n            pivot = partition(arr, left, right)\\n            if pivot == k:\\n                return arr[pivot][1]\\n            \\n            if pivot < k:\\n                return k_th_index(arr, pivot + 1, right, k)\\n            else:\\n                return k_th_index(arr, left, pivot - 1, k)\\n\\n        max_digit = len(nums[0])\\n        ans = []\\n        for k, digit in queries:\\n            arr = [[int(num[max_digit - digit:]), i] for i, num in enumerate(nums)]\\n            index = k_th_index(arr, 0, len(arr) - 1, k - 1)\\n            ans.append(index)\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Sort",
                    "Quickselect"
                ],
                "code": "```\\nclass Solution:\\n    def smallestTrimmedNumbers(self, nums: List[str], queries: List[List[int]]) -> List[int]:\\n        def partition(arr, left, right):\\n            pivot = random.randint(left, right)\\n            pivot_val = arr[pivot]\\n\\n            arr[pivot], arr[right] = arr[right], arr[pivot]\\n\\n            index = left\\n            for i in range(left, right):\\n                if arr[i] < pivot_val:\\n                    arr[index], arr[i] = arr[i], arr[index]\\n                    index += 1\\n            \\n            arr[index], arr[right] = arr[right], arr[index]\\n            return index\\n\\n        def k_th_index(arr, left, right, k):\\n            if left >= right:\\n                return arr[left][1]\\n            \\n            pivot = partition(arr, left, right)\\n            if pivot == k:\\n                return arr[pivot][1]\\n            \\n            if pivot < k:\\n                return k_th_index(arr, pivot + 1, right, k)\\n            else:\\n                return k_th_index(arr, left, pivot - 1, k)\\n\\n        max_digit = len(nums[0])\\n        ans = []\\n        for k, digit in queries:\\n            arr = [[int(num[max_digit - digit:]), i] for i, num in enumerate(nums)]\\n            index = k_th_index(arr, 0, len(arr) - 1, k - 1)\\n            ans.append(index)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2972711,
                "title": "clean-readable-and-yet-fast-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWrite a function to process each query. It should take the original `nums` and `trim` and `k` and given that nums element is a string , we can do string manipulation to trim number to int. Remember to keep the original index at this point of time. Once this is done, all we need to is to apply this function for each query in `queries\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nif `n` is length of `nums` and `m` is the length of `queries`, then time complexity is O(m*n*logn)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def query(self, nums, trim, k):\\n        vals = [(int(n[-trim:]),i) for i,n in enumerate(nums)]\\n        vals.sort(key=lambda x:x[0])\\n        return vals[k-1][1]\\n\\n    def smallestTrimmedNumbers(self, nums: List[str], queries: List[List[int]]) -> List[int]:\\n        n = len(queries)\\n        result = []\\n        for q in queries:\\n            result.append(self.query(nums, q[1], q[0]))\\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def query(self, nums, trim, k):\\n        vals = [(int(n[-trim:]),i) for i,n in enumerate(nums)]\\n        vals.sort(key=lambda x:x[0])\\n        return vals[k-1][1]\\n\\n    def smallestTrimmedNumbers(self, nums: List[str], queries: List[List[int]]) -> List[int]:\\n        n = len(queries)\\n        result = []\\n        for q in queries:\\n            result.append(self.query(nums, q[1], q[0]))\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2911954,
                "title": "swift-radix-sort-memorization",
                "content": "```\\nclass Solution {\\n    func smallestTrimmedNumbers(_ nums: [String], _ queries: [[Int]]) -> [Int] {\\n\\n        let s = nums.first ?? \"\"\\n        let n = nums.count\\n        var sorted = nums\\n        \\n        var result = [Int]()\\n        var memo = [Int: [String]]()\\n\\n        func radix(_ trim: Int) {\\n            if let cached = memo[trim] {\\n                sorted = cached\\n            } else {\\n                var index = s.endIndex\\n                for i in 0..<trim {\\n                    index = s.index(before: index)\\n                    sort(by: index)\\n                    memo[i + 1] = sorted\\n                }\\n            }\\n        }\\n\\n        func sort(by index: String.Index) {\\n            var counter = Array<Int>(repeating: 0, count: 11)\\n            var new = Array<String>(repeating: \"\", count: n)\\n            for i in 0..<n {\\n                let val = Int(String(sorted[i][index]))!\\n                counter[val + 1] = counter[val + 1] + 1\\n            }\\n            for i in 0..<10 {\\n                counter[i + 1] = counter[i] + counter[i + 1]\\n            }\\n            for (i, num) in sorted.enumerated() {\\n                let val = Int(String(num[index]))!\\n                new[counter[val]] = num\\n                counter[val] = counter[val] + 1\\n            }\\n            sorted = new\\n        }\\n\\n        for q in queries {\\n            sorted = nums\\n            radix(q[1])\\n            let original = sorted[q[0] - 1]\\n            var index = 0\\n            var k = 0\\n            for (i, n) in nums.enumerated() {\\n                if original == n && k < q[1] {\\n                    index = i\\n                    k = k + 1\\n                }\\n            }\\n            result.append(index)\\n        }\\n\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func smallestTrimmedNumbers(_ nums: [String], _ queries: [[Int]]) -> [Int] {\\n\\n        let s = nums.first ?? \"\"\\n        let n = nums.count\\n        var sorted = nums\\n        \\n        var result = [Int]()\\n        var memo = [Int: [String]]()\\n\\n        func radix(_ trim: Int) {\\n            if let cached = memo[trim] {\\n                sorted = cached\\n            } else {\\n                var index = s.endIndex\\n                for i in 0..<trim {\\n                    index = s.index(before: index)\\n                    sort(by: index)\\n                    memo[i + 1] = sorted\\n                }\\n            }\\n        }\\n\\n        func sort(by index: String.Index) {\\n            var counter = Array<Int>(repeating: 0, count: 11)\\n            var new = Array<String>(repeating: \"\", count: n)\\n            for i in 0..<n {\\n                let val = Int(String(sorted[i][index]))!\\n                counter[val + 1] = counter[val + 1] + 1\\n            }\\n            for i in 0..<10 {\\n                counter[i + 1] = counter[i] + counter[i + 1]\\n            }\\n            for (i, num) in sorted.enumerated() {\\n                let val = Int(String(num[index]))!\\n                new[counter[val]] = num\\n                counter[val] = counter[val] + 1\\n            }\\n            sorted = new\\n        }\\n\\n        for q in queries {\\n            sorted = nums\\n            radix(q[1])\\n            let original = sorted[q[0] - 1]\\n            var index = 0\\n            var k = 0\\n            for (i, n) in nums.enumerated() {\\n                if original == n && k < q[1] {\\n                    index = i\\n                    k = k + 1\\n                }\\n            }\\n            result.append(index)\\n        }\\n\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2884703,
                "title": "beats-100-typescript-javascript-o-mn-radix-sort-and-hashmap-with-comments",
                "content": "# Intuition\\nBecause we trim the stings (numbers) it is good idea to use radix sort.\\n\\n# Complexity\\n- Time complexity: $$O(nm)$$ where n - count of nums and m - length of num\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$ we copy radix matrix (array with splitted numbers) during the counting sort.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction smallestTrimmedNumbers(nums: string[], queries: number[][]): number[] {\\n    const N = nums.length;\\n    const M = nums[0].length;\\n    const trimMap = new Map<number, string[]>();\\n\\n    /*\\n        Create matrix with leading index of original order in nums\\n    */\\n    let matrix: string[][] = [];\\n    for (let i = 0; i < nums.length; i++) {\\n        matrix.push([i.toString(), ...nums[i].split(\"\")]);\\n    }\\n\\n    const getDigit = (char: string): number => char.charCodeAt(0) - \"0\".charCodeAt(0);\\n\\n    // Count sort for radix column in the matrix\\n    const countSort = (radix: number): void => {\\n        const counts = new Array(10).fill(0).map(() => new Array());\\n        for (let i = 0; i < N; i++) {\\n            const j = M - radix + 1;\\n            counts[getDigit(matrix[i][j])].push(matrix[i].concat());\\n        }\\n\\n        matrix = [];\\n        let indexes = []\\n        for (let count of counts) {\\n            while (count.length) {\\n                const row = count.shift();\\n                matrix.push(row);\\n                indexes.push(row[0]);\\n            }\\n        }\\n        trimMap.set(radix, indexes.concat());\\n    }\\n\\n    // Go through the queries and perform radix sort (counting sort iteration) if needed\\n    const result = [];\\n    let minTrim = 1;\\n    for (const [k, trim] of queries) {\\n        if (!trimMap.has(trim)) {  \\n            for (let i = minTrim; i <= trim; i++) {\\n                countSort(i);\\n            }\\n            minTrim = trim + 1;\\n        }\\n        result.push(trimMap.get(trim)[k - 1]);\\n    }\\n\\n    return result.map(item => parseInt(item));\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction smallestTrimmedNumbers(nums: string[], queries: number[][]): number[] {\\n    const N = nums.length;\\n    const M = nums[0].length;\\n    const trimMap = new Map<number, string[]>();\\n\\n    /*\\n        Create matrix with leading index of original order in nums\\n    */\\n    let matrix: string[][] = [];\\n    for (let i = 0; i < nums.length; i++) {\\n        matrix.push([i.toString(), ...nums[i].split(\"\")]);\\n    }\\n\\n    const getDigit = (char: string): number => char.charCodeAt(0) - \"0\".charCodeAt(0);\\n\\n    // Count sort for radix column in the matrix\\n    const countSort = (radix: number): void => {\\n        const counts = new Array(10).fill(0).map(() => new Array());\\n        for (let i = 0; i < N; i++) {\\n            const j = M - radix + 1;\\n            counts[getDigit(matrix[i][j])].push(matrix[i].concat());\\n        }\\n\\n        matrix = [];\\n        let indexes = []\\n        for (let count of counts) {\\n            while (count.length) {\\n                const row = count.shift();\\n                matrix.push(row);\\n                indexes.push(row[0]);\\n            }\\n        }\\n        trimMap.set(radix, indexes.concat());\\n    }\\n\\n    // Go through the queries and perform radix sort (counting sort iteration) if needed\\n    const result = [];\\n    let minTrim = 1;\\n    for (const [k, trim] of queries) {\\n        if (!trimMap.has(trim)) {  \\n            for (let i = minTrim; i <= trim; i++) {\\n                countSort(i);\\n            }\\n            minTrim = trim + 1;\\n        }\\n        result.push(trimMap.get(trim)[k - 1]);\\n    }\\n\\n    return result.map(item => parseInt(item));\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2876903,
                "title": "easy-to-understand-priority-queue-cpp-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& queries) {\\n\\n        vector <int> res;\\n        int n = nums[0].size();\\n        int len = nums.size();\\n\\n        for (auto q : queries) {\\n            priority_queue <pair <string, int>, vector <pair<string, int>>, greater<pair<string, int>>> pq;\\n            \\n            int k = q[0], trim = q[1];\\n\\n            for (int i = 0; i < len; i++)\\n                pq.push({nums[i].substr(n - trim), i});     // trims the first n-trim digits\\n\\n            for (int i = 1; i < k; i++)\\n                pq.pop();\\n\\n            res.push_back(pq.top().second); // pushes the index of the kth sallest trimmed number\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& queries) {\\n\\n        vector <int> res;\\n        int n = nums[0].size();\\n        int len = nums.size();\\n\\n        for (auto q : queries) {\\n            priority_queue <pair <string, int>, vector <pair<string, int>>, greater<pair<string, int>>> pq;\\n            \\n            int k = q[0], trim = q[1];\\n\\n            for (int i = 0; i < len; i++)\\n                pq.push({nums[i].substr(n - trim), i});     // trims the first n-trim digits\\n\\n            for (int i = 1; i < k; i++)\\n                pq.pop();\\n\\n            res.push_back(pq.top().second); // pushes the index of the kth sallest trimmed number\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2823724,
                "title": "simple-approach-in-c",
                "content": "# Approach\\nAs we have to trim the elements of the nums string, so for each query we have to trim each element according to the constraints given in the query. So we can\\'t optimize it.\\n\\nThe other thing is that we have to find the index of the kth smallest element after trimming the element of the array nums.\\n\\nSo we will use max-heap (priority_queue in c++) to store the element in sorted order.\\n\\nSo first we trim the elements of the array nums using the substr method in c++ after that we will push the elements in our max-heap.\\n\\nThe important note is that we are going to make the heap of size K.\\nSo first, we put k element into it. After that, we check whether the top element of the queue is less than the current element if it is, then pop the top element and insert the current one and if the current is greater than the top then no operation is needed.\\n\\nIf we push all the elements in the priority queue then TLE will occur. In order to avoid that we use a priority queue.\\n\\nAt the end, print the top element of the priority_queue or max_heap.\\n\\nFor source code follow this link : -[https://www.codewithengineer.in/2022/07/query-kth-smallest-trimmed-number.html](http://)\\n",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "# Approach\\nAs we have to trim the elements of the nums string, so for each query we have to trim each element according to the constraints given in the query. So we can\\'t optimize it.\\n\\nThe other thing is that we have to find the index of the kth smallest element after trimming the element of the array nums.\\n\\nSo we will use max-heap (priority_queue in c++) to store the element in sorted order.\\n\\nSo first we trim the elements of the array nums using the substr method in c++ after that we will push the elements in our max-heap.\\n\\nThe important note is that we are going to make the heap of size K.\\nSo first, we put k element into it. After that, we check whether the top element of the queue is less than the current element if it is, then pop the top element and insert the current one and if the current is greater than the top then no operation is needed.\\n\\nIf we push all the elements in the priority queue then TLE will occur. In order to avoid that we use a priority queue.\\n\\nAt the end, print the top element of the priority_queue or max_heap.\\n\\nFor source code follow this link : -[https://www.codewithengineer.in/2022/07/query-kth-smallest-trimmed-number.html](http://)\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2787728,
                "title": "my-python-solution",
                "content": "class Solution:\\n    def smallestTrimmedNumbers(self, nums: List[str], queries: List[List[int]]) -> List[int]:\\n        n = len(nums[0])\\n        helpnums = [0] * len(nums)\\n        res = []\\n        for k,trim in queries:\\n            for i in range(len(nums)):\\n                helpnums[i] = (i, nums[i][n-trim:])\\n            helpnums.sort(key = lambda p:p[1] )\\n            res.append(helpnums[k-1][0])\\n        return res\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n    def smallestTrimmedNumbers(self, nums: List[str], queries: List[List[int]]) -> List[int]:\\n        n = len(nums[0])\\n        helpnums = [0] * len(nums)\\n        res = []\\n        for k,trim in queries:\\n            for i in range(len(nums)):\\n                helpnums[i] = (i, nums[i][n-trim:])\\n            helpnums.sort(key = lambda p:p[1] )\\n            res.append(helpnums[k-1][0])\\n        return res\\n",
                "codeTag": "Java"
            },
            {
                "id": 2786753,
                "title": "pthon-clear-7-lines",
                "content": "```\\nclass Solution:\\n    def smallestTrimmedNumbers(self, nums: List[str], queries: List[List[int]]) -> List[int]:\\n        # trim to kth element for each\\n        res = []\\n        n = len(nums)\\n        for k, trim in queries:\\n            # get subtring from index (array_size - trim, array_size). We also store the index as second element\\n            trimmed_array = [[elem[-trim:],i] for i, elem in enumerate(nums)]\\n            # sort \\n            trimmed_array.sort()\\n            # kth smallest is just kth index - 1 (since 0 indexing) of sorted arary\\n            res.append(trimmed_array[k - 1][1])\\n            \\n        return res\\n    \\n    ```",
                "solutionTags": [
                    "Python",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def smallestTrimmedNumbers(self, nums: List[str], queries: List[List[int]]) -> List[int]:\\n        # trim to kth element for each\\n        res = []\\n        n = len(nums)\\n        for k, trim in queries:\\n            # get subtring from index (array_size - trim, array_size). We also store the index as second element\\n            trimmed_array = [[elem[-trim:],i] for i, elem in enumerate(nums)]\\n            # sort \\n            trimmed_array.sort()\\n            # kth smallest is just kth index - 1 (since 0 indexing) of sorted arary\\n            res.append(trimmed_array[k - 1][1])\\n            \\n        return res\\n    \\n    ```",
                "codeTag": "Java"
            },
            {
                "id": 2785608,
                "title": "c-radix-sort-o-q-n-l-commented-code-with-explanation",
                "content": "Lots of great solutions here. I tried the Radix sort approach in order to leverage the equal length of the strings. The idea is to look at only one digit per number, from left to right, and try to single down on an answer. Starting with the most significant digit (after trimming), put the index of numbers in buckets of [0-9] based of current digit, and then find out where Kth element would be according to these buckets. Let\\'s say we position K at 4\\'s bucket. Now if 4\\'s bucket has only one index, then we don\\'t need to look further, we found our answer. If not, then we will repeat the process for the next significant digit, but only consider the numbers represented by indexes in 4\\'s bucket.\\n\\n```c++\\nclass Solution {\\npublic:\\n    \\n    int radixKthSmallest(vector<string>& nums, int i, int k, int l, vector<int> possibleIndex) {\\n        vector<vector<int>> buckets(10);\\n        \\n        // For the current digit, sort the numbers in buckets [0-9].\\n        // So if we have the following numbers [\"213\", \"349\", \"731\", \"732\"],\\n        // and the current digit is 0, the buckets would look like this:\\n        //        0: []\\n        //        1: []\\n        //        2: [0] 0th element\\'s current digit is 2\\n        //        3: [1] 1st element\\'s current digit is 3\\n        //        4: []\\n        //        5: []\\n        //        6: []\\n        //        7: [2,3] 2nd & 3rd element\\'s current digit is 7\\n        //        8: []\\n        //        9: []\\n        for(int idx : possibleIndex) {\\n            buckets[nums[idx][i]-\\'0\\'].push_back(idx);\\n        }\\n        \\n        // Loop from 0 to 9, reduce the value of K by subtracting the size of buckets, while\\n        // K > 0. Let\\'s say we are at bucket B. Check if B only has one element. If not, then \\n        // we\\'ll need to see what the next digits are. But for the next round we will limit \\n        // our search to only the elements that filled B. If we are at the last digit, just \\n        // return (K-1)th element in B.\\n        for(int j=0; j < 10; j++) {\\n            if (buckets[j].size() == 0)\\n                continue;\\n            \\n            if(k > buckets[j].size()) {\\n                k -= buckets[j].size();\\n            } else {\\n                if (buckets[j].size() == 1) {\\n                    return buckets[j][0];\\n                } else if (i == l-1) {\\n                    return buckets[j][k-1];\\n                }\\n                return radixKthSmallest(nums, i+1, k, l, buckets[j]);\\n            }\\n        }\\n\\t\\t// We will never reach here :)\\n        return 42069;\\n    }\\n    \\n    vector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& queries) {\\n        int n = nums.size(), l = nums[0].size();\\n        \\n        vector<int> answers;\\n        vector<int> possibleIndex(n);\\n        \\n        // Put indexes of all the numbers from 0 through n-1 in the solution space initially\\n        for (int i=0; i < nums.size(); i++) possibleIndex[i] = i;\\n        \\n        for (vector<int> query : queries) {\\n            answers.push_back(radixKthSmallest(nums, l-query[1], query[0], l, possibleIndex));\\n        }\\n        \\n        return answers;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    \\n    int radixKthSmallest(vector<string>& nums, int i, int k, int l, vector<int> possibleIndex) {\\n        vector<vector<int>> buckets(10);\\n        \\n        // For the current digit, sort the numbers in buckets [0-9].\\n        // So if we have the following numbers [\"213\", \"349\", \"731\", \"732\"],\\n        // and the current digit is 0, the buckets would look like this:\\n        //        0: []\\n        //        1: []\\n        //        2: [0] 0th element\\'s current digit is 2\\n        //        3: [1] 1st element\\'s current digit is 3\\n        //        4: []\\n        //        5: []\\n        //        6: []\\n        //        7: [2,3] 2nd & 3rd element\\'s current digit is 7\\n        //        8: []\\n        //        9: []\\n        for(int idx : possibleIndex) {\\n            buckets[nums[idx][i]-\\'0\\'].push_back(idx);\\n        }\\n        \\n        // Loop from 0 to 9, reduce the value of K by subtracting the size of buckets, while\\n        // K > 0. Let\\'s say we are at bucket B. Check if B only has one element. If not, then \\n        // we\\'ll need to see what the next digits are. But for the next round we will limit \\n        // our search to only the elements that filled B. If we are at the last digit, just \\n        // return (K-1)th element in B.\\n        for(int j=0; j < 10; j++) {\\n            if (buckets[j].size() == 0)\\n                continue;\\n            \\n            if(k > buckets[j].size()) {\\n                k -= buckets[j].size();\\n            } else {\\n                if (buckets[j].size() == 1) {\\n                    return buckets[j][0];\\n                } else if (i == l-1) {\\n                    return buckets[j][k-1];\\n                }\\n                return radixKthSmallest(nums, i+1, k, l, buckets[j]);\\n            }\\n        }\\n\\t\\t// We will never reach here :)\\n        return 42069;\\n    }\\n    \\n    vector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& queries) {\\n        int n = nums.size(), l = nums[0].size();\\n        \\n        vector<int> answers;\\n        vector<int> possibleIndex(n);\\n        \\n        // Put indexes of all the numbers from 0 through n-1 in the solution space initially\\n        for (int i=0; i < nums.size(); i++) possibleIndex[i] = i;\\n        \\n        for (vector<int> query : queries) {\\n            answers.push_back(radixKthSmallest(nums, l-query[1], query[0], l, possibleIndex));\\n        }\\n        \\n        return answers;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2744431,
                "title": "java-time-o-q-n-2-nlogn-space-o-n-sorting",
                "content": "```\\n//its basically a sorting problem\\n\\n\\nclass Solution {\\n    public int[] smallestTrimmedNumbers(String[] nums, int[][] queries) {\\n        int m = nums[0].length();\\n        int n = queries.length;\\n        int[] ans = new int[n];\\n        List<Pair<String,Integer>> list = new ArrayList<>();\\n        for(int i = 0;i<n;i++){\\n            list.clear();\\n            int[] q = queries[i];\\n            for(int j = 0;j<nums.length;j++){\\n                String s = nums[j];\\n                String tmp = s.substring(m-q[1]);\\n                list.add(new Pair<>(tmp,j));\\n            }\\n            Collections.sort(list,(a,b)->((a.getKey()).equals(b.getKey())?a.getValue()-b.getValue():(a.getKey()).compareTo(b.getKey())));\\n            ans[i] = list.get(q[0]-1).getValue();\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\n//its basically a sorting problem\\n\\n\\nclass Solution {\\n    public int[] smallestTrimmedNumbers(String[] nums, int[][] queries) {\\n        int m = nums[0].length();\\n        int n = queries.length;\\n        int[] ans = new int[n];\\n        List<Pair<String,Integer>> list = new ArrayList<>();\\n        for(int i = 0;i<n;i++){\\n            list.clear();\\n            int[] q = queries[i];\\n            for(int j = 0;j<nums.length;j++){\\n                String s = nums[j];\\n                String tmp = s.substring(m-q[1]);\\n                list.add(new Pair<>(tmp,j));\\n            }\\n            Collections.sort(list,(a,b)->((a.getKey()).equals(b.getKey())?a.getValue()-b.getValue():(a.getKey()).compareTo(b.getKey())));\\n            ans[i] = list.get(q[0]-1).getValue();\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2728541,
                "title": "python-heap-queue",
                "content": "```\\nclass Solution:\\n    def smallestTrimmedNumbers(self, a: List[str], q: List[List[int]]) -> List[int]:\\n        normal = [int(x) for x in a]\\n        ans = []\\n        for p in q:\\n            heap = []\\n            base = 10 ** p[1]\\n            for i in range(len(normal)):\\n                heappush(heap, [normal[i] % base, i])\\n            now = -1\\n            while p[0]:\\n                p[0] -= 1\\n                now = heappop(heap)[1]\\n            ans.append(now)\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def smallestTrimmedNumbers(self, a: List[str], q: List[List[int]]) -> List[int]:\\n        normal = [int(x) for x in a]\\n        ans = []\\n        for p in q:\\n            heap = []\\n            base = 10 ** p[1]\\n            for i in range(len(normal)):\\n                heappush(heap, [normal[i] % base, i])\\n            now = -1\\n            while p[0]:\\n                p[0] -= 1\\n                now = heappop(heap)[1]\\n            ans.append(now)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2723523,
                "title": "js-solution-radix-sort",
                "content": "```\\n/**\\n * @param {string[]} nums\\n * @param {number[][]} queries\\n * @return {number[]}\\n */\\nvar smallestTrimmedNumbers = function (nums, queries) {\\n  const steps = radixSortSteps(nums);\\n  return queries.map(([k, trim]) => steps[trim - 1][k - 1]);\\n};\\n\\nvar radixSortSteps = function (nums) {\\n  const sorted = Array(nums.length);\\n  const steps = [];\\n  let stepCount = 0;\\n  let pos = nums[0].length - 1;\\n  while (pos >= 0) {\\n    const currentSteps = [];\\n    const count = Array(10).fill(0);\\n    for (let num of nums) {\\n      count[num[pos]]++;\\n    }\\n    for (let i = 1; i < count.length; i++) {\\n      count[i] += count[i - 1];\\n    }\\n    for (let i = nums.length - 1; i >= 0; i--) {\\n      const newPos = --count[nums[i][pos]];\\n      sorted[newPos] = nums[i];\\n      currentSteps[newPos] = stepCount > 0 ? steps[stepCount - 1][i] : i;\\n    }\\n    for (let i = 0; i < nums.length; i++) {\\n      nums[i] = sorted[i];\\n    }\\n    steps.push(currentSteps);\\n    pos--;\\n    stepCount++;\\n  }\\n  return steps;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} nums\\n * @param {number[][]} queries\\n * @return {number[]}\\n */\\nvar smallestTrimmedNumbers = function (nums, queries) {\\n  const steps = radixSortSteps(nums);\\n  return queries.map(([k, trim]) => steps[trim - 1][k - 1]);\\n};\\n\\nvar radixSortSteps = function (nums) {\\n  const sorted = Array(nums.length);\\n  const steps = [];\\n  let stepCount = 0;\\n  let pos = nums[0].length - 1;\\n  while (pos >= 0) {\\n    const currentSteps = [];\\n    const count = Array(10).fill(0);\\n    for (let num of nums) {\\n      count[num[pos]]++;\\n    }\\n    for (let i = 1; i < count.length; i++) {\\n      count[i] += count[i - 1];\\n    }\\n    for (let i = nums.length - 1; i >= 0; i--) {\\n      const newPos = --count[nums[i][pos]];\\n      sorted[newPos] = nums[i];\\n      currentSteps[newPos] = stepCount > 0 ? steps[stepCount - 1][i] : i;\\n    }\\n    for (let i = 0; i < nums.length; i++) {\\n      nums[i] = sorted[i];\\n    }\\n    steps.push(currentSteps);\\n    pos--;\\n    stepCount++;\\n  }\\n  return steps;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2718849,
                "title": "python-solution-documented-smaller-than-98-99",
                "content": "Python solution coded under test conditions in 10mins:\\n\\n```python\\nclass Solution:\\n    def smallestTrimmedNumbers(self, nums: List[str], queries: List[List[int]]) -> List[int]:\\n        \"\"\"\\n        This solution initialises an outcome array, then, for each value in queries, the\\n        query_helper function is called on nums and the i\\'th query, where the outcome is\\n        assigned to out. This is then appended to outcome, and outcome is returned upon\\n        completion of the loop.\\n        \\n        :param nums: the nums array. List[str]\\n        :param queries: the queries array. List[List[int]]\\n        :return: outcome: the outcome array. (List[int])\\n        \"\"\"\\n        outcome = []\\n        for i in range(len(queries)):\\n            out = self.query_helper(nums, queries[i])\\n            outcome.append(out)\\n        return outcome\\n            \\n\\n    def query_helper(self, num_array: List[str], query: List[int]) -> int:\\n        \"\"\"This helper generates the query outcome for each query.\"\"\"\\n        index_of_interest = query[0] - 1\\n        slice_val = -query[1]\\n        vals = [(int(num_array[x][slice_val:]), x) for x in range(len(num_array))]\\n        val_sort = sorted(vals, key = lambda x: x[0])[index_of_interest]\\n        return val_sort[1]",
                "solutionTags": [
                    "Python"
                ],
                "code": "Python solution coded under test conditions in 10mins:\\n\\n```python\\nclass Solution:\\n    def smallestTrimmedNumbers(self, nums: List[str], queries: List[List[int]]) -> List[int]:\\n        \"\"\"\\n        This solution initialises an outcome array, then, for each value in queries, the\\n        query_helper function is called on nums and the i\\'th query, where the outcome is\\n        assigned to out. This is then appended to outcome, and outcome is returned upon\\n        completion of the loop.\\n        \\n        :param nums: the nums array. List[str]\\n        :param queries: the queries array. List[List[int]]\\n        :return: outcome: the outcome array. (List[int])\\n        \"\"\"\\n        outcome = []\\n        for i in range(len(queries)):\\n            out = self.query_helper(nums, queries[i])\\n            outcome.append(out)\\n        return outcome\\n            \\n\\n    def query_helper(self, num_array: List[str], query: List[int]) -> int:\\n        \"\"\"This helper generates the query outcome for each query.\"\"\"\\n        index_of_interest = query[0] - 1\\n        slice_val = -query[1]\\n        vals = [(int(num_array[x][slice_val:]), x) for x in range(len(num_array))]\\n        val_sort = sorted(vals, key = lambda x: x[0])[index_of_interest]\\n        return val_sort[1]",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1956919,
                "content": [
                    {
                        "username": "zartabali7298",
                        "content": "a question for sorting array"
                    },
                    {
                        "username": "zartabali7298",
                        "content": "Thank you for your feedback!\\n"
                    },
                    {
                        "username": "zartabali7298",
                        "content": "sort list"
                    },
                    {
                        "username": "zartabali7298",
                        "content": "Thank you for your feedback!"
                    },
                    {
                        "username": "zartabali7298",
                        "content": "Thank you for your feedback!"
                    },
                    {
                        "username": "zartabali7298",
                        "content": "thank you for easy problems"
                    },
                    {
                        "username": "an5dy90",
                        "content": "Karen here. Please provide an official solution or I would like to speak to your manager for a refund. "
                    },
                    {
                        "username": "hacker363",
                        "content": "```class Solution:\n    def smallestTrimmedNumbers(self, nums: List[str], queries: List[List[int]]) -> List[int]:\n        ans = []\n        for i in queries:\n            temp = []\n            for j in nums:\n                temp.append(j[len(j)-i[1]:])\n            p =[]\n            d = sorted(temp)\n            for itr in range(len(temp)):\n                if(temp[itr] == d[i[0]-1]):\n                    p.append(itr)\n            print(p)\n            ans.append(p[-1])\n            p=[]\n        return ans\n```\n\nCan anyone please help me why my code is wrong at test case 83\nIt is given in question that if the trimmed number are equal then the one at larger index is treated as larger.\nPlease helppppppp!!!!!!"
                    },
                    {
                        "username": "FumiyaShibusawa",
                        "content": "When I run this code, it passes with input`nums` of 92 digit numbers. But when I submitted it, it gets Time Limit Exceeded on an input `nums` of 93 digit numbers. I roughly measured time for each query with `std::time::Instant`, but it seems to be pretty decent like a total of 17.874756ms. I'm at a loss where to optimize. If anyone had a idea, please leave a comment. :pray: \n\n```rust\nimpl Solution {\n    pub fn smallest_trimmed_numbers(nums: Vec<String>, queries: Vec<Vec<i32>>) -> Vec<i32> {\n        let mut answer = Vec::new();\n        for query in queries {\n            let now = std::time::Instant::now();\n\n            let k = query[0] as usize;\n            let trim = query[1] as usize;\n            let mut trimmed_nums: Vec<(String, i32)> = nums\n                .iter()\n                .enumerate()\n                .map(|(i, num)| (num[(num.len() - trim)..].to_owned(), i as i32))\n                .collect();\n\n            Self::radix_sort(&mut trimmed_nums);\n            answer.push(trimmed_nums[k - 1].1);\n\n            println!(\"{:?}\", now.elapsed());\n        }\n        answer\n    }\n\n    fn radix_sort(trimmed_nums: &mut Vec<(String, i32)>) {\n        let max_digit = trimmed_nums[0].0.len();\n\n        for i in (0..max_digit).rev() {\n            let mut counts = [0; 10];\n            let nums: Vec<u32> = trimmed_nums\n                .iter()\n                .map(|(num, _)| num[i..=i].parse::<u32>().unwrap())\n                .collect();\n            for num in &nums {\n                counts[*num as usize] += 1;\n            }\n\n            let mut starting_index = 0;\n            for i in 0..counts.len() {\n                let count = counts[i];\n                counts[i] = starting_index;\n                starting_index += count;\n            }\n\n            let mut sorted_array: Vec<(String, i32)> = Vec::new();\n            sorted_array.resize(trimmed_nums.len(), (String::new(), -1));\n\n            for i in 0..trimmed_nums.len() {\n                sorted_array[counts[nums[i] as usize] as usize] = trimmed_nums[i].clone();\n                counts[nums[i] as usize] += 1;\n            }\n\n            for i in 0..sorted_array.len() {\n                trimmed_nums[i] = sorted_array[i].clone();\n            }\n        }\n    }\n}\n\n```"
                    }
                ]
            },
            {
                "id": 1956918,
                "content": [
                    {
                        "username": "zartabali7298",
                        "content": "a question for sorting array"
                    },
                    {
                        "username": "zartabali7298",
                        "content": "Thank you for your feedback!\\n"
                    },
                    {
                        "username": "zartabali7298",
                        "content": "sort list"
                    },
                    {
                        "username": "zartabali7298",
                        "content": "Thank you for your feedback!"
                    },
                    {
                        "username": "zartabali7298",
                        "content": "Thank you for your feedback!"
                    },
                    {
                        "username": "zartabali7298",
                        "content": "thank you for easy problems"
                    },
                    {
                        "username": "an5dy90",
                        "content": "Karen here. Please provide an official solution or I would like to speak to your manager for a refund. "
                    },
                    {
                        "username": "hacker363",
                        "content": "```class Solution:\n    def smallestTrimmedNumbers(self, nums: List[str], queries: List[List[int]]) -> List[int]:\n        ans = []\n        for i in queries:\n            temp = []\n            for j in nums:\n                temp.append(j[len(j)-i[1]:])\n            p =[]\n            d = sorted(temp)\n            for itr in range(len(temp)):\n                if(temp[itr] == d[i[0]-1]):\n                    p.append(itr)\n            print(p)\n            ans.append(p[-1])\n            p=[]\n        return ans\n```\n\nCan anyone please help me why my code is wrong at test case 83\nIt is given in question that if the trimmed number are equal then the one at larger index is treated as larger.\nPlease helppppppp!!!!!!"
                    },
                    {
                        "username": "FumiyaShibusawa",
                        "content": "When I run this code, it passes with input`nums` of 92 digit numbers. But when I submitted it, it gets Time Limit Exceeded on an input `nums` of 93 digit numbers. I roughly measured time for each query with `std::time::Instant`, but it seems to be pretty decent like a total of 17.874756ms. I'm at a loss where to optimize. If anyone had a idea, please leave a comment. :pray: \n\n```rust\nimpl Solution {\n    pub fn smallest_trimmed_numbers(nums: Vec<String>, queries: Vec<Vec<i32>>) -> Vec<i32> {\n        let mut answer = Vec::new();\n        for query in queries {\n            let now = std::time::Instant::now();\n\n            let k = query[0] as usize;\n            let trim = query[1] as usize;\n            let mut trimmed_nums: Vec<(String, i32)> = nums\n                .iter()\n                .enumerate()\n                .map(|(i, num)| (num[(num.len() - trim)..].to_owned(), i as i32))\n                .collect();\n\n            Self::radix_sort(&mut trimmed_nums);\n            answer.push(trimmed_nums[k - 1].1);\n\n            println!(\"{:?}\", now.elapsed());\n        }\n        answer\n    }\n\n    fn radix_sort(trimmed_nums: &mut Vec<(String, i32)>) {\n        let max_digit = trimmed_nums[0].0.len();\n\n        for i in (0..max_digit).rev() {\n            let mut counts = [0; 10];\n            let nums: Vec<u32> = trimmed_nums\n                .iter()\n                .map(|(num, _)| num[i..=i].parse::<u32>().unwrap())\n                .collect();\n            for num in &nums {\n                counts[*num as usize] += 1;\n            }\n\n            let mut starting_index = 0;\n            for i in 0..counts.len() {\n                let count = counts[i];\n                counts[i] = starting_index;\n                starting_index += count;\n            }\n\n            let mut sorted_array: Vec<(String, i32)> = Vec::new();\n            sorted_array.resize(trimmed_nums.len(), (String::new(), -1));\n\n            for i in 0..trimmed_nums.len() {\n                sorted_array[counts[nums[i] as usize] as usize] = trimmed_nums[i].clone();\n                counts[nums[i] as usize] += 1;\n            }\n\n            for i in 0..sorted_array.len() {\n                trimmed_nums[i] = sorted_array[i].clone();\n            }\n        }\n    }\n}\n\n```"
                    }
                ]
            },
            {
                "id": 1956917,
                "content": [
                    {
                        "username": "zartabali7298",
                        "content": "a question for sorting array"
                    },
                    {
                        "username": "zartabali7298",
                        "content": "Thank you for your feedback!\\n"
                    },
                    {
                        "username": "zartabali7298",
                        "content": "sort list"
                    },
                    {
                        "username": "zartabali7298",
                        "content": "Thank you for your feedback!"
                    },
                    {
                        "username": "zartabali7298",
                        "content": "Thank you for your feedback!"
                    },
                    {
                        "username": "zartabali7298",
                        "content": "thank you for easy problems"
                    },
                    {
                        "username": "an5dy90",
                        "content": "Karen here. Please provide an official solution or I would like to speak to your manager for a refund. "
                    },
                    {
                        "username": "hacker363",
                        "content": "```class Solution:\n    def smallestTrimmedNumbers(self, nums: List[str], queries: List[List[int]]) -> List[int]:\n        ans = []\n        for i in queries:\n            temp = []\n            for j in nums:\n                temp.append(j[len(j)-i[1]:])\n            p =[]\n            d = sorted(temp)\n            for itr in range(len(temp)):\n                if(temp[itr] == d[i[0]-1]):\n                    p.append(itr)\n            print(p)\n            ans.append(p[-1])\n            p=[]\n        return ans\n```\n\nCan anyone please help me why my code is wrong at test case 83\nIt is given in question that if the trimmed number are equal then the one at larger index is treated as larger.\nPlease helppppppp!!!!!!"
                    },
                    {
                        "username": "FumiyaShibusawa",
                        "content": "When I run this code, it passes with input`nums` of 92 digit numbers. But when I submitted it, it gets Time Limit Exceeded on an input `nums` of 93 digit numbers. I roughly measured time for each query with `std::time::Instant`, but it seems to be pretty decent like a total of 17.874756ms. I'm at a loss where to optimize. If anyone had a idea, please leave a comment. :pray: \n\n```rust\nimpl Solution {\n    pub fn smallest_trimmed_numbers(nums: Vec<String>, queries: Vec<Vec<i32>>) -> Vec<i32> {\n        let mut answer = Vec::new();\n        for query in queries {\n            let now = std::time::Instant::now();\n\n            let k = query[0] as usize;\n            let trim = query[1] as usize;\n            let mut trimmed_nums: Vec<(String, i32)> = nums\n                .iter()\n                .enumerate()\n                .map(|(i, num)| (num[(num.len() - trim)..].to_owned(), i as i32))\n                .collect();\n\n            Self::radix_sort(&mut trimmed_nums);\n            answer.push(trimmed_nums[k - 1].1);\n\n            println!(\"{:?}\", now.elapsed());\n        }\n        answer\n    }\n\n    fn radix_sort(trimmed_nums: &mut Vec<(String, i32)>) {\n        let max_digit = trimmed_nums[0].0.len();\n\n        for i in (0..max_digit).rev() {\n            let mut counts = [0; 10];\n            let nums: Vec<u32> = trimmed_nums\n                .iter()\n                .map(|(num, _)| num[i..=i].parse::<u32>().unwrap())\n                .collect();\n            for num in &nums {\n                counts[*num as usize] += 1;\n            }\n\n            let mut starting_index = 0;\n            for i in 0..counts.len() {\n                let count = counts[i];\n                counts[i] = starting_index;\n                starting_index += count;\n            }\n\n            let mut sorted_array: Vec<(String, i32)> = Vec::new();\n            sorted_array.resize(trimmed_nums.len(), (String::new(), -1));\n\n            for i in 0..trimmed_nums.len() {\n                sorted_array[counts[nums[i] as usize] as usize] = trimmed_nums[i].clone();\n                counts[nums[i] as usize] += 1;\n            }\n\n            for i in 0..sorted_array.len() {\n                trimmed_nums[i] = sorted_array[i].clone();\n            }\n        }\n    }\n}\n\n```"
                    }
                ]
            },
            {
                "id": 1956916,
                "content": [
                    {
                        "username": "zartabali7298",
                        "content": "a question for sorting array"
                    },
                    {
                        "username": "zartabali7298",
                        "content": "Thank you for your feedback!\\n"
                    },
                    {
                        "username": "zartabali7298",
                        "content": "sort list"
                    },
                    {
                        "username": "zartabali7298",
                        "content": "Thank you for your feedback!"
                    },
                    {
                        "username": "zartabali7298",
                        "content": "Thank you for your feedback!"
                    },
                    {
                        "username": "zartabali7298",
                        "content": "thank you for easy problems"
                    },
                    {
                        "username": "an5dy90",
                        "content": "Karen here. Please provide an official solution or I would like to speak to your manager for a refund. "
                    },
                    {
                        "username": "hacker363",
                        "content": "```class Solution:\n    def smallestTrimmedNumbers(self, nums: List[str], queries: List[List[int]]) -> List[int]:\n        ans = []\n        for i in queries:\n            temp = []\n            for j in nums:\n                temp.append(j[len(j)-i[1]:])\n            p =[]\n            d = sorted(temp)\n            for itr in range(len(temp)):\n                if(temp[itr] == d[i[0]-1]):\n                    p.append(itr)\n            print(p)\n            ans.append(p[-1])\n            p=[]\n        return ans\n```\n\nCan anyone please help me why my code is wrong at test case 83\nIt is given in question that if the trimmed number are equal then the one at larger index is treated as larger.\nPlease helppppppp!!!!!!"
                    },
                    {
                        "username": "FumiyaShibusawa",
                        "content": "When I run this code, it passes with input`nums` of 92 digit numbers. But when I submitted it, it gets Time Limit Exceeded on an input `nums` of 93 digit numbers. I roughly measured time for each query with `std::time::Instant`, but it seems to be pretty decent like a total of 17.874756ms. I'm at a loss where to optimize. If anyone had a idea, please leave a comment. :pray: \n\n```rust\nimpl Solution {\n    pub fn smallest_trimmed_numbers(nums: Vec<String>, queries: Vec<Vec<i32>>) -> Vec<i32> {\n        let mut answer = Vec::new();\n        for query in queries {\n            let now = std::time::Instant::now();\n\n            let k = query[0] as usize;\n            let trim = query[1] as usize;\n            let mut trimmed_nums: Vec<(String, i32)> = nums\n                .iter()\n                .enumerate()\n                .map(|(i, num)| (num[(num.len() - trim)..].to_owned(), i as i32))\n                .collect();\n\n            Self::radix_sort(&mut trimmed_nums);\n            answer.push(trimmed_nums[k - 1].1);\n\n            println!(\"{:?}\", now.elapsed());\n        }\n        answer\n    }\n\n    fn radix_sort(trimmed_nums: &mut Vec<(String, i32)>) {\n        let max_digit = trimmed_nums[0].0.len();\n\n        for i in (0..max_digit).rev() {\n            let mut counts = [0; 10];\n            let nums: Vec<u32> = trimmed_nums\n                .iter()\n                .map(|(num, _)| num[i..=i].parse::<u32>().unwrap())\n                .collect();\n            for num in &nums {\n                counts[*num as usize] += 1;\n            }\n\n            let mut starting_index = 0;\n            for i in 0..counts.len() {\n                let count = counts[i];\n                counts[i] = starting_index;\n                starting_index += count;\n            }\n\n            let mut sorted_array: Vec<(String, i32)> = Vec::new();\n            sorted_array.resize(trimmed_nums.len(), (String::new(), -1));\n\n            for i in 0..trimmed_nums.len() {\n                sorted_array[counts[nums[i] as usize] as usize] = trimmed_nums[i].clone();\n                counts[nums[i] as usize] += 1;\n            }\n\n            for i in 0..sorted_array.len() {\n                trimmed_nums[i] = sorted_array[i].clone();\n            }\n        }\n    }\n}\n\n```"
                    }
                ]
            },
            {
                "id": 1956915,
                "content": [
                    {
                        "username": "zartabali7298",
                        "content": "a question for sorting array"
                    },
                    {
                        "username": "zartabali7298",
                        "content": "Thank you for your feedback!\\n"
                    },
                    {
                        "username": "zartabali7298",
                        "content": "sort list"
                    },
                    {
                        "username": "zartabali7298",
                        "content": "Thank you for your feedback!"
                    },
                    {
                        "username": "zartabali7298",
                        "content": "Thank you for your feedback!"
                    },
                    {
                        "username": "zartabali7298",
                        "content": "thank you for easy problems"
                    },
                    {
                        "username": "an5dy90",
                        "content": "Karen here. Please provide an official solution or I would like to speak to your manager for a refund. "
                    },
                    {
                        "username": "hacker363",
                        "content": "```class Solution:\n    def smallestTrimmedNumbers(self, nums: List[str], queries: List[List[int]]) -> List[int]:\n        ans = []\n        for i in queries:\n            temp = []\n            for j in nums:\n                temp.append(j[len(j)-i[1]:])\n            p =[]\n            d = sorted(temp)\n            for itr in range(len(temp)):\n                if(temp[itr] == d[i[0]-1]):\n                    p.append(itr)\n            print(p)\n            ans.append(p[-1])\n            p=[]\n        return ans\n```\n\nCan anyone please help me why my code is wrong at test case 83\nIt is given in question that if the trimmed number are equal then the one at larger index is treated as larger.\nPlease helppppppp!!!!!!"
                    },
                    {
                        "username": "FumiyaShibusawa",
                        "content": "When I run this code, it passes with input`nums` of 92 digit numbers. But when I submitted it, it gets Time Limit Exceeded on an input `nums` of 93 digit numbers. I roughly measured time for each query with `std::time::Instant`, but it seems to be pretty decent like a total of 17.874756ms. I'm at a loss where to optimize. If anyone had a idea, please leave a comment. :pray: \n\n```rust\nimpl Solution {\n    pub fn smallest_trimmed_numbers(nums: Vec<String>, queries: Vec<Vec<i32>>) -> Vec<i32> {\n        let mut answer = Vec::new();\n        for query in queries {\n            let now = std::time::Instant::now();\n\n            let k = query[0] as usize;\n            let trim = query[1] as usize;\n            let mut trimmed_nums: Vec<(String, i32)> = nums\n                .iter()\n                .enumerate()\n                .map(|(i, num)| (num[(num.len() - trim)..].to_owned(), i as i32))\n                .collect();\n\n            Self::radix_sort(&mut trimmed_nums);\n            answer.push(trimmed_nums[k - 1].1);\n\n            println!(\"{:?}\", now.elapsed());\n        }\n        answer\n    }\n\n    fn radix_sort(trimmed_nums: &mut Vec<(String, i32)>) {\n        let max_digit = trimmed_nums[0].0.len();\n\n        for i in (0..max_digit).rev() {\n            let mut counts = [0; 10];\n            let nums: Vec<u32> = trimmed_nums\n                .iter()\n                .map(|(num, _)| num[i..=i].parse::<u32>().unwrap())\n                .collect();\n            for num in &nums {\n                counts[*num as usize] += 1;\n            }\n\n            let mut starting_index = 0;\n            for i in 0..counts.len() {\n                let count = counts[i];\n                counts[i] = starting_index;\n                starting_index += count;\n            }\n\n            let mut sorted_array: Vec<(String, i32)> = Vec::new();\n            sorted_array.resize(trimmed_nums.len(), (String::new(), -1));\n\n            for i in 0..trimmed_nums.len() {\n                sorted_array[counts[nums[i] as usize] as usize] = trimmed_nums[i].clone();\n                counts[nums[i] as usize] += 1;\n            }\n\n            for i in 0..sorted_array.len() {\n                trimmed_nums[i] = sorted_array[i].clone();\n            }\n        }\n    }\n}\n\n```"
                    }
                ]
            },
            {
                "id": 1956912,
                "content": [
                    {
                        "username": "zartabali7298",
                        "content": "a question for sorting array"
                    },
                    {
                        "username": "zartabali7298",
                        "content": "Thank you for your feedback!\\n"
                    },
                    {
                        "username": "zartabali7298",
                        "content": "sort list"
                    },
                    {
                        "username": "zartabali7298",
                        "content": "Thank you for your feedback!"
                    },
                    {
                        "username": "zartabali7298",
                        "content": "Thank you for your feedback!"
                    },
                    {
                        "username": "zartabali7298",
                        "content": "thank you for easy problems"
                    },
                    {
                        "username": "an5dy90",
                        "content": "Karen here. Please provide an official solution or I would like to speak to your manager for a refund. "
                    },
                    {
                        "username": "hacker363",
                        "content": "```class Solution:\n    def smallestTrimmedNumbers(self, nums: List[str], queries: List[List[int]]) -> List[int]:\n        ans = []\n        for i in queries:\n            temp = []\n            for j in nums:\n                temp.append(j[len(j)-i[1]:])\n            p =[]\n            d = sorted(temp)\n            for itr in range(len(temp)):\n                if(temp[itr] == d[i[0]-1]):\n                    p.append(itr)\n            print(p)\n            ans.append(p[-1])\n            p=[]\n        return ans\n```\n\nCan anyone please help me why my code is wrong at test case 83\nIt is given in question that if the trimmed number are equal then the one at larger index is treated as larger.\nPlease helppppppp!!!!!!"
                    },
                    {
                        "username": "FumiyaShibusawa",
                        "content": "When I run this code, it passes with input`nums` of 92 digit numbers. But when I submitted it, it gets Time Limit Exceeded on an input `nums` of 93 digit numbers. I roughly measured time for each query with `std::time::Instant`, but it seems to be pretty decent like a total of 17.874756ms. I'm at a loss where to optimize. If anyone had a idea, please leave a comment. :pray: \n\n```rust\nimpl Solution {\n    pub fn smallest_trimmed_numbers(nums: Vec<String>, queries: Vec<Vec<i32>>) -> Vec<i32> {\n        let mut answer = Vec::new();\n        for query in queries {\n            let now = std::time::Instant::now();\n\n            let k = query[0] as usize;\n            let trim = query[1] as usize;\n            let mut trimmed_nums: Vec<(String, i32)> = nums\n                .iter()\n                .enumerate()\n                .map(|(i, num)| (num[(num.len() - trim)..].to_owned(), i as i32))\n                .collect();\n\n            Self::radix_sort(&mut trimmed_nums);\n            answer.push(trimmed_nums[k - 1].1);\n\n            println!(\"{:?}\", now.elapsed());\n        }\n        answer\n    }\n\n    fn radix_sort(trimmed_nums: &mut Vec<(String, i32)>) {\n        let max_digit = trimmed_nums[0].0.len();\n\n        for i in (0..max_digit).rev() {\n            let mut counts = [0; 10];\n            let nums: Vec<u32> = trimmed_nums\n                .iter()\n                .map(|(num, _)| num[i..=i].parse::<u32>().unwrap())\n                .collect();\n            for num in &nums {\n                counts[*num as usize] += 1;\n            }\n\n            let mut starting_index = 0;\n            for i in 0..counts.len() {\n                let count = counts[i];\n                counts[i] = starting_index;\n                starting_index += count;\n            }\n\n            let mut sorted_array: Vec<(String, i32)> = Vec::new();\n            sorted_array.resize(trimmed_nums.len(), (String::new(), -1));\n\n            for i in 0..trimmed_nums.len() {\n                sorted_array[counts[nums[i] as usize] as usize] = trimmed_nums[i].clone();\n                counts[nums[i] as usize] += 1;\n            }\n\n            for i in 0..sorted_array.len() {\n                trimmed_nums[i] = sorted_array[i].clone();\n            }\n        }\n    }\n}\n\n```"
                    }
                ]
            },
            {
                "id": 1954066,
                "content": [
                    {
                        "username": "zartabali7298",
                        "content": "a question for sorting array"
                    },
                    {
                        "username": "zartabali7298",
                        "content": "Thank you for your feedback!\\n"
                    },
                    {
                        "username": "zartabali7298",
                        "content": "sort list"
                    },
                    {
                        "username": "zartabali7298",
                        "content": "Thank you for your feedback!"
                    },
                    {
                        "username": "zartabali7298",
                        "content": "Thank you for your feedback!"
                    },
                    {
                        "username": "zartabali7298",
                        "content": "thank you for easy problems"
                    },
                    {
                        "username": "an5dy90",
                        "content": "Karen here. Please provide an official solution or I would like to speak to your manager for a refund. "
                    },
                    {
                        "username": "hacker363",
                        "content": "```class Solution:\n    def smallestTrimmedNumbers(self, nums: List[str], queries: List[List[int]]) -> List[int]:\n        ans = []\n        for i in queries:\n            temp = []\n            for j in nums:\n                temp.append(j[len(j)-i[1]:])\n            p =[]\n            d = sorted(temp)\n            for itr in range(len(temp)):\n                if(temp[itr] == d[i[0]-1]):\n                    p.append(itr)\n            print(p)\n            ans.append(p[-1])\n            p=[]\n        return ans\n```\n\nCan anyone please help me why my code is wrong at test case 83\nIt is given in question that if the trimmed number are equal then the one at larger index is treated as larger.\nPlease helppppppp!!!!!!"
                    },
                    {
                        "username": "FumiyaShibusawa",
                        "content": "When I run this code, it passes with input`nums` of 92 digit numbers. But when I submitted it, it gets Time Limit Exceeded on an input `nums` of 93 digit numbers. I roughly measured time for each query with `std::time::Instant`, but it seems to be pretty decent like a total of 17.874756ms. I'm at a loss where to optimize. If anyone had a idea, please leave a comment. :pray: \n\n```rust\nimpl Solution {\n    pub fn smallest_trimmed_numbers(nums: Vec<String>, queries: Vec<Vec<i32>>) -> Vec<i32> {\n        let mut answer = Vec::new();\n        for query in queries {\n            let now = std::time::Instant::now();\n\n            let k = query[0] as usize;\n            let trim = query[1] as usize;\n            let mut trimmed_nums: Vec<(String, i32)> = nums\n                .iter()\n                .enumerate()\n                .map(|(i, num)| (num[(num.len() - trim)..].to_owned(), i as i32))\n                .collect();\n\n            Self::radix_sort(&mut trimmed_nums);\n            answer.push(trimmed_nums[k - 1].1);\n\n            println!(\"{:?}\", now.elapsed());\n        }\n        answer\n    }\n\n    fn radix_sort(trimmed_nums: &mut Vec<(String, i32)>) {\n        let max_digit = trimmed_nums[0].0.len();\n\n        for i in (0..max_digit).rev() {\n            let mut counts = [0; 10];\n            let nums: Vec<u32> = trimmed_nums\n                .iter()\n                .map(|(num, _)| num[i..=i].parse::<u32>().unwrap())\n                .collect();\n            for num in &nums {\n                counts[*num as usize] += 1;\n            }\n\n            let mut starting_index = 0;\n            for i in 0..counts.len() {\n                let count = counts[i];\n                counts[i] = starting_index;\n                starting_index += count;\n            }\n\n            let mut sorted_array: Vec<(String, i32)> = Vec::new();\n            sorted_array.resize(trimmed_nums.len(), (String::new(), -1));\n\n            for i in 0..trimmed_nums.len() {\n                sorted_array[counts[nums[i] as usize] as usize] = trimmed_nums[i].clone();\n                counts[nums[i] as usize] += 1;\n            }\n\n            for i in 0..sorted_array.len() {\n                trimmed_nums[i] = sorted_array[i].clone();\n            }\n        }\n    }\n}\n\n```"
                    }
                ]
            },
            {
                "id": 1949659,
                "content": [
                    {
                        "username": "zartabali7298",
                        "content": "a question for sorting array"
                    },
                    {
                        "username": "zartabali7298",
                        "content": "Thank you for your feedback!\\n"
                    },
                    {
                        "username": "zartabali7298",
                        "content": "sort list"
                    },
                    {
                        "username": "zartabali7298",
                        "content": "Thank you for your feedback!"
                    },
                    {
                        "username": "zartabali7298",
                        "content": "Thank you for your feedback!"
                    },
                    {
                        "username": "zartabali7298",
                        "content": "thank you for easy problems"
                    },
                    {
                        "username": "an5dy90",
                        "content": "Karen here. Please provide an official solution or I would like to speak to your manager for a refund. "
                    },
                    {
                        "username": "hacker363",
                        "content": "```class Solution:\n    def smallestTrimmedNumbers(self, nums: List[str], queries: List[List[int]]) -> List[int]:\n        ans = []\n        for i in queries:\n            temp = []\n            for j in nums:\n                temp.append(j[len(j)-i[1]:])\n            p =[]\n            d = sorted(temp)\n            for itr in range(len(temp)):\n                if(temp[itr] == d[i[0]-1]):\n                    p.append(itr)\n            print(p)\n            ans.append(p[-1])\n            p=[]\n        return ans\n```\n\nCan anyone please help me why my code is wrong at test case 83\nIt is given in question that if the trimmed number are equal then the one at larger index is treated as larger.\nPlease helppppppp!!!!!!"
                    },
                    {
                        "username": "FumiyaShibusawa",
                        "content": "When I run this code, it passes with input`nums` of 92 digit numbers. But when I submitted it, it gets Time Limit Exceeded on an input `nums` of 93 digit numbers. I roughly measured time for each query with `std::time::Instant`, but it seems to be pretty decent like a total of 17.874756ms. I'm at a loss where to optimize. If anyone had a idea, please leave a comment. :pray: \n\n```rust\nimpl Solution {\n    pub fn smallest_trimmed_numbers(nums: Vec<String>, queries: Vec<Vec<i32>>) -> Vec<i32> {\n        let mut answer = Vec::new();\n        for query in queries {\n            let now = std::time::Instant::now();\n\n            let k = query[0] as usize;\n            let trim = query[1] as usize;\n            let mut trimmed_nums: Vec<(String, i32)> = nums\n                .iter()\n                .enumerate()\n                .map(|(i, num)| (num[(num.len() - trim)..].to_owned(), i as i32))\n                .collect();\n\n            Self::radix_sort(&mut trimmed_nums);\n            answer.push(trimmed_nums[k - 1].1);\n\n            println!(\"{:?}\", now.elapsed());\n        }\n        answer\n    }\n\n    fn radix_sort(trimmed_nums: &mut Vec<(String, i32)>) {\n        let max_digit = trimmed_nums[0].0.len();\n\n        for i in (0..max_digit).rev() {\n            let mut counts = [0; 10];\n            let nums: Vec<u32> = trimmed_nums\n                .iter()\n                .map(|(num, _)| num[i..=i].parse::<u32>().unwrap())\n                .collect();\n            for num in &nums {\n                counts[*num as usize] += 1;\n            }\n\n            let mut starting_index = 0;\n            for i in 0..counts.len() {\n                let count = counts[i];\n                counts[i] = starting_index;\n                starting_index += count;\n            }\n\n            let mut sorted_array: Vec<(String, i32)> = Vec::new();\n            sorted_array.resize(trimmed_nums.len(), (String::new(), -1));\n\n            for i in 0..trimmed_nums.len() {\n                sorted_array[counts[nums[i] as usize] as usize] = trimmed_nums[i].clone();\n                counts[nums[i] as usize] += 1;\n            }\n\n            for i in 0..sorted_array.len() {\n                trimmed_nums[i] = sorted_array[i].clone();\n            }\n        }\n    }\n}\n\n```"
                    }
                ]
            },
            {
                "id": 1753101,
                "content": [
                    {
                        "username": "zartabali7298",
                        "content": "a question for sorting array"
                    },
                    {
                        "username": "zartabali7298",
                        "content": "Thank you for your feedback!\\n"
                    },
                    {
                        "username": "zartabali7298",
                        "content": "sort list"
                    },
                    {
                        "username": "zartabali7298",
                        "content": "Thank you for your feedback!"
                    },
                    {
                        "username": "zartabali7298",
                        "content": "Thank you for your feedback!"
                    },
                    {
                        "username": "zartabali7298",
                        "content": "thank you for easy problems"
                    },
                    {
                        "username": "an5dy90",
                        "content": "Karen here. Please provide an official solution or I would like to speak to your manager for a refund. "
                    },
                    {
                        "username": "hacker363",
                        "content": "```class Solution:\n    def smallestTrimmedNumbers(self, nums: List[str], queries: List[List[int]]) -> List[int]:\n        ans = []\n        for i in queries:\n            temp = []\n            for j in nums:\n                temp.append(j[len(j)-i[1]:])\n            p =[]\n            d = sorted(temp)\n            for itr in range(len(temp)):\n                if(temp[itr] == d[i[0]-1]):\n                    p.append(itr)\n            print(p)\n            ans.append(p[-1])\n            p=[]\n        return ans\n```\n\nCan anyone please help me why my code is wrong at test case 83\nIt is given in question that if the trimmed number are equal then the one at larger index is treated as larger.\nPlease helppppppp!!!!!!"
                    },
                    {
                        "username": "FumiyaShibusawa",
                        "content": "When I run this code, it passes with input`nums` of 92 digit numbers. But when I submitted it, it gets Time Limit Exceeded on an input `nums` of 93 digit numbers. I roughly measured time for each query with `std::time::Instant`, but it seems to be pretty decent like a total of 17.874756ms. I'm at a loss where to optimize. If anyone had a idea, please leave a comment. :pray: \n\n```rust\nimpl Solution {\n    pub fn smallest_trimmed_numbers(nums: Vec<String>, queries: Vec<Vec<i32>>) -> Vec<i32> {\n        let mut answer = Vec::new();\n        for query in queries {\n            let now = std::time::Instant::now();\n\n            let k = query[0] as usize;\n            let trim = query[1] as usize;\n            let mut trimmed_nums: Vec<(String, i32)> = nums\n                .iter()\n                .enumerate()\n                .map(|(i, num)| (num[(num.len() - trim)..].to_owned(), i as i32))\n                .collect();\n\n            Self::radix_sort(&mut trimmed_nums);\n            answer.push(trimmed_nums[k - 1].1);\n\n            println!(\"{:?}\", now.elapsed());\n        }\n        answer\n    }\n\n    fn radix_sort(trimmed_nums: &mut Vec<(String, i32)>) {\n        let max_digit = trimmed_nums[0].0.len();\n\n        for i in (0..max_digit).rev() {\n            let mut counts = [0; 10];\n            let nums: Vec<u32> = trimmed_nums\n                .iter()\n                .map(|(num, _)| num[i..=i].parse::<u32>().unwrap())\n                .collect();\n            for num in &nums {\n                counts[*num as usize] += 1;\n            }\n\n            let mut starting_index = 0;\n            for i in 0..counts.len() {\n                let count = counts[i];\n                counts[i] = starting_index;\n                starting_index += count;\n            }\n\n            let mut sorted_array: Vec<(String, i32)> = Vec::new();\n            sorted_array.resize(trimmed_nums.len(), (String::new(), -1));\n\n            for i in 0..trimmed_nums.len() {\n                sorted_array[counts[nums[i] as usize] as usize] = trimmed_nums[i].clone();\n                counts[nums[i] as usize] += 1;\n            }\n\n            for i in 0..sorted_array.len() {\n                trimmed_nums[i] = sorted_array[i].clone();\n            }\n        }\n    }\n}\n\n```"
                    }
                ]
            }
        ]
    },
    {
        "title": "Minimum Costs Using the Train Line",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1720927,
                "content": [
                    {
                        "username": "praneeth029",
                        "content": "Relatively easy compared to other LC Hard problems.\\nCan make it medium."
                    },
                    {
                        "username": "as9vd2",
                        "content": "What confused the shit out of me was the fact that the paths in the picture don\\'t necessarily match whichever array had the minimum value up to that point."
                    },
                    {
                        "username": "vijaysince89",
                        "content": "Even I see the first Example picture does not match with the output. Can you please explain, if you understand the first example ?"
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "I think this is better to be labeled as a medium question"
                    },
                    {
                        "username": "ylilarry",
                        "content": "Isn\\'t the description wrong? \"regular[i] describes the cost it takes to go from stop i - 1 to stop i using the regular route\" - it should be regular[i-1] instead."
                    },
                    {
                        "username": "JerryXie96",
                        "content": "yep. the description of the returning list is also wrong. should be costs[i-1]."
                    },
                    {
                        "username": "deleted_user",
                        "content": "Yes, description seems wrong. Otherwise the example is wrong. "
                    },
                    {
                        "username": "willq1",
                        "content": "I was wondering if someone would mind explaining to me why for example 1, the following answer would not be valid?\n[1, 11, 14, 19]\nregular = [1,6,9,5], express = [5,2,3,10], expressCost = 8\n\nYou take the regular transit. (1) [1]\nYou switch and take the express. (1 + 2 + 8) [1, 11]\nYou take the express to the next stop. (1 + 2 + 8 + 3) [1, 11, 14]\nYou take the regular to the next stop. (1 + 2 + 8 + 3 + 5) [1, 11, 14, 19]"
                    },
                    {
                        "username": "vijaysince89",
                        "content": "I\\'m wondering the same for a long time. But I don\\'t see any post explaining it."
                    },
                    {
                        "username": "fli033",
                        "content": "holycrap 1st time 1-try-accepted on a hard problem."
                    },
                    {
                        "username": "shrined",
                        "content": "Yeah this would be the type of hard for that to happen because it seems mislabeled. "
                    },
                    {
                        "username": "totorstan",
                        "content": "The problem is almost the same as this medium: https://leetcode.com/problems/longest-non-decreasing-subarray-from-two-arrays/"
                    },
                    {
                        "username": "Sergei_Gusev",
                        "content": "People, please VOTE for this PETITION to save OLD Study Plans: https://leetcode.com/discuss/feedback/3832685/petition-dont-kick-off-old-study-plans-we-love-it"
                    },
                    {
                        "username": "NicholasCG",
                        "content": "This feels like a pretty standard dp medium."
                    },
                    {
                        "username": "ChenxiLu",
                        "content": "Probably just a medium level problem. Though it could be easy to get the transition states wrong if not careful."
                    }
                ]
            },
            {
                "id": 1825355,
                "content": [
                    {
                        "username": "praneeth029",
                        "content": "Relatively easy compared to other LC Hard problems.\\nCan make it medium."
                    },
                    {
                        "username": "as9vd2",
                        "content": "What confused the shit out of me was the fact that the paths in the picture don\\'t necessarily match whichever array had the minimum value up to that point."
                    },
                    {
                        "username": "vijaysince89",
                        "content": "Even I see the first Example picture does not match with the output. Can you please explain, if you understand the first example ?"
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "I think this is better to be labeled as a medium question"
                    },
                    {
                        "username": "ylilarry",
                        "content": "Isn\\'t the description wrong? \"regular[i] describes the cost it takes to go from stop i - 1 to stop i using the regular route\" - it should be regular[i-1] instead."
                    },
                    {
                        "username": "JerryXie96",
                        "content": "yep. the description of the returning list is also wrong. should be costs[i-1]."
                    },
                    {
                        "username": "deleted_user",
                        "content": "Yes, description seems wrong. Otherwise the example is wrong. "
                    },
                    {
                        "username": "willq1",
                        "content": "I was wondering if someone would mind explaining to me why for example 1, the following answer would not be valid?\n[1, 11, 14, 19]\nregular = [1,6,9,5], express = [5,2,3,10], expressCost = 8\n\nYou take the regular transit. (1) [1]\nYou switch and take the express. (1 + 2 + 8) [1, 11]\nYou take the express to the next stop. (1 + 2 + 8 + 3) [1, 11, 14]\nYou take the regular to the next stop. (1 + 2 + 8 + 3 + 5) [1, 11, 14, 19]"
                    },
                    {
                        "username": "vijaysince89",
                        "content": "I\\'m wondering the same for a long time. But I don\\'t see any post explaining it."
                    },
                    {
                        "username": "fli033",
                        "content": "holycrap 1st time 1-try-accepted on a hard problem."
                    },
                    {
                        "username": "shrined",
                        "content": "Yeah this would be the type of hard for that to happen because it seems mislabeled. "
                    },
                    {
                        "username": "totorstan",
                        "content": "The problem is almost the same as this medium: https://leetcode.com/problems/longest-non-decreasing-subarray-from-two-arrays/"
                    },
                    {
                        "username": "Sergei_Gusev",
                        "content": "People, please VOTE for this PETITION to save OLD Study Plans: https://leetcode.com/discuss/feedback/3832685/petition-dont-kick-off-old-study-plans-we-love-it"
                    },
                    {
                        "username": "NicholasCG",
                        "content": "This feels like a pretty standard dp medium."
                    },
                    {
                        "username": "ChenxiLu",
                        "content": "Probably just a medium level problem. Though it could be easy to get the transition states wrong if not careful."
                    }
                ]
            },
            {
                "id": 1995181,
                "content": [
                    {
                        "username": "praneeth029",
                        "content": "Relatively easy compared to other LC Hard problems.\\nCan make it medium."
                    },
                    {
                        "username": "as9vd2",
                        "content": "What confused the shit out of me was the fact that the paths in the picture don\\'t necessarily match whichever array had the minimum value up to that point."
                    },
                    {
                        "username": "vijaysince89",
                        "content": "Even I see the first Example picture does not match with the output. Can you please explain, if you understand the first example ?"
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "I think this is better to be labeled as a medium question"
                    },
                    {
                        "username": "ylilarry",
                        "content": "Isn\\'t the description wrong? \"regular[i] describes the cost it takes to go from stop i - 1 to stop i using the regular route\" - it should be regular[i-1] instead."
                    },
                    {
                        "username": "JerryXie96",
                        "content": "yep. the description of the returning list is also wrong. should be costs[i-1]."
                    },
                    {
                        "username": "deleted_user",
                        "content": "Yes, description seems wrong. Otherwise the example is wrong. "
                    },
                    {
                        "username": "willq1",
                        "content": "I was wondering if someone would mind explaining to me why for example 1, the following answer would not be valid?\n[1, 11, 14, 19]\nregular = [1,6,9,5], express = [5,2,3,10], expressCost = 8\n\nYou take the regular transit. (1) [1]\nYou switch and take the express. (1 + 2 + 8) [1, 11]\nYou take the express to the next stop. (1 + 2 + 8 + 3) [1, 11, 14]\nYou take the regular to the next stop. (1 + 2 + 8 + 3 + 5) [1, 11, 14, 19]"
                    },
                    {
                        "username": "vijaysince89",
                        "content": "I\\'m wondering the same for a long time. But I don\\'t see any post explaining it."
                    },
                    {
                        "username": "fli033",
                        "content": "holycrap 1st time 1-try-accepted on a hard problem."
                    },
                    {
                        "username": "shrined",
                        "content": "Yeah this would be the type of hard for that to happen because it seems mislabeled. "
                    },
                    {
                        "username": "totorstan",
                        "content": "The problem is almost the same as this medium: https://leetcode.com/problems/longest-non-decreasing-subarray-from-two-arrays/"
                    },
                    {
                        "username": "Sergei_Gusev",
                        "content": "People, please VOTE for this PETITION to save OLD Study Plans: https://leetcode.com/discuss/feedback/3832685/petition-dont-kick-off-old-study-plans-we-love-it"
                    },
                    {
                        "username": "NicholasCG",
                        "content": "This feels like a pretty standard dp medium."
                    },
                    {
                        "username": "ChenxiLu",
                        "content": "Probably just a medium level problem. Though it could be easy to get the transition states wrong if not careful."
                    }
                ]
            },
            {
                "id": 1735943,
                "content": [
                    {
                        "username": "praneeth029",
                        "content": "Relatively easy compared to other LC Hard problems.\\nCan make it medium."
                    },
                    {
                        "username": "as9vd2",
                        "content": "What confused the shit out of me was the fact that the paths in the picture don\\'t necessarily match whichever array had the minimum value up to that point."
                    },
                    {
                        "username": "vijaysince89",
                        "content": "Even I see the first Example picture does not match with the output. Can you please explain, if you understand the first example ?"
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "I think this is better to be labeled as a medium question"
                    },
                    {
                        "username": "ylilarry",
                        "content": "Isn\\'t the description wrong? \"regular[i] describes the cost it takes to go from stop i - 1 to stop i using the regular route\" - it should be regular[i-1] instead."
                    },
                    {
                        "username": "JerryXie96",
                        "content": "yep. the description of the returning list is also wrong. should be costs[i-1]."
                    },
                    {
                        "username": "deleted_user",
                        "content": "Yes, description seems wrong. Otherwise the example is wrong. "
                    },
                    {
                        "username": "willq1",
                        "content": "I was wondering if someone would mind explaining to me why for example 1, the following answer would not be valid?\n[1, 11, 14, 19]\nregular = [1,6,9,5], express = [5,2,3,10], expressCost = 8\n\nYou take the regular transit. (1) [1]\nYou switch and take the express. (1 + 2 + 8) [1, 11]\nYou take the express to the next stop. (1 + 2 + 8 + 3) [1, 11, 14]\nYou take the regular to the next stop. (1 + 2 + 8 + 3 + 5) [1, 11, 14, 19]"
                    },
                    {
                        "username": "vijaysince89",
                        "content": "I\\'m wondering the same for a long time. But I don\\'t see any post explaining it."
                    },
                    {
                        "username": "fli033",
                        "content": "holycrap 1st time 1-try-accepted on a hard problem."
                    },
                    {
                        "username": "shrined",
                        "content": "Yeah this would be the type of hard for that to happen because it seems mislabeled. "
                    },
                    {
                        "username": "totorstan",
                        "content": "The problem is almost the same as this medium: https://leetcode.com/problems/longest-non-decreasing-subarray-from-two-arrays/"
                    },
                    {
                        "username": "Sergei_Gusev",
                        "content": "People, please VOTE for this PETITION to save OLD Study Plans: https://leetcode.com/discuss/feedback/3832685/petition-dont-kick-off-old-study-plans-we-love-it"
                    },
                    {
                        "username": "NicholasCG",
                        "content": "This feels like a pretty standard dp medium."
                    },
                    {
                        "username": "ChenxiLu",
                        "content": "Probably just a medium level problem. Though it could be easy to get the transition states wrong if not careful."
                    }
                ]
            },
            {
                "id": 2015726,
                "content": [
                    {
                        "username": "praneeth029",
                        "content": "Relatively easy compared to other LC Hard problems.\\nCan make it medium."
                    },
                    {
                        "username": "as9vd2",
                        "content": "What confused the shit out of me was the fact that the paths in the picture don\\'t necessarily match whichever array had the minimum value up to that point."
                    },
                    {
                        "username": "vijaysince89",
                        "content": "Even I see the first Example picture does not match with the output. Can you please explain, if you understand the first example ?"
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "I think this is better to be labeled as a medium question"
                    },
                    {
                        "username": "ylilarry",
                        "content": "Isn\\'t the description wrong? \"regular[i] describes the cost it takes to go from stop i - 1 to stop i using the regular route\" - it should be regular[i-1] instead."
                    },
                    {
                        "username": "JerryXie96",
                        "content": "yep. the description of the returning list is also wrong. should be costs[i-1]."
                    },
                    {
                        "username": "deleted_user",
                        "content": "Yes, description seems wrong. Otherwise the example is wrong. "
                    },
                    {
                        "username": "willq1",
                        "content": "I was wondering if someone would mind explaining to me why for example 1, the following answer would not be valid?\n[1, 11, 14, 19]\nregular = [1,6,9,5], express = [5,2,3,10], expressCost = 8\n\nYou take the regular transit. (1) [1]\nYou switch and take the express. (1 + 2 + 8) [1, 11]\nYou take the express to the next stop. (1 + 2 + 8 + 3) [1, 11, 14]\nYou take the regular to the next stop. (1 + 2 + 8 + 3 + 5) [1, 11, 14, 19]"
                    },
                    {
                        "username": "vijaysince89",
                        "content": "I\\'m wondering the same for a long time. But I don\\'t see any post explaining it."
                    },
                    {
                        "username": "fli033",
                        "content": "holycrap 1st time 1-try-accepted on a hard problem."
                    },
                    {
                        "username": "shrined",
                        "content": "Yeah this would be the type of hard for that to happen because it seems mislabeled. "
                    },
                    {
                        "username": "totorstan",
                        "content": "The problem is almost the same as this medium: https://leetcode.com/problems/longest-non-decreasing-subarray-from-two-arrays/"
                    },
                    {
                        "username": "Sergei_Gusev",
                        "content": "People, please VOTE for this PETITION to save OLD Study Plans: https://leetcode.com/discuss/feedback/3832685/petition-dont-kick-off-old-study-plans-we-love-it"
                    },
                    {
                        "username": "NicholasCG",
                        "content": "This feels like a pretty standard dp medium."
                    },
                    {
                        "username": "ChenxiLu",
                        "content": "Probably just a medium level problem. Though it could be easy to get the transition states wrong if not careful."
                    }
                ]
            },
            {
                "id": 1995147,
                "content": [
                    {
                        "username": "praneeth029",
                        "content": "Relatively easy compared to other LC Hard problems.\\nCan make it medium."
                    },
                    {
                        "username": "as9vd2",
                        "content": "What confused the shit out of me was the fact that the paths in the picture don\\'t necessarily match whichever array had the minimum value up to that point."
                    },
                    {
                        "username": "vijaysince89",
                        "content": "Even I see the first Example picture does not match with the output. Can you please explain, if you understand the first example ?"
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "I think this is better to be labeled as a medium question"
                    },
                    {
                        "username": "ylilarry",
                        "content": "Isn\\'t the description wrong? \"regular[i] describes the cost it takes to go from stop i - 1 to stop i using the regular route\" - it should be regular[i-1] instead."
                    },
                    {
                        "username": "JerryXie96",
                        "content": "yep. the description of the returning list is also wrong. should be costs[i-1]."
                    },
                    {
                        "username": "deleted_user",
                        "content": "Yes, description seems wrong. Otherwise the example is wrong. "
                    },
                    {
                        "username": "willq1",
                        "content": "I was wondering if someone would mind explaining to me why for example 1, the following answer would not be valid?\n[1, 11, 14, 19]\nregular = [1,6,9,5], express = [5,2,3,10], expressCost = 8\n\nYou take the regular transit. (1) [1]\nYou switch and take the express. (1 + 2 + 8) [1, 11]\nYou take the express to the next stop. (1 + 2 + 8 + 3) [1, 11, 14]\nYou take the regular to the next stop. (1 + 2 + 8 + 3 + 5) [1, 11, 14, 19]"
                    },
                    {
                        "username": "vijaysince89",
                        "content": "I\\'m wondering the same for a long time. But I don\\'t see any post explaining it."
                    },
                    {
                        "username": "fli033",
                        "content": "holycrap 1st time 1-try-accepted on a hard problem."
                    },
                    {
                        "username": "shrined",
                        "content": "Yeah this would be the type of hard for that to happen because it seems mislabeled. "
                    },
                    {
                        "username": "totorstan",
                        "content": "The problem is almost the same as this medium: https://leetcode.com/problems/longest-non-decreasing-subarray-from-two-arrays/"
                    },
                    {
                        "username": "Sergei_Gusev",
                        "content": "People, please VOTE for this PETITION to save OLD Study Plans: https://leetcode.com/discuss/feedback/3832685/petition-dont-kick-off-old-study-plans-we-love-it"
                    },
                    {
                        "username": "NicholasCG",
                        "content": "This feels like a pretty standard dp medium."
                    },
                    {
                        "username": "ChenxiLu",
                        "content": "Probably just a medium level problem. Though it could be easy to get the transition states wrong if not careful."
                    }
                ]
            },
            {
                "id": 2004302,
                "content": [
                    {
                        "username": "praneeth029",
                        "content": "Relatively easy compared to other LC Hard problems.\\nCan make it medium."
                    },
                    {
                        "username": "as9vd2",
                        "content": "What confused the shit out of me was the fact that the paths in the picture don\\'t necessarily match whichever array had the minimum value up to that point."
                    },
                    {
                        "username": "vijaysince89",
                        "content": "Even I see the first Example picture does not match with the output. Can you please explain, if you understand the first example ?"
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "I think this is better to be labeled as a medium question"
                    },
                    {
                        "username": "ylilarry",
                        "content": "Isn\\'t the description wrong? \"regular[i] describes the cost it takes to go from stop i - 1 to stop i using the regular route\" - it should be regular[i-1] instead."
                    },
                    {
                        "username": "JerryXie96",
                        "content": "yep. the description of the returning list is also wrong. should be costs[i-1]."
                    },
                    {
                        "username": "deleted_user",
                        "content": "Yes, description seems wrong. Otherwise the example is wrong. "
                    },
                    {
                        "username": "willq1",
                        "content": "I was wondering if someone would mind explaining to me why for example 1, the following answer would not be valid?\n[1, 11, 14, 19]\nregular = [1,6,9,5], express = [5,2,3,10], expressCost = 8\n\nYou take the regular transit. (1) [1]\nYou switch and take the express. (1 + 2 + 8) [1, 11]\nYou take the express to the next stop. (1 + 2 + 8 + 3) [1, 11, 14]\nYou take the regular to the next stop. (1 + 2 + 8 + 3 + 5) [1, 11, 14, 19]"
                    },
                    {
                        "username": "vijaysince89",
                        "content": "I\\'m wondering the same for a long time. But I don\\'t see any post explaining it."
                    },
                    {
                        "username": "fli033",
                        "content": "holycrap 1st time 1-try-accepted on a hard problem."
                    },
                    {
                        "username": "shrined",
                        "content": "Yeah this would be the type of hard for that to happen because it seems mislabeled. "
                    },
                    {
                        "username": "totorstan",
                        "content": "The problem is almost the same as this medium: https://leetcode.com/problems/longest-non-decreasing-subarray-from-two-arrays/"
                    },
                    {
                        "username": "Sergei_Gusev",
                        "content": "People, please VOTE for this PETITION to save OLD Study Plans: https://leetcode.com/discuss/feedback/3832685/petition-dont-kick-off-old-study-plans-we-love-it"
                    },
                    {
                        "username": "NicholasCG",
                        "content": "This feels like a pretty standard dp medium."
                    },
                    {
                        "username": "ChenxiLu",
                        "content": "Probably just a medium level problem. Though it could be easy to get the transition states wrong if not careful."
                    }
                ]
            },
            {
                "id": 2002688,
                "content": [
                    {
                        "username": "praneeth029",
                        "content": "Relatively easy compared to other LC Hard problems.\\nCan make it medium."
                    },
                    {
                        "username": "as9vd2",
                        "content": "What confused the shit out of me was the fact that the paths in the picture don\\'t necessarily match whichever array had the minimum value up to that point."
                    },
                    {
                        "username": "vijaysince89",
                        "content": "Even I see the first Example picture does not match with the output. Can you please explain, if you understand the first example ?"
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "I think this is better to be labeled as a medium question"
                    },
                    {
                        "username": "ylilarry",
                        "content": "Isn\\'t the description wrong? \"regular[i] describes the cost it takes to go from stop i - 1 to stop i using the regular route\" - it should be regular[i-1] instead."
                    },
                    {
                        "username": "JerryXie96",
                        "content": "yep. the description of the returning list is also wrong. should be costs[i-1]."
                    },
                    {
                        "username": "deleted_user",
                        "content": "Yes, description seems wrong. Otherwise the example is wrong. "
                    },
                    {
                        "username": "willq1",
                        "content": "I was wondering if someone would mind explaining to me why for example 1, the following answer would not be valid?\n[1, 11, 14, 19]\nregular = [1,6,9,5], express = [5,2,3,10], expressCost = 8\n\nYou take the regular transit. (1) [1]\nYou switch and take the express. (1 + 2 + 8) [1, 11]\nYou take the express to the next stop. (1 + 2 + 8 + 3) [1, 11, 14]\nYou take the regular to the next stop. (1 + 2 + 8 + 3 + 5) [1, 11, 14, 19]"
                    },
                    {
                        "username": "vijaysince89",
                        "content": "I\\'m wondering the same for a long time. But I don\\'t see any post explaining it."
                    },
                    {
                        "username": "fli033",
                        "content": "holycrap 1st time 1-try-accepted on a hard problem."
                    },
                    {
                        "username": "shrined",
                        "content": "Yeah this would be the type of hard for that to happen because it seems mislabeled. "
                    },
                    {
                        "username": "totorstan",
                        "content": "The problem is almost the same as this medium: https://leetcode.com/problems/longest-non-decreasing-subarray-from-two-arrays/"
                    },
                    {
                        "username": "Sergei_Gusev",
                        "content": "People, please VOTE for this PETITION to save OLD Study Plans: https://leetcode.com/discuss/feedback/3832685/petition-dont-kick-off-old-study-plans-we-love-it"
                    },
                    {
                        "username": "NicholasCG",
                        "content": "This feels like a pretty standard dp medium."
                    },
                    {
                        "username": "ChenxiLu",
                        "content": "Probably just a medium level problem. Though it could be easy to get the transition states wrong if not careful."
                    }
                ]
            },
            {
                "id": 2001863,
                "content": [
                    {
                        "username": "praneeth029",
                        "content": "Relatively easy compared to other LC Hard problems.\\nCan make it medium."
                    },
                    {
                        "username": "as9vd2",
                        "content": "What confused the shit out of me was the fact that the paths in the picture don\\'t necessarily match whichever array had the minimum value up to that point."
                    },
                    {
                        "username": "vijaysince89",
                        "content": "Even I see the first Example picture does not match with the output. Can you please explain, if you understand the first example ?"
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "I think this is better to be labeled as a medium question"
                    },
                    {
                        "username": "ylilarry",
                        "content": "Isn\\'t the description wrong? \"regular[i] describes the cost it takes to go from stop i - 1 to stop i using the regular route\" - it should be regular[i-1] instead."
                    },
                    {
                        "username": "JerryXie96",
                        "content": "yep. the description of the returning list is also wrong. should be costs[i-1]."
                    },
                    {
                        "username": "deleted_user",
                        "content": "Yes, description seems wrong. Otherwise the example is wrong. "
                    },
                    {
                        "username": "willq1",
                        "content": "I was wondering if someone would mind explaining to me why for example 1, the following answer would not be valid?\n[1, 11, 14, 19]\nregular = [1,6,9,5], express = [5,2,3,10], expressCost = 8\n\nYou take the regular transit. (1) [1]\nYou switch and take the express. (1 + 2 + 8) [1, 11]\nYou take the express to the next stop. (1 + 2 + 8 + 3) [1, 11, 14]\nYou take the regular to the next stop. (1 + 2 + 8 + 3 + 5) [1, 11, 14, 19]"
                    },
                    {
                        "username": "vijaysince89",
                        "content": "I\\'m wondering the same for a long time. But I don\\'t see any post explaining it."
                    },
                    {
                        "username": "fli033",
                        "content": "holycrap 1st time 1-try-accepted on a hard problem."
                    },
                    {
                        "username": "shrined",
                        "content": "Yeah this would be the type of hard for that to happen because it seems mislabeled. "
                    },
                    {
                        "username": "totorstan",
                        "content": "The problem is almost the same as this medium: https://leetcode.com/problems/longest-non-decreasing-subarray-from-two-arrays/"
                    },
                    {
                        "username": "Sergei_Gusev",
                        "content": "People, please VOTE for this PETITION to save OLD Study Plans: https://leetcode.com/discuss/feedback/3832685/petition-dont-kick-off-old-study-plans-we-love-it"
                    },
                    {
                        "username": "NicholasCG",
                        "content": "This feels like a pretty standard dp medium."
                    },
                    {
                        "username": "ChenxiLu",
                        "content": "Probably just a medium level problem. Though it could be easy to get the transition states wrong if not careful."
                    }
                ]
            },
            {
                "id": 2001569,
                "content": [
                    {
                        "username": "praneeth029",
                        "content": "Relatively easy compared to other LC Hard problems.\\nCan make it medium."
                    },
                    {
                        "username": "as9vd2",
                        "content": "What confused the shit out of me was the fact that the paths in the picture don\\'t necessarily match whichever array had the minimum value up to that point."
                    },
                    {
                        "username": "vijaysince89",
                        "content": "Even I see the first Example picture does not match with the output. Can you please explain, if you understand the first example ?"
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "I think this is better to be labeled as a medium question"
                    },
                    {
                        "username": "ylilarry",
                        "content": "Isn\\'t the description wrong? \"regular[i] describes the cost it takes to go from stop i - 1 to stop i using the regular route\" - it should be regular[i-1] instead."
                    },
                    {
                        "username": "JerryXie96",
                        "content": "yep. the description of the returning list is also wrong. should be costs[i-1]."
                    },
                    {
                        "username": "deleted_user",
                        "content": "Yes, description seems wrong. Otherwise the example is wrong. "
                    },
                    {
                        "username": "willq1",
                        "content": "I was wondering if someone would mind explaining to me why for example 1, the following answer would not be valid?\n[1, 11, 14, 19]\nregular = [1,6,9,5], express = [5,2,3,10], expressCost = 8\n\nYou take the regular transit. (1) [1]\nYou switch and take the express. (1 + 2 + 8) [1, 11]\nYou take the express to the next stop. (1 + 2 + 8 + 3) [1, 11, 14]\nYou take the regular to the next stop. (1 + 2 + 8 + 3 + 5) [1, 11, 14, 19]"
                    },
                    {
                        "username": "vijaysince89",
                        "content": "I\\'m wondering the same for a long time. But I don\\'t see any post explaining it."
                    },
                    {
                        "username": "fli033",
                        "content": "holycrap 1st time 1-try-accepted on a hard problem."
                    },
                    {
                        "username": "shrined",
                        "content": "Yeah this would be the type of hard for that to happen because it seems mislabeled. "
                    },
                    {
                        "username": "totorstan",
                        "content": "The problem is almost the same as this medium: https://leetcode.com/problems/longest-non-decreasing-subarray-from-two-arrays/"
                    },
                    {
                        "username": "Sergei_Gusev",
                        "content": "People, please VOTE for this PETITION to save OLD Study Plans: https://leetcode.com/discuss/feedback/3832685/petition-dont-kick-off-old-study-plans-we-love-it"
                    },
                    {
                        "username": "NicholasCG",
                        "content": "This feels like a pretty standard dp medium."
                    },
                    {
                        "username": "ChenxiLu",
                        "content": "Probably just a medium level problem. Though it could be easy to get the transition states wrong if not careful."
                    }
                ]
            },
            {
                "id": 1720927,
                "content": [
                    {
                        "username": "praneeth029",
                        "content": "Relatively easy compared to other LC Hard problems.\\nCan make it medium."
                    },
                    {
                        "username": "as9vd2",
                        "content": "What confused the shit out of me was the fact that the paths in the picture don\\'t necessarily match whichever array had the minimum value up to that point."
                    },
                    {
                        "username": "vijaysince89",
                        "content": "Even I see the first Example picture does not match with the output. Can you please explain, if you understand the first example ?"
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "I think this is better to be labeled as a medium question"
                    },
                    {
                        "username": "ylilarry",
                        "content": "Isn\\'t the description wrong? \"regular[i] describes the cost it takes to go from stop i - 1 to stop i using the regular route\" - it should be regular[i-1] instead."
                    },
                    {
                        "username": "JerryXie96",
                        "content": "yep. the description of the returning list is also wrong. should be costs[i-1]."
                    },
                    {
                        "username": "deleted_user",
                        "content": "Yes, description seems wrong. Otherwise the example is wrong. "
                    },
                    {
                        "username": "willq1",
                        "content": "I was wondering if someone would mind explaining to me why for example 1, the following answer would not be valid?\n[1, 11, 14, 19]\nregular = [1,6,9,5], express = [5,2,3,10], expressCost = 8\n\nYou take the regular transit. (1) [1]\nYou switch and take the express. (1 + 2 + 8) [1, 11]\nYou take the express to the next stop. (1 + 2 + 8 + 3) [1, 11, 14]\nYou take the regular to the next stop. (1 + 2 + 8 + 3 + 5) [1, 11, 14, 19]"
                    },
                    {
                        "username": "vijaysince89",
                        "content": "I\\'m wondering the same for a long time. But I don\\'t see any post explaining it."
                    },
                    {
                        "username": "fli033",
                        "content": "holycrap 1st time 1-try-accepted on a hard problem."
                    },
                    {
                        "username": "shrined",
                        "content": "Yeah this would be the type of hard for that to happen because it seems mislabeled. "
                    },
                    {
                        "username": "totorstan",
                        "content": "The problem is almost the same as this medium: https://leetcode.com/problems/longest-non-decreasing-subarray-from-two-arrays/"
                    },
                    {
                        "username": "Sergei_Gusev",
                        "content": "People, please VOTE for this PETITION to save OLD Study Plans: https://leetcode.com/discuss/feedback/3832685/petition-dont-kick-off-old-study-plans-we-love-it"
                    },
                    {
                        "username": "NicholasCG",
                        "content": "This feels like a pretty standard dp medium."
                    },
                    {
                        "username": "ChenxiLu",
                        "content": "Probably just a medium level problem. Though it could be easy to get the transition states wrong if not careful."
                    }
                ]
            },
            {
                "id": 1825355,
                "content": [
                    {
                        "username": "praneeth029",
                        "content": "Relatively easy compared to other LC Hard problems.\\nCan make it medium."
                    },
                    {
                        "username": "as9vd2",
                        "content": "What confused the shit out of me was the fact that the paths in the picture don\\'t necessarily match whichever array had the minimum value up to that point."
                    },
                    {
                        "username": "vijaysince89",
                        "content": "Even I see the first Example picture does not match with the output. Can you please explain, if you understand the first example ?"
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "I think this is better to be labeled as a medium question"
                    },
                    {
                        "username": "ylilarry",
                        "content": "Isn\\'t the description wrong? \"regular[i] describes the cost it takes to go from stop i - 1 to stop i using the regular route\" - it should be regular[i-1] instead."
                    },
                    {
                        "username": "JerryXie96",
                        "content": "yep. the description of the returning list is also wrong. should be costs[i-1]."
                    },
                    {
                        "username": "deleted_user",
                        "content": "Yes, description seems wrong. Otherwise the example is wrong. "
                    },
                    {
                        "username": "willq1",
                        "content": "I was wondering if someone would mind explaining to me why for example 1, the following answer would not be valid?\n[1, 11, 14, 19]\nregular = [1,6,9,5], express = [5,2,3,10], expressCost = 8\n\nYou take the regular transit. (1) [1]\nYou switch and take the express. (1 + 2 + 8) [1, 11]\nYou take the express to the next stop. (1 + 2 + 8 + 3) [1, 11, 14]\nYou take the regular to the next stop. (1 + 2 + 8 + 3 + 5) [1, 11, 14, 19]"
                    },
                    {
                        "username": "vijaysince89",
                        "content": "I\\'m wondering the same for a long time. But I don\\'t see any post explaining it."
                    },
                    {
                        "username": "fli033",
                        "content": "holycrap 1st time 1-try-accepted on a hard problem."
                    },
                    {
                        "username": "shrined",
                        "content": "Yeah this would be the type of hard for that to happen because it seems mislabeled. "
                    },
                    {
                        "username": "totorstan",
                        "content": "The problem is almost the same as this medium: https://leetcode.com/problems/longest-non-decreasing-subarray-from-two-arrays/"
                    },
                    {
                        "username": "Sergei_Gusev",
                        "content": "People, please VOTE for this PETITION to save OLD Study Plans: https://leetcode.com/discuss/feedback/3832685/petition-dont-kick-off-old-study-plans-we-love-it"
                    },
                    {
                        "username": "NicholasCG",
                        "content": "This feels like a pretty standard dp medium."
                    },
                    {
                        "username": "ChenxiLu",
                        "content": "Probably just a medium level problem. Though it could be easy to get the transition states wrong if not careful."
                    }
                ]
            },
            {
                "id": 1995181,
                "content": [
                    {
                        "username": "praneeth029",
                        "content": "Relatively easy compared to other LC Hard problems.\\nCan make it medium."
                    },
                    {
                        "username": "as9vd2",
                        "content": "What confused the shit out of me was the fact that the paths in the picture don\\'t necessarily match whichever array had the minimum value up to that point."
                    },
                    {
                        "username": "vijaysince89",
                        "content": "Even I see the first Example picture does not match with the output. Can you please explain, if you understand the first example ?"
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "I think this is better to be labeled as a medium question"
                    },
                    {
                        "username": "ylilarry",
                        "content": "Isn\\'t the description wrong? \"regular[i] describes the cost it takes to go from stop i - 1 to stop i using the regular route\" - it should be regular[i-1] instead."
                    },
                    {
                        "username": "JerryXie96",
                        "content": "yep. the description of the returning list is also wrong. should be costs[i-1]."
                    },
                    {
                        "username": "deleted_user",
                        "content": "Yes, description seems wrong. Otherwise the example is wrong. "
                    },
                    {
                        "username": "willq1",
                        "content": "I was wondering if someone would mind explaining to me why for example 1, the following answer would not be valid?\n[1, 11, 14, 19]\nregular = [1,6,9,5], express = [5,2,3,10], expressCost = 8\n\nYou take the regular transit. (1) [1]\nYou switch and take the express. (1 + 2 + 8) [1, 11]\nYou take the express to the next stop. (1 + 2 + 8 + 3) [1, 11, 14]\nYou take the regular to the next stop. (1 + 2 + 8 + 3 + 5) [1, 11, 14, 19]"
                    },
                    {
                        "username": "vijaysince89",
                        "content": "I\\'m wondering the same for a long time. But I don\\'t see any post explaining it."
                    },
                    {
                        "username": "fli033",
                        "content": "holycrap 1st time 1-try-accepted on a hard problem."
                    },
                    {
                        "username": "shrined",
                        "content": "Yeah this would be the type of hard for that to happen because it seems mislabeled. "
                    },
                    {
                        "username": "totorstan",
                        "content": "The problem is almost the same as this medium: https://leetcode.com/problems/longest-non-decreasing-subarray-from-two-arrays/"
                    },
                    {
                        "username": "Sergei_Gusev",
                        "content": "People, please VOTE for this PETITION to save OLD Study Plans: https://leetcode.com/discuss/feedback/3832685/petition-dont-kick-off-old-study-plans-we-love-it"
                    },
                    {
                        "username": "NicholasCG",
                        "content": "This feels like a pretty standard dp medium."
                    },
                    {
                        "username": "ChenxiLu",
                        "content": "Probably just a medium level problem. Though it could be easy to get the transition states wrong if not careful."
                    }
                ]
            },
            {
                "id": 1735943,
                "content": [
                    {
                        "username": "praneeth029",
                        "content": "Relatively easy compared to other LC Hard problems.\\nCan make it medium."
                    },
                    {
                        "username": "as9vd2",
                        "content": "What confused the shit out of me was the fact that the paths in the picture don\\'t necessarily match whichever array had the minimum value up to that point."
                    },
                    {
                        "username": "vijaysince89",
                        "content": "Even I see the first Example picture does not match with the output. Can you please explain, if you understand the first example ?"
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "I think this is better to be labeled as a medium question"
                    },
                    {
                        "username": "ylilarry",
                        "content": "Isn\\'t the description wrong? \"regular[i] describes the cost it takes to go from stop i - 1 to stop i using the regular route\" - it should be regular[i-1] instead."
                    },
                    {
                        "username": "JerryXie96",
                        "content": "yep. the description of the returning list is also wrong. should be costs[i-1]."
                    },
                    {
                        "username": "deleted_user",
                        "content": "Yes, description seems wrong. Otherwise the example is wrong. "
                    },
                    {
                        "username": "willq1",
                        "content": "I was wondering if someone would mind explaining to me why for example 1, the following answer would not be valid?\n[1, 11, 14, 19]\nregular = [1,6,9,5], express = [5,2,3,10], expressCost = 8\n\nYou take the regular transit. (1) [1]\nYou switch and take the express. (1 + 2 + 8) [1, 11]\nYou take the express to the next stop. (1 + 2 + 8 + 3) [1, 11, 14]\nYou take the regular to the next stop. (1 + 2 + 8 + 3 + 5) [1, 11, 14, 19]"
                    },
                    {
                        "username": "vijaysince89",
                        "content": "I\\'m wondering the same for a long time. But I don\\'t see any post explaining it."
                    },
                    {
                        "username": "fli033",
                        "content": "holycrap 1st time 1-try-accepted on a hard problem."
                    },
                    {
                        "username": "shrined",
                        "content": "Yeah this would be the type of hard for that to happen because it seems mislabeled. "
                    },
                    {
                        "username": "totorstan",
                        "content": "The problem is almost the same as this medium: https://leetcode.com/problems/longest-non-decreasing-subarray-from-two-arrays/"
                    },
                    {
                        "username": "Sergei_Gusev",
                        "content": "People, please VOTE for this PETITION to save OLD Study Plans: https://leetcode.com/discuss/feedback/3832685/petition-dont-kick-off-old-study-plans-we-love-it"
                    },
                    {
                        "username": "NicholasCG",
                        "content": "This feels like a pretty standard dp medium."
                    },
                    {
                        "username": "ChenxiLu",
                        "content": "Probably just a medium level problem. Though it could be easy to get the transition states wrong if not careful."
                    }
                ]
            },
            {
                "id": 2015726,
                "content": [
                    {
                        "username": "praneeth029",
                        "content": "Relatively easy compared to other LC Hard problems.\\nCan make it medium."
                    },
                    {
                        "username": "as9vd2",
                        "content": "What confused the shit out of me was the fact that the paths in the picture don\\'t necessarily match whichever array had the minimum value up to that point."
                    },
                    {
                        "username": "vijaysince89",
                        "content": "Even I see the first Example picture does not match with the output. Can you please explain, if you understand the first example ?"
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "I think this is better to be labeled as a medium question"
                    },
                    {
                        "username": "ylilarry",
                        "content": "Isn\\'t the description wrong? \"regular[i] describes the cost it takes to go from stop i - 1 to stop i using the regular route\" - it should be regular[i-1] instead."
                    },
                    {
                        "username": "JerryXie96",
                        "content": "yep. the description of the returning list is also wrong. should be costs[i-1]."
                    },
                    {
                        "username": "deleted_user",
                        "content": "Yes, description seems wrong. Otherwise the example is wrong. "
                    },
                    {
                        "username": "willq1",
                        "content": "I was wondering if someone would mind explaining to me why for example 1, the following answer would not be valid?\n[1, 11, 14, 19]\nregular = [1,6,9,5], express = [5,2,3,10], expressCost = 8\n\nYou take the regular transit. (1) [1]\nYou switch and take the express. (1 + 2 + 8) [1, 11]\nYou take the express to the next stop. (1 + 2 + 8 + 3) [1, 11, 14]\nYou take the regular to the next stop. (1 + 2 + 8 + 3 + 5) [1, 11, 14, 19]"
                    },
                    {
                        "username": "vijaysince89",
                        "content": "I\\'m wondering the same for a long time. But I don\\'t see any post explaining it."
                    },
                    {
                        "username": "fli033",
                        "content": "holycrap 1st time 1-try-accepted on a hard problem."
                    },
                    {
                        "username": "shrined",
                        "content": "Yeah this would be the type of hard for that to happen because it seems mislabeled. "
                    },
                    {
                        "username": "totorstan",
                        "content": "The problem is almost the same as this medium: https://leetcode.com/problems/longest-non-decreasing-subarray-from-two-arrays/"
                    },
                    {
                        "username": "Sergei_Gusev",
                        "content": "People, please VOTE for this PETITION to save OLD Study Plans: https://leetcode.com/discuss/feedback/3832685/petition-dont-kick-off-old-study-plans-we-love-it"
                    },
                    {
                        "username": "NicholasCG",
                        "content": "This feels like a pretty standard dp medium."
                    },
                    {
                        "username": "ChenxiLu",
                        "content": "Probably just a medium level problem. Though it could be easy to get the transition states wrong if not careful."
                    }
                ]
            },
            {
                "id": 1995147,
                "content": [
                    {
                        "username": "praneeth029",
                        "content": "Relatively easy compared to other LC Hard problems.\\nCan make it medium."
                    },
                    {
                        "username": "as9vd2",
                        "content": "What confused the shit out of me was the fact that the paths in the picture don\\'t necessarily match whichever array had the minimum value up to that point."
                    },
                    {
                        "username": "vijaysince89",
                        "content": "Even I see the first Example picture does not match with the output. Can you please explain, if you understand the first example ?"
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "I think this is better to be labeled as a medium question"
                    },
                    {
                        "username": "ylilarry",
                        "content": "Isn\\'t the description wrong? \"regular[i] describes the cost it takes to go from stop i - 1 to stop i using the regular route\" - it should be regular[i-1] instead."
                    },
                    {
                        "username": "JerryXie96",
                        "content": "yep. the description of the returning list is also wrong. should be costs[i-1]."
                    },
                    {
                        "username": "deleted_user",
                        "content": "Yes, description seems wrong. Otherwise the example is wrong. "
                    },
                    {
                        "username": "willq1",
                        "content": "I was wondering if someone would mind explaining to me why for example 1, the following answer would not be valid?\n[1, 11, 14, 19]\nregular = [1,6,9,5], express = [5,2,3,10], expressCost = 8\n\nYou take the regular transit. (1) [1]\nYou switch and take the express. (1 + 2 + 8) [1, 11]\nYou take the express to the next stop. (1 + 2 + 8 + 3) [1, 11, 14]\nYou take the regular to the next stop. (1 + 2 + 8 + 3 + 5) [1, 11, 14, 19]"
                    },
                    {
                        "username": "vijaysince89",
                        "content": "I\\'m wondering the same for a long time. But I don\\'t see any post explaining it."
                    },
                    {
                        "username": "fli033",
                        "content": "holycrap 1st time 1-try-accepted on a hard problem."
                    },
                    {
                        "username": "shrined",
                        "content": "Yeah this would be the type of hard for that to happen because it seems mislabeled. "
                    },
                    {
                        "username": "totorstan",
                        "content": "The problem is almost the same as this medium: https://leetcode.com/problems/longest-non-decreasing-subarray-from-two-arrays/"
                    },
                    {
                        "username": "Sergei_Gusev",
                        "content": "People, please VOTE for this PETITION to save OLD Study Plans: https://leetcode.com/discuss/feedback/3832685/petition-dont-kick-off-old-study-plans-we-love-it"
                    },
                    {
                        "username": "NicholasCG",
                        "content": "This feels like a pretty standard dp medium."
                    },
                    {
                        "username": "ChenxiLu",
                        "content": "Probably just a medium level problem. Though it could be easy to get the transition states wrong if not careful."
                    }
                ]
            },
            {
                "id": 2004302,
                "content": [
                    {
                        "username": "praneeth029",
                        "content": "Relatively easy compared to other LC Hard problems.\\nCan make it medium."
                    },
                    {
                        "username": "as9vd2",
                        "content": "What confused the shit out of me was the fact that the paths in the picture don\\'t necessarily match whichever array had the minimum value up to that point."
                    },
                    {
                        "username": "vijaysince89",
                        "content": "Even I see the first Example picture does not match with the output. Can you please explain, if you understand the first example ?"
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "I think this is better to be labeled as a medium question"
                    },
                    {
                        "username": "ylilarry",
                        "content": "Isn\\'t the description wrong? \"regular[i] describes the cost it takes to go from stop i - 1 to stop i using the regular route\" - it should be regular[i-1] instead."
                    },
                    {
                        "username": "JerryXie96",
                        "content": "yep. the description of the returning list is also wrong. should be costs[i-1]."
                    },
                    {
                        "username": "deleted_user",
                        "content": "Yes, description seems wrong. Otherwise the example is wrong. "
                    },
                    {
                        "username": "willq1",
                        "content": "I was wondering if someone would mind explaining to me why for example 1, the following answer would not be valid?\n[1, 11, 14, 19]\nregular = [1,6,9,5], express = [5,2,3,10], expressCost = 8\n\nYou take the regular transit. (1) [1]\nYou switch and take the express. (1 + 2 + 8) [1, 11]\nYou take the express to the next stop. (1 + 2 + 8 + 3) [1, 11, 14]\nYou take the regular to the next stop. (1 + 2 + 8 + 3 + 5) [1, 11, 14, 19]"
                    },
                    {
                        "username": "vijaysince89",
                        "content": "I\\'m wondering the same for a long time. But I don\\'t see any post explaining it."
                    },
                    {
                        "username": "fli033",
                        "content": "holycrap 1st time 1-try-accepted on a hard problem."
                    },
                    {
                        "username": "shrined",
                        "content": "Yeah this would be the type of hard for that to happen because it seems mislabeled. "
                    },
                    {
                        "username": "totorstan",
                        "content": "The problem is almost the same as this medium: https://leetcode.com/problems/longest-non-decreasing-subarray-from-two-arrays/"
                    },
                    {
                        "username": "Sergei_Gusev",
                        "content": "People, please VOTE for this PETITION to save OLD Study Plans: https://leetcode.com/discuss/feedback/3832685/petition-dont-kick-off-old-study-plans-we-love-it"
                    },
                    {
                        "username": "NicholasCG",
                        "content": "This feels like a pretty standard dp medium."
                    },
                    {
                        "username": "ChenxiLu",
                        "content": "Probably just a medium level problem. Though it could be easy to get the transition states wrong if not careful."
                    }
                ]
            },
            {
                "id": 2002688,
                "content": [
                    {
                        "username": "praneeth029",
                        "content": "Relatively easy compared to other LC Hard problems.\\nCan make it medium."
                    },
                    {
                        "username": "as9vd2",
                        "content": "What confused the shit out of me was the fact that the paths in the picture don\\'t necessarily match whichever array had the minimum value up to that point."
                    },
                    {
                        "username": "vijaysince89",
                        "content": "Even I see the first Example picture does not match with the output. Can you please explain, if you understand the first example ?"
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "I think this is better to be labeled as a medium question"
                    },
                    {
                        "username": "ylilarry",
                        "content": "Isn\\'t the description wrong? \"regular[i] describes the cost it takes to go from stop i - 1 to stop i using the regular route\" - it should be regular[i-1] instead."
                    },
                    {
                        "username": "JerryXie96",
                        "content": "yep. the description of the returning list is also wrong. should be costs[i-1]."
                    },
                    {
                        "username": "deleted_user",
                        "content": "Yes, description seems wrong. Otherwise the example is wrong. "
                    },
                    {
                        "username": "willq1",
                        "content": "I was wondering if someone would mind explaining to me why for example 1, the following answer would not be valid?\n[1, 11, 14, 19]\nregular = [1,6,9,5], express = [5,2,3,10], expressCost = 8\n\nYou take the regular transit. (1) [1]\nYou switch and take the express. (1 + 2 + 8) [1, 11]\nYou take the express to the next stop. (1 + 2 + 8 + 3) [1, 11, 14]\nYou take the regular to the next stop. (1 + 2 + 8 + 3 + 5) [1, 11, 14, 19]"
                    },
                    {
                        "username": "vijaysince89",
                        "content": "I\\'m wondering the same for a long time. But I don\\'t see any post explaining it."
                    },
                    {
                        "username": "fli033",
                        "content": "holycrap 1st time 1-try-accepted on a hard problem."
                    },
                    {
                        "username": "shrined",
                        "content": "Yeah this would be the type of hard for that to happen because it seems mislabeled. "
                    },
                    {
                        "username": "totorstan",
                        "content": "The problem is almost the same as this medium: https://leetcode.com/problems/longest-non-decreasing-subarray-from-two-arrays/"
                    },
                    {
                        "username": "Sergei_Gusev",
                        "content": "People, please VOTE for this PETITION to save OLD Study Plans: https://leetcode.com/discuss/feedback/3832685/petition-dont-kick-off-old-study-plans-we-love-it"
                    },
                    {
                        "username": "NicholasCG",
                        "content": "This feels like a pretty standard dp medium."
                    },
                    {
                        "username": "ChenxiLu",
                        "content": "Probably just a medium level problem. Though it could be easy to get the transition states wrong if not careful."
                    }
                ]
            },
            {
                "id": 2001863,
                "content": [
                    {
                        "username": "praneeth029",
                        "content": "Relatively easy compared to other LC Hard problems.\\nCan make it medium."
                    },
                    {
                        "username": "as9vd2",
                        "content": "What confused the shit out of me was the fact that the paths in the picture don\\'t necessarily match whichever array had the minimum value up to that point."
                    },
                    {
                        "username": "vijaysince89",
                        "content": "Even I see the first Example picture does not match with the output. Can you please explain, if you understand the first example ?"
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "I think this is better to be labeled as a medium question"
                    },
                    {
                        "username": "ylilarry",
                        "content": "Isn\\'t the description wrong? \"regular[i] describes the cost it takes to go from stop i - 1 to stop i using the regular route\" - it should be regular[i-1] instead."
                    },
                    {
                        "username": "JerryXie96",
                        "content": "yep. the description of the returning list is also wrong. should be costs[i-1]."
                    },
                    {
                        "username": "deleted_user",
                        "content": "Yes, description seems wrong. Otherwise the example is wrong. "
                    },
                    {
                        "username": "willq1",
                        "content": "I was wondering if someone would mind explaining to me why for example 1, the following answer would not be valid?\n[1, 11, 14, 19]\nregular = [1,6,9,5], express = [5,2,3,10], expressCost = 8\n\nYou take the regular transit. (1) [1]\nYou switch and take the express. (1 + 2 + 8) [1, 11]\nYou take the express to the next stop. (1 + 2 + 8 + 3) [1, 11, 14]\nYou take the regular to the next stop. (1 + 2 + 8 + 3 + 5) [1, 11, 14, 19]"
                    },
                    {
                        "username": "vijaysince89",
                        "content": "I\\'m wondering the same for a long time. But I don\\'t see any post explaining it."
                    },
                    {
                        "username": "fli033",
                        "content": "holycrap 1st time 1-try-accepted on a hard problem."
                    },
                    {
                        "username": "shrined",
                        "content": "Yeah this would be the type of hard for that to happen because it seems mislabeled. "
                    },
                    {
                        "username": "totorstan",
                        "content": "The problem is almost the same as this medium: https://leetcode.com/problems/longest-non-decreasing-subarray-from-two-arrays/"
                    },
                    {
                        "username": "Sergei_Gusev",
                        "content": "People, please VOTE for this PETITION to save OLD Study Plans: https://leetcode.com/discuss/feedback/3832685/petition-dont-kick-off-old-study-plans-we-love-it"
                    },
                    {
                        "username": "NicholasCG",
                        "content": "This feels like a pretty standard dp medium."
                    },
                    {
                        "username": "ChenxiLu",
                        "content": "Probably just a medium level problem. Though it could be easy to get the transition states wrong if not careful."
                    }
                ]
            },
            {
                "id": 2001569,
                "content": [
                    {
                        "username": "praneeth029",
                        "content": "Relatively easy compared to other LC Hard problems.\\nCan make it medium."
                    },
                    {
                        "username": "as9vd2",
                        "content": "What confused the shit out of me was the fact that the paths in the picture don\\'t necessarily match whichever array had the minimum value up to that point."
                    },
                    {
                        "username": "vijaysince89",
                        "content": "Even I see the first Example picture does not match with the output. Can you please explain, if you understand the first example ?"
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "I think this is better to be labeled as a medium question"
                    },
                    {
                        "username": "ylilarry",
                        "content": "Isn\\'t the description wrong? \"regular[i] describes the cost it takes to go from stop i - 1 to stop i using the regular route\" - it should be regular[i-1] instead."
                    },
                    {
                        "username": "JerryXie96",
                        "content": "yep. the description of the returning list is also wrong. should be costs[i-1]."
                    },
                    {
                        "username": "deleted_user",
                        "content": "Yes, description seems wrong. Otherwise the example is wrong. "
                    },
                    {
                        "username": "willq1",
                        "content": "I was wondering if someone would mind explaining to me why for example 1, the following answer would not be valid?\n[1, 11, 14, 19]\nregular = [1,6,9,5], express = [5,2,3,10], expressCost = 8\n\nYou take the regular transit. (1) [1]\nYou switch and take the express. (1 + 2 + 8) [1, 11]\nYou take the express to the next stop. (1 + 2 + 8 + 3) [1, 11, 14]\nYou take the regular to the next stop. (1 + 2 + 8 + 3 + 5) [1, 11, 14, 19]"
                    },
                    {
                        "username": "vijaysince89",
                        "content": "I\\'m wondering the same for a long time. But I don\\'t see any post explaining it."
                    },
                    {
                        "username": "fli033",
                        "content": "holycrap 1st time 1-try-accepted on a hard problem."
                    },
                    {
                        "username": "shrined",
                        "content": "Yeah this would be the type of hard for that to happen because it seems mislabeled. "
                    },
                    {
                        "username": "totorstan",
                        "content": "The problem is almost the same as this medium: https://leetcode.com/problems/longest-non-decreasing-subarray-from-two-arrays/"
                    },
                    {
                        "username": "Sergei_Gusev",
                        "content": "People, please VOTE for this PETITION to save OLD Study Plans: https://leetcode.com/discuss/feedback/3832685/petition-dont-kick-off-old-study-plans-we-love-it"
                    },
                    {
                        "username": "NicholasCG",
                        "content": "This feels like a pretty standard dp medium."
                    },
                    {
                        "username": "ChenxiLu",
                        "content": "Probably just a medium level problem. Though it could be easy to get the transition states wrong if not careful."
                    }
                ]
            }
        ]
    }
]