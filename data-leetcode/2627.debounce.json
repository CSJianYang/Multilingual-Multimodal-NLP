[
    {
        "title": "Debounce",
        "question_content": "Given a function&nbsp;fn and a time in milliseconds&nbsp;t, return&nbsp;a&nbsp;debounced&nbsp;version of that function.\nA&nbsp;debounced&nbsp;function is a function whose execution is delayed by&nbsp;t&nbsp;milliseconds and whose&nbsp;execution is cancelled if it is called again within that window of time. The debounced function should also receive the passed parameters.\nFor example, let's say&nbsp;t = 50ms, and the function was called at&nbsp;30ms,&nbsp;60ms, and 100ms. The first 2 function calls would be cancelled, and the 3rd function call would be executed at&nbsp;150ms. If instead&nbsp;t = 35ms, The 1st call would be cancelled, the 2nd would be executed at&nbsp;95ms, and the 3rd would be executed at&nbsp;135ms.\n\nThe above diagram&nbsp;shows how debounce will transform&nbsp;events. Each rectangle represents 100ms and the debounce time is 400ms. Each color represents a different set of inputs.\nPlease solve it without using lodash's&nbsp;_.debounce() function.\n&nbsp;\nExample 1:\n\nInput: \nt = 50\ncalls = [\n&nbsp; {\"t\": 50, inputs: [1]},\n&nbsp; {\"t\": 75, inputs: [2]}\n]\nOutput: [{\"t\": 125, inputs: [2]}]\nExplanation:\nlet start = Date.now();\nfunction log(...inputs) { \n&nbsp; console.log([Date.now() - start, inputs ])\n}\nconst dlog = debounce(log, 50);\nsetTimeout(() => dlog(1), 50);\nsetTimeout(() => dlog(2), 75);\nThe 1st call is cancelled by the 2nd call because the 2nd call occurred before 100ms\nThe 2nd call is delayed by 50ms and executed at 125ms. The inputs were (2).\n\nExample 2:\n\nInput: \nt = 20\ncalls = [\n&nbsp; {\"t\": 50, inputs: [1]},\n&nbsp; {\"t\": 100, inputs: [2]}\n]\nOutput: [{\"t\": 70, inputs: [1]}, {\"t\": 120, inputs: [2]}]\nExplanation:\nThe 1st call is delayed until 70ms. The inputs were (1).\nThe 2nd call is delayed until 120ms. The inputs were (2).\n\nExample 3:\n\nInput: \nt = 150\ncalls = [\n&nbsp; {\"t\": 50, inputs: [1, 2]},\n&nbsp; {\"t\": 300, inputs: [3, 4]},\n&nbsp; {\"t\": 300, inputs: [5, 6]}\n]\nOutput: [{\"t\": 200, inputs: [1,2]}, {\"t\": 450, inputs: [5, 6]}]\nExplanation:\nThe 1st call is delayed by 150ms and ran at 200ms. The inputs were (1, 2).\nThe 2nd call is cancelled by the 3rd call\nThe 3rd call is delayed by 150ms and ran at 450ms. The inputs were (5, 6).\n\n&nbsp;\nConstraints:\n\n\t0 <= t <= 1000\n\t1 <= calls.length <= 10\n\t0 <= calls[i].t <= 1000\n\t0 <= calls[i].inputs.length <= 10",
        "solutions": [
            {
                "id": 3416731,
                "title": "easiest-explanation-with-codesandbox-example-closure-settimeout-beats-99",
                "content": "# Why to use Debouncing?\\n\\nHave you ever encountered a situation where a function gets called multiple times within a short amount of time, leading to performance issues or unexpected behavior? This is a common problem in JavaScript, especially when working with events like scrolling, resizing, or typing.\\n\\nFortunately, there\\'s a simple technique called \"debouncing\" that can help you control the frequency of function calls and avoid these issues.\\n\\n# What is Debouncing?\\n\\nDebouncing is a method that limits the rate at which a function gets called. It works by delaying the execution of a function until a certain amount of time has passed without any additional function calls. If another function call happens within this time frame, the timer resets and the function execution is delayed again.\\n\\n- Debouncing is useful in situations where you want to prevent a function from being called too frequently, such as:\\n\\n- Handling user input events like keypresses, mouse movements, or button clicks\\n- Handling expensive computations or network requests that don\\'t need to be performed on every function call\\n\\n[Try it out on Codesandbox](https://codesandbox.io/s/debounce-example-zccfci)\\n\\n![1_-r8hP_iDBPrj-odjIZajzw.gif](https://assets.leetcode.com/users/images/47fbf3cb-9556-4833-8025-d6e706a807cd_1684032775.2844126.gif)\\n\\n\\n# Intuition and Approach\\n<!-- Describe your approach to solving the problem. -->\\n- debounce takes two arguments: `fn` and `t`.\\n- `fn` is the function that you want to debounce.\\n- `t` is the amount of time you want to wait before executing `fn` after the last time it was called.\\n- The `debounce` function returns a new function that takes any number of arguments (`...args`).\\n- Within the returned function, a timer is set using `setTimeout`. The timer is initially set to `t` milliseconds.\\n- Every time the returned function is called, the `clearTimeout` function is called to reset the timer to `t` milliseconds.\\n- Once the timer has elapsed without the returned function being called again, the timer\\'s callback function is executed. The callback function calls `fn` with the arguments that were passed to the returned function.\\n- The `debounce` function returns the new function that was created in step 2.\\n\\nIn simpler terms, the debounce function creates a new function that can only be executed after a certain amount of time has passed without it being called again. This is achieved by creating a timer that is reset every time the debounced function is called. Once the timer has elapsed without the debounced function being called again, the function is executed. This is useful when you want to limit the frequency of some expensive operation, such as making an HTTP request or rendering a large number of elements on a page.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the debounce function is constant, $$O(1)$$, since it performs a constant number of operations (setting and clearing a timer).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nThe space complexity of the debounce function is also constant, $$O(1)$$, since it only uses a fixed amount of memory to store the timer variable.\\n\\n\\n<img src=\"https://assets.leetcode.com/users/images/b93dcc50-7e19-44d3-80ec-c41558d719ba_1684043630.2104852.png\" width=\"50%\">\\n\\n\\n# Code\\n```javascript []\\nvar debounce = function(fn, t = 1000) {\\n    let timer;\\n    return function(...args) {\\n        clearTimeout(timer);\\n        timer = setTimeout(() => fn(...args), t);\\n    }\\n};\\n```\\n```typescript []\\ntype F = (...p: any[]) => any\\n\\nfunction debounce(fn: F, t: number): F {\\n    let timer : ReturnType<typeof setTimeout>;\\n    return function(...args) {\\n        clearTimeout(timer);\\n        timer = setTimeout(() => fn(...args), t);\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```javascript []\\nvar debounce = function(fn, t = 1000) {\\n    let timer;\\n    return function(...args) {\\n        clearTimeout(timer);\\n        timer = setTimeout(() => fn(...args), t);\\n    }\\n};\\n```\n```typescript []\\ntype F = (...p: any[]) => any\\n\\nfunction debounce(fn: F, t: number): F {\\n    let timer : ReturnType<typeof setTimeout>;\\n    return function(...args) {\\n        clearTimeout(timer);\\n        timer = setTimeout(() => fn(...args), t);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3409008,
                "title": "vanilla-js-solution-using-settimeout-and-cleartimeout",
                "content": "# Intuition\\nCalling debounce returns a function, in this case a wrapper around the input `fn`. Calling this wrapper should initiate the timeout, with a reference to a previous call stored in the parent closure. Destructuring `args` allows your method to remain agnostic to the input of subsequent calls.\\n\\n# Approach\\n1. Return a function wrapping a call the the input function `fn`\\n2. Within that function, call `setTimeout` to defer execution by `t` milliseconds\\n3. Store the return from `setTimeout` in a variable scoped to the parent closure. This is used to cancel previous timeouts which have not completed.\\n\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    let timeout = null\\n    return (...args) => {\\n        clearTimeout(timeout)\\n        timeout = setTimeout(fn, t, ...args)\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    let timeout = null\\n    return (...args) => {\\n        clearTimeout(timeout)\\n        timeout = setTimeout(fn, t, ...args)\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3540468,
                "title": "debounce-function-detailed-explanation",
                "content": "### \\u2705\\u2705\\uD83D\\uDD1D\\uD83D\\uDD1DPlease Upvote if you find this helpful. \\uD83D\\uDD1D\\uD83D\\uDD1D\\u2705\\u2705\\n\\n\\n1. The `debounce` function, according to the problem statement, accepts two parameters: `fn` (the original function to be debounced) and `t` (the debounce time in milliseconds).\\n2. A variable `timeoutId` is declared inside the `debounce` function to keep track of the debounce timer.\\n3. The `debounce` function returns an arrow function representing the original function\\'s debounced version. Using the rest parameter syntax `...args`, this arrow function accepts any number of arguments.\\n4. When the debounced function is called, it first clears any previously scheduled execution of the original function by calling `clearTimeout` with the `timeoutId` variable.\\n5. A new debounce timer is set using `setTimeout`. The `setTimeout` function takes a callback function and a delay time. In this case, the callback function is an arrow function that will invoke the original function (`fn`) and pass it the captured arguments (`args`). The delay time is `t`, which represents the debounce time.\\n6. The `timeoutId` is updated with the identifier of the new debounce timer, allowing it to be cleared if the debounced function is called again before the debounce time elapses.\\n7. As a result, if the debounced function is called multiple times within the debounce time window, the timer is reset each time, and the original function will only be executed after a period of inactivity that exceeds the debounce time.\\n8. The debounce function returns the debounced version of the original function, which can be assigned to a variable and invoked as needed.\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nconst debounce = (fn, t) => {\\n  let timeoutId;\\n\\n  return (...args) => {\\n    clearTimeout(timeoutId);\\n\\n    timeoutId = setTimeout(() => {\\n      fn.apply(this, args);\\n    }, t);\\n  };\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nconst debounce = (fn, t) => {\\n  let timeoutId;\\n\\n  return (...args) => {\\n    clearTimeout(timeoutId);\\n\\n    timeoutId = setTimeout(() => {\\n      fn.apply(this, args);\\n    }, t);\\n  };\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3540531,
                "title": "day-6-o-1-o-9-commented-examples",
                "content": "The code you provided is an implementation of a debounce function in JavaScript. Debouncing is a technique used to limit the number of times a function is called within a certain time frame, typically used in scenarios where the function is triggered frequently (e.g., event handlers).\\n\\nHere\\'s how the code works:\\n\\n1. The `debounce` function takes two parameters: `fn` (the function to be debounced) and `t` (the debounce time, in milliseconds).\\n\\n2. Inside the `debounce` function, a variable named `temp` is declared. This variable will store a reference to the timer used for debouncing.\\n\\n3. The `debounce` function returns an anonymous function (a closure) that takes any number of arguments using the rest parameter syntax (`...args`).\\n\\n4. Inside the returned function, `clearTimeout(temp)` is called to clear any previously scheduled debounced function calls. This ensures that only the most recent call will be executed.\\n\\n5. Then, a new timer is set using `setTimeout`. The timer is set to `t` milliseconds in the future. When the timer expires, it triggers an anonymous function that calls the original function `fn` with the provided arguments `...args`.\\n\\nHere\\'s an example to illustrate how to use the `debounce` function:\\n\\n```javascript\\n// Example function to be debounced\\nfunction search(query) {\\n  // Perform search operation\\n  console.log(\"Searching for:\", query);\\n}\\n\\n// Create a debounced version of the search function\\nvar debouncedSearch = debounce(search, 500);\\n\\n// Call the debounced function multiple times\\ndebouncedSearch(\"apple\");\\ndebouncedSearch(\"banana\");\\ndebouncedSearch(\"cherry\");\\n\\n// Output: (after 500ms)\\n// Searching for: cherry\\n```\\n\\nIn the example above, the `search` function is passed as the `fn` parameter to the `debounce` function, and a debounce time of 500 milliseconds is specified. The `debouncedSearch` function is then used instead of the original `search` function.\\n\\nWhen `debouncedSearch` is called multiple times in quick succession, the debounce function ensures that only the final call (with the argument \"cherry\") triggers the actual search operation. The previous calls with arguments \"apple\" and \"banana\" are discarded because they are overridden by the subsequent call within the debounce time frame of 500 milliseconds.\\nHere is the code to current probem :- \\n\\n\\n```\\n\\nvar debounce = function(fn, t) {\\n  let temp;\\n  return function(...args) {\\n    clearTimeout(temp);\\n    temp = setTimeout(() => {\\n      fn(...args);\\n    }, t);\\n  }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n// Example function to be debounced\\nfunction search(query) {\\n  // Perform search operation\\n  console.log(\"Searching for:\", query);\\n}\\n\\n// Create a debounced version of the search function\\nvar debouncedSearch = debounce(search, 500);\\n\\n// Call the debounced function multiple times\\ndebouncedSearch(\"apple\");\\ndebouncedSearch(\"banana\");\\ndebouncedSearch(\"cherry\");\\n\\n// Output: (after 500ms)\\n// Searching for: cherry\\n```\n```\\n\\nvar debounce = function(fn, t) {\\n  let temp;\\n  return function(...args) {\\n    clearTimeout(temp);\\n    temp = setTimeout(() => {\\n      fn(...args);\\n    }, t);\\n  }\\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4050822,
                "title": "30-days-of-javascript-promises-time-runtime-92-21-memory-90-04",
                "content": "# ** Explanation\\n\"Debouncing\" is a programming practice to ensure that time-consuming tasks not to be called more often, which will interfere the performance of the web page or an application.\\n\\nIn Javascript, *Debouncing* is a practice used to improve browser performance by \"limiting the rate at which a time-consuming functionality gets invoked.\"\\n\\nThe general idea for debouncing is:\\n(1) Start with 0 timeout\\n(2) If the debounced function is called again, reset the timer to the specified delay\\n(3) In case of timeout, call the debounced function. Thus every call to a debounce function, reset the timer and delays the call\\n```\\nfunction debounce(() => {\\n    // irrespective of how many times you call\\n    // the function (i.e., mouse clicking, scrolling..),\\n    // it only gets executed after the given time delay\\n}, delay)\\n```\\n# ** Application\\n**->** applied in implementing suggestive text, where we wait for the user to stop typing for a few seconds before suggesting the text. On every key stroke, we wait for some few seconds before giving suggestions\\n**Eg**: Search bar in e-commerce websites, Google chrome\\n\\n**->** content-loading webpages like Facebook and Twitter where the user keeps on scrolling. Here, if the scroll event is fired too frequently there might be a performance impact, as it contains lots of videos and images\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// debounce function is provided with 2 parameters -\\n// a function and number (delay)\\nvar debounce = function(fn, t) {\\n    // declare a variable timerId, a unique identifier that\\n    // recieves a parameter after a certain delay \\'t\\' after\\n    // calling the function\\n    let timerId;\\n    return function(...args) {\\n        // if the function is called within the given delay \\'t\\',\\n        // the execution of timeout func is revoked\\n        clearTimeout(timerId);\\n        // the time delay is reset, again from 0 to t millisecs\\n        timerId = setTimeout(() => {\\n            fn.apply(this, args);\\n        }, t);\\n    }\\n};\\n```\\n\\n->>>>> ***please upvote***",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction debounce(() => {\\n    // irrespective of how many times you call\\n    // the function (i.e., mouse clicking, scrolling..),\\n    // it only gets executed after the given time delay\\n}, delay)\\n```\n```\\n// debounce function is provided with 2 parameters -\\n// a function and number (delay)\\nvar debounce = function(fn, t) {\\n    // declare a variable timerId, a unique identifier that\\n    // recieves a parameter after a certain delay \\'t\\' after\\n    // calling the function\\n    let timerId;\\n    return function(...args) {\\n        // if the function is called within the given delay \\'t\\',\\n        // the execution of timeout func is revoked\\n        clearTimeout(timerId);\\n        // the time delay is reset, again from 0 to t millisecs\\n        timerId = setTimeout(() => {\\n            fn.apply(this, args);\\n        }, t);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3459757,
                "title": "if-u-r-having-no-intution-u-can-try-to-understand-this-one",
                "content": "# Intuition\\ni didn\\'t get any intution initially\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSome javascript concepts that should be known: \\n1. we are returning function , but it will always have access to outer functions variable (this is known as closure concept)\\n2. t is fixed , i.e we have to delay function everytime it is called by fixed time t . (Before setting new delay we have to clear previous(clearTimeout()))\\n3. declare id variable , it will store id of setTimeout() which will be used to clearTimeout()\\n4. we are returning function , which will be called again and again.  \\n# Complexity\\n- Time complexity:\\n\\n- Space complexity:\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    let id = null;\\n    return function(...args) {\\n       clearTimeout(id);\\n       id = setTimeout(()=>{fn(...args)},t);   \\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    let id = null;\\n    return function(...args) {\\n       clearTimeout(id);\\n       id = setTimeout(()=>{fn(...args)},t);   \\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3407521,
                "title": "typescript",
                "content": "```typescript []\\ntype F = (...p: any[]) => any\\n\\nconst debounce = (fn: F, t: number): F => {\\n    let timeout: ReturnType<typeof setTimeout>\\n    return (...args) => {\\n        clearTimeout(timeout)\\n        timeout = setTimeout(() => fn(...args), t)\\n    }\\n}\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```typescript []\\ntype F = (...p: any[]) => any\\n\\nconst debounce = (fn: F, t: number): F => {\\n    let timeout: ReturnType<typeof setTimeout>\\n    return (...args) => {\\n        clearTimeout(timeout)\\n        timeout = setTimeout(() => fn(...args), t)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3406675,
                "title": "javascript-using-closures",
                "content": "```javascript []\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    let executionTime = 0\\n    let ref\\n\\n    return function(...args) {\\n        const currentTime = Date.now()\\n        if (currentTime <= executionTime) clearTimeout(ref)\\n        executionTime = currentTime + t\\n        \\n        ref = setTimeout(() => {\\n            return fn(...args)\\n        }, t)\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript []\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    let executionTime = 0\\n    let ref\\n\\n    return function(...args) {\\n        const currentTime = Date.now()\\n        if (currentTime <= executionTime) clearTimeout(ref)\\n        executionTime = currentTime + t\\n        \\n        ref = setTimeout(() => {\\n            return fn(...args)\\n        }, t)\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3541414,
                "title": "simple-javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe solution involves using the setTimeout function to execute the input function (fn) after a specified time (t). Before executing the setTimeout function, it is necessary to clear any previous timeouts by storing their values. This ensures that only the most recent timeout will be active and executed.\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    var deb;\\n    return function(...args) {\\n        clearTimeout(deb);\\n        deb = setTimeout(function() {fn(...args)}, t);\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    var deb;\\n    return function(...args) {\\n        clearTimeout(deb);\\n        deb = setTimeout(function() {fn(...args)}, t);\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3540363,
                "title": "3-line-solution-easy-solution",
                "content": "Step By Step Solution ->\\n\\nOne thing is sure,we have to use setTimeout function which can run input function `fn` after time `t`.\\n\\nBefore running setTimeout function we have to clear previous timeout,for clearing previous timeout, we have to store the value of that.\\n\\n# Code\\n```\\nvar debounce = function(fn, t) {\\n    let id;\\n    return function(...args) {\\n        clearTimeout(id);\\n        id = setTimeout(() => fn(...args),t); \\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar debounce = function(fn, t) {\\n    let id;\\n    return function(...args) {\\n        clearTimeout(id);\\n        id = setTimeout(() => fn(...args),t); \\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3540261,
                "title": "java-script-solution-for-debounce-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe debounce function ensures that the original function (fn) is executed only after a certain delay (t) has passed since the last invocation. If the debounced function is called multiple times within the delay period, the previous pending executions are canceled, and a new timeout is set.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. The debounce function takes two arguments: fn (the original function) and t (the delay time in milliseconds).\\n1. It returns a new function that acts as the debounced version of the original function.\\n1. Inside the debounced function, a timeoutId variable is declared to keep track of the timeout ID returned by setTimeout.\\n1. When the debounced function is called, any pending timeouts are cleared using clearTimeout to ensure that the function execution is delayed by the specified time.\\n1. A new timeout is set using setTimeout, which triggers the execution of the original function (fn.apply(this, args)) after the specified delay (t).\\n1. The apply method is used to invoke the function with the provided arguments (args).\\n1. By canceling and resetting the timeout on each invocation, the debounced function ensures that the original function is executed only after the specified delay period has elapsed since the last call.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the debounce function depends on the time complexity of the original function (fn) and the number of times the debounced function is called. The debounce function itself has a time complexity of O(1) since it performs simple operations like clearing and setting timeouts.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the debounce function is also O(1). It uses a constant amount of additional memory to store the timeoutId variable.\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    let timeoutId; // To keep track of the timeout ID\\n\\n    return function(...args) {\\n        clearTimeout(timeoutId); // Clear any pending timeouts\\n\\n        timeoutId = setTimeout(() => {\\n            fn.apply(this, args); // Execute the function after the specified delay\\n        }, t);\\n    };\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    let timeoutId; // To keep track of the timeout ID\\n\\n    return function(...args) {\\n        clearTimeout(timeoutId); // Clear any pending timeouts\\n\\n        timeoutId = setTimeout(() => {\\n            fn.apply(this, args); // Execute the function after the specified delay\\n        }, t);\\n    };\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3510471,
                "title": "javascript-solution",
                "content": "\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    let timer;\\n    return function(...args) {\\n        clearTimeout(timer);\\n        timer=setTimeout(()=>fn(...args),t);\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    let timer;\\n    return function(...args) {\\n        clearTimeout(timer);\\n        timer=setTimeout(()=>fn(...args),t);\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3479960,
                "title": "java-script-solution-for-debounce-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe debounce function takes in a function fn and a time delay t in milliseconds as input and returns a new function that can be used to \"debounce\" the input function.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe debounce function works by creating a closure with a timer variable initialized to null. When the debounced function is called, it first clears any existing timeout using clearTimeout(timer), and then sets a new timeout using setTimeout to call the input function after the specified delay t. By doing this, the debounced function ensures that the input function is only called once after the specified delay, even if the debounced function is called multiple times during that period.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nthe debounce function has a constant time complexity of O(1) because it performs a fixed number of operations regardless of the size of the input.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\ndebounce function has a space complexity of O(1) because it only creates a new closure with a single variable timer, which has a constant size.\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nconst debounce = function(fn, t) {\\n  let timer = null\\n    return function(...args) {\\n        clearTimeout(timer)\\n      timer = setTimeout(() => {\\n        fn(...args)\\n      }, t)\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nconst debounce = function(fn, t) {\\n  let timer = null\\n    return function(...args) {\\n        clearTimeout(timer)\\n      timer = setTimeout(() => {\\n        fn(...args)\\n      }, t)\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3407767,
                "title": "use-settimeout-and-cleartimeout",
                "content": "# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n  let timeout;\\n  return function(...args) {\\n    clearTimeout(timeout);\\n    timeout = setTimeout(() => {\\n      fn(...args);\\n    }, t);\\n  }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n  let timeout;\\n  return function(...args) {\\n    clearTimeout(timeout);\\n    timeout = setTimeout(() => {\\n      fn(...args);\\n    }, t);\\n  }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4097754,
                "title": "very-easy-solution-using-closure-function-cleartimeout-function",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    let call;\\n    return function(...args) {\\n        clearTimeout(call)\\n        call = setTimeout(()=> fn(...args), t)   \\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    let call;\\n    return function(...args) {\\n        clearTimeout(call)\\n        call = setTimeout(()=> fn(...args), t)   \\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4092109,
                "title": "debounce-function-for-javascript",
                "content": "# Intuition\\nThe debounce function aims to delay the execution of a provided function (fn) until a specified time (`t`) has passed without any further calls. This is useful for scenarios where you want to handle user input, such as keystrokes or mouse movements, but only perform the action once after a certain timeout.\\n\\n# Approach\\n1. Inside the debounce function, we declare a timer variable to keep track of the setTimeout timer.\\n2. We return an inner function that takes any number of arguments (...args).\\n3. Within the inner function:\\n    - We clear the previous timer if it exists using clearTimeout(timer).\\n    - We set a new timer using setTimeout. When the timer expires:\\n        - We execute the provided function fn with the provided arguments args.\\n4. The function returned by debounce will effectively delay the execution of fn until t milliseconds have passed without any new calls. If a new call is made within that time, the timer is reset.\\n\\n# Complexity\\n- Time complexity:\\n$$O(1)$$\\n\\n- Space complexity:\\n$$O(1)$$ \\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function (fn, t) {\\n    let timer;\\n\\n    return function (...args) {\\n        if (timer) {\\n            clearTimeout(timer);\\n        }\\n        timer = setTimeout(() => {\\n            fn(...args);\\n        }, t);\\n    };\\n};\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function (fn, t) {\\n    let timer;\\n\\n    return function (...args) {\\n        if (timer) {\\n            clearTimeout(timer);\\n        }\\n        timer = setTimeout(() => {\\n            fn(...args);\\n        }, t);\\n    };\\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4060992,
                "title": "simple-readable-idiomatic-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntype F = (...args: number[]) => void\\n\\nfunction debounce(fn: F, t: number): F {\\n    let timeoutId: ReturnType< typeof setTimeout>;  \\n    return function(...args) {\\n        if (timeoutId !== undefined) {\\n            clearTimeout(timeoutId);\\n        }\\n        timeoutId = setTimeout( () => { fn(...args); timeoutId = undefined; }, t);\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype F = (...args: number[]) => void\\n\\nfunction debounce(fn: F, t: number): F {\\n    let timeoutId: ReturnType< typeof setTimeout>;  \\n    return function(...args) {\\n        if (timeoutId !== undefined) {\\n            clearTimeout(timeoutId);\\n        }\\n        timeoutId = setTimeout( () => { fn(...args); timeoutId = undefined; }, t);\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4045321,
                "title": "c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    let CFC\\n    return function(...args) {\\nclearTimeout(CFC)\\n   CFC = setTimeout(()=>{\\n    return fn(...args)\\n    },t)  \\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    let CFC\\n    return function(...args) {\\nclearTimeout(CFC)\\n   CFC = setTimeout(()=>{\\n    return fn(...args)\\n    },t)  \\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4041977,
                "title": "simple-debounce-using-timeout",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    value = false\\n    let timer\\n    return function(...args) {\\n        if(value){\\n            clearTimeout(timer)\\n        }\\n        value = true\\n         timer = setTimeout(() =>{\\n                fn(...args)\\n                value = false\\n        }, t)\\n        \\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    value = false\\n    let timer\\n    return function(...args) {\\n        if(value){\\n            clearTimeout(timer)\\n        }\\n        value = true\\n         timer = setTimeout(() =>{\\n                fn(...args)\\n                value = false\\n        }, t)\\n        \\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4018879,
                "title": "beats-92-beginner-friendly-typescript-solution",
                "content": "\\n# Code\\n```\\ntype F = (...p: any[]) => any\\n\\nfunction debounce(fn: F, t: number): F {\\n\\n    let timeOut: ReturnType<typeof setTimeout>\\n\\n    return function(...args) {\\n        clearTimeout(timeOut)\\n        timeOut = setTimeout(() => {\\n            fn(...args)\\n        }, t)\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype F = (...p: any[]) => any\\n\\nfunction debounce(fn: F, t: number): F {\\n\\n    let timeOut: ReturnType<typeof setTimeout>\\n\\n    return function(...args) {\\n        clearTimeout(timeOut)\\n        timeOut = setTimeout(() => {\\n            fn(...args)\\n        }, t)\\n    }\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4018736,
                "title": "best-of-js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    let timer;\\n    return function(...args) {\\n        clearTimeout(timer);\\n        timer = setTimeout(() => fn(...args), t);\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    let timer;\\n    return function(...args) {\\n        clearTimeout(timer);\\n        timer = setTimeout(() => fn(...args), t);\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4010746,
                "title": "debounce",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvar debounce = function(fn, t = 1000) {\\n    let timer;\\n    return function(...args) {\\n        clearTimeout(timer);\\n        timer = setTimeout(() => fn(...args), t);\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar debounce = function(fn, t = 1000) {\\n    let timer;\\n    return function(...args) {\\n        clearTimeout(timer);\\n        timer = setTimeout(() => fn(...args), t);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4006012,
                "title": "easy-solution-with-explanation",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nThe idea of this problem revolves around `setTimeout` and its features. For instance, we are checking `if (id) clearTimeout(id);`. `setTimeout` returns a new identifier everytime a new `setTimeout` is created. So basically if we found the previous identifier i.e. `setTimeout`, this line of code cancels the previous timer and a new timer is created with a new identifier. like 1, 2, 3 .. and the process repeats. If the new timer is not created after a given timeframe, then it executes the provided function.\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    let id;\\n  return function (...args) {\\n    if (id) clearTimeout(id);\\n    id = setTimeout(() => {\\n      fn(...args);\\n    }, t);\\n  };\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    let id;\\n  return function (...args) {\\n    if (id) clearTimeout(id);\\n    id = setTimeout(() => {\\n      fn(...args);\\n    }, t);\\n  };\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4005930,
                "title": "debounce",
                "content": "# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    let timeout;\\n\\n    return function(...args) {\\n        clearTimeout(timeout);\\n        timeout = setTimeout(() => fn(...args), t)                \\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    let timeout;\\n\\n    return function(...args) {\\n        clearTimeout(timeout);\\n        timeout = setTimeout(() => fn(...args), t)                \\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4005676,
                "title": "js-clear-solution",
                "content": "\\n\\n# Code\\n```\\nvar debounce = function(fn, t) {\\n    let timeout = 0;\\n    return function(...args) {\\n        clearTimeout(timeout);\\n        timeout = setTimeout(function() {\\n            fn(...args);\\n        }, t);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar debounce = function(fn, t) {\\n    let timeout = 0;\\n    return function(...args) {\\n        clearTimeout(timeout);\\n        timeout = setTimeout(function() {\\n            fn(...args);\\n        }, t);\\n    }\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3995842,
                "title": "debouncing-in-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    let timer;\\n    return function(...args) {\\n        clearTimeout(timer);\\n        timer = setTimeout(()=>{\\n             fn(...args);\\n        },t)\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    let timer;\\n    return function(...args) {\\n        clearTimeout(timer);\\n        timer = setTimeout(()=>{\\n             fn(...args);\\n        },t)\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3995306,
                "title": "typescript-simple-o-1-solution-using-boolean-and-timeout-variables",
                "content": "# Intuition\\n\\nWhen the debounced function is called there are two possibilites:\\n\\n1. There are no pending functions\\n2. There is a pending function, meaning the debounced function was called less than t seconds ago\\n\\nIn case of 1, the current debounced function should run after t seconds. In case of 2 above, the pending function should be cancelled, and the new function should run after t seconds.\\n\\n# Approach\\nKeep track of two mutable variables using a closure: `timer` and `scheduled`. The `timer` variable holds a reference to the pending function that is scheduled to be run. The `scheduled` variable is a boolean indicating if there is a pending function. If `scheduled` is set to true then we need to cancel the pending function execution. This can be done using the built-in clearTimeout, passing in the `timer` Timeout variable. Then, schedule the new debounced function to run after t seconds, and re-set `scheduled` to true.\\n\\n# Complexity\\n- Time complexity:\\n$$O(1)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\ntype F = (...p: any[]) => any\\n\\nfunction debounce(fn: F, t: number): F {\\n    let timer: ReturnType<typeof setTimeout>\\n    let scheduled: boolean = false\\n\\n    return function(...args) {\\n        if (scheduled) {\\n            clearTimeout(timer)\\n        }\\n        timer = setTimeout(() => {\\n            scheduled = false\\n            fn(...args)\\n        }, t)\\n        scheduled = true\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype F = (...p: any[]) => any\\n\\nfunction debounce(fn: F, t: number): F {\\n    let timer: ReturnType<typeof setTimeout>\\n    let scheduled: boolean = false\\n\\n    return function(...args) {\\n        if (scheduled) {\\n            clearTimeout(timer)\\n        }\\n        timer = setTimeout(() => {\\n            scheduled = false\\n            fn(...args)\\n        }, t)\\n        scheduled = true\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3986616,
                "title": "2-solutions",
                "content": "\\n# Approach\\nEvery time if function is getting called just clear the timeout and set new timeout.\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    let timeout;\\n    return function(...args) {\\n      clearTimeout(timeout);\\n      timeout = setTimeout(()=>fn(...args),t)\\n    }\\n}\\n```\\n```\\nvar debounce = function(fn, t) {\\n    let interval;\\n    return function(...args) {\\n      const lastCall = Date.now();\\n      clearInterval(interval);\\n      interval = setInterval(()=>{\\n        if(Date.now() - lastCall >= t){\\n          fn(...args);\\n          clearInterval(interval);\\n        }\\n      })\\n        \\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    let timeout;\\n    return function(...args) {\\n      clearTimeout(timeout);\\n      timeout = setTimeout(()=>fn(...args),t)\\n    }\\n}\\n```\n```\\nvar debounce = function(fn, t) {\\n    let interval;\\n    return function(...args) {\\n      const lastCall = Date.now();\\n      clearInterval(interval);\\n      interval = setInterval(()=>{\\n        if(Date.now() - lastCall >= t){\\n          fn(...args);\\n          clearInterval(interval);\\n        }\\n      })\\n        \\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3985989,
                "title": "typescript-solution-using-arrays",
                "content": "# Code\\n```\\n/** NodeJS.Timeout */\\ntype Timeout = any;\\ntype FunctionType = (...params: any[]) => any;\\n\\nconst debounce = (\\n  delayedFunction: FunctionType,\\n  timeInMs: number\\n): FunctionType => {\\n  const timeouts: Timeout[] = [];\\n\\n  return (...args) => {\\n    const prevTimeout = timeouts.pop();\\n\\n    if (prevTimeout) {\\n      clearTimeout(prevTimeout);\\n    }\\n\\n    timeouts.push(setTimeout(() => delayedFunction(...args), timeInMs));\\n  };\\n};\\n\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\n/** NodeJS.Timeout */\\ntype Timeout = any;\\ntype FunctionType = (...params: any[]) => any;\\n\\nconst debounce = (\\n  delayedFunction: FunctionType,\\n  timeInMs: number\\n): FunctionType => {\\n  const timeouts: Timeout[] = [];\\n\\n  return (...args) => {\\n    const prevTimeout = timeouts.pop();\\n\\n    if (prevTimeout) {\\n      clearTimeout(prevTimeout);\\n    }\\n\\n    timeouts.push(setTimeout(() => delayedFunction(...args), timeInMs));\\n  };\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3977830,
                "title": "understanding-basic-logic-behind-the-execution-flow",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nTwo key points:\\n- We call clearTimeout() every time new instance is called\\n- setTimeout() id will be undefine if it has finish executing and hence next clearTimeout() will be called with undefine value (Doesn\\'t affect anything)\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function (fn, t) {\\n  let delayFunId;\\n  return function (...args) {\\n    clearTimeout(delayFunId);\\n\\n    delayFunId = setTimeout(() => {\\n      fn(...args);\\n    }, t);\\n  };\\n};\\n\\n// /**\\n//  * const log = debounce(console.log, 100);\\n//  * log(\\'Hello\\'); // cancelled\\n//  * log(\\'Hello\\'); // cancelled\\n//  * log(\\'Hello\\'); // Logged at t=100ms\\n//  */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function (fn, t) {\\n  let delayFunId;\\n  return function (...args) {\\n    clearTimeout(delayFunId);\\n\\n    delayFunId = setTimeout(() => {\\n      fn(...args);\\n    }, t);\\n  };\\n};\\n\\n// /**\\n//  * const log = debounce(console.log, 100);\\n//  * log(\\'Hello\\'); // cancelled\\n//  * log(\\'Hello\\'); // cancelled\\n//  * log(\\'Hello\\'); // Logged at t=100ms\\n//  */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3963382,
                "title": "solution-with-closure",
                "content": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n\\n    let intevalId\\n\\n    return function(...args) {\\n\\n        clearTimeout(intevalId)\\n        \\n        intevalId = setTimeout(function() {\\n            fn(...args)\\n        }, t)\\n    }\\n\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n\\n    let intevalId\\n\\n    return function(...args) {\\n\\n        clearTimeout(intevalId)\\n        \\n        intevalId = setTimeout(function() {\\n            fn(...args)\\n        }, t)\\n    }\\n\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3956661,
                "title": "3-lines",
                "content": "```\\nvar debounce = function(fn, t) {\\n    let timeout = null;\\n    return function(...args) {\\n      clearInterval(timeout)\\n      timeout = setTimeout(fn.bind(this,...args),t)\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar debounce = function(fn, t) {\\n    let timeout = null;\\n    return function(...args) {\\n      clearInterval(timeout)\\n      timeout = setTimeout(fn.bind(this,...args),t)\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3951375,
                "title": "debounce-solution",
                "content": "# Intuition\\nMy first thoughts were to do a little more research on setTimeout which led me to learn more about clearTimeout. I also knew I needed to research more on closures. \\n\\n# Approach\\nI knew I would need to maintain a timer of some sort as well as preserve the original \"t\" and fn. \\n\\nthe .apply method helped me with that. \\n\\n# Complexity\\n- Time complexity:\\n    O(1)\\n\\n- Space complexity:\\n    O(n)\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    let timer;\\n\\n    return function(...args) {\\n\\n        if(timer){\\n            clearTimeout(timer);\\n        }\\n\\n        timer = setTimeout(() =>{\\n            fn.apply(this, args);\\n        }, t)\\n        \\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    let timer;\\n\\n    return function(...args) {\\n\\n        if(timer){\\n            clearTimeout(timer);\\n        }\\n\\n        timer = setTimeout(() =>{\\n            fn.apply(this, args);\\n        }, t)\\n        \\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3922185,
                "title": "",
                "content": "# Intuition\\n\\n\\u0414\\u043B\\u044F \\u0440\\u0435\\u0430\\u043B\\u0438\\u0437\\u0430\\u0446\\u0438\\u0438 \\u0437\\u0430\\u0434\\u0435\\u0440\\u0436\\u043A\\u0438 \\u0432\\u044B\\u043F\\u043E\\u043B\\u043D\\u0435\\u043D\\u0438\\u044F \\u0444\\u0443\\u043D\\u043A\\u0446\\u0438\\u0438 \\u043C\\u043E\\u0436\\u043D\\u043E \\u0438\\u0441\\u043F\\u043E\\u043B\\u044C\\u0437\\u043E\\u0432\\u0430\\u0442\\u044C setTimeout. \\u0415\\u0441\\u043B\\u0438 \\u0444\\u0443\\u043D\\u043A\\u0446\\u0438\\u044F \\u0432\\u044B\\u0437\\u044B\\u0432\\u0430\\u0435\\u0442\\u0441\\u044F \\u043F\\u043E\\u0432\\u0442\\u043E\\u0440\\u043D\\u043E \\u0432 \\u0442\\u0435\\u0447\\u0435\\u043D\\u0438\\u0435 \\u0437\\u0430\\u0434\\u0435\\u0440\\u0436\\u043A\\u0438, \\u043F\\u0440\\u0435\\u0434\\u044B\\u0434\\u0443\\u0449\\u0438\\u0439 \\u0442\\u0430\\u0439\\u043C\\u0435\\u0440 \\u043E\\u0442\\u043C\\u0435\\u043D\\u044F\\u0435\\u0442\\u0441\\u044F \\u0441 \\u043F\\u043E\\u043C\\u043E\\u0449\\u044C\\u044E clearInterval.\\n\\n# Approach\\n\\n\\u041C\\u044B \\u0441\\u043E\\u0437\\u0434\\u0430\\u0435\\u043C \\u0442\\u0430\\u0439\\u043C\\u0435\\u0440 \\u0441 \\u043F\\u043E\\u043C\\u043E\\u0449\\u044C\\u044E setTimeout, \\u043A\\u043E\\u0442\\u043E\\u0440\\u044B\\u0439 \\u0432\\u044B\\u0437\\u044B\\u0432\\u0430\\u0435\\u0442 \\u0444\\u0443\\u043D\\u043A\\u0446\\u0438\\u044E fn \\u043F\\u043E\\u0441\\u043B\\u0435 \\u0437\\u0430\\u0434\\u0435\\u0440\\u0436\\u043A\\u0438 t. \\u0415\\u0441\\u043B\\u0438 debounce \\u0432\\u044B\\u0437\\u044B\\u0432\\u0430\\u0435\\u0442\\u0441\\u044F \\u0441\\u043D\\u043E\\u0432\\u0430 \\u0434\\u043E \\u0438\\u0441\\u0442\\u0435\\u0447\\u0435\\u043D\\u0438\\u044F \\u0437\\u0430\\u0434\\u0435\\u0440\\u0436\\u043A\\u0438, \\u043F\\u0440\\u0435\\u0434\\u044B\\u0434\\u0443\\u0449\\u0438\\u0439 \\u0442\\u0430\\u0439\\u043C\\u0435\\u0440 \\u043E\\u0442\\u043C\\u0435\\u043D\\u044F\\u0435\\u0442\\u0441\\u044F, \\u0438 \\u043D\\u043E\\u0432\\u044B\\u0439 \\u0442\\u0430\\u0439\\u043C\\u0435\\u0440 \\u0443\\u0441\\u0442\\u0430\\u043D\\u0430\\u0432\\u043B\\u0438\\u0432\\u0430\\u0435\\u0442\\u0441\\u044F \\u0437\\u0430\\u043D\\u043E\\u0432\\u043E.\\n\\n# Complexity\\n- Time complexity: $$O(1)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    let timer;\\n    return function(...args) {\\n        if (timer) clearInterval(timer)\\n        timer = setTimeout(()=>fn(...args), t);\\n    }\\n};\\n\\n\\nconst log = debounce(console.log, 100);\\nlog(\\'Hello\\'); // cancelled\\nlog(\\'Hello\\'); // cancelled\\nlog(\\'Hello\\'); // Logged at t=100ms\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    let timer;\\n    return function(...args) {\\n        if (timer) clearInterval(timer)\\n        timer = setTimeout(()=>fn(...args), t);\\n    }\\n};\\n\\n\\nconst log = debounce(console.log, 100);\\nlog(\\'Hello\\'); // cancelled\\nlog(\\'Hello\\'); // cancelled\\nlog(\\'Hello\\'); // Logged at t=100ms\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3919867,
                "title": "typescript-closure-solution-very-simple",
                "content": "# Code\\n```\\ntype F = (...p: any[]) => any\\n\\nfunction debounce(fn: F, t: number): F {\\n    let ref: number;\\n    return function ( ...args ) {\\n        clearTimeout( ref );\\n        ref = setTimeout( fn, t, ...args );\\n    }\\n\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype F = (...p: any[]) => any\\n\\nfunction debounce(fn: F, t: number): F {\\n    let ref: number;\\n    return function ( ...args ) {\\n        clearTimeout( ref );\\n        ref = setTimeout( fn, t, ...args );\\n    }\\n\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3917835,
                "title": "simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    let timeout;\\n\\n    return function(...args) {\\n        clearTimeout(timeout);\\n\\n        timeout = setTimeout(() => {\\n            fn(...args);\\n        }, t)\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    let timeout;\\n\\n    return function(...args) {\\n        clearTimeout(timeout);\\n\\n        timeout = setTimeout(() => {\\n            fn(...args);\\n        }, t)\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3913908,
                "title": "simple-and-sassy-beats-99-users",
                "content": "\\n# Code\\n```\\nlet handel;\\n\\nvar debounce = function(fn, t) {\\n    return function(...args) {\\n        if(handel)\\n            clearTimeout(handel)\\n        handel = setTimeout(() => fn(...args), t)\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nlet handel;\\n\\nvar debounce = function(fn, t) {\\n    return function(...args) {\\n        if(handel)\\n            clearTimeout(handel)\\n        handel = setTimeout(() => fn(...args), t)\\n    }\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3894396,
                "title": "clean-solution",
                "content": "# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nconst debounce = (fn, t) => {\\n    let timeoutId\\n\\n    return (...args) => {\\n        timeoutId && clearTimeout(timeoutId)\\n        timeoutId = setTimeout(fn, t, ...args)\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nconst debounce = (fn, t) => {\\n    let timeoutId\\n\\n    return (...args) => {\\n        timeoutId && clearTimeout(timeoutId)\\n        timeoutId = setTimeout(fn, t, ...args)\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3893262,
                "title": "debounced-function-using-setimeout-and-cleartimeout-methods",
                "content": "# Intuition\\nWe want to create a debounced version of a given function that delays its execution by a specified time t and cancels the execution if the function is called again within that window of time.\\n\\n# Approach\\nWe can achieve this by using a combination of the setTimeout and clearTimeout functions. When the debounced function is called, we start a timer using setTimeout. If the function is called again before the timer expires, we cancel the previous timer using clearTimeout and start a new timer. This ensures that the function execution is delayed by at least t milliseconds and is cancelled if called again within that time.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of this implementation is O(1) for each call to the debounced function since it involves starting or cancelling a timer, which is a constant-time operation.\\n- Space complexity:\\nThe space complexity is O(1) since it only uses a constant amount of memory to store the timer variable.\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    let timer;\\n    return function(...args) {\\n           clearTimeout(timer);\\n    timer = setTimeout(() => {\\n      fn.apply(this, args);\\n    }, t);\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    let timer;\\n    return function(...args) {\\n           clearTimeout(timer);\\n    timer = setTimeout(() => {\\n      fn.apply(this, args);\\n    }, t);\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3889467,
                "title": "beats-100-with-prove-simple-solution-with-minimal-code",
                "content": "# Intuition\\nThese approach emphasizes achieving **performance with minimal code**.\\n\\nPlease **Upvote** if you find helpful.\\n\\nHere is the screenshot:-\\n\\n![LeetCode-The-World-s-Leading-Online-Programming-Learning-Platform.png](https://assets.leetcode.com/users/images/7509c3e1-51fe-46f0-8130-7eb362c376db_1691655468.9884892.png)\\n\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = (fn, t) => {\\n    let timeoutId;\\n    return (...args) => (\\n        clearTimeout(timeoutId),\\n        timeoutId = setTimeout(()=> fn(...args), t)\\n    );\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = (fn, t) => {\\n    let timeoutId;\\n    return (...args) => (\\n        clearTimeout(timeoutId),\\n        timeoutId = setTimeout(()=> fn(...args), t)\\n    );\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3881013,
                "title": "my-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// Time:  O(1)\\n// Space: O(1)\\n\\ntype F = (...p: any[]) => any\\n\\nfunction debounce(fn: F, t: number): F {\\n    let timeout = null;\\n    return (...args) => {\\n        clearTimeout(timeout);\\n        timeout = setTimeout(fn, t, ...args);\\n    }\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\n// Time:  O(1)\\n// Space: O(1)\\n\\ntype F = (...p: any[]) => any\\n\\nfunction debounce(fn: F, t: number): F {\\n    let timeout = null;\\n    return (...args) => {\\n        clearTimeout(timeout);\\n        timeout = setTimeout(fn, t, ...args);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3872689,
                "title": "2627-debounce",
                "content": "\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    let timeout;\\n    return  function(...args) {\\n        clearTimeout(timeout);\\n        timeout = setTimeout(()=>{\\n            fn(...args);\\n        }, t);\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    let timeout;\\n    return  function(...args) {\\n        clearTimeout(timeout);\\n        timeout = setTimeout(()=>{\\n            fn(...args);\\n        }, t);\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3862125,
                "title": "js-solution-simple",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nsetTimeout for each call and cancel if there are any newer call.\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    let t2\\n    return function(...a) {\\n        if (t2)\\n            clearTimeout(t2);\\n        t2 = setTimeout(() => fn(...a), t)\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    let t2\\n    return function(...a) {\\n        if (t2)\\n            clearTimeout(t2);\\n        t2 = setTimeout(() => fn(...a), t)\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3840437,
                "title": "debounce-super-easy-javascript",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    let timeOut;\\n    return function(...args) {\\n        clearTimeout(timeOut);  \\n        timeOut = setTimeout(() => {fn(...args)}, t);  \\n    };\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    let timeOut;\\n    return function(...args) {\\n        clearTimeout(timeOut);  \\n        timeOut = setTimeout(() => {fn(...args)}, t);  \\n    };\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3823808,
                "title": "modular-way-to-implement-debouncing-in-your-code",
                "content": "# Intuition\\nThe intuition behind this code is to implement a debounce function. Debouncing is a technique used to control how frequently a function is called, especially in response to rapid or frequent events (e.g., user input events). It ensures that the function is executed only after a certain quiet period without any new events being triggered.\\n\\n# Approach\\nThe approach taken in the code is to create a debounce function that accepts two parameters: `fn` (the function to be debounced) and `t` (the debounce delay in milliseconds). The debounce function `returns a new function`, which will be the debounced version of the original function.\\n\\nMake sure to declare the`timer`variable inside the wrapper function as if it\\'s created in the Global Scope it won\\'t be modular and if created in the debounced function returned it won\\'t work as expected because every time the function gets called it will create a new timer variable and hence it\\'ll create a bug. So better use it in the wrapper function using the concept of closures and `Encapsulation / Data Hiding` in javascript\\n\\n\\n# Code\\n```\\nconst debounce =(fn, t)=> {\\n    let timer;\\n    return (...args) =>{\\n    timer!= null ? clearTimeout(timer): null\\n    timer = setTimeout(()=>{\\n            fn(...args)\\n        },t)\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst debounce =(fn, t)=> {\\n    let timer;\\n    return (...args) =>{\\n    timer!= null ? clearTimeout(timer): null\\n    timer = setTimeout(()=>{\\n            fn(...args)\\n        },t)\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3820114,
                "title": "javascript-o-1-solution",
                "content": "# Intuition\\nreturn a setTimeout with old timeout cleared using clearTimeout\\n\\n# Approach\\n1. Take a variable for reference \\'timeout\\'\\n2. Return a function having a setTimeout of the \\'fn\\' execution with \\'args\\' and timeout \\'t\\', and take it\\'s reference in the \\'timeout\\' variable.\\n3. On the first line, clear the timeout by reference \\'timeout\\' using clearTimeout.\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nconst debounce = (fn, t) => {\\n    let timeout;\\n    return (...args) => {\\n        clearTimeout(timeout);\\n        timeout = setTimeout(()=>fn(...args),t)\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nconst debounce = (fn, t) => {\\n    let timeout;\\n    return (...args) => {\\n        clearTimeout(timeout);\\n        timeout = setTimeout(()=>fn(...args),t)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3809851,
                "title": "very-simple-and-clean-solution",
                "content": "\\n```\\nconst debounce = (fn, t) => {\\n    let timer = null;\\n\\n    return function(...args) {\\n        clearTimeout(timer);\\n\\n        timer = setTimeout(() => fn.apply(this, args), t);\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nconst debounce = (fn, t) => {\\n    let timer = null;\\n\\n    return function(...args) {\\n        clearTimeout(timer);\\n\\n        timer = setTimeout(() => fn.apply(this, args), t);\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3797746,
                "title": "timeout-settimeout-and-cleartimeout-functions",
                "content": "# Approach\\n1. Fn is the function to be debounced\\n2. T is the time to wait until the next execution of fn is permitted\\n3. Assign and set timeout variable to null\\n4. Return function with arguments (of the function to be debounced, fn)\\n5. Clear the previous timeout everytime the previous function runs\\n6. Assign timeout a setTimeout function with fn, its arguments and assign the time the setTimeout function will wait until executing fn.\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n let timeout = null\\n    return function (...arguments) {\\n        clearTimeout(timeout)\\n        timeout = setTimeout(() => {\\n            fn(...arguments);\\n            }, t);\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n let timeout = null\\n    return function (...arguments) {\\n        clearTimeout(timeout)\\n        timeout = setTimeout(() => {\\n            fn(...arguments);\\n            }, t);\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3794758,
                "title": "3-line-javascript-code-using-settimeout-and-cleartimeout",
                "content": "# Intuition\\nThis is a very simple question.I don\\'t know why it is in medium category.\\n\\n# Approach\\n1.In the function,use setTimeout to defer solutions after t milliseconds and store it in a variable.\\n2.Use clearTimeout and pass that variable in clearTimeout to cancel timeout established by setTimeout.\\n3.By just using these two methods,we can achieve our soultion.\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    let timeout = null;\\n    return function(...args) {\\n        clearTimeout(timeout);\\n        timeout=setTimeout(fn,t,...args);\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    let timeout = null;\\n    return function(...args) {\\n        clearTimeout(timeout);\\n        timeout=setTimeout(fn,t,...args);\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3772922,
                "title": "beats-100-js",
                "content": "# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    var calledFirstTime = true;\\n    var timeout;\\n\\n    return function(...args) {\\n        if (calledFirstTime) {\\n            timeout = setTimeout(() => {\\n                fn(...args)\\n            }, t);\\n            calledFirstTime = false;\\n        } else {\\n            clearTimeout(timeout);\\n            timeout = setTimeout(() => {\\n                fn(...args)\\n            }, t);\\n        }\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    var calledFirstTime = true;\\n    var timeout;\\n\\n    return function(...args) {\\n        if (calledFirstTime) {\\n            timeout = setTimeout(() => {\\n                fn(...args)\\n            }, t);\\n            calledFirstTime = false;\\n        } else {\\n            clearTimeout(timeout);\\n            timeout = setTimeout(() => {\\n                fn(...args)\\n            }, t);\\n        }\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3761497,
                "title": "typescript-following-the-hints",
                "content": "# Code\\n```\\ntype F = (...p: any[]) => any\\n\\nfunction debounce(fn: F, t: number): F {\\n    var ref = null;\\n    return function(...args) {\\n        if(ref !== null) {\\n            clearTimeout(ref)\\n        }\\n        ref = setTimeout(()=>fn(...args), t)\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype F = (...p: any[]) => any\\n\\nfunction debounce(fn: F, t: number): F {\\n    var ref = null;\\n    return function(...args) {\\n        if(ref !== null) {\\n            clearTimeout(ref)\\n        }\\n        ref = setTimeout(()=>fn(...args), t)\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3750556,
                "title": "easiest-way-to-solve-it",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t = 1000) {\\n    let timer;\\n    return function(...args) {\\n        clearTimeout(timer);\\n        timer = setTimeout(() => fn(...args), t);\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t = 1000) {\\n    let timer;\\n    return function(...args) {\\n        clearTimeout(timer);\\n        timer = setTimeout(() => fn(...args), t);\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3700898,
                "title": "solution-using-js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    let timer\\n    return function(...args) {\\n        clearTimeout(timer)\\n        timer = setTimeout(fn, t, ...args)\\n        return timer\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    let timer\\n    return function(...args) {\\n        clearTimeout(timer)\\n        timer = setTimeout(fn, t, ...args)\\n        return timer\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3695412,
                "title": "simple-ts-js-solution",
                "content": "# Code\\n``` Javascript []\\nfunction debounce(fn, t){\\n    let timeout;\\n    return (...args) => {\\n        clearTimeout(timeout)\\n        timeout = setTimeout(()=>{\\n            return fn(...args)\\n        }, t) \\n    }\\n};\\n```\\n``` Typescript []\\nfunction debounce(fn: F, t: number): F {\\n    let timeout: ReturnType<typeof setTimeout>;\\n    return (...args) => {\\n        clearTimeout(timeout)\\n        timeout = setTimeout(()=>{\\n            return fn(...args)\\n        }, t) \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "``` Javascript []\\nfunction debounce(fn, t){\\n    let timeout;\\n    return (...args) => {\\n        clearTimeout(timeout)\\n        timeout = setTimeout(()=>{\\n            return fn(...args)\\n        }, t) \\n    }\\n};\\n```\n``` Typescript []\\nfunction debounce(fn: F, t: number): F {\\n    let timeout: ReturnType<typeof setTimeout>;\\n    return (...args) => {\\n        clearTimeout(timeout)\\n        timeout = setTimeout(()=>{\\n            return fn(...args)\\n        }, t) \\n    }\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3685201,
                "title": "did-you-know-that-the-settimeout-function-receives-three-arguments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\n\\nvar debounce = function(fn, t) {\\n    let id;\\n    return function(...args) {\\n        clearTimeout(id);\\n        id = setTimeout(fn, t, ...args);\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\n\\nvar debounce = function(fn, t) {\\n    let id;\\n    return function(...args) {\\n        clearTimeout(id);\\n        id = setTimeout(fn, t, ...args);\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3674842,
                "title": "easy-js-solution",
                "content": "# Code\\n```\\nvar debounce = function(fn, t) {\\n    let timer;\\n    return function(...args) {\\n        if (timer) clearTimeout(timer);\\n        timer = setTimeout(() => fn(...args), t);\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar debounce = function(fn, t) {\\n    let timer;\\n    return function(...args) {\\n        if (timer) clearTimeout(timer);\\n        timer = setTimeout(() => fn(...args), t);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3659207,
                "title": "easy-javascript",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    let tOut;\\n    return function(...args) {\\n        if(tOut) clearTimeout(tOut);\\n        tOut = setTimeout(()=>{ fn(...args); },t);\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    let tOut;\\n    return function(...args) {\\n        if(tOut) clearTimeout(tOut);\\n        tOut = setTimeout(()=>{ fn(...args); },t);\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3643549,
                "title": "js",
                "content": "# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    let debounceTimer;\\n    return function(...args) {\\n        clearTimeout(debounceTimer);\\n        debounceTimer = setTimeout(() => fn.apply(this,args), t)\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    let debounceTimer;\\n    return function(...args) {\\n        clearTimeout(debounceTimer);\\n        debounceTimer = setTimeout(() => fn.apply(this,args), t)\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3613250,
                "title": "3-line-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    let id;\\n    return function(...args) {\\n        clearTimeout(id);\\n        id = setTimeout(()=>fn(...args),t);\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    let id;\\n    return function(...args) {\\n        clearTimeout(id);\\n        id = setTimeout(()=>fn(...args),t);\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3606939,
                "title": "js-debounce-noodkhan-navin",
                "content": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\n```\\n```\\nvar debounce = function (fn, t) {\\n    let timeout;\\n    return function (...args) {\\n        clearTimeout(timeout);\\n        timeout = setTimeout(() => {\\n            fn(...args);\\n        }, t)\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\n```\n```\\nvar debounce = function (fn, t) {\\n    let timeout;\\n    return function (...args) {\\n        clearTimeout(timeout);\\n        timeout = setTimeout(() => {\\n            fn(...args);\\n        }, t)\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3593488,
                "title": "day-15-javascript-solution",
                "content": "# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n  let timeout;\\n  return function(...args) {\\n    clearTimeout(timeout);\\n    timeout = setTimeout(() => { \\n      fn(...args); \\n      clearTimeout(timeout);\\n    }, t);\\n  }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n  let timeout;\\n  return function(...args) {\\n    clearTimeout(timeout);\\n    timeout = setTimeout(() => { \\n      fn(...args); \\n      clearTimeout(timeout);\\n    }, t);\\n  }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3590554,
                "title": "simple-settimeout-typescript-solution-closures",
                "content": "# Code\\n```\\ntype F = (...p: any[]) => any\\n\\nfunction debounce(fn: F, t: number): F {\\n    let timer;\\n    return function(...args) {\\n        if(timer){\\n            clearTimeout(timer);\\n        }\\n        timer = setTimeout(() => fn(...args), t);\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype F = (...p: any[]) => any\\n\\nfunction debounce(fn: F, t: number): F {\\n    let timer;\\n    return function(...args) {\\n        if(timer){\\n            clearTimeout(timer);\\n        }\\n        timer = setTimeout(() => fn(...args), t);\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3586294,
                "title": "js-debounce-concept-settimeout-closure-day-15",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nDebouncing is a method that limits the rate at which a function gets called. It works by delaying the execution of a function until a certain amount of time has passed without any additional function calls. If another function call happens within this time frame, the timer resets and the function execution is delayed again.\\n\\nDebouncing is useful in situations where we want to prevent a function from being called too frequently, such as:\\n\\n    1. Handling user input events like keypresses, mouse movements, or button clicks\\n\\n    2. Handling expensive computations or network requests that don\\'t need to be performed on every function call\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere is the simple approach below:\\n    1. delay the function call using setTimeout function\\n    2. If another function Call happens during the time window clear the previous timer first and again start a new timer with the new function.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(delay)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    let timer;\\n    return function(...args) {\\n        if(timer) clearTimeout(timer)\\n        timer = setTimeout(()=> {\\n            fn.apply(this, args)\\n        }, t)\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    let timer;\\n    return function(...args) {\\n        if(timer) clearTimeout(timer)\\n        timer = setTimeout(()=> {\\n            fn.apply(this, args)\\n        }, t)\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3585602,
                "title": "javascript-simple-javascript-typescript-solution",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Approach 1 Using Javascript :\\n# Runtime: 59 ms, faster than 68.61% of JavaScript online submissions for Debounce.\\n# Memory Usage: 41.8 MB, less than 64.33% of JavaScript online submissions for Debounce.\\n\\tvar debounce = function(fn, t) {\\n\\t  let timeout;\\n\\t  return function(...args) {\\n\\t\\tclearTimeout(timeout);\\n\\t\\ttimeout = setTimeout(() => {\\n\\t\\t  fn(...args)\\n\\t\\t}, t);\\n\\t  };\\n\\t};\\n\\t\\n# Approach 2 Using Typescript :\\n# Runtime: 73 ms, faster than 19.85% of TypeScript online submissions for Debounce.\\n# Memory Usage: 42.9 MB, less than 57.03% of TypeScript online submissions for Debounce.\\n\\n\\ttype F = (...p: any[]) => any\\n\\n\\tfunction debounce(fn: F, t: number): F {\\n\\n\\t  let timeout;\\n\\t  return function(...args) {\\n\\t\\tclearTimeout(timeout);\\n\\t\\ttimeout = setTimeout(() => {\\n\\t\\t  fn(...args)\\n\\t\\t}, t);\\n\\t  };\\n\\n\\t};\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Approach 1 Using Javascript :\\n# Runtime: 59 ms, faster than 68.61% of JavaScript online submissions for Debounce.\\n# Memory Usage: 41.8 MB, less than 64.33% of JavaScript online submissions for Debounce.\\n\\tvar debounce = function(fn, t) {\\n\\t  let timeout;\\n\\t  return function(...args) {\\n\\t\\tclearTimeout(timeout);\\n\\t\\ttimeout = setTimeout(() => {\\n\\t\\t  fn(...args)\\n\\t\\t}, t);\\n\\t  };\\n\\t};\\n\\t\\n# Approach 2 Using Typescript :\\n# Runtime: 73 ms, faster than 19.85% of TypeScript online submissions for Debounce.\\n# Memory Usage: 42.9 MB, less than 57.03% of TypeScript online submissions for Debounce.\\n\\n\\ttype F = (...p: any[]) => any\\n\\n\\tfunction debounce(fn: F, t: number): F {\\n\\n\\t  let timeout;\\n\\t  return function(...args) {\\n\\t\\tclearTimeout(timeout);\\n\\t\\ttimeout = setTimeout(() => {\\n\\t\\t  fn(...args)\\n\\t\\t}, t);\\n\\t  };\\n\\n\\t};\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "codeTag": "Unknown"
            },
            {
                "id": 3583189,
                "title": "javascript-easy-solution",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    let id;\\n    return function(...args) {\\n        clearTimeout(id);\\n        id = setTimeout(()=> fn(...args), t);\\n        \\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    let id;\\n    return function(...args) {\\n        clearTimeout(id);\\n        id = setTimeout(()=> fn(...args), t);\\n        \\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3578479,
                "title": "easiest-javascript-solution",
                "content": "# What is Debouncing?\\n\\nDebouncing is a method that limits the rate at which a function gets called. It works by delaying the execution of a function until a certain amount of time has passed without any additional function calls. If another function call happens within this time frame, the timer resets and the function execution is delayed again.\\n\\n- Debouncing is useful in situations where you want to prevent a function from being called too frequently, such as:\\n\\n- Handling user input events like keypresses, mouse movements, or button clicks\\n\\n- Handling expensive computations or network requests that don\\'t need to be performed on every function call\\n\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t = 1000) {\\n    let countDown;\\n    return function(...args) {\\n        clearTimeout(countDown);\\n        countDown = setTimeout(() => fn(...args), t);\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t = 1000) {\\n    let countDown;\\n    return function(...args) {\\n        clearTimeout(countDown);\\n        countDown = setTimeout(() => fn(...args), t);\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3577244,
                "title": "cleanest-js-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    let timer;\\n    return function(...args) {\\n        clearTimeout(timer);\\n        timer = setTimeout(fn, t, ...args);\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    let timer;\\n    return function(...args) {\\n        clearTimeout(timer);\\n        timer = setTimeout(fn, t, ...args);\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3572169,
                "title": "js-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t = 1000) {\\n    let timerr;\\n    return function(...args) {\\n        clearTimeout(timerr);\\n        timerr = setTimeout(() => fn(...args), t);\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t = 1000) {\\n    let timerr;\\n    return function(...args) {\\n        clearTimeout(timerr);\\n        timerr = setTimeout(() => fn(...args), t);\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3569005,
                "title": "settimeout-cleartimeout-closure-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntype F = (...p: any[]) => any\\n\\nfunction debounce(fn: F, t: number): F {\\n    let timer\\n    return function(...args) {\\n        if (timer) {\\n            clearTimeout(timer)\\n            timer = null\\n        }\\n        timer = setTimeout(() => {\\n            fn(...args)\\n        }, t)\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype F = (...p: any[]) => any\\n\\nfunction debounce(fn: F, t: number): F {\\n    let timer\\n    return function(...args) {\\n        if (timer) {\\n            clearTimeout(timer)\\n            timer = null\\n        }\\n        timer = setTimeout(() => {\\n            fn(...args)\\n        }, t)\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3554383,
                "title": "debounce-function",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    let timer;\\n\\n    return function(...args) {\\n        clearTimeout(timer);\\n\\n        timer = setTimeout(() => fn(...args), t);\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    let timer;\\n\\n    return function(...args) {\\n        clearTimeout(timer);\\n\\n        timer = setTimeout(() => fn(...args), t);\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3552034,
                "title": "debounced",
                "content": "# Intuition\\nThe problem requires implementing a debounced version of a function that respects a time interval t. The debounced function should be called with a delay after the last invocation, and if the function is called again within the delay period, the execution should be cancelled and the timer reset.\\n\\n# Approach\\nTo solve this problem, we can use a closure and a set of variables to keep track of the state. Here is the approach:\\n1.\\tCreate a closure function that takes two arguments: fn (the original function to be debounced) and t (the time interval).\\n2.\\tInitialize two variables within the closure: timeout (to track the setTimeout ID) and lastCall (to store the timestamp of the last function call).\\n3.\\tImplement the debounced function within the closure, which takes any number of arguments (...args).\\n4.\\tGet the current time using Date.now().\\n5.\\tCheck if the difference between the current time and lastCall is less than t. If it is, clear the existing timeout to cancel the execution of the function.\\n6.\\tSet the lastCall variable to the current time.\\n7.\\tSet a new timeout using setTimeout to execute the function after the delay period t. Pass the provided arguments ...args to the function.\\n8.\\tIf the debounced function is called again within the delay period, repeat steps 4-7.\\n9.\\tImplement a cleanup function that can be used to cancel the pending execution of the debounced function.\\n10.\\tReturn the debounced function and the cleanup function as an array or an object.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of this implementation depends on the number of function invocations and the time intervals between them. If the invocations are evenly spaced and not too frequent, the time complexity is O(1) because there are no nested loops or iterations. However, if the invocations are very close to each other, the execution time can approach O(n), where n is the number of invocations. The overall time complexity also depends on the execution time of the original function fn.\\n\\n- Space complexity:\\nThe space complexity is O(1) as we are using a constant amount of additional memory to store the variables timeout and lastCall. The closure and debounced function do not create any additional space complexity.\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n  let timeout;\\n  return function(...args) {\\n    clearTimeout(timeout);\\n    timeout = setTimeout(() => {\\n      fn.apply(this, args);\\n    }, t);\\n  };\\n};\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n  let timeout;\\n  return function(...args) {\\n    clearTimeout(timeout);\\n    timeout = setTimeout(() => {\\n      fn.apply(this, args);\\n    }, t);\\n  };\\n};\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3551181,
                "title": "easy-js-solution-using-closure-and-settimeout",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    let timer;\\n    return function(...args) {\\n        let context = this;\\n        if(timer){\\n            clearTimeout(timer);\\n        }\\n        timer = setTimeout(()=> fn.apply(context, args), t);\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    let timer;\\n    return function(...args) {\\n        let context = this;\\n        if(timer){\\n            clearTimeout(timer);\\n        }\\n        timer = setTimeout(()=> fn.apply(context, args), t);\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3548809,
                "title": "js-easy-and-3-line-solution",
                "content": "```\\nvar debounce = function(fn, t) {\\n  let timeout;\\n  return function(...args) {\\n    clearTimeout(timeout);\\n    timeout = setTimeout(() => {\\n      fn(...args)\\n    }, t);\\n  };\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar debounce = function(fn, t) {\\n  let timeout;\\n  return function(...args) {\\n    clearTimeout(timeout);\\n    timeout = setTimeout(() => {\\n      fn(...args)\\n    }, t);\\n  };\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3543122,
                "title": "simple-solution-easy-to-understand-o-1-time-o-1-space",
                "content": "# Complexity\\n- Time complexity: **O(1)**\\n- Space complexity: **O(1)**\\n\\n# Code\\n```\\nvar debounce = function(fn, t) {\\n    let timeoutId;\\n\\n    return function(...args) {\\n        clearTimeout(timeoutId);\\n        timeoutId = setTimeout(() => fn(...args), t);\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar debounce = function(fn, t) {\\n    let timeoutId;\\n\\n    return function(...args) {\\n        clearTimeout(timeoutId);\\n        timeoutId = setTimeout(() => fn(...args), t);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3543085,
                "title": "solution-without-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    let timerId;\\n    return function(...args) {\\n        if (timerId !== null) {\\n            clearTimeout(timerId);\\n        }\\n        timerId = setTimeout(() => fn(...args), t);\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    let timerId;\\n    return function(...args) {\\n        if (timerId !== null) {\\n            clearTimeout(timerId);\\n        }\\n        timerId = setTimeout(() => fn(...args), t);\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3542806,
                "title": "debouncing-in-javascript-js-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    let timer;\\n    return function(...args) {\\n        clearTimeout(timer);\\n        timer=setTimeout(()=>{\\n            fn.apply(this,args);\\n        },t)\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    let timer;\\n    return function(...args) {\\n        clearTimeout(timer);\\n        timer=setTimeout(()=>{\\n            fn.apply(this,args);\\n        },t)\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3542676,
                "title": "easy-javascript-solution",
                "content": "# Approach\\n- Define a variable timeoutId outside the debounced function. This variable will store the timeout ID returned by setTimeout().\\n\\n- Create a function named debounce that takes two parameters: fn (the function to be debounced) and t (the debounce time in milliseconds).\\n\\n- Inside the debounce function, return a new function that will serve as the debounced version of fn. This function will take any number of arguments using the rest parameter syntax (...args).\\n\\n- Within the debounced function, clear the previously set timeout using clearTimeout(timeoutId).\\n\\n- Set a new timeout using setTimeout(). Inside the timeout callback function, call the original function fn with the provided arguments (fn.apply(this, args)). The timeout duration should be the debounce time t.\\n\\n- Store the timeout ID returned by setTimeout() in the timeoutId variable.\\n\\n- Finally, return the debounced function.\\n\\nBy following this approach, the debounced function will delay the execution of the original function by t milliseconds each time it is called. If the debounced function is called again within the debounce time window, the previous timeout will be cleared, and a new timeout will be set.\\n\\nThis ensures that the original function is only executed once, after a certain period of inactivity defined by the debounce time.\\n\\n# Complexity\\n- Time complexity: O(1)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    let timeoutId;\\n    return function(...args) {\\n        clearTimeout(timeoutId);\\n    \\n        timeoutId = setTimeout(() => {\\n        fn.apply(this, args);\\n        }, t);\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    let timeoutId;\\n    return function(...args) {\\n        clearTimeout(timeoutId);\\n    \\n        timeoutId = setTimeout(() => {\\n        fn.apply(this, args);\\n        }, t);\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3542589,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    let id;\\n    return function(...args) {\\n        clearTimeout(id);\\n        id=setTimeout(()=> fn(...args),t);\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    let id;\\n    return function(...args) {\\n        clearTimeout(id);\\n        id=setTimeout(()=> fn(...args),t);\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3542420,
                "title": "simple-easy-explanation-of-debounce-typescript-javascript",
                "content": "# Debounce\\nA `debounced` function is a function whose execution is delayed by `t` milliseconds and whose execution is cancelled if it is called again within that window of time. The `debounced` function should also recieve the passed parameters.\\n\\n![debounce.png](https://assets.leetcode.com/users/images/7cc12fc5-06b2-4b09-a38e-307a71fc072d_1684516834.8978395.png)\\n\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n`Debouncing` is a technique used to limit the frequency of executing a function when it\\'s called repeatedly within a short span of time. The debounce function takes in another function `fn` and a time duration `t` as parameters and returns a new function that wraps the original function with a debouncing mechanism.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. The `debounce` function accepts two parameters: `fn` (the original function to be debounced) and `t` (the time duration in milliseconds).\\n2. Inside the `debounce` function, a variable `id` is declared to keep track of the timer ID.\\n3. The function returns a new function that acts as a wrapper around the original function.\\n4. When the wrapper function is invoked, it first clears any existing timer associated with the `id` by calling `clearTimeout(id)`.\\n5. It then sets a new timer using `setTimeout`. The timer is set to execute the original function after the specified duration `t` has passed.\\n\\n# Use Case\\nThis technique is useful in scenarios where you want to limit the frequency of executing a function, such as handling user input events or API requests.\\n\\n# Code\\n```javascript []\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    let id;\\n    return function(...args) {\\n        clearTimeout(id);\\n        let self = this;\\n        id = setTimeout(() => {\\n            fn.apply(self, args)\\n        }, t)\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```\\n```typescript []\\ntype F = (...p: any[]) => any\\n\\nfunction debounce(fn: F, t: number): F {\\n    let id: any;\\n    return function(...args) {\\n        clearTimeout(id);\\n        let self = this;\\n        id = setTimeout(() => {\\n            fn.apply(self, args)\\n        }, t)\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```javascript []\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    let id;\\n    return function(...args) {\\n        clearTimeout(id);\\n        let self = this;\\n        id = setTimeout(() => {\\n            fn.apply(self, args)\\n        }, t)\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```\n```typescript []\\ntype F = (...p: any[]) => any\\n\\nfunction debounce(fn: F, t: number): F {\\n    let id: any;\\n    return function(...args) {\\n        clearTimeout(id);\\n        let self = this;\\n        id = setTimeout(() => {\\n            fn.apply(self, args)\\n        }, t)\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3542371,
                "title": "beginner-friendly-solution-detailed-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe debounce function can be implemented using a combination of closures and JavaScript\\'s setTimeout and clearTimeout functions. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nStep 1: Variable Initialization\\nDeclare a variable timeout without assigning any value to it. This variable will be used to store the identifier of the timeout set by the setTimeout function.\\n\\nStep 2: Returning the Debounced Function\\nReturn an anonymous function that uses the rest parameter syntax ...args to accept any number of arguments. This function will serve as the debounced function that wraps the original function fn.\\n\\nStep 3: Clearing Existing Timeout\\nInside the anonymous function, call clearTimeout(timeout) to clear any existing timeout that might have been set in previous invocations. This step ensures that only the most recent timeout is executed.\\n\\nStep 4: Setting a New Timeout\\nUsing setTimeout and an arrow function, set a new timeout. The arrow function will be invoked after the specified time duration t. This delay provides a window of time during which subsequent invocations of the debounced function can reset the timeout, effectively postponing the execution.\\n\\nStep 5: Invoking the Original Function\\nInside the arrow function, call the original function fn and pass the arguments received by the debounced function using the spread syntax ...args. This ensures that the original function is executed with the correct arguments after the debounce duration has elapsed.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe debounce function has a time complexity of O(1) for setting and clearing timeouts. The execution of the original function fn is delayed until the debounce duration t has elapsed without any further invocations. This helps in optimizing performance by reducing unnecessary function calls.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the given debounce function is O(1)\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    let timeout;\\n    return function(...args) {\\n        clearTimeout(timeout);  \\n        timeout = setTimeout(() => {fn(...args)}, t);  \\n    };\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    let timeout;\\n    return function(...args) {\\n        clearTimeout(timeout);  \\n        timeout = setTimeout(() => {fn(...args)}, t);  \\n    };\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3542289,
                "title": "typescript-cleartimeout-and-settimeout-every-time-the-function-is-called-runtime-80",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe call setTimeout everytime the function is called, if it was called earlier than `t`, the clearance of the timeoutID stops the previous one, if it is called later, the clearance of the timeoutID has no effect. Either way timeout is always cleared and setTimeout is always called.\\n\\n\\n# Complexity\\n- Time complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```TypeScript\\ntype F = (...p: any[]) => any\\n\\nfunction debounce(fn: F, t: number): F {\\n    // The type of setTimeout return is \"NodeJS.Timeout\" in Node\\n    // and in the browser the type is \"number\"\\n    let timeoutID: NodeJS.Timeout = null;\\n    return function(...args) {\\n        // If the function is already called\\n        // clearing timeout has no effect\\n        if (timeoutID) clearTimeout(timeoutID);\\n        // Always call setTimeout with given t\\n        // no matter when the function is called\\n        timeoutID = setTimeout(() => fn(...args), t);\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```TypeScript\\ntype F = (...p: any[]) => any\\n\\nfunction debounce(fn: F, t: number): F {\\n    // The type of setTimeout return is \"NodeJS.Timeout\" in Node\\n    // and in the browser the type is \"number\"\\n    let timeoutID: NodeJS.Timeout = null;\\n    return function(...args) {\\n        // If the function is already called\\n        // clearing timeout has no effect\\n        if (timeoutID) clearTimeout(timeoutID);\\n        // Always call setTimeout with given t\\n        // no matter when the function is called\\n        timeoutID = setTimeout(() => fn(...args), t);\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3542143,
                "title": "javascript-easy-solution",
                "content": "# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    let interval;\\n    return function(...args) {\\n    const lastCall = Date.now()\\n    clearInterval(interval);\\n    interval = setInterval(() => {\\n      if (Date.now() - lastCall >= t) {\\n        fn(...args);\\n        clearInterval(interval);\\n      }\\n    }, 1);\\n  }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```\\n![UpvoteLeetcode.jpeg](https://assets.leetcode.com/users/images/ebc5ee8e-46e9-4227-b548-d3f361f311a0_1684510218.4058857.jpeg)\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    let interval;\\n    return function(...args) {\\n    const lastCall = Date.now()\\n    clearInterval(interval);\\n    interval = setInterval(() => {\\n      if (Date.now() - lastCall >= t) {\\n        fn(...args);\\n        clearInterval(interval);\\n      }\\n    }, 1);\\n  }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3542077,
                "title": "simple-solution-using-array-with-detailed-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function (fn, t) {\\n   //use this array to store functions called so far \\n  let pendingF = [];\\n  return function (...args) {\\n    let cur = Date.now();\\n\\n    //see if function called in the array has a run time in the future\\n    //if find, cancel the call by calling clearTimeout\\n    for (let obj of pendingF) {\\n      if (obj.start > cur) {\\n        clearTimeout(obj.timeout);\\n      }\\n    }\\n\\n    //delay the function\\n    myTimeout = setTimeout(() => fn(...args), t);\\n\\n    //build timeout id and time to run object and put into that array\\n    pendingF.push({ timeout: myTimeout, start: cur + t });\\n  };\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function (fn, t) {\\n   //use this array to store functions called so far \\n  let pendingF = [];\\n  return function (...args) {\\n    let cur = Date.now();\\n\\n    //see if function called in the array has a run time in the future\\n    //if find, cancel the call by calling clearTimeout\\n    for (let obj of pendingF) {\\n      if (obj.start > cur) {\\n        clearTimeout(obj.timeout);\\n      }\\n    }\\n\\n    //delay the function\\n    myTimeout = setTimeout(() => fn(...args), t);\\n\\n    //build timeout id and time to run object and put into that array\\n    pendingF.push({ timeout: myTimeout, start: cur + t });\\n  };\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3542049,
                "title": "javascript-code-only",
                "content": "\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function (fn, t) {\\n  \\n  let prevTimer; \\n  return function (...args) {\\n    clearTimeout(prevTimer) \\n    prevTimer = setTimeout(()=> { \\n      fn(...args) \\n    }, t)\\n  };\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function (fn, t) {\\n  \\n  let prevTimer; \\n  return function (...args) {\\n    clearTimeout(prevTimer) \\n    prevTimer = setTimeout(()=> { \\n      fn(...args) \\n    }, t)\\n  };\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3542021,
                "title": "day15-simple-js-solution-with-clear-and-settimeout",
                "content": "# Intuition\\nDebounce : Debounce is the Technique for avoiding the simultaneous function calling in given time interval, by the help of debounce only the last call be executed and all the previous calls will be cancelled if simultaneous calls are made in a given interval of time.\\n\\n -  Our task is to execute a function \\n -  If simultanous calls occurs in given interval , we need to carry previous calls.\\n\\n# Approach\\n**Task 1** : To execute a function we with a specific time limit of t ,we will be using set Timeout function .\\n\\n**setTimeout** :\\n - This is the function used for the execution of specific function after some time delay. It is generally used to give a execution delay to the program.\\n - This function Takes Two Argument one the function to be executed and another the time in mili seconds this will be delay to the function between , when function was called and function was executed.\\n\\n**ClearTimeout**:\\n- This function clears a timeout if one running previously\\n- this function takes one argument , i.e. the key of the timeout that has to be cleared.\\n\\n**Steps of Execution**\\n\\n1. First we will be making a variable prevTimer\\n2. This will store the key for the timer is running.\\n3. if the debounce is called it will first clear the prev running timeout and then\\n4. it will start a new timeout for time t\\n5. then it will execute the function fn\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(1)$$\\n\\n- Space complexity:\\n $$O(1)$$\\n\\n# Code\\n```\\nvar debounce = function (fn, t) {\\n  \\n  let prevTimer; \\n  return function (...args) {\\n    clearTimeout(prevTimer) \\n    prevTimer = setTimeout(()=> { \\n      fn(...args) \\n    }, t)\\n  };\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar debounce = function (fn, t) {\\n  \\n  let prevTimer; \\n  return function (...args) {\\n    clearTimeout(prevTimer) \\n    prevTimer = setTimeout(()=> { \\n      fn(...args) \\n    }, t)\\n  };\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3541956,
                "title": "day-15-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n     let timeoutId;\\n    return function(...args) {\\n       clearTimeout(timeoutId);\\n       timeoutId = setTimeout(() => {\\n       fn.apply(this, args);\\n    }, t); \\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n     let timeoutId;\\n    return function(...args) {\\n       clearTimeout(timeoutId);\\n       timeoutId = setTimeout(() => {\\n       fn.apply(this, args);\\n    }, t); \\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3541799,
                "title": "java-script-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nconst debounce = (fn, t) => {\\n  let timeoutId;\\n\\n  return (...args) => {\\n    clearTimeout(timeoutId);\\n\\n    timeoutId = setTimeout(() => {\\n      fn.apply(this, args);\\n    }, t);\\n  };\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nconst debounce = (fn, t) => {\\n  let timeoutId;\\n\\n  return (...args) => {\\n    clearTimeout(timeoutId);\\n\\n    timeoutId = setTimeout(() => {\\n      fn.apply(this, args);\\n    }, t);\\n  };\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3541766,
                "title": "chatgpt-code-snippet",
                "content": "## Intuition\\nDebouncing a function involves delaying its execution until a certain amount of time has passed without any further calls to the function. This technique is useful in scenarios where frequent function calls need to be controlled to prevent unnecessary or redundant executions. In this problem, we are given a function `fn` and a time interval `t`, and we need to implement a debounced version of the function.\\n\\n## Approach\\nTo implement the debounced function, we can use a timer and closures. The idea is to delay the execution of the function `fn` by `t` milliseconds, and if another call to the debounced function is made within that time window, the previous execution is cancelled, and a new timer is set.\\n\\nWe can use a closure to maintain the `timerId` variable, which keeps track of the timer set for the debounced function. When the debounced function is called, we first clear any existing timer using `clearTimeout(timerId)`. Then, we set a new timer using `setTimeout` that executes the debounced function after the specified time `t`. The debounced function (`fn`) is invoked using the `apply` method to preserve the `this` value and pass the arguments (`args`) to the function.\\n\\n## Complexity Analysis\\nLet\\'s analyze the time and space complexity of the solution.\\n\\n- Time Complexity: The time complexity of the debounced function is O(1) because it only performs basic operations like clearing a timer and setting a new timer. The execution time of the debounced function `fn` itself is not included in this complexity analysis.\\n- Space Complexity: The space complexity is O(1) as well. We only use a constant amount of additional space to store the `timerId`.\\n\\n## Code\\nHere is the implementation of the `debounce` function in JavaScript:\\n\\n```javascript\\nvar debounce = function(fn, t) {\\n  let timerId;\\n  \\n  return function(...args) {\\n    clearTimeout(timerId);\\n    \\n    timerId = setTimeout(() => {\\n      fn.apply(this, args);\\n    }, t);\\n  };\\n};\\n```\\n\\nYou can test the `debounce` function with the provided example or customize your own test cases:\\n\\n```javascript\\nconst log = debounce(console.log, 100);\\n\\nlog(\\'Hello\\'); // This call will be cancelled\\nlog(\\'Hello\\'); // This call will be cancelled\\nlog(\\'Hello\\'); // This call will be logged after 100ms\\n```\\n\\nThis implementation of the `debounce` function solves the problem by debouncing the execution of the provided function `fn` based on the specified time interval `t`.\\n\\n---",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar debounce = function(fn, t) {\\n  let timerId;\\n  \\n  return function(...args) {\\n    clearTimeout(timerId);\\n    \\n    timerId = setTimeout(() => {\\n      fn.apply(this, args);\\n    }, t);\\n  };\\n};\\n```\n```javascript\\nconst log = debounce(console.log, 100);\\n\\nlog(\\'Hello\\'); // This call will be cancelled\\nlog(\\'Hello\\'); // This call will be cancelled\\nlog(\\'Hello\\'); // This call will be logged after 100ms\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3541656,
                "title": "easy-solution-debounce-javascript",
                "content": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    let timeout;\\n    return function(...args) {\\n        clearTimeout(timeout)\\n        timeout = setTimeout(() => {\\n            fn(...args)\\n        }, t)\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    let timeout;\\n    return function(...args) {\\n        clearTimeout(timeout)\\n        timeout = setTimeout(() => {\\n            fn(...args)\\n        }, t)\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3541616,
                "title": "easy-solution-in-typescript",
                "content": "# Code\\n```\\ntype F = (...p: any[]) => any\\n\\nfunction debounce(fn: F, t: number): F {\\n    let timeOutID: ReturnType<typeof setTimeout>;\\n    return function(...args) {\\n        clearTimeout(timeOutID);\\n        timeOutID = setTimeout(() => fn(...args), t);\\n    }\\n};",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "# Code\\n```\\ntype F = (...p: any[]) => any\\n\\nfunction debounce(fn: F, t: number): F {\\n    let timeOutID: ReturnType<typeof setTimeout>;\\n    return function(...args) {\\n        clearTimeout(timeOutID);\\n        timeOutID = setTimeout(() => fn(...args), t);\\n    }\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 3541581,
                "title": "easy-way",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    let timer;\\n    return function(...args) {\\n        clearTimeout(timer);\\n        timer = setTimeout(()=>{\\n            fn(...args);\\n        },t)\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    let timer;\\n    return function(...args) {\\n        clearTimeout(timer);\\n        timer = setTimeout(()=>{\\n            fn(...args);\\n        },t)\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3541531,
                "title": "one-liner",
                "content": "\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\n\\nconst debounce = (fn, t, id) => (...args) => \\n    (clearTimeout(id), id = setTimeout(() => fn(...args), t));\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\n\\nconst debounce = (fn, t, id) => (...args) => \\n    (clearTimeout(id), id = setTimeout(() => fn(...args), t));\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3541516,
                "title": "solution",
                "content": "# Code\\n```\\ntype F = (...p: any[]) => any\\n\\nfunction debounce(fn: F, t: number): F {\\n    let timeoutId = null;\\n\\n    return function(...args) {\\n        clearTimeout(timeoutId!);\\n\\n        timeoutId = setTimeout(() => {\\n            fn(...args);\\n        }, t);\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\ntype F = (...p: any[]) => any\\n\\nfunction debounce(fn: F, t: number): F {\\n    let timeoutId = null;\\n\\n    return function(...args) {\\n        clearTimeout(timeoutId!);\\n\\n        timeoutId = setTimeout(() => {\\n            fn(...args);\\n        }, t);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3541482,
                "title": "easy-solution-o-1",
                "content": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    let timer;\\n    return function(...args) {\\n        clearTimeout(timer);\\n        timer = setTimeout(() => { fn(...args); }, t);\\n    };\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    let timer;\\n    return function(...args) {\\n        clearTimeout(timer);\\n        timer = setTimeout(() => { fn(...args); }, t);\\n    };\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3541380,
                "title": "beat-93-with-simple-way",
                "content": "# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    let delay = null;\\n    return function(...args) {\\n        if(delay!==null) {\\n            clearTimeout(delay);\\n        }\\n        delay = setTimeout(() => fn(...args), t);\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    let delay = null;\\n    return function(...args) {\\n        if(delay!==null) {\\n            clearTimeout(delay);\\n        }\\n        delay = setTimeout(() => fn(...args), t);\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3541344,
                "title": "solution-typescript-javascript",
                "content": "# Code\\n``` typescript []\\ntype F = (...p: any[]) => any\\n\\nfunction debounce(fn: F, t: number): F {\\n    let timeout: NodeJS.Timeout | undefined;\\n    return function(...args) {\\n        if (timeout) {\\n            clearTimeout(timeout);\\n        }\\n        timeout = setTimeout(() => fn(...args), t);\\n    }\\n};\\n```\\n``` javascript []\\nvar debounce = function(fn, t) {\\n    let timeout;\\n    return function(...args) {\\n        if (timeout) {\\n            clearTimeout(timeout);\\n        }\\n        timeout = setTimeout(() => fn(...args), t);\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "``` typescript []\\ntype F = (...p: any[]) => any\\n\\nfunction debounce(fn: F, t: number): F {\\n    let timeout: NodeJS.Timeout | undefined;\\n    return function(...args) {\\n        if (timeout) {\\n            clearTimeout(timeout);\\n        }\\n        timeout = setTimeout(() => fn(...args), t);\\n    }\\n};\\n```\n``` javascript []\\nvar debounce = function(fn, t) {\\n    let timeout;\\n    return function(...args) {\\n        if (timeout) {\\n            clearTimeout(timeout);\\n        }\\n        timeout = setTimeout(() => fn(...args), t);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3541271,
                "title": "js-easy-solved",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n\\n    let time = null;\\n\\n    return function(...args) {\\n        if(time){\\n            clearTimeout(time);\\n            time = null;\\n        }\\n\\n        time = setTimeout(()=> {\\n            return fn(...args);\\n        }, t)\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n\\n    let time = null;\\n\\n    return function(...args) {\\n        if(time){\\n            clearTimeout(time);\\n            time = null;\\n        }\\n\\n        time = setTimeout(()=> {\\n            return fn(...args);\\n        }, t)\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3541256,
                "title": "the-simplest-solution-you-could-come-up-with",
                "content": "# Intuition\\nFirst of all we need to clear the execution of the previous function. Since we know that the id that setTimeout returns is positive. We could initialize it as the negative and when it would be not negative we would clear its timeout.\\n\\n# Complexity\\n- Time complexity: $O(1)$\\n\\n- Space complexity: $O(1)$\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    let timeout = -1;\\n    return function(...args) {\\n        if (timeout != -1) {\\n            clearTimeout(timeout);\\n        }\\n        timeout = setTimeout(() => fn(...args), t);\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    let timeout = -1;\\n    return function(...args) {\\n        if (timeout != -1) {\\n            clearTimeout(timeout);\\n        }\\n        timeout = setTimeout(() => fn(...args), t);\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3541214,
                "title": "easiest-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- A timer is set using setTimeout, in the returned function. \\n- It is initially set to $$t$$ milliseconds.\\n- The clearTimeout function is called to reset the timer to $$t$$ milliseconds, every time when the returned function is called.\\n- The timer\\'s callback function will execute, once the timer has elapsed without making the call to the returned function.\\n- $$fn$$ along with the passed arguments will be called by the callback function.\\n\\n\\n# Code\\n``` javaScript []\\nvar debounce = function(fn, t) {\\n    let timeoutID = 0;\\n    return function(...args) {\\n        clearTimeout(timeoutID);\\n        timeoutID = setTimeout(() => fn(...args), t);\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` javaScript []\\nvar debounce = function(fn, t) {\\n    let timeoutID = 0;\\n    return function(...args) {\\n        clearTimeout(timeoutID);\\n        timeoutID = setTimeout(() => fn(...args), t);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3541144,
                "title": "easy-js-solution",
                "content": "\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n  let timeout;\\n  return function(...args) {\\n    clearTimeout(timeout);\\n    timeout = setTimeout(() => {\\n      fn(...args)\\n    }, t);\\n  };\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n  let timeout;\\n  return function(...args) {\\n    clearTimeout(timeout);\\n    timeout = setTimeout(() => {\\n      fn(...args)\\n    }, t);\\n  };\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3541057,
                "title": "easy-solution-with-comments",
                "content": "# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    \\n    let interval; // Define global variable\\n\\n    return function(...args) {\\n        \\n        clearTimeout(interval); // Clear timeout function if exists\\n\\n        //Add new timeout function with given time\\n        interval = setTimeout(() => {\\n            fn.apply(this,args); // Run given function with given arguments\\n        },t);\\n\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    \\n    let interval; // Define global variable\\n\\n    return function(...args) {\\n        \\n        clearTimeout(interval); // Clear timeout function if exists\\n\\n        //Add new timeout function with given time\\n        interval = setTimeout(() => {\\n            fn.apply(this,args); // Run given function with given arguments\\n        },t);\\n\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3540986,
                "title": "debounce-javascript-solution",
                "content": "# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t){\\n    let temp;\\n    return function(...args) {\\n        clearTimeout(temp);\\n\\n        temp=setTimeout(()=>{\\n            fn(...args);\\n        },t);\\n        \\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t){\\n    let temp;\\n    return function(...args) {\\n        clearTimeout(temp);\\n\\n        temp=setTimeout(()=>{\\n            fn(...args);\\n        },t);\\n        \\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3540984,
                "title": "debounce-easy-solution-with-explanation",
                "content": "# Intuition\\nThe problem here is to create a debounce function, a fundamental concept used to limit the rate at which a function gets invoked. Debouncing is particularly useful for events that can be triggered rapidly and repetitively, such as scrolling, resizing, keypresses etc. The goal is to wait until there\\'s a pause in the event triggering, and only then to execute the function.\\n\\n# Approach\\nTo solve this problem, we will utilize JavaScript\\'s built-in setTimeout and clearTimeout functions.\\n\\nHere\\'s a basic idea of how the function works:\\n\\n- We declare a variable timeoutId to hold our timeout, it\\'s initially not set.\\n- When the function is invoked, we first clear the timeout, cancelling the previously scheduled function call (if it exists).\\n- Then we set up a new timeout to call the function after t milliseconds. The function is called with the context and arguments preserved, using the apply method.\\n- If the function is invoked again before the timeout has passed, the previous timeout is cleared and a new one is set.\\n- If the function is not called again before the timeout, then the function is invoked after the timeout has passed.\\n\\n# Complexity\\n- Time complexity: $$O(1)$$\\nThe time complexity of the debounce function is constant because we are only invoking a single function, regardless of the input size.\\n\\n- Space complexity: $$O(1)$$\\nThe space complexity is also constant because we\\'re only storing the timeoutId and the function parameters. The number of parameters does not affect the number of timeouts, as each call to the debounce function only schedules one timeout.\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar debounce = function (fn, t) {\\n  let timeoutId;\\n\\n  return function (...args) {\\n    clearTimeout(timeoutId);\\n\\n    timeoutId = setTimeout(() => {\\n      fn.apply(this, args);\\n    }, t);\\n  };\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar debounce = function (fn, t) {\\n  let timeoutId;\\n\\n  return function (...args) {\\n    clearTimeout(timeoutId);\\n\\n    timeoutId = setTimeout(() => {\\n      fn.apply(this, args);\\n    }, t);\\n  };\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3540943,
                "title": "beginner-friendly-js-solution",
                "content": "# Intuition\\n`setTimeout()` might come handy \\uD83E\\uDD14\\n\\n# Approach\\n`setTimeout()` delays the code execution so we can use that, but we also need to keep track of old timerIds, as we need to cancel those before creating the new one, so here the concept will be helpful. We can create a variable timerId which will store the timerId returned by setTimeout() last time. \\n\\nSo next time we call the function again the old timer gets cleared first and then only the new one is set. \\uD83D\\uDE07\\n\\n# Complexity\\n- Time complexity:\\n$$O(1)$$ \\n\\n- Space complexity:\\n$$O(1)$$ \\n\\n![image.png](https://assets.leetcode.com/users/images/cf09c28c-14f5-4509-8920-0d4ddfa57e57_1684482160.9929914.png)\\n\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n\\tlet timerId = \\'\\';\\n    return function(...args) {\\n        clearTimeout(timerId);\\n\\t\\ttimerId = setTimeout(()=> fn(...args),t);\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n\\tlet timerId = \\'\\';\\n    return function(...args) {\\n        clearTimeout(timerId);\\n\\t\\ttimerId = setTimeout(()=> fn(...args),t);\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3540937,
                "title": "js-timeout-time-63ms-44-space-41mb-94",
                "content": "# Approach\\nThe debonced function will call the original function after a specified timeout. And since this timeout can be overwritten, we have to remember it to be able to clear and write over it.\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    // remember any timeout associated with the fn\\n    let timeout;\\n    \\n    // create new debounced function\\n    return function(...args) {\\n        // clear previous timeout if any\\n        clearTimeout(timeout);\\n        // set new timeout\\n        timeout = setTimeout(() => {\\n            fn(...args);\\n        }, t);\\n    };\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    // remember any timeout associated with the fn\\n    let timeout;\\n    \\n    // create new debounced function\\n    return function(...args) {\\n        // clear previous timeout if any\\n        clearTimeout(timeout);\\n        // set new timeout\\n        timeout = setTimeout(() => {\\n            fn(...args);\\n        }, t);\\n    };\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3540924,
                "title": "easy-single-variable-js-soltuion-using-settimeout-and-cleartimeout",
                "content": "Code uses timerId variable to keep track of previous time out Id.\\n\\nBefore creating a new timeout, the code checks if there is an existing timerId value (meaning there is an ongoing timeout). If so, it clears the previous timeout using clearTimeout to cancel it.\\n\\nThe timerId is updated with the new timeout ID, ensuring that only the most recent timeout will be executed.\\n\\n```\\nvar debounce = function(fn, t) {\\n    let timerId;\\n    return function(...args) {\\n        const id = setTimeout(()=>fn(...args),t);\\n        if(timerId !== undefined)\\n            clearTimeout(timerId);\\n        timerId = id; \\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar debounce = function(fn, t) {\\n    let timerId;\\n    return function(...args) {\\n        const id = setTimeout(()=>fn(...args),t);\\n        if(timerId !== undefined)\\n            clearTimeout(timerId);\\n        timerId = id; \\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3540891,
                "title": "line-solution-typescript-bind",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntype F = (...p: any[]) => any\\n\\nfunction debounce(fn: F, t: number): F {\\n    let lastExecuationId = -1;\\n    return function(...args) {\\n        clearTimeout(lastExecuationId);\\n        lastExecuationId = Number(setTimeout(fn.bind(null, ...args), t));\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype F = (...p: any[]) => any\\n\\nfunction debounce(fn: F, t: number): F {\\n    let lastExecuationId = -1;\\n    return function(...args) {\\n        clearTimeout(lastExecuationId);\\n        lastExecuationId = Number(setTimeout(fn.bind(null, ...args), t));\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3540834,
                "title": "simplest-solution-debounce-settimeout",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    let timer\\n    return function(...args) {\\n        clearTimeout(timer)\\n        timer = setTimeout(()=>{\\n            fn.call(this, ...args)\\n        }, t)\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    let timer\\n    return function(...args) {\\n        clearTimeout(timer)\\n        timer = setTimeout(()=>{\\n            fn.call(this, ...args)\\n        }, t)\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3540782,
                "title": "javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nconst debounce = function(fn, t) {\\n  let timer = null\\n    return function(...args) {\\n        clearTimeout(timer)\\n      timer = setTimeout(() => {\\n        fn(...args)\\n      }, t)\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nconst debounce = function(fn, t) {\\n  let timer = null\\n    return function(...args) {\\n        clearTimeout(timer)\\n      timer = setTimeout(() => {\\n        fn(...args)\\n      }, t)\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3540738,
                "title": "javascript-simplest-solution",
                "content": "\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    let id;\\n    return function(...args) {\\n        clearTimeout(id);\\n        id = setTimeout(() => fn(...args),t); \\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    let id;\\n    return function(...args) {\\n        clearTimeout(id);\\n        id = setTimeout(() => fn(...args),t); \\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3540624,
                "title": "javascript-timeout",
                "content": "# Intuition\\nUse a timeout.\\n\\n# Approach\\nThe function sets a timeout which executes the given function after the given delay. The timeout ID is saved to a variable called currentlyExecuting. If the function is called again then the currently-executing timeout is cleared before another timeout is created for the new function call.\\n\\n# Complexity\\n- Time complexity: O(1)\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nvar debounce = function(fn, t) {\\n    let timeoutId;\\n    return function(...args) {\\n        clearTimeout(timeoutId);\\n        timeoutId = setTimeout(() => {\\n            fn(...args)\\n        }, t);\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar debounce = function(fn, t) {\\n    let timeoutId;\\n    return function(...args) {\\n        clearTimeout(timeoutId);\\n        timeoutId = setTimeout(() => {\\n            fn(...args)\\n        }, t);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3540612,
                "title": "easy-and-sort-solution",
                "content": "\\n```\\nvar debounce = function(fn, t) {\\n    let timeout;\\n    return function(...args) {\\n        clearTimeout(timeout);\\n        timeout = setTimeout(() => {\\n            fn(...args)\\n        }, t)\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar debounce = function(fn, t) {\\n    let timeout;\\n    return function(...args) {\\n        clearTimeout(timeout);\\n        timeout = setTimeout(() => {\\n            fn(...args)\\n        }, t)\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3540567,
                "title": "debouncing-functions-silencing-the-chaos-of-rapid-calls",
                "content": "# Intuition\\nTo prevent rapid and frequent executions of a function by introducing a delay.\\n\\nWhen a debounced function is called, it sets a timer to delay the execution of the original function by a specified time interval (in milliseconds). If the debounced function is called again before the timer expires, the previous timer is cleared and a new timer is set. This effectively restarts the timer, ensuring that the original function is only executed after a specific quiet period.\\n\\nThis behavior is useful in scenarios where you want to optimize performance or control the rate of function execution. For example, in event handling, you may debounce a function that updates the UI based on user input. By debouncing the function, you can prevent excessive updates and improve the overall responsiveness of the application.\\n\\nThe debounce function can be implemented using JavaScript\\'s setTimeout and clearTimeout functions. By keeping track of the timer ID in a closure, the debounce function can effectively cancel and restart the timer as needed.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nDeclare a variable (timerId) inside the debounce function to store the timer ID.\\nReturn a new function that will be the debounced version of the original function.\\nInside the debounced function, clear any existing timer using clearTimeout(timerId).\\nSet a new timer using setTimeout to delay the execution of the original function.\\nAssign the timer ID to the timerId variable for tracking.\\nWhen the timer expires, execute the original function with the provided arguments.\\nOptionally, handle the correct context (this) for the original function using apply or call.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity : O(fn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : O(fn)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvar debounce = function(fn, t) {\\n    let timerId = null;\\n  \\n    return function(...args) {\\n        clearTimeout(timerId);\\n      \\n        timerId = setTimeout(() => {\\n            fn.apply(this, args);\\n        }, t);\\n    };\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar debounce = function(fn, t) {\\n    let timerId = null;\\n  \\n    return function(...args) {\\n        clearTimeout(timerId);\\n      \\n        timerId = setTimeout(() => {\\n            fn.apply(this, args);\\n        }, t);\\n    };\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3540550,
                "title": "javascript-with-comments-beginner-friendly",
                "content": "# Code\\n```\\n// Explanation: Store all timeouts in a singe key, for each new call,\\n// clear previous timeout add set new timeout\\n\\nvar debounce = function(fn, t) {\\n    let key; // Address of setTimeout function\\n    return function(...args) {\\n        if(key) clearTimeout(key); // Cancel previous setTimeout if any\\n        key = setTimeout(() => fn(...args), t) // setTimeout\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// Explanation: Store all timeouts in a singe key, for each new call,\\n// clear previous timeout add set new timeout\\n\\nvar debounce = function(fn, t) {\\n    let key; // Address of setTimeout function\\n    return function(...args) {\\n        if(key) clearTimeout(key); // Cancel previous setTimeout if any\\n        key = setTimeout(() => fn(...args), t) // setTimeout\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3540549,
                "title": "day-15-solution-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n  let interval;\\n  return function(...args) {\\n    const lastCall = Date.now()\\n    clearInterval(interval);\\n    interval = setInterval(() => {\\n      if (Date.now() - lastCall >= t) {\\n        fn(...args);\\n        clearInterval(interval);\\n      }\\n    }, 1);\\n  }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n  let interval;\\n  return function(...args) {\\n    const lastCall = Date.now()\\n    clearInterval(interval);\\n    interval = setInterval(() => {\\n      if (Date.now() - lastCall >= t) {\\n        fn(...args);\\n        clearInterval(interval);\\n      }\\n    }, 1);\\n  }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3540505,
                "title": "settimeout-arrow-function-and-closure",
                "content": "\\n# Code\\n```\\ntype F = (...p: any[]) => any\\n\\nfunction debounce(fn: F, t: number): F {\\n    let timer:ReturnType<typeof setTimeout>;\\n    return function(...args) {\\n        if(timer){\\n            clearTimeout(timer);\\n        }\\n        timer = setTimeout(() => {\\n            fn(...args)\\n        }, t)\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype F = (...p: any[]) => any\\n\\nfunction debounce(fn: F, t: number): F {\\n    let timer:ReturnType<typeof setTimeout>;\\n    return function(...args) {\\n        if(timer){\\n            clearTimeout(timer);\\n        }\\n        timer = setTimeout(() => {\\n            fn(...args)\\n        }, t)\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3540492,
                "title": "using-cleartimeout-timeoutid-and-apply-thisargs-argsarray",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nif the function was called initially then it might have an id timeoutId so if it had the id initially then delete the setTimeout(of that timeoutId);\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nusing clearTimeout(timeoutId);\\n\\n# --> apply function\\nIn JavaScript, the apply() method is a function method that allows you to call a function with a given this value and an array or array-like object as arguments.\\n\\nThe apply() method is used to invoke a function with a specified this value and an array (or an array-like object) of arguments. It takes two main parameters:\\n\\nThe this value: The value to be used as the this object inside the function when it is executed.\\nArguments array (or array-like object): An array or array-like object containing the arguments to be passed to the function.\\n\\n# Syntax\\n```\\n    function.apply(thisArg, [argsArray])\\n```\\n\\n# --> clearTimeout\\nIn JavaScript, clearTimeout() is a function that cancels a timeout previously set with the setTimeout() function. It clears the scheduled execution of a function specified by the timeout ID, preventing it from running.\\n\\nWhen you create a timeout using setTimeout(), it returns a unique timeout ID that represents the scheduled task. This ID is used by clearTimeout() to identify and cancel the associated timeout.\\n\\n# Syntax\\n```\\nconst timeoutID = setTimeout(() => {\\n  console.log(\\'Timeout function executed\\');\\n}, 3000);\\n\\n// ...later in the code, before the timeout expires\\nclearTimeout(timeoutID);\\n```\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    let timeoutId;\\n    return function(...args) {\\n        clearTimeout(timeoutId);\\n        timeoutId = setTimeout(() => {\\n            fn.apply(this, args);\\n        }, t);\\n    };\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n    function.apply(thisArg, [argsArray])\\n```\n```\\nconst timeoutID = setTimeout(() => {\\n  console.log(\\'Timeout function executed\\');\\n}, 3000);\\n\\n// ...later in the code, before the timeout expires\\nclearTimeout(timeoutID);\\n```\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    let timeoutId;\\n    return function(...args) {\\n        clearTimeout(timeoutId);\\n        timeoutId = setTimeout(() => {\\n            fn.apply(this, args);\\n        }, t);\\n    };\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3540486,
                "title": "js-solution-using-async-await-and-settimeout-cleartimeout",
                "content": "```\\nvar debounce = function(fn, t) {\\n    let result;\\n    return async function(...args) {\\n        if(typeof result !== \\'undefined\\') clearTimeout(result);\\n        result = await setTimeout(() => fn(...args), t);\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar debounce = function(fn, t) {\\n    let result;\\n    return async function(...args) {\\n        if(typeof result !== \\'undefined\\') clearTimeout(result);\\n        result = await setTimeout(() => fn(...args), t);\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3540477,
                "title": "javascript-and-typescript-solutiions",
                "content": "**Javascript Solution**\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function (fn, t) {\\n  let timer; // to store previous setTimeout key\\n  return function (...args) {\\n    clearTimeout(timer); // clear any previously existing timer\\n    timer = setTimeout(() => {\\n      // start a new timer to call after `t` time\\n      fn(...args); // call the function\\n    }, t);\\n  };\\n};\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n\\n```\\n\\n**Typescript Solution**\\n```\\ntype F = (...p: any[]) => any\\n\\nfunction debounce(fn: F, t: number): F {\\n  let timer: ReturnType<typeof setTimeout>; // to store previous setTimeout key\\n  return function (...args) {\\n    clearTimeout(timer); // clear any previously existing timer\\n    timer = setTimeout(() => {\\n      // start a new timer to call after `t` time\\n        // console.log(typeof(timer))\\n      fn(...args); // call the function\\n    }, t);\\n  };\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function (fn, t) {\\n  let timer; // to store previous setTimeout key\\n  return function (...args) {\\n    clearTimeout(timer); // clear any previously existing timer\\n    timer = setTimeout(() => {\\n      // start a new timer to call after `t` time\\n      fn(...args); // call the function\\n    }, t);\\n  };\\n};\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n\\n```\n```\\ntype F = (...p: any[]) => any\\n\\nfunction debounce(fn: F, t: number): F {\\n  let timer: ReturnType<typeof setTimeout>; // to store previous setTimeout key\\n  return function (...args) {\\n    clearTimeout(timer); // clear any previously existing timer\\n    timer = setTimeout(() => {\\n      // start a new timer to call after `t` time\\n        // console.log(typeof(timer))\\n      fn(...args); // call the function\\n    }, t);\\n  };\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3540431,
                "title": "easy-javascript-solution-full-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind the debouncing technique is to control the execution of a function based on a specified time window.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach to solving the debouncing problem is as follows:\\n\\n1. Create a debounced function that takes the original function fn and the debounce time t as input.\\n2. Return a new function that will serve as the debounced version of the original function.\\n3. Inside the debounced function, initialize a timeout variable.\\n4. When the debounced function is called, clear the previous timeout.\\n5. Set a new timeout to execute the original function after t milliseconds.\\n6. Pass any provided arguments to the original function.\\n7. The debounced function effectively delays the execution of the original function and cancels it if called again within the specified time window.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n     let timeoutId = null;\\n    return function(...args) {\\n        clearTimeout(timeoutId);\\n\\n    timeoutId = setTimeout(() => {\\n      fn.apply(this, args);\\n    }, t); \\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n     let timeoutId = null;\\n    return function(...args) {\\n        clearTimeout(timeoutId);\\n\\n    timeoutId = setTimeout(() => {\\n      fn.apply(this, args);\\n    }, t); \\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3540426,
                "title": "easy-javascript-solution-using-settimeout",
                "content": "# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    let timeout;\\n    return function(...args) {\\n        clearTimeout(timeout)\\n        timeout =  setTimeout(()=>{\\n            fn(...args)\\n        },t)\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    let timeout;\\n    return function(...args) {\\n        clearTimeout(timeout)\\n        timeout =  setTimeout(()=>{\\n            fn(...args)\\n        },t)\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3540351,
                "title": "javascript-simple-solution-using-settimeout-with-explaination",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe function is called after `t` milliseconds so `setTimeout` is the best way to do it.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing `setTimeout` to execute the function after `t` milliseconds. The `setTimeout` function returns an `id`. When that function is called again within `t` milliseconds (even if it\\'s not, calling `clearTimeout` is fine because the function has already been executed), pass that `id` to `clearTimeout` to cancel prevent the function from executing.\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    let id\\n    return function(...args) {\\n        clearTimeout(id)\\n        id = setTimeout(() => fn(...args), t)\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    let id\\n    return function(...args) {\\n        clearTimeout(id)\\n        id = setTimeout(() => fn(...args), t)\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3540336,
                "title": "using-js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    let timeout = null;\\n    return function(...args) {\\n        clearTimeout(timeout);\\n        timeout = setTimeout(fn, t, ...args);\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    let timeout = null;\\n    return function(...args) {\\n        clearTimeout(timeout);\\n        timeout = setTimeout(fn, t, ...args);\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3540332,
                "title": "time-settimeout",
                "content": "\\n\\n\\n# Complexity\\n- Time complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} time milliseconds\\n * @return {Function}\\n */\\n\\nvar debounce = function (fn, time = 300, a = false, context = null) {\\n    let timer; // to see the timeout\\n\\n    return function (...args) {\\n        const executeFn = function () {\\n            fn.apply(context || this, args); \\n        };\\n\\n        if (a && !timer) {\\n            executeFn(); // immediately execute the function\\n        }\\n\\n        clearTimeout(timer); // the previous timeout if it exists\\n\\n        timer = setTimeout(function () {\\n            timer = null; // reset \\n\\n            if (!a) {\\n                executeFn(); // If \\'a\\' is false, execute the function after the specified timeout\\n            }\\n        }, time);\\n    };\\n};\\n\\n// TC :- o(1)\\n// SC :- o(1)\\n\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} time milliseconds\\n * @return {Function}\\n */\\n\\nvar debounce = function (fn, time = 300, a = false, context = null) {\\n    let timer; // to see the timeout\\n\\n    return function (...args) {\\n        const executeFn = function () {\\n            fn.apply(context || this, args); \\n        };\\n\\n        if (a && !timer) {\\n            executeFn(); // immediately execute the function\\n        }\\n\\n        clearTimeout(timer); // the previous timeout if it exists\\n\\n        timer = setTimeout(function () {\\n            timer = null; // reset \\n\\n            if (!a) {\\n                executeFn(); // If \\'a\\' is false, execute the function after the specified timeout\\n            }\\n        }, time);\\n    };\\n};\\n\\n// TC :- o(1)\\n// SC :- o(1)\\n\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3540321,
                "title": "easy-solution-settimeout-cleartimeout-approach",
                "content": "# Complexity\\n- Time complexity:O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    let timer = null;\\n    return function(...args) {\\n        clearTimeout(timer);\\n        timer = setTimeout(() => fn(...args),t)        \\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    let timer = null;\\n    return function(...args) {\\n        clearTimeout(timer);\\n        timer = setTimeout(() => fn(...args),t)        \\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3540299,
                "title": "settimeout-cleartimeout-closure-solution-typescript",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCreate refrence of the setTimeout function, so that next time the function is called if the reference exists you can clear it.\\n\\n# Code\\n```\\ntype F = (...p: any[]) => any\\n\\nfunction debounce(fn: F, t: number): F {\\n    var ref = null;\\n    return function (...args) {\\n        if (ref)\\n            clearTimeout(ref);\\n        ref = setTimeout(() => {\\n                fn(...args);\\n            }, t);\\n    }\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype F = (...p: any[]) => any\\n\\nfunction debounce(fn: F, t: number): F {\\n    var ref = null;\\n    return function (...args) {\\n        if (ref)\\n            clearTimeout(ref);\\n        ref = setTimeout(() => {\\n                fn(...args);\\n            }, t);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3540263,
                "title": "simple-timeout-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    let time;\\n    return function(...args) {\\n        clearTimeout(time);\\n        time=setTimeout(()=>{\\n            fn(...args)\\n        },t);\\n    };\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    let time;\\n    return function(...args) {\\n        clearTimeout(time);\\n        time=setTimeout(()=>{\\n            fn(...args)\\n        },t);\\n    };\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3540233,
                "title": "2627-debounce-let-s-discuss-the-problem-solution",
                "content": "The **debounce** function takes two arguments: a function and a duration in milliseconds. The function will be called only once after the specified duration has passed since the last time it was called.\\n\\nThe first line of the function defines a variable called **timer**. This variable will be used to store a reference to the timer object.\\n\\nThe next line of the function returns a new function. This new function will be called when the user calls the **debounce** function.\\n\\nThe body of the new function contains two statements. The first statement calls the **clearTimeout** function to clear any existing timer. The second statement calls the **setTimeout** function to create a new timer. The new timer will be set to fire after the specified duration has passed.\\n\\nWhen the timer fires, it will call the original function. The original function will be called with the same arguments that were passed to the **debounce** function.\\n\\n# Code snippet\\n```\\nvar debouncedSearch = debounce(search, 500);\\n\\nfunction search(query) {\\n  // Do something with the query.\\n}\\n\\ndocument.getElementById(\"search\").addEventListener(\"click\", debouncedSearch);\\n\\n```\\n\\nIn this example, the **debouncedSearch** function will be called when the user clicks on the \"Search\" button. However, the search function will only be called once after 500 milliseconds have passed since the last time the user clicked on the button.\\n\\nDebouncing can be used to improve the performance of your code by preventing a function from being called too frequently. For example, you could use debounce to prevent a function from being called every time the user moves the mouse.\\n\\nHope this helps you to understand the Problem More !!",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nvar debouncedSearch = debounce(search, 500);\\n\\nfunction search(query) {\\n  // Do something with the query.\\n}\\n\\ndocument.getElementById(\"search\").addEventListener(\"click\", debouncedSearch);\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3540225,
                "title": "day-15-easy-solution-in-js",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    let timer;\\n    return function(...args) {\\n        clearTimeout(timer);\\n        timer=setTimeout(()=>fn(...args),t);\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    let timer;\\n    return function(...args) {\\n        clearTimeout(timer);\\n        timer=setTimeout(()=>fn(...args),t);\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3540191,
                "title": "simple-typescript-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nKeep track of the previous call\\'s `timeoutID`, and cancel if it is pointing at a `timeoutID`\\n\\n# Code\\n```typescript\\ntype F = (...p: any[]) => any\\n\\nfunction debounce(fn: F, t: number): F {\\n    let timeout: NodeJS.Timeout = null;\\n    return function(...args) {\\n        if (timeout != null) {\\n            clearTimeout(timeout);\\n        }\\n        timeout = setTimeout(() => {\\n            fn(...args);\\n            timeout = null;\\n        }, t);\\n    }\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```typescript\\ntype F = (...p: any[]) => any\\n\\nfunction debounce(fn: F, t: number): F {\\n    let timeout: NodeJS.Timeout = null;\\n    return function(...args) {\\n        if (timeout != null) {\\n            clearTimeout(timeout);\\n        }\\n        timeout = setTimeout(() => {\\n            fn(...args);\\n            timeout = null;\\n        }, t);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3540174,
                "title": "usefulness-of-debounce-js-solution",
                "content": "## Problem Topic\\n\\n### Debounce\\n\\nIn situations where we want to control the frequencies of of function executions, in response to events, such as, user interactions or rapid changes\\n\\nIn these situations but not limited to only these , debouncing can be useful:\\n\\n### Scroll event or resizing window\\n\\n- Infinite scrolling\\n    - Debouncing the scroll event handle, when we implement infinite scrolling within an web application, allows us to load additional content when the user has stopped scrolling or reached their desired position. This will  prevent multiple rapid requests for content with much more smooth scrolling experience\\n- Response layout reszing\\n    - Debouning layout resizing function ensures us that it will only trigger the window resize event after the user finishes resizing the  windows viewport. This helps prevent excessive and unnecessary layout recalculations during changes being made, which help optimze web application performances\\n\\n### Handling User Input\\n\\n- Search Functionality\\n    - Debouncing search function to only trigger the search request only after the user has finished typing or pausing for a short duration. This prevents the search function from executing on every keystroke being types in, which provides a smooth user search experience and reducing rapid API calls\\n\\n### Optimization for API Calls\\n\\n- Search API requests\\n    - Search functionalities often have API calls being made where user requests their desired output. Debouncing API request being made to fetch search results ensures that requests are only sent after the user has paused typing or is submitting the search query. It helps prevent frequent and unnecessary API calls during rapid typing\\n- Sorting and filtering API request\\n    - Sorting and filtering functionalities also often relies on API calls being called. Debouncing, can be used to delay the execution of the request until the user has finished typing or selecting its desired requests. This also optimized the number of API calls being made.\\n\\n### Handling Events\\n\\n- Clicking buttons\\n    - Handling button clicks with debounce can be very useful, especially in cases where rapid clicks may cause unintended behaviors or duplicated actions as it helps ensure that actions are only executed only once, after a brief delay or immediately, which helps prevent double clicks\\n- Form submissions\\n    - If a user clicks on the submit button multiple of times very quickly, debouncing can prevent multiple form submissions, which helps ensure that the form is only being submitted once, regardless of the number of times the submit button is being clicked on\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, delay) {\\n    let timeoutID ;\\n    return function(...args) {\\n        clearTimeout(timeoutID)\\n        timeoutID = setTimeout(() => {\\n            fn(...args)\\n        }, delay)\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```\\n## Example\\n\\nUsing the above debounced code, we can create a more optimized web application \\n\\n- Search API requests\\n\\n```jsx\\nlet searchRequestDebounce = debounce(function(searchQuery) {\\n  console.log(\"search query request:\", searchQuery);\\n}, 100);\\n\\nfunction handleSearchChanges(event) {\\n  var searchQuery = event.target.value;\\n  searchRequestDebounce(searchQuery);\\n}\\n\\nlet searchInput = document.getElementById(\"search-input\");\\nsearchInput.addEventListener(\"input\", handleSearchChanges);\\n```\\n\\n### Time Complexity: O(1)\\n### Space Complexity: O(1)",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, delay) {\\n    let timeoutID ;\\n    return function(...args) {\\n        clearTimeout(timeoutID)\\n        timeoutID = setTimeout(() => {\\n            fn(...args)\\n        }, delay)\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```\n```jsx\\nlet searchRequestDebounce = debounce(function(searchQuery) {\\n  console.log(\"search query request:\", searchQuery);\\n}, 100);\\n\\nfunction handleSearchChanges(event) {\\n  var searchQuery = event.target.value;\\n  searchRequestDebounce(searchQuery);\\n}\\n\\nlet searchInput = document.getElementById(\"search-input\");\\nsearchInput.addEventListener(\"input\", handleSearchChanges);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3540145,
                "title": "3-lines-solution",
                "content": "# Code\\n```\\ntype F = (...p: any[]) => any\\n\\nfunction debounce(fn: F, t: number): F {\\n    let timeout: NodeJS.Timeout \\n\\n    return function(...args) {\\n      if (timeout) clearTimeout(timeout)\\n      timeout = setTimeout(() => { fn(...args) }, t)\\n    }\\n}\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype F = (...p: any[]) => any\\n\\nfunction debounce(fn: F, t: number): F {\\n    let timeout: NodeJS.Timeout \\n\\n    return function(...args) {\\n      if (timeout) clearTimeout(timeout)\\n      timeout = setTimeout(() => { fn(...args) }, t)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3540123,
                "title": "javascript-easy-solution",
                "content": "The code provided demonstrates the implementation of a basic debounce function in JavaScript. Let\\'s go through the code and explain its functionality:\\n\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n  let timer;\\n\\n  return function(...args) {\\n    clearTimeout(timer);\\n    timer = setTimeout(() => {\\n      fn(...args);\\n    }, t);\\n  };\\n};\\n```\\n\\nThis code defines a function named debounce that takes two parameters: fn (a function) and t (a time duration in milliseconds). It returns a new function that will be used as a debounced version of the original function.\\n\\nWithin the returned function, a local variable named timer is declared to keep track of the timeout associated with the debouncing mechanism.\\n\\nWhenever the returned function is invoked (with any number of arguments), it first clears any existing timeout by calling clearTimeout(timer). This ensures that if the function is called within the specified time duration (t), the previous timeout is canceled.\\n\\nNext, a new timeout is set using setTimeout. It calls the provided function fn(...args) after the specified time duration (t).\\n\\nHere\\'s an example usage of the debounce function:\\n\\n```\\nconst log = debounce(console.log, 100);\\nlog(\\'Hello\\'); // Cancelled\\nlog(\\'Hello\\'); // Cancelled\\nlog(\\'Hello\\'); // Logged at t=100ms\\n```\\n\\nIn this example, console.log is passed as the original function fn, and 100 is passed as the debounce time t. The returned function is assigned to the variable log.\\n\\nWhen log(\\'Hello\\') is called three times in rapid succession, the first two calls are canceled because each subsequent call resets the timeout. The third call triggers the execution of console.log(\\'Hello\\') after a delay of 100 milliseconds, effectively debouncing the function call.\\n\\nAs a result, only one log statement will be executed after the debounce time has passed, preventing the excessive execution of the original function in scenarios where events occur rapidly.",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n  let timer;\\n\\n  return function(...args) {\\n    clearTimeout(timer);\\n    timer = setTimeout(() => {\\n      fn(...args);\\n    }, t);\\n  };\\n};\\n```\n```\\nconst log = debounce(console.log, 100);\\nlog(\\'Hello\\'); // Cancelled\\nlog(\\'Hello\\'); // Cancelled\\nlog(\\'Hello\\'); // Logged at t=100ms\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3540065,
                "title": "typescript-solution",
                "content": "```\\ntype F = (...p: any[]) => any\\n\\nfunction debounce(fn: F, t: number): F {\\n    let timeoutId: ReturnType<typeof setTimeout>\\n    \\n    return function(...args) {\\n        if (timeoutId) {\\n            clearTimeout(timeoutId)\\n        }\\n        \\n        timeoutId = setTimeout(() => fn(...args), t)\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\ntype F = (...p: any[]) => any\\n\\nfunction debounce(fn: F, t: number): F {\\n    let timeoutId: ReturnType<typeof setTimeout>\\n    \\n    return function(...args) {\\n        if (timeoutId) {\\n            clearTimeout(timeoutId)\\n        }\\n        \\n        timeoutId = setTimeout(() => fn(...args), t)\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3540019,
                "title": "only-use-cleartimeout",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe global clearTimeout() method cancels a timeout previously established by calling setTimeout().\\n\\nIf the parameter provided does not identify a previously established action, this method does nothing.\\n\\nSyntax\\n```\\nclearTimeout(timeoutID)\\n```\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nWe only need to store the timeoutID in the closure scope, so that we can cancel in the next call.\\n\\n\\n# Code\\n```\\n\\nvar debounce = function(fn, t) {\\n    let timeoutID = null ;\\n    return function(...args) {\\n        clearTimeout(timeoutID);\\n        timeoutID = setTimeout(()=>fn(...args), t);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclearTimeout(timeoutID)\\n```\n```\\n\\nvar debounce = function(fn, t) {\\n    let timeoutID = null ;\\n    return function(...args) {\\n        clearTimeout(timeoutID);\\n        timeoutID = setTimeout(()=>fn(...args), t);\\n    }\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3539997,
                "title": "day-15-javascript-typescript",
                "content": "# Code - JS\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n  let interval;\\n  return function(...args) {\\n    const lastCall = Date.now()\\n    clearInterval(interval);\\n    interval = setInterval(() => {\\n      if (Date.now() - lastCall >= t) {\\n        fn(...args);\\n        clearInterval(interval);\\n      }\\n    }, 1);\\n  }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```\\n# TS\\n```\\ntype F = (...p: any[]) => any\\n\\nfunction debounce(fn: F, t: number): F {\\n  let timeout;\\n  return function(...args) {\\n    clearTimeout(timeout);\\n    timeout = setTimeout(() => {\\n      fn(...args)\\n    }, t);\\n  };\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n  let interval;\\n  return function(...args) {\\n    const lastCall = Date.now()\\n    clearInterval(interval);\\n    interval = setInterval(() => {\\n      if (Date.now() - lastCall >= t) {\\n        fn(...args);\\n        clearInterval(interval);\\n      }\\n    }, 1);\\n  }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```\n```\\ntype F = (...p: any[]) => any\\n\\nfunction debounce(fn: F, t: number): F {\\n  let timeout;\\n  return function(...args) {\\n    clearTimeout(timeout);\\n    timeout = setTimeout(() => {\\n      fn(...args)\\n    }, t);\\n  };\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3539994,
                "title": "day-15",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    let timeout;\\n\\n  return function (...args) {\\n    clearTimeout(timeout);\\n    timeout = setTimeout(() => {\\n      fn.apply(this, args);\\n    }, t);\\n  };\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    let timeout;\\n\\n  return function (...args) {\\n    clearTimeout(timeout);\\n    timeout = setTimeout(() => {\\n      fn.apply(this, args);\\n    }, t);\\n  };\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3527659,
                "title": "perform-this-important-optimization-to-minimize-runtime-and-memory-usage",
                "content": "**Set the timeoutId to `null` when the timeout resolves to avoid unnecessary `clearTimeout` calls.**\\n\\n```javascript\\nvar debounce = function(fn, t) {\\n    let timeoutId = null;\\n    return function(...args) {\\n        if(timeoutId !== null) {\\n            clearTimeout(timeoutId);\\n        }\\n        timeoutId = setTimeout(() => {\\n            timeoutId = null;\\n            fn(...args);\\n        }, t);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nvar debounce = function(fn, t) {\\n    let timeoutId = null;\\n    return function(...args) {\\n        if(timeoutId !== null) {\\n            clearTimeout(timeoutId);\\n        }\\n        timeoutId = setTimeout(() => {\\n            timeoutId = null;\\n            fn(...args);\\n        }, t);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3518667,
                "title": "ts-with-ref-solution",
                "content": "# Code\\n```\\ntype F = (...p: any[]) => any;\\n\\nfunction debounce(fn: F, t: number): F {\\n  const ref = { val: null };\\n  return function (...args) {\\n    clearTimeout(ref.val);\\n    ref.val = setTimeout(fn, t, ...args);\\n  }\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype F = (...p: any[]) => any;\\n\\nfunction debounce(fn: F, t: number): F {\\n  const ref = { val: null };\\n  return function (...args) {\\n    clearTimeout(ref.val);\\n    ref.val = setTimeout(fn, t, ...args);\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3517553,
                "title": "ts-wrapper-settimeout-49ms-42-5mb",
                "content": "Another function easily set with a wrapper, like we did for a few other JS kata; also check the sibling challenge of creating a [throttled function](https://leetcode.com/problems/throttle/) ([cracked here](https://leetcode.com/problems/throttle/solutions/3517718/)).\\n\\nThis one in particular is a classic and while most people would just import it from a library, it is good to know how things work under the hood.\\n\\nIn a rather simple fashion, similar to what we did to [allow one function call](https://leetcode.com/problems/allow-one-function-call/) ([solved here](https://leetcode.com/problems/allow-one-function-call/solutions/3502193/)), we will create a variable outside the wrapper we are going to `return`; this variable, `timeout`, will store the id of the timeout we are about to create; its first value will be `undefined`.\\n\\nIn our wrapper function, we will, take the usual indefinite amount of parameters `args` with the rest operator, then:\\n* if a `timeout` value exist, we will cancel said timeout with `clearTimeout`;\\n* set a new `timeout` value, as the `return` value of a call to `setTimeout` invokved with a call back that will just execute `fn` with `...args` after `t` milliseconds.\\n\\n# Complexity\\n- Time complexity: $$O(1)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```ts\\ntype F = (...p: any[]) => any\\n\\nconst debounce = (fn: F, t: number): F => {\\n    let timeout = undefined;\\n    return (...args) => {\\n        if (timeout) clearTimeout(timeout);\\n        timeout = setTimeout(() => fn(...args), t);\\n    }\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```ts\\ntype F = (...p: any[]) => any\\n\\nconst debounce = (fn: F, t: number): F => {\\n    let timeout = undefined;\\n    return (...args) => {\\n        if (timeout) clearTimeout(timeout);\\n        timeout = setTimeout(() => fn(...args), t);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3510028,
                "title": "easy-fast-javascript",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    let handle = 0;\\n\\n    return function(...args) {\\n        clearTimeout(handle);\\n        handle = setTimeout(() => fn(...args), t);\\n    }\\n};\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    let handle = 0;\\n\\n    return function(...args) {\\n        clearTimeout(handle);\\n        handle = setTimeout(() => fn(...args), t);\\n    }\\n};\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3503494,
                "title": "debouncing-function-in-javascript-with-explanation-and-implementation",
                "content": "# Intuition\\nThe debounce function takes a function and a time interval as arguments, and returns a new function that can be used in place of the original function. When the new function is called, it sets a timeout to execute the original function after the specified time interval has passed. If the new function is called again before the timeout has expired, the previous timeout is cleared and a new one is set.\\n\\n# Approach\\nThe debounce function uses the setTimeout method to execute the original function after the specified time interval has elapsed. To ensure that the previous timeout is cleared if the new function is called again before the timeout has expired, the clearTimeout method is used.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of the debounce function is O(1), since setting and clearing timeouts are both constant time operations.\\n- Space complexity:\\nThe space complexity of the debounce function is also O(1), since it only stores a reference to the timeout in the timer variable.\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    let timer = null;\\n    return function(...args) {\\n        clearTimeout(timer);\\n        timer = setTimeout(()=>fn(...args), t);\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    let timer = null;\\n    return function(...args) {\\n        clearTimeout(timer);\\n        timer = setTimeout(()=>fn(...args), t);\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3503360,
                "title": "easy-solution-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t = 1000) {\\n    let timer;\\n    return function(...args) {\\n        clearTimeout(timer);\\n        timer = setTimeout(() => fn(...args), t);\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t = 1000) {\\n    let timer;\\n    return function(...args) {\\n        clearTimeout(timer);\\n        timer = setTimeout(() => fn(...args), t);\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3497675,
                "title": "easiest-javascript-solution",
                "content": "# Intuition\\nUse debounce function of the loadash library\\n\\n# Approach\\nreturn the function wrapped inside the debounce function.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    return _.debounce((...args) => {\\n        fn(...args);\\n    }, t);\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    return _.debounce((...args) => {\\n        fn(...args);\\n    }, t);\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3492903,
                "title": "2627-debounce",
                "content": "# How to solve it:\\nTo create a debounced function, we can use setTimeout and clearTimeout methods. We will declare a variable to store the timer id created by setTimeout and check if it has a value before creating a new setTimeout. If the debounced function is called again before the timer expires, we will reset the timer with a new setTimeout, canceling the previous one. Finally, when the timer expires, we will execute the original function with the provided parameters.\\n\\nWe use the spread operator (...) to pass all arguments to the debounced function. The apply method is used to call the original function with the correct context and parameters. When the timer expires, we set timerId to null to indicate that the function can be called again.\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    let timerId;\\n    return function(...args) {\\n        if (timerId) {\\n            clearTimeout(timerId);\\n        }\\n        timerId = setTimeout(() => {\\n            fn.apply(this, args);\\n            timerId = null;\\n        }, t);\\n    }\\n};\\n\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    let timerId;\\n    return function(...args) {\\n        if (timerId) {\\n            clearTimeout(timerId);\\n        }\\n        timerId = setTimeout(() => {\\n            fn.apply(this, args);\\n            timerId = null;\\n        }, t);\\n    }\\n};\\n\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3491924,
                "title": "clean-code-explained-javascript",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- define a timer\\n- clearTimeout of timer if debounce function is called before delayed time t (initially timer is undefined).\\n- setTimeout for timer again\\n- timer will excute fn after time t.\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    let timer;\\n    return function(...args) {\\n        // clear timer if function is called before delay time t..\\n        clearTimeout(timer);\\n\\n        // set new timer..\\n        timer = setTimeout( () => {fn.apply(this, args)}, t )\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    let timer;\\n    return function(...args) {\\n        // clear timer if function is called before delay time t..\\n        clearTimeout(timer);\\n\\n        // set new timer..\\n        timer = setTimeout( () => {fn.apply(this, args)}, t )\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3491619,
                "title": "debounced-function-explained-0-1",
                "content": "# Intuition\\nThe provided code implements a debounced function that delays the execution of a given function by a specified amount of time `t`. If the debounced function is called again within that time window, the previous execution is cancelled. The debounced function retains the latest set of parameters passed to it.\\n\\n# Approach\\nThe implementation uses a closure mechanism and the `setTimeout` function to achieve the debouncing behavior. The debounce function takes the original function func and the time delay wait as parameters and returns a new debounced function.\\n\\nThe debounced function stores a `timeoutId variable`, initially set to `null`, to keep track of the timer. When the debounced function is called, it clears any existing timer using `clearTimeout`. It then sets a new timer using `setTimeout`, which delays the execution of the original function by wait milliseconds. After the specified time has passed, the original function is invoked with the latest set of parameters using func.`apply(this, args)`.\\n\\nIf the debounced function is called again within the time window while the timer is still active, the previous timer is cleared, and a new timer is set, effectively restarting the time window. This `cancellation` and resetting of the timer ensure that the debounced function execution is delayed and only occurs when there is a pause in calling the function within the specified time.The implementation uses a `closure mechanism` and the `setTimeout` function to achieve the debouncing behavior. The debounce function takes the original function func and the time delay wait as parameters and returns a new debounced function.\\n\\nThe debounced function stores a `timeoutId variable`, initially set to `null`, to keep track of the timer. When the debounced function is called, it clears any existing timer using `clearTimeout`. It then sets a new timer using `setTimeout`, which delays the execution of the original function by wait milliseconds. After the specified time has passed, the original function is invoked with the latest set of parameters using func.`apply(this, args)`.\\n\\nIf the debounced function is called again within the time window while the timer is still active, the previous timer is cleared, and a new timer is set, effectively restarting the time window. This cancellation and resetting of the timer ensure that the debounced function execution is delayed and only occurs when there is a pause in calling the function within the specified time.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of the debounced function is `O(1)` for each call. The function clears and sets a timer using clearTimeout and setTimeout, respectively, which are both constant time operations. The execution of the original function func occurs once the timer expires.\\n\\n- Space complexity:\\nThe space complexity of the debounced function is `O(1)` as well. It only requires a constant amount of space to store the timeoutId variable and the inner function itself. The space usage remains constant regardless of the number of function calls made.\\n\\n# Code\\n```\\n\\n/**\\n * @param {Function} func\\n * @param {number} wait\\n */\\nfunction debounce(func, wait) {\\n  // your code here\\n  let timeoutId = null;\\n\\n  return function(...args) {\\n    const later = () => {\\n      timeoutId = null;\\n      func.apply(this, args);\\n    }\\n    \\n    clearTimeout(timeoutId);\\n    timeoutId = setTimeout(later, wait);\\n  }\\n}\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\n/**\\n * @param {Function} func\\n * @param {number} wait\\n */\\nfunction debounce(func, wait) {\\n  // your code here\\n  let timeoutId = null;\\n\\n  return function(...args) {\\n    const later = () => {\\n      timeoutId = null;\\n      func.apply(this, args);\\n    }\\n    \\n    clearTimeout(timeoutId);\\n    timeoutId = setTimeout(later, wait);\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3486507,
                "title": "ts-js-timeout-solution-clear-explanation",
                "content": "## Explanation\\n- At first I had a hard time understanding the probalem description so I will try to reiterate the important points\\n- Our function `fn` can be called at any time\\n- When called, this function\\'s exectution needs to be delayed by vairable `t`\\n- If the `fn` is called again before the delay of a previous call has ran out, that previous call should be canceled.\\n- This can be achieved using the `setTimeout` and `clearTimeout` functions\\n- \"The global `setTimeout()` method sets a timer which executes a function or specified piece of code once the timer expires.\"\\n- The global `clearTimeout()` method cancels a timeout previously established by calling `setTimeout()`\\n- When a `fn` is called, we delay its execution by `t` using setTimeout\\n- We store this id in `timeoutId `\\n- If fn is called again and `timeoutId` is not null, we cancel that previous function call and `setTimeout` again\\n\\n## Code\\n```javascript []\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\n\\nvar debounce = function(fn, t) {\\n    let timeoutId = null\\n    return function(...args) {\\n        if (timeoutId){\\n            clearTimeout(timeoutId)\\n            timeoutId = null\\n        }\\n        timeoutId = setTimeout(function(){\\n            return fn(...args)\\n        }, t);\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```\\n```typescript []\\ntype F = (...p: any[]) => any\\n\\nfunction debounce(fn: F, t: number): F {\\n    let timeoutId = null\\n    return function(...args) {\\n        if (timeoutId){\\n            clearTimeout(timeoutId)\\n            timeoutId = null\\n        }\\n        timeoutId = setTimeout(function(){\\n            return fn(...args)\\n        }, t);\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```javascript []\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\n\\nvar debounce = function(fn, t) {\\n    let timeoutId = null\\n    return function(...args) {\\n        if (timeoutId){\\n            clearTimeout(timeoutId)\\n            timeoutId = null\\n        }\\n        timeoutId = setTimeout(function(){\\n            return fn(...args)\\n        }, t);\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```\n```typescript []\\ntype F = (...p: any[]) => any\\n\\nfunction debounce(fn: F, t: number): F {\\n    let timeoutId = null\\n    return function(...args) {\\n        if (timeoutId){\\n            clearTimeout(timeoutId)\\n            timeoutId = null\\n        }\\n        timeoutId = setTimeout(function(){\\n            return fn(...args)\\n        }, t);\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3478473,
                "title": "debounce",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    let id = null;\\n    return function(...args) {\\n        clearTimeout(id);\\n        let self = this;\\n        id = setTimeout(() => {\\n            fn.apply(self, args)\\n        }, t)\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    let id = null;\\n    return function(...args) {\\n        clearTimeout(id);\\n        let self = this;\\n        id = setTimeout(() => {\\n            fn.apply(self, args)\\n        }, t)\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3466447,
                "title": "solution-with-explanation",
                "content": "Given:\\n- We have to return a function.\\n\\nApproach:\\n- We keep a variable `timer` that keeps count of time passed.\\n- Next we return a function, which has access to the `timer` function, thanks to `closure`.\\n- This returned function will be what runs if the client does not intervene till `timer` has passed thanks to `setTimeout`.\\n- If the client intervenes, the timer is reset and set to `t`.\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    let timer;\\n    return (...args) => {\\n        clearTimeout(timer);\\n        timer = setTimeout(() => {\\n            fn(...args)\\n        }, t)\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t milliseconds\\n * @return {Function}\\n */\\nvar debounce = function(fn, t) {\\n    let timer;\\n    return (...args) => {\\n        clearTimeout(timer);\\n        timer = setTimeout(() => {\\n            fn(...args)\\n        }, t)\\n    }\\n};\\n\\n/**\\n * const log = debounce(console.log, 100);\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // cancelled\\n * log(\\'Hello\\'); // Logged at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1862213,
                "content": [
                    {
                        "username": "vadya-coder",
                        "content": "Personally, it was too easy for me. Accordingly, I would put it on the EASY level. The difficulty was only in understanding the task. I spent about 4 minutes on the task."
                    },
                    {
                        "username": "cortadordeunha666",
                        "content": "[@cortadordeunha666](/cortadordeunha666) nvm"
                    },
                    {
                        "username": "cortadordeunha666",
                        "content": "[@vadya-coder](/vadya-coder) I know about clearTimeout, I just dont know why there\\'s the need of return a function and if I really need to use setTimeout"
                    },
                    {
                        "username": "vadya-coder",
                        "content": "[@cortadordeunha666](/cortadordeunha666) Try reading about clearTimeout \\uD83D\\uDE09"
                    },
                    {
                        "username": "cortadordeunha666",
                        "content": "it took you 4 minutes? lol, it\\'s been 2 hours and I\\'m still stuck, guess that I\\'m just stupid."
                    },
                    {
                        "username": "aaachris1820",
                        "content": "I had a hard time understanding the cancellation happens if two consecutive calls happens inside the time t"
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "Debouncing comes under the advance concept in js."
                    },
                    {
                        "username": "Vegeta_",
                        "content": "This can be moved to easy. For medium, a new problem with title Debounce ii would be good and in the new problem, options like leading and trailing can be added to raise the difficulty"
                    },
                    {
                        "username": "khe1154",
                        "content": "agreed, adding `trailing` and `leading` option would good up followup"
                    },
                    {
                        "username": "JayPokale",
                        "content": "Very Easy but useful concept of JavaScript."
                    },
                    {
                        "username": "Nogaroid",
                        "content": "When I tested my code with Run if failed on the 2nd testcase. My ouput was [{\"t\":69,\"inputs\":[1]},{\"t\":119,\"inputs\":[2]}], only 1t off the output in the problem description, but the expected output in the testcase was [{\"t\":86,\"inputs\":[1]},{\"t\":124,\"inputs\":[2]}], 4t off what's written in the description. However, my code was accepted when I submitted it. \\_()_/"
                    },
                    {
                        "username": "dimple27",
                        "content": "Why it is green (test case passed) even value is different for t? \\uD83E\\uDD14  \\n` for input: 20\\n                  [{\"t\":50,\"inputs\":[1]},{\"t\":100,\"inputs\":[2]}]\\n\\noutput:       [{\"t\":70,\"inputs\":[1]},{\"t\":119,\"inputs\":[2]}]\\nexpected:  [{\"t\":69,\"inputs\":[1]},{\"t\":120,\"inputs\":[2]}]\\n` "
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day15 : Done Solving Today\\'s Question .\\n\\n\\n\\nHint : Try to use Clear Timeout And Set Timeout Functions"
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "I was overthinking the solution. In the description, multiple functions were used to explain the concept of debouncing. Notice, however, that the test cases only call a single function multiple time. That is to say that we only need to worry about cancelling one function (unlike the \"Cache with Time Limit\" problem where we needed to keep a cache to store the timeouts of multiple functions). "
                    },
                    {
                        "username": "cortadordeunha666",
                        "content": "yes, I didn\\'t notice that it was the funtion inside the closure that was being invocked, not the closure itself."
                    }
                ]
            },
            {
                "id": 1902077,
                "content": [
                    {
                        "username": "vadya-coder",
                        "content": "Personally, it was too easy for me. Accordingly, I would put it on the EASY level. The difficulty was only in understanding the task. I spent about 4 minutes on the task."
                    },
                    {
                        "username": "cortadordeunha666",
                        "content": "[@cortadordeunha666](/cortadordeunha666) nvm"
                    },
                    {
                        "username": "cortadordeunha666",
                        "content": "[@vadya-coder](/vadya-coder) I know about clearTimeout, I just dont know why there\\'s the need of return a function and if I really need to use setTimeout"
                    },
                    {
                        "username": "vadya-coder",
                        "content": "[@cortadordeunha666](/cortadordeunha666) Try reading about clearTimeout \\uD83D\\uDE09"
                    },
                    {
                        "username": "cortadordeunha666",
                        "content": "it took you 4 minutes? lol, it\\'s been 2 hours and I\\'m still stuck, guess that I\\'m just stupid."
                    },
                    {
                        "username": "aaachris1820",
                        "content": "I had a hard time understanding the cancellation happens if two consecutive calls happens inside the time t"
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "Debouncing comes under the advance concept in js."
                    },
                    {
                        "username": "Vegeta_",
                        "content": "This can be moved to easy. For medium, a new problem with title Debounce ii would be good and in the new problem, options like leading and trailing can be added to raise the difficulty"
                    },
                    {
                        "username": "khe1154",
                        "content": "agreed, adding `trailing` and `leading` option would good up followup"
                    },
                    {
                        "username": "JayPokale",
                        "content": "Very Easy but useful concept of JavaScript."
                    },
                    {
                        "username": "Nogaroid",
                        "content": "When I tested my code with Run if failed on the 2nd testcase. My ouput was [{\"t\":69,\"inputs\":[1]},{\"t\":119,\"inputs\":[2]}], only 1t off the output in the problem description, but the expected output in the testcase was [{\"t\":86,\"inputs\":[1]},{\"t\":124,\"inputs\":[2]}], 4t off what's written in the description. However, my code was accepted when I submitted it. \\_()_/"
                    },
                    {
                        "username": "dimple27",
                        "content": "Why it is green (test case passed) even value is different for t? \\uD83E\\uDD14  \\n` for input: 20\\n                  [{\"t\":50,\"inputs\":[1]},{\"t\":100,\"inputs\":[2]}]\\n\\noutput:       [{\"t\":70,\"inputs\":[1]},{\"t\":119,\"inputs\":[2]}]\\nexpected:  [{\"t\":69,\"inputs\":[1]},{\"t\":120,\"inputs\":[2]}]\\n` "
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day15 : Done Solving Today\\'s Question .\\n\\n\\n\\nHint : Try to use Clear Timeout And Set Timeout Functions"
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "I was overthinking the solution. In the description, multiple functions were used to explain the concept of debouncing. Notice, however, that the test cases only call a single function multiple time. That is to say that we only need to worry about cancelling one function (unlike the \"Cache with Time Limit\" problem where we needed to keep a cache to store the timeouts of multiple functions). "
                    },
                    {
                        "username": "cortadordeunha666",
                        "content": "yes, I didn\\'t notice that it was the funtion inside the closure that was being invocked, not the closure itself."
                    }
                ]
            },
            {
                "id": 1899283,
                "content": [
                    {
                        "username": "vadya-coder",
                        "content": "Personally, it was too easy for me. Accordingly, I would put it on the EASY level. The difficulty was only in understanding the task. I spent about 4 minutes on the task."
                    },
                    {
                        "username": "cortadordeunha666",
                        "content": "[@cortadordeunha666](/cortadordeunha666) nvm"
                    },
                    {
                        "username": "cortadordeunha666",
                        "content": "[@vadya-coder](/vadya-coder) I know about clearTimeout, I just dont know why there\\'s the need of return a function and if I really need to use setTimeout"
                    },
                    {
                        "username": "vadya-coder",
                        "content": "[@cortadordeunha666](/cortadordeunha666) Try reading about clearTimeout \\uD83D\\uDE09"
                    },
                    {
                        "username": "cortadordeunha666",
                        "content": "it took you 4 minutes? lol, it\\'s been 2 hours and I\\'m still stuck, guess that I\\'m just stupid."
                    },
                    {
                        "username": "aaachris1820",
                        "content": "I had a hard time understanding the cancellation happens if two consecutive calls happens inside the time t"
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "Debouncing comes under the advance concept in js."
                    },
                    {
                        "username": "Vegeta_",
                        "content": "This can be moved to easy. For medium, a new problem with title Debounce ii would be good and in the new problem, options like leading and trailing can be added to raise the difficulty"
                    },
                    {
                        "username": "khe1154",
                        "content": "agreed, adding `trailing` and `leading` option would good up followup"
                    },
                    {
                        "username": "JayPokale",
                        "content": "Very Easy but useful concept of JavaScript."
                    },
                    {
                        "username": "Nogaroid",
                        "content": "When I tested my code with Run if failed on the 2nd testcase. My ouput was [{\"t\":69,\"inputs\":[1]},{\"t\":119,\"inputs\":[2]}], only 1t off the output in the problem description, but the expected output in the testcase was [{\"t\":86,\"inputs\":[1]},{\"t\":124,\"inputs\":[2]}], 4t off what's written in the description. However, my code was accepted when I submitted it. \\_()_/"
                    },
                    {
                        "username": "dimple27",
                        "content": "Why it is green (test case passed) even value is different for t? \\uD83E\\uDD14  \\n` for input: 20\\n                  [{\"t\":50,\"inputs\":[1]},{\"t\":100,\"inputs\":[2]}]\\n\\noutput:       [{\"t\":70,\"inputs\":[1]},{\"t\":119,\"inputs\":[2]}]\\nexpected:  [{\"t\":69,\"inputs\":[1]},{\"t\":120,\"inputs\":[2]}]\\n` "
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day15 : Done Solving Today\\'s Question .\\n\\n\\n\\nHint : Try to use Clear Timeout And Set Timeout Functions"
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "I was overthinking the solution. In the description, multiple functions were used to explain the concept of debouncing. Notice, however, that the test cases only call a single function multiple time. That is to say that we only need to worry about cancelling one function (unlike the \"Cache with Time Limit\" problem where we needed to keep a cache to store the timeouts of multiple functions). "
                    },
                    {
                        "username": "cortadordeunha666",
                        "content": "yes, I didn\\'t notice that it was the funtion inside the closure that was being invocked, not the closure itself."
                    }
                ]
            },
            {
                "id": 1877337,
                "content": [
                    {
                        "username": "vadya-coder",
                        "content": "Personally, it was too easy for me. Accordingly, I would put it on the EASY level. The difficulty was only in understanding the task. I spent about 4 minutes on the task."
                    },
                    {
                        "username": "cortadordeunha666",
                        "content": "[@cortadordeunha666](/cortadordeunha666) nvm"
                    },
                    {
                        "username": "cortadordeunha666",
                        "content": "[@vadya-coder](/vadya-coder) I know about clearTimeout, I just dont know why there\\'s the need of return a function and if I really need to use setTimeout"
                    },
                    {
                        "username": "vadya-coder",
                        "content": "[@cortadordeunha666](/cortadordeunha666) Try reading about clearTimeout \\uD83D\\uDE09"
                    },
                    {
                        "username": "cortadordeunha666",
                        "content": "it took you 4 minutes? lol, it\\'s been 2 hours and I\\'m still stuck, guess that I\\'m just stupid."
                    },
                    {
                        "username": "aaachris1820",
                        "content": "I had a hard time understanding the cancellation happens if two consecutive calls happens inside the time t"
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "Debouncing comes under the advance concept in js."
                    },
                    {
                        "username": "Vegeta_",
                        "content": "This can be moved to easy. For medium, a new problem with title Debounce ii would be good and in the new problem, options like leading and trailing can be added to raise the difficulty"
                    },
                    {
                        "username": "khe1154",
                        "content": "agreed, adding `trailing` and `leading` option would good up followup"
                    },
                    {
                        "username": "JayPokale",
                        "content": "Very Easy but useful concept of JavaScript."
                    },
                    {
                        "username": "Nogaroid",
                        "content": "When I tested my code with Run if failed on the 2nd testcase. My ouput was [{\"t\":69,\"inputs\":[1]},{\"t\":119,\"inputs\":[2]}], only 1t off the output in the problem description, but the expected output in the testcase was [{\"t\":86,\"inputs\":[1]},{\"t\":124,\"inputs\":[2]}], 4t off what's written in the description. However, my code was accepted when I submitted it. \\_()_/"
                    },
                    {
                        "username": "dimple27",
                        "content": "Why it is green (test case passed) even value is different for t? \\uD83E\\uDD14  \\n` for input: 20\\n                  [{\"t\":50,\"inputs\":[1]},{\"t\":100,\"inputs\":[2]}]\\n\\noutput:       [{\"t\":70,\"inputs\":[1]},{\"t\":119,\"inputs\":[2]}]\\nexpected:  [{\"t\":69,\"inputs\":[1]},{\"t\":120,\"inputs\":[2]}]\\n` "
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day15 : Done Solving Today\\'s Question .\\n\\n\\n\\nHint : Try to use Clear Timeout And Set Timeout Functions"
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "I was overthinking the solution. In the description, multiple functions were used to explain the concept of debouncing. Notice, however, that the test cases only call a single function multiple time. That is to say that we only need to worry about cancelling one function (unlike the \"Cache with Time Limit\" problem where we needed to keep a cache to store the timeouts of multiple functions). "
                    },
                    {
                        "username": "cortadordeunha666",
                        "content": "yes, I didn\\'t notice that it was the funtion inside the closure that was being invocked, not the closure itself."
                    }
                ]
            },
            {
                "id": 1898742,
                "content": [
                    {
                        "username": "vadya-coder",
                        "content": "Personally, it was too easy for me. Accordingly, I would put it on the EASY level. The difficulty was only in understanding the task. I spent about 4 minutes on the task."
                    },
                    {
                        "username": "cortadordeunha666",
                        "content": "[@cortadordeunha666](/cortadordeunha666) nvm"
                    },
                    {
                        "username": "cortadordeunha666",
                        "content": "[@vadya-coder](/vadya-coder) I know about clearTimeout, I just dont know why there\\'s the need of return a function and if I really need to use setTimeout"
                    },
                    {
                        "username": "vadya-coder",
                        "content": "[@cortadordeunha666](/cortadordeunha666) Try reading about clearTimeout \\uD83D\\uDE09"
                    },
                    {
                        "username": "cortadordeunha666",
                        "content": "it took you 4 minutes? lol, it\\'s been 2 hours and I\\'m still stuck, guess that I\\'m just stupid."
                    },
                    {
                        "username": "aaachris1820",
                        "content": "I had a hard time understanding the cancellation happens if two consecutive calls happens inside the time t"
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "Debouncing comes under the advance concept in js."
                    },
                    {
                        "username": "Vegeta_",
                        "content": "This can be moved to easy. For medium, a new problem with title Debounce ii would be good and in the new problem, options like leading and trailing can be added to raise the difficulty"
                    },
                    {
                        "username": "khe1154",
                        "content": "agreed, adding `trailing` and `leading` option would good up followup"
                    },
                    {
                        "username": "JayPokale",
                        "content": "Very Easy but useful concept of JavaScript."
                    },
                    {
                        "username": "Nogaroid",
                        "content": "When I tested my code with Run if failed on the 2nd testcase. My ouput was [{\"t\":69,\"inputs\":[1]},{\"t\":119,\"inputs\":[2]}], only 1t off the output in the problem description, but the expected output in the testcase was [{\"t\":86,\"inputs\":[1]},{\"t\":124,\"inputs\":[2]}], 4t off what's written in the description. However, my code was accepted when I submitted it. \\_()_/"
                    },
                    {
                        "username": "dimple27",
                        "content": "Why it is green (test case passed) even value is different for t? \\uD83E\\uDD14  \\n` for input: 20\\n                  [{\"t\":50,\"inputs\":[1]},{\"t\":100,\"inputs\":[2]}]\\n\\noutput:       [{\"t\":70,\"inputs\":[1]},{\"t\":119,\"inputs\":[2]}]\\nexpected:  [{\"t\":69,\"inputs\":[1]},{\"t\":120,\"inputs\":[2]}]\\n` "
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day15 : Done Solving Today\\'s Question .\\n\\n\\n\\nHint : Try to use Clear Timeout And Set Timeout Functions"
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "I was overthinking the solution. In the description, multiple functions were used to explain the concept of debouncing. Notice, however, that the test cases only call a single function multiple time. That is to say that we only need to worry about cancelling one function (unlike the \"Cache with Time Limit\" problem where we needed to keep a cache to store the timeouts of multiple functions). "
                    },
                    {
                        "username": "cortadordeunha666",
                        "content": "yes, I didn\\'t notice that it was the funtion inside the closure that was being invocked, not the closure itself."
                    }
                ]
            },
            {
                "id": 2063539,
                "content": [
                    {
                        "username": "vadya-coder",
                        "content": "Personally, it was too easy for me. Accordingly, I would put it on the EASY level. The difficulty was only in understanding the task. I spent about 4 minutes on the task."
                    },
                    {
                        "username": "cortadordeunha666",
                        "content": "[@cortadordeunha666](/cortadordeunha666) nvm"
                    },
                    {
                        "username": "cortadordeunha666",
                        "content": "[@vadya-coder](/vadya-coder) I know about clearTimeout, I just dont know why there\\'s the need of return a function and if I really need to use setTimeout"
                    },
                    {
                        "username": "vadya-coder",
                        "content": "[@cortadordeunha666](/cortadordeunha666) Try reading about clearTimeout \\uD83D\\uDE09"
                    },
                    {
                        "username": "cortadordeunha666",
                        "content": "it took you 4 minutes? lol, it\\'s been 2 hours and I\\'m still stuck, guess that I\\'m just stupid."
                    },
                    {
                        "username": "aaachris1820",
                        "content": "I had a hard time understanding the cancellation happens if two consecutive calls happens inside the time t"
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "Debouncing comes under the advance concept in js."
                    },
                    {
                        "username": "Vegeta_",
                        "content": "This can be moved to easy. For medium, a new problem with title Debounce ii would be good and in the new problem, options like leading and trailing can be added to raise the difficulty"
                    },
                    {
                        "username": "khe1154",
                        "content": "agreed, adding `trailing` and `leading` option would good up followup"
                    },
                    {
                        "username": "JayPokale",
                        "content": "Very Easy but useful concept of JavaScript."
                    },
                    {
                        "username": "Nogaroid",
                        "content": "When I tested my code with Run if failed on the 2nd testcase. My ouput was [{\"t\":69,\"inputs\":[1]},{\"t\":119,\"inputs\":[2]}], only 1t off the output in the problem description, but the expected output in the testcase was [{\"t\":86,\"inputs\":[1]},{\"t\":124,\"inputs\":[2]}], 4t off what's written in the description. However, my code was accepted when I submitted it. \\_()_/"
                    },
                    {
                        "username": "dimple27",
                        "content": "Why it is green (test case passed) even value is different for t? \\uD83E\\uDD14  \\n` for input: 20\\n                  [{\"t\":50,\"inputs\":[1]},{\"t\":100,\"inputs\":[2]}]\\n\\noutput:       [{\"t\":70,\"inputs\":[1]},{\"t\":119,\"inputs\":[2]}]\\nexpected:  [{\"t\":69,\"inputs\":[1]},{\"t\":120,\"inputs\":[2]}]\\n` "
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day15 : Done Solving Today\\'s Question .\\n\\n\\n\\nHint : Try to use Clear Timeout And Set Timeout Functions"
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "I was overthinking the solution. In the description, multiple functions were used to explain the concept of debouncing. Notice, however, that the test cases only call a single function multiple time. That is to say that we only need to worry about cancelling one function (unlike the \"Cache with Time Limit\" problem where we needed to keep a cache to store the timeouts of multiple functions). "
                    },
                    {
                        "username": "cortadordeunha666",
                        "content": "yes, I didn\\'t notice that it was the funtion inside the closure that was being invocked, not the closure itself."
                    }
                ]
            },
            {
                "id": 2017493,
                "content": [
                    {
                        "username": "vadya-coder",
                        "content": "Personally, it was too easy for me. Accordingly, I would put it on the EASY level. The difficulty was only in understanding the task. I spent about 4 minutes on the task."
                    },
                    {
                        "username": "cortadordeunha666",
                        "content": "[@cortadordeunha666](/cortadordeunha666) nvm"
                    },
                    {
                        "username": "cortadordeunha666",
                        "content": "[@vadya-coder](/vadya-coder) I know about clearTimeout, I just dont know why there\\'s the need of return a function and if I really need to use setTimeout"
                    },
                    {
                        "username": "vadya-coder",
                        "content": "[@cortadordeunha666](/cortadordeunha666) Try reading about clearTimeout \\uD83D\\uDE09"
                    },
                    {
                        "username": "cortadordeunha666",
                        "content": "it took you 4 minutes? lol, it\\'s been 2 hours and I\\'m still stuck, guess that I\\'m just stupid."
                    },
                    {
                        "username": "aaachris1820",
                        "content": "I had a hard time understanding the cancellation happens if two consecutive calls happens inside the time t"
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "Debouncing comes under the advance concept in js."
                    },
                    {
                        "username": "Vegeta_",
                        "content": "This can be moved to easy. For medium, a new problem with title Debounce ii would be good and in the new problem, options like leading and trailing can be added to raise the difficulty"
                    },
                    {
                        "username": "khe1154",
                        "content": "agreed, adding `trailing` and `leading` option would good up followup"
                    },
                    {
                        "username": "JayPokale",
                        "content": "Very Easy but useful concept of JavaScript."
                    },
                    {
                        "username": "Nogaroid",
                        "content": "When I tested my code with Run if failed on the 2nd testcase. My ouput was [{\"t\":69,\"inputs\":[1]},{\"t\":119,\"inputs\":[2]}], only 1t off the output in the problem description, but the expected output in the testcase was [{\"t\":86,\"inputs\":[1]},{\"t\":124,\"inputs\":[2]}], 4t off what's written in the description. However, my code was accepted when I submitted it. \\_()_/"
                    },
                    {
                        "username": "dimple27",
                        "content": "Why it is green (test case passed) even value is different for t? \\uD83E\\uDD14  \\n` for input: 20\\n                  [{\"t\":50,\"inputs\":[1]},{\"t\":100,\"inputs\":[2]}]\\n\\noutput:       [{\"t\":70,\"inputs\":[1]},{\"t\":119,\"inputs\":[2]}]\\nexpected:  [{\"t\":69,\"inputs\":[1]},{\"t\":120,\"inputs\":[2]}]\\n` "
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day15 : Done Solving Today\\'s Question .\\n\\n\\n\\nHint : Try to use Clear Timeout And Set Timeout Functions"
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "I was overthinking the solution. In the description, multiple functions were used to explain the concept of debouncing. Notice, however, that the test cases only call a single function multiple time. That is to say that we only need to worry about cancelling one function (unlike the \"Cache with Time Limit\" problem where we needed to keep a cache to store the timeouts of multiple functions). "
                    },
                    {
                        "username": "cortadordeunha666",
                        "content": "yes, I didn\\'t notice that it was the funtion inside the closure that was being invocked, not the closure itself."
                    }
                ]
            },
            {
                "id": 1899084,
                "content": [
                    {
                        "username": "vadya-coder",
                        "content": "Personally, it was too easy for me. Accordingly, I would put it on the EASY level. The difficulty was only in understanding the task. I spent about 4 minutes on the task."
                    },
                    {
                        "username": "cortadordeunha666",
                        "content": "[@cortadordeunha666](/cortadordeunha666) nvm"
                    },
                    {
                        "username": "cortadordeunha666",
                        "content": "[@vadya-coder](/vadya-coder) I know about clearTimeout, I just dont know why there\\'s the need of return a function and if I really need to use setTimeout"
                    },
                    {
                        "username": "vadya-coder",
                        "content": "[@cortadordeunha666](/cortadordeunha666) Try reading about clearTimeout \\uD83D\\uDE09"
                    },
                    {
                        "username": "cortadordeunha666",
                        "content": "it took you 4 minutes? lol, it\\'s been 2 hours and I\\'m still stuck, guess that I\\'m just stupid."
                    },
                    {
                        "username": "aaachris1820",
                        "content": "I had a hard time understanding the cancellation happens if two consecutive calls happens inside the time t"
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "Debouncing comes under the advance concept in js."
                    },
                    {
                        "username": "Vegeta_",
                        "content": "This can be moved to easy. For medium, a new problem with title Debounce ii would be good and in the new problem, options like leading and trailing can be added to raise the difficulty"
                    },
                    {
                        "username": "khe1154",
                        "content": "agreed, adding `trailing` and `leading` option would good up followup"
                    },
                    {
                        "username": "JayPokale",
                        "content": "Very Easy but useful concept of JavaScript."
                    },
                    {
                        "username": "Nogaroid",
                        "content": "When I tested my code with Run if failed on the 2nd testcase. My ouput was [{\"t\":69,\"inputs\":[1]},{\"t\":119,\"inputs\":[2]}], only 1t off the output in the problem description, but the expected output in the testcase was [{\"t\":86,\"inputs\":[1]},{\"t\":124,\"inputs\":[2]}], 4t off what's written in the description. However, my code was accepted when I submitted it. \\_()_/"
                    },
                    {
                        "username": "dimple27",
                        "content": "Why it is green (test case passed) even value is different for t? \\uD83E\\uDD14  \\n` for input: 20\\n                  [{\"t\":50,\"inputs\":[1]},{\"t\":100,\"inputs\":[2]}]\\n\\noutput:       [{\"t\":70,\"inputs\":[1]},{\"t\":119,\"inputs\":[2]}]\\nexpected:  [{\"t\":69,\"inputs\":[1]},{\"t\":120,\"inputs\":[2]}]\\n` "
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day15 : Done Solving Today\\'s Question .\\n\\n\\n\\nHint : Try to use Clear Timeout And Set Timeout Functions"
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "I was overthinking the solution. In the description, multiple functions were used to explain the concept of debouncing. Notice, however, that the test cases only call a single function multiple time. That is to say that we only need to worry about cancelling one function (unlike the \"Cache with Time Limit\" problem where we needed to keep a cache to store the timeouts of multiple functions). "
                    },
                    {
                        "username": "cortadordeunha666",
                        "content": "yes, I didn\\'t notice that it was the funtion inside the closure that was being invocked, not the closure itself."
                    }
                ]
            },
            {
                "id": 1898606,
                "content": [
                    {
                        "username": "vadya-coder",
                        "content": "Personally, it was too easy for me. Accordingly, I would put it on the EASY level. The difficulty was only in understanding the task. I spent about 4 minutes on the task."
                    },
                    {
                        "username": "cortadordeunha666",
                        "content": "[@cortadordeunha666](/cortadordeunha666) nvm"
                    },
                    {
                        "username": "cortadordeunha666",
                        "content": "[@vadya-coder](/vadya-coder) I know about clearTimeout, I just dont know why there\\'s the need of return a function and if I really need to use setTimeout"
                    },
                    {
                        "username": "vadya-coder",
                        "content": "[@cortadordeunha666](/cortadordeunha666) Try reading about clearTimeout \\uD83D\\uDE09"
                    },
                    {
                        "username": "cortadordeunha666",
                        "content": "it took you 4 minutes? lol, it\\'s been 2 hours and I\\'m still stuck, guess that I\\'m just stupid."
                    },
                    {
                        "username": "aaachris1820",
                        "content": "I had a hard time understanding the cancellation happens if two consecutive calls happens inside the time t"
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "Debouncing comes under the advance concept in js."
                    },
                    {
                        "username": "Vegeta_",
                        "content": "This can be moved to easy. For medium, a new problem with title Debounce ii would be good and in the new problem, options like leading and trailing can be added to raise the difficulty"
                    },
                    {
                        "username": "khe1154",
                        "content": "agreed, adding `trailing` and `leading` option would good up followup"
                    },
                    {
                        "username": "JayPokale",
                        "content": "Very Easy but useful concept of JavaScript."
                    },
                    {
                        "username": "Nogaroid",
                        "content": "When I tested my code with Run if failed on the 2nd testcase. My ouput was [{\"t\":69,\"inputs\":[1]},{\"t\":119,\"inputs\":[2]}], only 1t off the output in the problem description, but the expected output in the testcase was [{\"t\":86,\"inputs\":[1]},{\"t\":124,\"inputs\":[2]}], 4t off what's written in the description. However, my code was accepted when I submitted it. \\_()_/"
                    },
                    {
                        "username": "dimple27",
                        "content": "Why it is green (test case passed) even value is different for t? \\uD83E\\uDD14  \\n` for input: 20\\n                  [{\"t\":50,\"inputs\":[1]},{\"t\":100,\"inputs\":[2]}]\\n\\noutput:       [{\"t\":70,\"inputs\":[1]},{\"t\":119,\"inputs\":[2]}]\\nexpected:  [{\"t\":69,\"inputs\":[1]},{\"t\":120,\"inputs\":[2]}]\\n` "
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day15 : Done Solving Today\\'s Question .\\n\\n\\n\\nHint : Try to use Clear Timeout And Set Timeout Functions"
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "I was overthinking the solution. In the description, multiple functions were used to explain the concept of debouncing. Notice, however, that the test cases only call a single function multiple time. That is to say that we only need to worry about cancelling one function (unlike the \"Cache with Time Limit\" problem where we needed to keep a cache to store the timeouts of multiple functions). "
                    },
                    {
                        "username": "cortadordeunha666",
                        "content": "yes, I didn\\'t notice that it was the funtion inside the closure that was being invocked, not the closure itself."
                    }
                ]
            }
        ]
    }
]