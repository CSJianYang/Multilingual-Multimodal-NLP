[
    {
        "title": "Convert an Array Into a 2D Array With Conditions",
        "question_content": "You are given an integer array nums. You need to create a 2D array from nums satisfying the following conditions:\n\n\tThe 2D array should contain only the elements of the array nums.\n\tEach row in the 2D array contains distinct integers.\n\tThe number of rows in the 2D array should be minimal.\n\nReturn the resulting array. If there are multiple answers, return any of them.\nNote that the 2D array can have a different number of elements on each row.\n&nbsp;\nExample 1:\n\nInput: nums = [1,3,4,1,2,3,1]\nOutput: [[1,3,4,2],[1,3],[1]]\nExplanation: We can create a 2D array that contains the following rows:\n- 1,3,4,2\n- 1,3\n- 1\nAll elements of nums were used, and each row of the 2D array contains distinct integers, so it is a valid answer.\nIt can be shown that we cannot have less than 3 rows in a valid array.\nExample 2:\n\nInput: nums = [1,2,3,4]\nOutput: [[4,3,2,1]]\nExplanation: All elements of the array are distinct, so we can keep all of them in the first row of the 2D array.\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 200\n\t1 <= nums[i] <= nums.length",
        "solutions": [
            {
                "id": 3368523,
                "title": "java-c-python-maximum-frequence",
                "content": "# **Intuition**\\nCount the frequency of elements,\\nthe rows we need is equal to the maximum frequency.\\n<br>\\n\\n# **Explanation**\\nIterate all `A[i]`,\\nand compare the current number of rows and `count[A[i]]`,\\nput it at row `res[count[A[i]]]`.\\n<br>\\n\\n# **Complexity**\\nTime `O(n)`\\nSpace `O(n)`\\n<br>\\n\\n**Java**\\n```java\\n    public List<List<Integer>> findMatrix(int[] A) {\\n        ArrayList<List<Integer>> res = new ArrayList<>();\\n        int n = A.length, count[] = new int[n + 1];\\n        for (int a : A) {\\n            if (res.size() < ++count[a])\\n                res.add(new ArrayList<>());\\n            res.get(count[a]).add(a);\\n        }\\n        return res;\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    vector<vector<int>> findMatrix(vector<int>& A) {\\n        int n = A.size();\\n        vector<int> count(n + 10);\\n        vector<vector<int>> res;\\n        for (int a : A) {\\n            if (res.size() <= count[a])\\n                res.push_back({});\\n            res[count[a]++].push_back(a);\\n        }\\n        return res;\\n    }\\n```\\n\\n**Python**\\n```py\\n    def findMatrix(self, nums: List[int]) -> List[List[int]]:\\n        count = Counter(nums)\\n        k = max(count.values())\\n        A = list(count.elements())\\n        return [A[i::k] for i in range(k)]\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public List<List<Integer>> findMatrix(int[] A) {\\n        ArrayList<List<Integer>> res = new ArrayList<>();\\n        int n = A.length, count[] = new int[n + 1];\\n        for (int a : A) {\\n            if (res.size() < ++count[a])\\n                res.add(new ArrayList<>());\\n            res.get(count[a]).add(a);\\n        }\\n        return res;\\n    }\\n```\n```cpp\\n    vector<vector<int>> findMatrix(vector<int>& A) {\\n        int n = A.size();\\n        vector<int> count(n + 10);\\n        vector<vector<int>> res;\\n        for (int a : A) {\\n            if (res.size() <= count[a])\\n                res.push_back({});\\n            res[count[a]++].push_back(a);\\n        }\\n        return res;\\n    }\\n```\n```py\\n    def findMatrix(self, nums: List[int]) -> List[List[int]]:\\n        count = Counter(nums)\\n        k = max(count.values())\\n        A = list(count.elements())\\n        return [A[i::k] for i in range(k)]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3368400,
                "title": "hashmap-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findMatrix(vector<int>& nums) {\\n        unordered_map<int, int> m;\\n        for(int i : nums) m[i]++;\\n        \\n        vector<vector<int>> ans;\\n        while(m.size()) {\\n            vector<int> v;\\n            for(auto i : m) v.push_back(i.first);\\n            for(int i : v) {\\n                if(!--m[i]) m.erase(i);\\n            }\\n            ans.push_back(v);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findMatrix(vector<int>& nums) {\\n        unordered_map<int, int> m;\\n        for(int i : nums) m[i]++;\\n        \\n        vector<vector<int>> ans;\\n        while(m.size()) {\\n            vector<int> v;\\n            for(auto i : m) v.push_back(i.first);\\n            for(int i : v) {\\n                if(!--m[i]) m.erase(i);\\n            }\\n            ans.push_back(v);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368321,
                "title": "counter",
                "content": "We count values, and for each row in the matrix we take one of each value.\\n\\nTherefore, the number of rows is equal to the maximum count.\\n\\nIf number `i` is repeated `j` times, we add it to the first `j` rows.\\n\\n**C++**\\n```cpp\\nvector<vector<int>> findMatrix(vector<int>& nums) {\\n    int cnt[201] = {}, max_cnt = 0;\\n    for (auto n : nums)\\n        max_cnt = max(max_cnt, ++cnt[n]);\\n    vector<vector<int>> res(max_cnt);\\n    for (int i = 0; i < 201; ++i)\\n        for (int j = 0; j < cnt[i]; ++j)\\n            res[j].push_back(i);\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nvector<vector<int>> findMatrix(vector<int>& nums) {\\n    int cnt[201] = {}, max_cnt = 0;\\n    for (auto n : nums)\\n        max_cnt = max(max_cnt, ++cnt[n]);\\n    vector<vector<int>> res(max_cnt);\\n    for (int i = 0; i < 201; ++i)\\n        for (int j = 0; j < cnt[i]; ++j)\\n            res[j].push_back(i);\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3368386,
                "title": "convert-1d-to-2d-java-simple-approach",
                "content": "Hi,\\n\\xA0\\nI wrote this solution beginner friendly without DP or other techniques just by counting the number of frequency of each element, since the number is small I used an integer array and counted their frequency.\\n\\xA0\\nI kept an variable max to know the maximum occurrence of any number.\\n\\xA0\\nUsing the occurrence array iterate from 1 to max and add the distinct elements to a new list and add to the result.\\n\\nKindly upvote :)\\n\\n```\\n    public List<List<Integer>> findMatrix(int[] nums) {\\n        int[] arr = new int[201];\\n        int max=0;\\n        for(int i=0; i<nums.length; i++){\\n        \\tarr[nums[i]]++;\\n        \\tmax = Math.max(max, arr[nums[i]]);\\n        }\\n        List<List<Integer>> res = new ArrayList();\\n        int i=1;\\n        while(i<=max){\\n        \\tList<Integer> list = new ArrayList<Integer>();\\n        \\tfor(int j=0; j<201; j++){\\n        \\t\\tif(arr[j]>=i){\\n        \\t\\t\\tlist.add(j);\\n        \\t\\t}\\n        \\t}\\n        \\tif(list.size()>0){\\n        \\t\\tres.add(list);\\n        \\t}\\n        \\ti++;\\n        }\\n        return res;\\n    }\\n\\n",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "Hi,\\n\\xA0\\nI wrote this solution beginner friendly without DP or other techniques just by counting the number of frequency of each element, since the number is small I used an integer array and counted their frequency.\\n\\xA0\\nI kept an variable max to know the maximum occurrence of any number.\\n\\xA0\\nUsing the occurrence array iterate from 1 to max and add the distinct elements to a new list and add to the result.\\n\\nKindly upvote :)\\n\\n```\\n    public List<List<Integer>> findMatrix(int[] nums) {\\n        int[] arr = new int[201];\\n        int max=0;\\n        for(int i=0; i<nums.length; i++){\\n        \\tarr[nums[i]]++;\\n        \\tmax = Math.max(max, arr[nums[i]]);\\n        }\\n        List<List<Integer>> res = new ArrayList();\\n        int i=1;\\n        while(i<=max){\\n        \\tList<Integer> list = new ArrayList<Integer>();\\n        \\tfor(int j=0; j<201; j++){\\n        \\t\\tif(arr[j]>=i){\\n        \\t\\t\\tlist.add(j);\\n        \\t\\t}\\n        \\t}\\n        \\tif(list.size()>0){\\n        \\t\\tres.add(list);\\n        \\t}\\n        \\ti++;\\n        }\\n        return res;\\n    }\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3368281,
                "title": "simple-java-hashmap-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$ \\n \\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> findMatrix(int[] nums) {\\n        int a[]=new int[201];\\n        for(int i:nums)\\n        {\\n            a[i]++;\\n        }\\n        List<List<Integer>> kk=new ArrayList<>();\\n        while(true)\\n        {\\n            List<Integer> k=new ArrayList<>();\\n            int x=0;\\n            for(int i=0;i<201;i++)\\n            {\\n                if(a[i]>0)\\n                {\\n                    k.add(i);\\n                    a[i]-=1;\\n                }\\n                else\\n                {\\n                    x++;\\n                }\\n            }\\n            if(x==201)\\n            {\\n                break;\\n            }\\n            kk.add(new ArrayList<>(k));\\n        }\\n        return kk;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> findMatrix(int[] nums) {\\n        int a[]=new int[201];\\n        for(int i:nums)\\n        {\\n            a[i]++;\\n        }\\n        List<List<Integer>> kk=new ArrayList<>();\\n        while(true)\\n        {\\n            List<Integer> k=new ArrayList<>();\\n            int x=0;\\n            for(int i=0;i<201;i++)\\n            {\\n                if(a[i]>0)\\n                {\\n                    k.add(i);\\n                    a[i]-=1;\\n                }\\n                else\\n                {\\n                    x++;\\n                }\\n            }\\n            if(x==201)\\n            {\\n                break;\\n            }\\n            kk.add(new ArrayList<>(k));\\n        }\\n        return kk;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368746,
                "title": "c-easy-to-understand-using-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo minimize the no. of rows we will put all distinct elements in 1st row and no. of rows will be equal to maximum freq of element.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIn order to implement it we can use map to store the number and its freq. Now we can easily iterate over map and put all the keys in the ans and decrease the freq. We will repeat this till all the keys have value equals to zero. This will result in the required 2D array.\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findMatrix(vector<int>& nums) {\\n        map<int,int> m;\\n        int maxi = INT_MIN;\\n        for(auto i:nums){\\n            m[i]++;\\n            if(maxi<m[i]){\\n                maxi=m[i];\\n            }\\n        }\\n        \\n        vector<vector<int>> arr;\\n        \\n        \\n        for(int i=0;i<maxi;i++){\\n           vector<int> e;\\n        for (auto it = m.begin(); it != m.end(); it++) {\\n            if(m[it->first]!=0){\\n        e.push_back(it->first);\\n            m[(it->first)]--;\\n            }\\n    }\\n            arr.push_back(e);\\n        }        \\n        \\n       return arr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findMatrix(vector<int>& nums) {\\n        map<int,int> m;\\n        int maxi = INT_MIN;\\n        for(auto i:nums){\\n            m[i]++;\\n            if(maxi<m[i]){\\n                maxi=m[i];\\n            }\\n        }\\n        \\n        vector<vector<int>> arr;\\n        \\n        \\n        for(int i=0;i<maxi;i++){\\n           vector<int> e;\\n        for (auto it = m.begin(); it != m.end(); it++) {\\n            if(m[it->first]!=0){\\n        e.push_back(it->first);\\n            m[(it->first)]--;\\n            }\\n    }\\n            arr.push_back(e);\\n        }        \\n        \\n       return arr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371509,
                "title": "python-3-3-lines-zip-longest-w-example-t-m-98-58",
                "content": "```\\nclass Solution:\\n    def findMatrix(self, nums: List[int]) -> List[List[int]]:\\n                                                            #  Example: [1,3,4,1,2,3,1]\\n    \\n        c = Counter(nums)                                   #    c = {1:3, 3:2, 4:1, 2:1}) \\n\\n        ans = zip_longest(*[[k]*c[k] for k in c])           #  ans = zip_longest([1,1,1],[3,3],[4],[2])\\n                                                            #      = [(1, 3, 4, 2), (1, 3, None, None), (1, None, None, None)]\\n\\n        return list(map(lambda x:[n for n in x if n], ans)) #  ans = [[1, 3, 4, 2], [1, 3], [1]]\\n```\\n[https://leetcode.com/problems/convert-an-array-into-a-2d-array-with-conditions/submissions/926724350/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*NM*) and space complexity is *O*(*NM*), where *N* ~ `nums` and *M* ~ `max(c.value())`.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findMatrix(self, nums: List[int]) -> List[List[int]]:\\n                                                            #  Example: [1,3,4,1,2,3,1]\\n    \\n        c = Counter(nums)                                   #    c = {1:3, 3:2, 4:1, 2:1}) \\n\\n        ans = zip_longest(*[[k]*c[k] for k in c])           #  ans = zip_longest([1,1,1],[3,3],[4],[2])\\n                                                            #      = [(1, 3, 4, 2), (1, 3, None, None), (1, None, None, None)]\\n\\n        return list(map(lambda x:[n for n in x if n], ans)) #  ans = [[1, 3, 4, 2], [1, 3], [1]]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3369344,
                "title": "java-simple-solution-using-hashmap",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> findMatrix(int[] nums) {\\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        HashSet<Integer> set=new HashSet<>();\\n        for(int i=0;i<nums.length;i++){\\n            map.put(nums[i],map.getOrDefault(nums[i],0)+1);\\n            set.add(nums[i]);\\n        }\\n        List<List<Integer>> ans=new ArrayList<>();\\n        while(map.size()!=0){\\n            List<Integer> curr=new ArrayList<>();\\n            for(int ele:set){\\n                if(map.containsKey(ele)){\\n                    int count=map.get(ele);\\n                    curr.add(ele);\\n                    if(count==1){\\n                        map.remove(ele);\\n                    }\\n                    else{\\n                        map.put(ele,count-1);\\n                    } \\n                }  \\n            }\\n            ans.add(curr);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> findMatrix(int[] nums) {\\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        HashSet<Integer> set=new HashSet<>();\\n        for(int i=0;i<nums.length;i++){\\n            map.put(nums[i],map.getOrDefault(nums[i],0)+1);\\n            set.add(nums[i]);\\n        }\\n        List<List<Integer>> ans=new ArrayList<>();\\n        while(map.size()!=0){\\n            List<Integer> curr=new ArrayList<>();\\n            for(int ele:set){\\n                if(map.containsKey(ele)){\\n                    int count=map.get(ele);\\n                    curr.add(ele);\\n                    if(count==1){\\n                        map.remove(ele);\\n                    }\\n                    else{\\n                        map.put(ele,count-1);\\n                    } \\n                }  \\n            }\\n            ans.add(curr);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3380880,
                "title": "day-369-java-c-python-explained-intuition-algorithm-proof",
                "content": "![image.png](https://assets.leetcode.com/users/images/a2267944-10b8-41f2-b624-81a67ccea163_1680148646.205976.png)\\n\\n# Please Upvote as it really motivates me\\n\\n##### \\u2022\\tIntuition: \\n##### \\u2022\\tWe are given an array of integers nums . \\n##### \\u2022\\tWe need to group the numbers in nums based on their frequency. \\n##### \\u2022\\tWe can create a 2D list where each row represents a group of numbers with the same frequency. \\n##### \\u2022\\tApproach: \\n##### \\u2022\\tWe can use an array freq to store the frequency of each number in nums . \\n##### \\u2022\\tWe can find the maximum frequency of any number in nums . \\n##### \\u2022\\tWe can create a 2D list with max number of rows, where max is the maximum frequency of any number in nums . \\n##### \\u2022\\tWe can iterate through freq and add the corresponding number to the freq[i] -th row of the 2D list. \\n##### \\u2022\\tAlgorithm: \\n##### \\u2022\\tInitialize nums to the given array of integers. Initialize n to the length of nums . \\n##### \\u2022\\tInitialize freq to an array of size n+1 with all elements set to 0 . Initialize max to 0 . Iterate through nums : For each number num , increment the frequency of num in freq . \\n##### \\u2022\\tUpdate max to be the maximum of max and the frequency of num . Initialize ans to an empty 2D list. Iterate from 0 to max-1 : For each index i , add an empty list to ans . \\n##### \\u2022\\tIterate from 0 to n : While the frequency of i in freq is greater than 0 : Decrement the frequency of i in freq . \\n##### \\u2022\\tAdd i to the freq[i] -th row of ans . \\n##### \\u2022\\tReturn ans .\\n\\n# Code\\n\\n```java []\\n    public List<List<Integer>> findMatrix(int[] nums) {\\n        int n = nums.length;\\n        int[] freq = new int[n + 1];\\n        int max = 0;\\n        for(int num : nums) {\\n            freq[num]++;\\n            max = Math.max(max,freq[num]);\\n        }\\n        List<List<Integer>> ans = new ArrayList<>();\\n        for(int i = 0;i < max;i++) ans.add(new ArrayList<>());\\n        for(int i = 0;i <= n;i++){\\n            while(freq[i]-- > 0){\\n                ans.get(freq[i]).add(i);\\n            }\\n        }\\n        return ans;\\n    }\\n```\\n```c++ []\\nvector<vector<int>> findMatrix(vector<int>& nums) {\\n    int n = nums.size();\\n    vector<int> freq(n + 1);\\n    int maxFreq = 0;\\n    for (int num : nums) {\\n        freq[num]++;\\n        maxFreq = max(maxFreq, freq[num]);\\n    }\\n    vector<vector<int>> ans(maxFreq);\\n    for (int i = 0; i < n; i++) {\\n        ans[freq[nums[i]] - 1].push_back(nums[i]);\\n        freq[nums[i]] = 0;\\n    }\\n    return ans;\\n}\\n```\\n```python []\\ndef findMatrix(nums: List[int]) -> List[List[int]]:\\n    n = len(nums)\\n    freq = [0] * (n + 1)\\n    maxFreq = 0\\n    for num in nums:\\n        freq[num] += 1\\n        maxFreq = max(maxFreq, freq[num])\\n    ans = [[] for _ in range(maxFreq)]\\n    for i in range(n):\\n        ans[freq[nums[i]] - 1].append(nums[i])\\n        freq[nums[i]] = 0\\n    return ans\\n```\\n\\n# Complexity\\n##### \\u2022\\tTC stands for Time Complexity, which refers to the amount of time taken by an algorithm to run as a function of the input size. It is usually expressed in terms of Big O notation. In this problem, the time complexity of the algorithm is O(n log n), where n is the size of the input array. This is because the algorithm involves sorting the frequency array, which takes O(n log n) time.\\n##### \\u2022\\tSC stands for Space Complexity, which refers to the amount of memory used by an algorithm as a function of the input size. In this problem, the space complexity of the algorithm is O(n), where n is the size of the input array. This is because the algorithm uses a frequency array of size 10^5+1 to count the occurrences of each integer in the array. The size of the frequency array is independent of the input size, so the space complexity is O(n). Additionally, the algorithm uses a vector of pairs to store the frequency array elements, but the size of the vector is at most 10^5, which is also independent of the input size. Therefore, the overall space complexity is O(n).\\n\\n\\n# 2ND WAY \\n```PYTHON []\\ndef findMatrix(nums: List[int]) -> List[List[int]]:\\n    maxFrequency = max(nums, key=lambda x: nums.count(x))\\n    ans = [[] for _ in range(nums.count(maxFrequency))]\\n    for a in nums:\\n        i = 0\\n        while i < len(ans):\\n            if a not in ans[i]:\\n                ans[i].append(a)\\n                break\\n            i += 1\\n    return ans\\n```\\n```C++ []\\nvector<vector<int>> findMatrix(vector<int>& nums) {\\n    int n = nums.size();\\n    int maxFrequency = *max_element(nums.begin(), nums.end(), [](int a, int b) { return count(nums.begin(), nums.end(), a) < count(nums.begin(), nums.end(), b); });\\n    vector<vector<int>> ans(maxFrequency);\\n    for (int a : nums) {\\n        int i = 0;\\n        while (i < maxFrequency) {\\n            if (!count(ans[i].begin(), ans[i].end(), a)) {\\n                ans[i].push_back(a);\\n                break;\\n            }\\n            i++;\\n        }\\n    }\\n    return ans;\\n}\\n```\\n```JAVA []\\n    public   List<List<Integer>> findMatrix(int[] nums) {\\n    int n=nums.length;\\n        int maxFrequency=Arrays.stream(nums)\\n                        .boxed()\\n                        .collect(Collectors.groupingBy(Function.identity(), Collectors.counting()))\\n                        .entrySet()\\n                        .stream()\\n                        .max(Map.Entry.comparingByValue())\\n                        .get()\\n                        .getValue().intValue();\\nList<List<Integer>> ans = new ArrayList<>();\\n        for (int i = 0; i < maxFrequency; i++) ans.add(new ArrayList<>());\\n        for(int a:nums){\\n            int i=0;\\n            while(i<maxFrequency){\\n                if(!ans.get(i).contains(a)) {\\n                    ans.get(i).add(a);\\n                    break;\\n                }\\n                i++;\\n            }\\n        }return ans;\\n    }\\n```\\n# 3RD WAY \\n```C++ []\\n    vector<vector<int>> findMatrix(vector<int>& nums) {\\n        unordered_map<int, int> mp;\\n        vector<vector<int>> res;\\n        for(int num: nums) mp[num]++;\\n        while(mp.size()) {\\n            vector<int> temp;\\n            for(auto m: mp) temp.push_back(m.first);\\n            for(int i: temp) if(--mp[i] == 0) mp.erase(i);\\n            res.push_back(temp);\\n        }\\n        return res;\\n    }\\n```\\n```JAVA []\\npublic List<List<Integer>> findMatrix[] nums) {\\n    Map<Integer, Integer> mp = new HashMap<>();\\n    List<List<Integer>> res = new ArrayList<>();\\n    for (int num : nums) {\\n        mp.put(num, mp.getOrDefault(num, 0) + 1);\\n    }\\n    while (!mp.isEmpty()) {\\n        List<Integer> temp = new ArrayList<>();\\n        for (int i : mp.keySet()) {\\n            temp.add(i);\\n        }\\n        for (int i : temp) {\\n            if (mp.put(i, mp.get(i) - 1) == 1) {\\n                mp.remove(i);\\n            }\\n        }\\n        res.add(temp);\\n    }\\n    return res;\\n}\\n```\\n```PYTHON []\\ndef findMatrix(nums: List[int]) -> List[List[int]]:\\n    mp = {}\\n    res = []\\n    for num in nums:\\n        mp[num] = mp.get(num, 0) + 1\\n    while mp:\\n        temp = []\\n        for i in mp.keys():\\n            temp.append(i)\\n        for i in temp:\\n            if mp[i] == 1:\\n                mp.pop(i)\\n            else:\\n                mp[i] -= 1\\n        res.append(temp)\\n    return res\\n```\\n# 4TH 3 LINER \\n```PYTHON []\\nfrom import Counter\\nfrom itertools import zip_longest\\nclass Solution:\\n    def findMatrix(self, nums: List[int]) -> List[List[int]]:\\n        # Count the frequency of each number in nums\\n        c = Counter(nums)\\n        # Create a list of lists where each sublist contains the same number repeated its frequency times\\n        # Then use zip_longest to group the sublists by index and fill missing values with None\\n        ans = zip_longest(*[[k]*c[k] for k in c])\\n        # Remove the None values from each sublist and return the result as a list of lists\\n        return list(map(lambda x:[n for n in x if n], ans))\\n```\\n```C++ []\\n    vector<vector<int>> findMatrix(vector<int>& nums) {\\n        int n = nums.size();\\n        unordered_map<int, int> freq;\\n        int max_freq = 0;\\n        for (int num : nums) {\\n            freq[num]++;\\n            max_freq = max(max_freq, freq[num]);\\n        }\\n        vector<vector<int>> ans(max_freq);\\n        for (auto& [num, f] : freq) {\\n            ans[f-1].push_back(num);\\n        }\\n        return ans;\\n    }\\n```\\n```JAVA []\\n    public List<List<Integer>> findMatrix(int[] nums) {\\n        int n = nums.length;\\n        Map<Integer, Integer> freq = new HashMap<>();\\n        int max_freq = 0;\\n        for (int num : nums) {\\n            freq.put(num, freq.getOrDefault(num, 0) + 1);\\n            max_freq = Math.max(max_freq, freq.get(num));\\n        }\\n        List<List<Integer>> ans = new ArrayList<>();\\n        for (int i = 0; i < max_freq; i++) {\\n            ans.add(new ArrayList<>());\\n        }\\n        for (Map.Entry<Integer, Integer> entry : freq.entrySet()) {\\n            int num = entry.getKey();\\n            int f = entry.getValue();\\n            ans.get(f-1).add(num);\\n        }\\n        return ans;\\n    }\\n```\\n\\n# DRY RUN \\n##### \\u2022\\tInitialize nums to [1,3,4,1,2,3,1] . Initialize n to 7 . \\n##### \\u2022\\tInitialize freq to [0, 3, 2, 1, 1, 0, 0, 0] . This array stores the frequency of each number in nums . \\n##### \\u2022\\tInitialize max to 3 . This is the maximum frequency of any number in nums . Initialize ans to [[ ], [ ], [ ]] . This is a 2D list with max number of rows.\\n##### \\u2022\\tIterate through freq from 0 to 7 : For each frequency freq[i] , add the corresponding number i to the freq[i] -th row of ans . ans is now [[1, 3, 4, 2], [1, 3], [1]] . \\n##### \\u2022\\tThis is the final output. So the function returns [[1, 3, 4, 2], [1, 3], [1]] for the given input.\\n\\n\\n![BREUSELEE.webp](https://assets.leetcode.com/users/images/062630f0-ef80-4e74-abdb-302827b99235_1680054012.5054147.webp)\\n\\n![meme2.png](https://assets.leetcode.com/users/images/d588f492-3f95-45f6-8e4a-10d6069002a5_1680054021.7117147.png)\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n\\nhttps://leetcode.com/problems/convert-an-array-into-a-2d-array-with-conditions/solutions/3380880/day-369-java-c-python-explained-intuition-algorithm-proof/",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "```java []\\n    public List<List<Integer>> findMatrix(int[] nums) {\\n        int n = nums.length;\\n        int[] freq = new int[n + 1];\\n        int max = 0;\\n        for(int num : nums) {\\n            freq[num]++;\\n            max = Math.max(max,freq[num]);\\n        }\\n        List<List<Integer>> ans = new ArrayList<>();\\n        for(int i = 0;i < max;i++) ans.add(new ArrayList<>());\\n        for(int i = 0;i <= n;i++){\\n            while(freq[i]-- > 0){\\n                ans.get(freq[i]).add(i);\\n            }\\n        }\\n        return ans;\\n    }\\n```\n```c++ []\\nvector<vector<int>> findMatrix(vector<int>& nums) {\\n    int n = nums.size();\\n    vector<int> freq(n + 1);\\n    int maxFreq = 0;\\n    for (int num : nums) {\\n        freq[num]++;\\n        maxFreq = max(maxFreq, freq[num]);\\n    }\\n    vector<vector<int>> ans(maxFreq);\\n    for (int i = 0; i < n; i++) {\\n        ans[freq[nums[i]] - 1].push_back(nums[i]);\\n        freq[nums[i]] = 0;\\n    }\\n    return ans;\\n}\\n```\n```python []\\ndef findMatrix(nums: List[int]) -> List[List[int]]:\\n    n = len(nums)\\n    freq = [0] * (n + 1)\\n    maxFreq = 0\\n    for num in nums:\\n        freq[num] += 1\\n        maxFreq = max(maxFreq, freq[num])\\n    ans = [[] for _ in range(maxFreq)]\\n    for i in range(n):\\n        ans[freq[nums[i]] - 1].append(nums[i])\\n        freq[nums[i]] = 0\\n    return ans\\n```\n```PYTHON []\\ndef findMatrix(nums: List[int]) -> List[List[int]]:\\n    maxFrequency = max(nums, key=lambda x: nums.count(x))\\n    ans = [[] for _ in range(nums.count(maxFrequency))]\\n    for a in nums:\\n        i = 0\\n        while i < len(ans):\\n            if a not in ans[i]:\\n                ans[i].append(a)\\n                break\\n            i += 1\\n    return ans\\n```\n```C++ []\\nvector<vector<int>> findMatrix(vector<int>& nums) {\\n    int n = nums.size();\\n    int maxFrequency = *max_element(nums.begin(), nums.end(), [](int a, int b) { return count(nums.begin(), nums.end(), a) < count(nums.begin(), nums.end(), b); });\\n    vector<vector<int>> ans(maxFrequency);\\n    for (int a : nums) {\\n        int i = 0;\\n        while (i < maxFrequency) {\\n            if (!count(ans[i].begin(), ans[i].end(), a)) {\\n                ans[i].push_back(a);\\n                break;\\n            }\\n            i++;\\n        }\\n    }\\n    return ans;\\n}\\n```\n```JAVA []\\n    public   List<List<Integer>> findMatrix(int[] nums) {\\n    int n=nums.length;\\n        int maxFrequency=Arrays.stream(nums)\\n                        .boxed()\\n                        .collect(Collectors.groupingBy(Function.identity(), Collectors.counting()))\\n                        .entrySet()\\n                        .stream()\\n                        .max(Map.Entry.comparingByValue())\\n                        .get()\\n                        .getValue().intValue();\\nList<List<Integer>> ans = new ArrayList<>();\\n        for (int i = 0; i < maxFrequency; i++) ans.add(new ArrayList<>());\\n        for(int a:nums){\\n            int i=0;\\n            while(i<maxFrequency){\\n                if(!ans.get(i).contains(a)) {\\n                    ans.get(i).add(a);\\n                    break;\\n                }\\n                i++;\\n            }\\n        }return ans;\\n    }\\n```\n```C++ []\\n    vector<vector<int>> findMatrix(vector<int>& nums) {\\n        unordered_map<int, int> mp;\\n        vector<vector<int>> res;\\n        for(int num: nums) mp[num]++;\\n        while(mp.size()) {\\n            vector<int> temp;\\n            for(auto m: mp) temp.push_back(m.first);\\n            for(int i: temp) if(--mp[i] == 0) mp.erase(i);\\n            res.push_back(temp);\\n        }\\n        return res;\\n    }\\n```\n```JAVA []\\npublic List<List<Integer>> findMatrix[] nums) {\\n    Map<Integer, Integer> mp = new HashMap<>();\\n    List<List<Integer>> res = new ArrayList<>();\\n    for (int num : nums) {\\n        mp.put(num, mp.getOrDefault(num, 0) + 1);\\n    }\\n    while (!mp.isEmpty()) {\\n        List<Integer> temp = new ArrayList<>();\\n        for (int i : mp.keySet()) {\\n            temp.add(i);\\n        }\\n        for (int i : temp) {\\n            if (mp.put(i, mp.get(i) - 1) == 1) {\\n                mp.remove(i);\\n            }\\n        }\\n        res.add(temp);\\n    }\\n    return res;\\n}\\n```\n```PYTHON []\\ndef findMatrix(nums: List[int]) -> List[List[int]]:\\n    mp = {}\\n    res = []\\n    for num in nums:\\n        mp[num] = mp.get(num, 0) + 1\\n    while mp:\\n        temp = []\\n        for i in mp.keys():\\n            temp.append(i)\\n        for i in temp:\\n            if mp[i] == 1:\\n                mp.pop(i)\\n            else:\\n                mp[i] -= 1\\n        res.append(temp)\\n    return res\\n```\n```PYTHON []\\nfrom import Counter\\nfrom itertools import zip_longest\\nclass Solution:\\n    def findMatrix(self, nums: List[int]) -> List[List[int]]:\\n        # Count the frequency of each number in nums\\n        c = Counter(nums)\\n        # Create a list of lists where each sublist contains the same number repeated its frequency times\\n        # Then use zip_longest to group the sublists by index and fill missing values with None\\n        ans = zip_longest(*[[k]*c[k] for k in c])\\n        # Remove the None values from each sublist and return the result as a list of lists\\n        return list(map(lambda x:[n for n in x if n], ans))\\n```\n```C++ []\\n    vector<vector<int>> findMatrix(vector<int>& nums) {\\n        int n = nums.size();\\n        unordered_map<int, int> freq;\\n        int max_freq = 0;\\n        for (int num : nums) {\\n            freq[num]++;\\n            max_freq = max(max_freq, freq[num]);\\n        }\\n        vector<vector<int>> ans(max_freq);\\n        for (auto& [num, f] : freq) {\\n            ans[f-1].push_back(num);\\n        }\\n        return ans;\\n    }\\n```\n```JAVA []\\n    public List<List<Integer>> findMatrix(int[] nums) {\\n        int n = nums.length;\\n        Map<Integer, Integer> freq = new HashMap<>();\\n        int max_freq = 0;\\n        for (int num : nums) {\\n            freq.put(num, freq.getOrDefault(num, 0) + 1);\\n            max_freq = Math.max(max_freq, freq.get(num));\\n        }\\n        List<List<Integer>> ans = new ArrayList<>();\\n        for (int i = 0; i < max_freq; i++) {\\n            ans.add(new ArrayList<>());\\n        }\\n        for (Map.Entry<Integer, Integer> entry : freq.entrySet()) {\\n            int num = entry.getKey();\\n            int f = entry.getValue();\\n            ans.get(f-1).add(num);\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368548,
                "title": "c-using-set-easy-to-understand",
                "content": "# Approach\\nWe can solve the problem using a greedy approach. We can start by creating an empty 2D array and an empty set. We then iterate through each element in the nums array. For each element, we iterate through each row in the 2D array. If we find a row where the element is not already present, we add the element to that row and insert it into the set. If we are unable to find a row where the element is not already present, we create a new row and insert the element into the set.\\n\\n\\n### Time Complexity:\\nThe time complexity of the solution is O(n^2), where n is the length of the nums array. This is because we iterate through each element in the nums array and for each element, we iterate through each row in the 2D array.\\n\\n### Space Complexity: \\nThe space complexity of the solution is O(n^2), where n is the length of the nums array. \\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findMatrix(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        vector<unordered_set<int>> seen;\\n        int sz=-1;\\n        for(int n:nums){\\n            bool add=false;\\n            int i=0;\\n            for(auto& vec:ans){\\n                if(vec.size()==0 || seen[i].count(n)==0){ // if the element is not present in current row\\n                    vec.push_back(n);\\n                    seen[i].insert(n);\\n                    add=true;\\n                    break;\\n                }\\n                ++i;\\n            }\\n            if(!add){ // if it is present in the current 2-D array, create new row and add it  \\n                ans.push_back({n});\\n                seen.push_back({n});\\n                sz++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findMatrix(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        vector<unordered_set<int>> seen;\\n        int sz=-1;\\n        for(int n:nums){\\n            bool add=false;\\n            int i=0;\\n            for(auto& vec:ans){\\n                if(vec.size()==0 || seen[i].count(n)==0){ // if the element is not present in current row\\n                    vec.push_back(n);\\n                    seen[i].insert(n);\\n                    add=true;\\n                    break;\\n                }\\n                ++i;\\n            }\\n            if(!add){ // if it is present in the current 2-D array, create new row and add it  \\n                ans.push_back({n});\\n                seen.push_back({n});\\n                sz++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3518568,
                "title": "c-easy-to-unserstand-using-map",
                "content": "store each elements frequency.\\nstore an which hash frequency > 0. and decrease it by 1. if frequency is 0. rease this element from mp.\\nrepeat above mention step untill map don\\'t empty.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findMatrix(vector<int>& nums) {\\n        unordered_map<int,int> mp;\\n        vector<vector<int>> ans;\\n        vector<int> v;\\n        for(auto &i: nums){\\n            mp[i]++;\\n        }\\n        unordered_map<int,int> tmp;\\n        while(!mp.empty()){\\n            tmp = mp;\\n            v.clear();\\n            for(auto &i: tmp){\\n                mp[i.first]--;\\n                v.push_back(i.first);\\n                if(mp[i.first]==0){\\n                    mp.erase(i.first);\\n                }\\n            }\\n            ans.push_back(v);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findMatrix(vector<int>& nums) {\\n        unordered_map<int,int> mp;\\n        vector<vector<int>> ans;\\n        vector<int> v;\\n        for(auto &i: nums){\\n            mp[i]++;\\n        }\\n        unordered_map<int,int> tmp;\\n        while(!mp.empty()){\\n            tmp = mp;\\n            v.clear();\\n            for(auto &i: tmp){\\n                mp[i.first]--;\\n                v.push_back(i.first);\\n                if(mp[i.first]==0){\\n                    mp.erase(i.first);\\n                }\\n            }\\n            ans.push_back(v);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368775,
                "title": "easy-and-simple-java-solution",
                "content": "```\\n\\nclass Solution {\\n    public List<List<Integer>> findMatrix(int[] nums) {\\n        \\n        List<List<Integer>> li = new ArrayList<>();\\n        \\n        int i = 0;\\n        int[] f = new int[nums.length + 1];\\n        for(int x : nums)\\n        {\\n            f[x]++;\\n        }\\n\\t\\t\\n\\t\\tfor(int freq : f )\\n\\t\\t{\\n\\t\\t\\ti = Math.max(i, freq);\\n\\t\\t}\\n        for(int j  = 0 ; j < i ; j++)\\n        {\\n            li.add(new ArrayList<>());\\n        }\\n        \\n       for(int x : nums)\\n       {\\n            for(int j = 0 ; j < i; j++)\\n            {\\n                if(!li.get(j).contains(x))\\n                {\\n                    li.get(j).add(x);\\n                    break;\\n                }\\n            }\\n        }\\n        return li;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    public List<List<Integer>> findMatrix(int[] nums) {\\n        \\n        List<List<Integer>> li = new ArrayList<>();\\n        \\n        int i = 0;\\n        int[] f = new int[nums.length + 1];\\n        for(int x : nums)\\n        {\\n            f[x]++;\\n        }\\n\\t\\t\\n\\t\\tfor(int freq : f )\\n\\t\\t{\\n\\t\\t\\ti = Math.max(i, freq);\\n\\t\\t}\\n        for(int j  = 0 ; j < i ; j++)\\n        {\\n            li.add(new ArrayList<>());\\n        }\\n        \\n       for(int x : nums)\\n       {\\n            for(int j = 0 ; j < i; j++)\\n            {\\n                if(!li.get(j).contains(x))\\n                {\\n                    li.get(j).add(x);\\n                    break;\\n                }\\n            }\\n        }\\n        return li;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368452,
                "title": "soo-simple-again",
                "content": "# Approach\\nSince we need to return a 2D vector the question what will be the number of rows and no. of columns?\\n\\nWhat will be the no. of rows?\\nSince we can only place distinct elements in each row and nums can have multiple elements.\\nI will have to make as many rows as many times a number is repeated.\\n\\nFor eg, [1,2,3,1,1]\\n1 at index 0 to row 1\\n1 at index 3 to row 2\\n1 at index 4 to row 3\\n\\nSo thats why we evaluate the max frequency of elements to get the number of rows.\\n\\nAfter that keep a track of frequency of all the elements using map\\nAnd then keep on inserting the elements to each row and update the freq in the map too.\\n\\n# Complexity\\n- Time complexity:\\nO(n) \\nbecause we are inserting one element at a time.\\n\\n- Space complexity:\\nO(n)\\nfor map.\\n\\n# Code\\n``` C++ []\\nclass Solution {\\npublic:\\n    vector<vector<int>> findMatrix(vector<int>& nums) {\\n        unordered_map<int,int> mp;\\n        int Ffreq = 0;\\n        for(auto x : nums)\\n        {\\n            mp[x]++;\\n            Ffreq = max(Ffreq, mp[x]);\\n        }\\n        vector<vector<int>> ans(Ffreq);\\n        \\n        while(1)\\n        {\\n            bool isValid = true;\\n            for(auto it=mp.begin(); it!=mp.end(); it++)\\n            {\\n                int freq = it->second;\\n                int ele = it->first;\\n                if(freq == 0)continue;\\n                isValid = false;\\n                ans[freq-1].push_back(ele);\\n                mp[ele]--;\\n            }\\n            if(isValid)break;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n```Java []\\npublic class Solution {\\n    public List<List<Integer>> findMatrix(List<Integer> nums) {\\n        Map<Integer, Integer> mp = new HashMap<>();\\n        int Ffreq = 0;\\n        for (int x : nums) {\\n            mp.put(x, mp.getOrDefault(x, 0) + 1);\\n            Ffreq = Math.max(Ffreq, mp.get(x));\\n        }\\n        List<List<Integer>> ans = new ArrayList<>(Ffreq);\\n        for (int i = 0; i < Ffreq; i++) {\\n            ans.add(new ArrayList<>());\\n        }\\n        while (true) {\\n            boolean isValid = true;\\n            for (Map.Entry<Integer, Integer> entry : mp.entrySet()) {\\n                int freq = entry.getValue();\\n                int ele = entry.getKey();\\n                if (freq == 0) continue;\\n                //to check whether all elements of the map are inserted into the list or not.\\n                isValid = false;\\n                ans.get(freq - 1).add(ele);\\n                mp.put(ele, freq - 1);\\n            }\\n            if (isValid) break;\\n        }\\n        return ans;\\n    }\\n}\\n```\\n```Python []\\nclass Solution:\\n    def findMatrix(self, nums: List[int]) -> List[List[int]]:\\n        mp = defaultdict(int)\\n        Ffreq = 0\\n        for x in nums:\\n            mp[x] += 1\\n            Ffreq = max(Ffreq, mp[x])\\n        ans = [[] for _ in range(Ffreq)]\\n        while True:\\n            isValid = True\\n            for ele, freq in mp.items():\\n                if freq == 0:\\n                    continue\\n                #to check whether all elements of the map are inserted into the list or not.\\n                isValid = False\\n                ans[freq-1].append(ele)\\n                mp[ele] -= 1\\n            if isValid:\\n                break\\n        return ans\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python"
                ],
                "code": "``` C++ []\\nclass Solution {\\npublic:\\n    vector<vector<int>> findMatrix(vector<int>& nums) {\\n        unordered_map<int,int> mp;\\n        int Ffreq = 0;\\n        for(auto x : nums)\\n        {\\n            mp[x]++;\\n            Ffreq = max(Ffreq, mp[x]);\\n        }\\n        vector<vector<int>> ans(Ffreq);\\n        \\n        while(1)\\n        {\\n            bool isValid = true;\\n            for(auto it=mp.begin(); it!=mp.end(); it++)\\n            {\\n                int freq = it->second;\\n                int ele = it->first;\\n                if(freq == 0)continue;\\n                isValid = false;\\n                ans[freq-1].push_back(ele);\\n                mp[ele]--;\\n            }\\n            if(isValid)break;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```Java []\\npublic class Solution {\\n    public List<List<Integer>> findMatrix(List<Integer> nums) {\\n        Map<Integer, Integer> mp = new HashMap<>();\\n        int Ffreq = 0;\\n        for (int x : nums) {\\n            mp.put(x, mp.getOrDefault(x, 0) + 1);\\n            Ffreq = Math.max(Ffreq, mp.get(x));\\n        }\\n        List<List<Integer>> ans = new ArrayList<>(Ffreq);\\n        for (int i = 0; i < Ffreq; i++) {\\n            ans.add(new ArrayList<>());\\n        }\\n        while (true) {\\n            boolean isValid = true;\\n            for (Map.Entry<Integer, Integer> entry : mp.entrySet()) {\\n                int freq = entry.getValue();\\n                int ele = entry.getKey();\\n                if (freq == 0) continue;\\n                //to check whether all elements of the map are inserted into the list or not.\\n                isValid = false;\\n                ans.get(freq - 1).add(ele);\\n                mp.put(ele, freq - 1);\\n            }\\n            if (isValid) break;\\n        }\\n        return ans;\\n    }\\n}\\n```\n```Python []\\nclass Solution:\\n    def findMatrix(self, nums: List[int]) -> List[List[int]]:\\n        mp = defaultdict(int)\\n        Ffreq = 0\\n        for x in nums:\\n            mp[x] += 1\\n            Ffreq = max(Ffreq, mp[x])\\n        ans = [[] for _ in range(Ffreq)]\\n        while True:\\n            isValid = True\\n            for ele, freq in mp.items():\\n                if freq == 0:\\n                    continue\\n                #to check whether all elements of the map are inserted into the list or not.\\n                isValid = False\\n                ans[freq-1].append(ele)\\n                mp[ele] -= 1\\n            if isValid:\\n                break\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368449,
                "title": "python-easy-approach-dictionary",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findMatrix(self, nums: List[int]) -> List[List[int]]:\\n        \\n        from collections import defaultdict\\n        \\n        a = defaultdict(int)\\n        \\n        for w in nums:\\n            a[w] += 1\\n        \\n        ans = []\\n        for i in range(max(a.values())):\\n            res = []\\n            for k, v in a.items():\\n                if v != 0:\\n                    a[k] -= 1\\n                    res.append(k)\\n            ans.append(res)\\n            \\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findMatrix(self, nums: List[int]) -> List[List[int]]:\\n        \\n        from collections import defaultdict\\n        \\n        a = defaultdict(int)\\n        \\n        for w in nums:\\n            a[w] += 1\\n        \\n        ans = []\\n        for i in range(max(a.values())):\\n            res = []\\n            for k, v in a.items():\\n                if v != 0:\\n                    a[k] -= 1\\n                    res.append(k)\\n            ans.append(res)\\n            \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368437,
                "title": "c-hashmap-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findMatrix(vector<int>& v) {\\n      unordered_map<int, int> um;\\n      for(auto &i: v) um[i]++;\\n      vector<vector<int>> ans;\\n      while(!um.empty()){\\n        vector<int> temp, toErase;\\n        for(auto &[f, s]: um){\\n          temp.emplace_back(f);\\n          s--;\\n          if(s == 0) toErase.emplace_back(f);\\n        }\\n        ans.emplace_back(temp);\\n        for(auto &i: toErase) um.erase(i);\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findMatrix(vector<int>& v) {\\n      unordered_map<int, int> um;\\n      for(auto &i: v) um[i]++;\\n      vector<vector<int>> ans;\\n      while(!um.empty()){\\n        vector<int> temp, toErase;\\n        for(auto &[f, s]: um){\\n          temp.emplace_back(f);\\n          s--;\\n          if(s == 0) toErase.emplace_back(f);\\n        }\\n        ans.emplace_back(temp);\\n        for(auto &i: toErase) um.erase(i);\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368369,
                "title": "best-code-in-c",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n### Please Upvote if u liked my Solution\\uD83E\\uDD17\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findMatrix(vector<int>& nums) {\\n        int n=nums.size(),maxi=0;\\n        unordered_map<int,int> mp;\\n        for(auto it:nums)\\n            mp[it]++;\\n        for(auto it:mp)\\n            maxi=max(maxi,it.second);\\n        vector<vector<int>> ans(maxi);\\n        for(auto it:mp){\\n            int x=it.second,val=it.first,i=0;\\n            while(x!=0){\\n                ans[i].push_back(val);\\n                x--;i++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findMatrix(vector<int>& nums) {\\n        int n=nums.size(),maxi=0;\\n        unordered_map<int,int> mp;\\n        for(auto it:nums)\\n            mp[it]++;\\n        for(auto it:mp)\\n            maxi=max(maxi,it.second);\\n        vector<vector<int>> ans(maxi);\\n        for(auto it:mp){\\n            int x=it.second,val=it.first,i=0;\\n            while(x!=0){\\n                ans[i].push_back(val);\\n                x--;i++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3404745,
                "title": "c-short-sweet-easy-to-understand-simple-code",
                "content": "````\\nclass Solution {\\npublic:\\n    vector<vector<int>> findMatrix(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        vector<int> tmp;\\n        unordered_map<int,int> mp,mp1;\\n        for(auto &i: nums)mp[i]++;\\n        while(mp.size()){\\n            tmp.clear();\\n            mp1 = mp;\\n            for(auto &i: mp1){\\n                tmp.push_back(i.first);\\n                i.second--;\\n                mp[i.first]--;\\n                if(i.second==0){\\n                    mp.erase(i.first);\\n                }\\n            }\\n            ans.push_back(tmp);\\n        }\\n        return ans;\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Hash Table"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    vector<vector<int>> findMatrix(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        vector<int> tmp;\\n        unordered_map<int,int> mp,mp1;\\n        for(auto &i: nums)mp[i]++;\\n        while(mp.size()){\\n            tmp.clear();\\n            mp1 = mp;\\n            for(auto &i: mp1){\\n                tmp.push_back(i.first);\\n                i.second--;\\n                mp[i.first]--;\\n                if(i.second==0){\\n                    mp.erase(i.first);\\n                }\\n            }\\n            ans.push_back(tmp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3381145,
                "title": "java-frequency-count-simple-10-lines-beats-87",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public List<List<Integer>> findMatrix(int[] nums) {\\n    var map = new int[200];\\n    List<List<Integer>> ans = new ArrayList<>();\\n    \\n    for (var i : nums)\\n      map[i-1]++;\\n\\n    for (var i=0; i<200; i++) {\\n      for (var j=0; j < map[i]; j++) {\\n        if (ans.size() == j)\\n          ans.add(new ArrayList<Integer>());\\n        \\n        ans.get(j).add(i+1);\\n      }\\n    }\\n    return ans;\\n  }\\n}\\n```\\nIf you like my solution, please upvote it!",
                "solutionTags": [
                    "Java",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n  public List<List<Integer>> findMatrix(int[] nums) {\\n    var map = new int[200];\\n    List<List<Integer>> ans = new ArrayList<>();\\n    \\n    for (var i : nums)\\n      map[i-1]++;\\n\\n    for (var i=0; i<200; i++) {\\n      for (var j=0; j < map[i]; j++) {\\n        if (ans.size() == j)\\n          ans.add(new ArrayList<Integer>());\\n        \\n        ans.get(j).add(i+1);\\n      }\\n    }\\n    return ans;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368879,
                "title": "using-dictionaries-logic",
                "content": "\\n# 1.Main Logic is Finding max Frequency\\n```\\nclass Solution:\\n    def findMatrix(self, nums: List[int]) -> List[List[int]]:\\n        dic=Counter(nums)\\n        list2=[]\\n        for i in range(max(dic.values())):\\n            list1=[]\\n            for key,freq in dic.items():\\n                if freq!=0:\\n                    dic[key]-=1\\n                    list1.append(key)\\n            list2.append(list1)\\n        return list2\\n        \\n```\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findMatrix(self, nums: List[int]) -> List[List[int]]:\\n        dic=Counter(nums)\\n        list2=[]\\n        for i in range(max(dic.values())):\\n            list1=[]\\n            for key,freq in dic.items():\\n                if freq!=0:\\n                    dic[key]-=1\\n                    list1.append(key)\\n            list2.append(list1)\\n        return list2\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368537,
                "title": "well-explained-easy-python-3-solution",
                "content": "# Intuition\\nTo satisfy the conditions of having distinct integers in each row and having the minimum number of rows, we can start by sorting the given integer array in descending order. Then we can create rows by adding the highest remaining integer to a row that does not already contain it. If no row exists that does not already contain the integer, we create a new row with that integer.\\n# Approach\\n1. Sort the integer array nums in descending order.\\n2. Initialize an empty list lignes to store the rows of the 2D array.\\n3. For each integer num in nums:\\n    a. Check if num is already present in any of the rows in lignes. If it is not present in any row, create a new row with num and append it to lignes.\\n\\n    b. If num is present in at least one row, add it to the first row in lignes that does not already contain it.\\n4. Return the list of rows lignes as the resulting 2D array.\\n# Complexity\\n- Time complexity:\\nThe sorting operation takes O(n log n) time. The loop over the nums array takes O(n) time, and for each iteration, we search through at most all existing rows in lignes, so the worst-case time complexity is O(n^2). Therefore, the overall time complexity is O(n^2 + n log n), which simplifies to O(n^2).\\n\\n\\n- Space complexity:\\nWe need to store the resulting 2D array, which can have at most n rows and n columns, so the space complexity is O(n^2). Additionally, we need to store the sorted integer array, which takes O(n) space. Therefore, the overall space complexity is O(n^2).\\n# Code\\n```\\nclass Solution:\\n    def findMatrix(self, nums: List[int]) -> List[List[int]]:\\n        nums.sort(reverse=True)\\n        lignes = []\\n        for num in nums:\\n            for ligne in lignes:\\n                if num not in ligne:\\n                    ligne.append(num)\\n                    break\\n            else:\\n                lignes.append([num])\\n        return lignes\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findMatrix(self, nums: List[int]) -> List[List[int]]:\\n        nums.sort(reverse=True)\\n        lignes = []\\n        for num in nums:\\n            for ligne in lignes:\\n                if num not in ligne:\\n                    ligne.append(num)\\n                    break\\n            else:\\n                lignes.append([num])\\n        return lignes\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368381,
                "title": "easy-c-solution-using-hash",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity\\n- Time complexity: O(N) -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findMatrix(vector<int>& nums) {\\n        vector<int> hash(201, 0); \\n        for(auto &n: nums) hash[n]++; \\n        vector<vector<int>> res; \\n        \\n        bool fl = false; \\n        while(true){\\n            vector<int> t; \\n            for(int i=0; i<=200; i++){\\n                if(hash[i]>0){\\n                    t.push_back(i); \\n                    hash[i]--; \\n                    fl = true; \\n                }\\n            }\\n            if(fl)\\n                res.push_back(t);\\n            if(!fl) return res; \\n            fl = false; \\n        }\\n        return res; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findMatrix(vector<int>& nums) {\\n        vector<int> hash(201, 0); \\n        for(auto &n: nums) hash[n]++; \\n        vector<vector<int>> res; \\n        \\n        bool fl = false; \\n        while(true){\\n            vector<int> t; \\n            for(int i=0; i<=200; i++){\\n                if(hash[i]>0){\\n                    t.push_back(i); \\n                    hash[i]--; \\n                    fl = true; \\n                }\\n            }\\n            if(fl)\\n                res.push_back(t);\\n            if(!fl) return res; \\n            fl = false; \\n        }\\n        return res; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3780195,
                "title": "c-different-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findMatrix(vector<int>& nums) {\\n        unordered_map<int,int> mpp;\\n        for(auto i:nums){\\n            mpp[i]++;\\n        }\\n        int x = INT_MIN;\\n        for(auto i:mpp){\\n            x=max(i.second,x);\\n        }\\n        vector<int> v;\\n        vector<vector<int>> ans(x,v);\\n        for(auto &j:mpp){\\n            for(int k=0;k<j.second;k++){\\n                ans[k].push_back(j.first);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findMatrix(vector<int>& nums) {\\n        unordered_map<int,int> mpp;\\n        for(auto i:nums){\\n            mpp[i]++;\\n        }\\n        int x = INT_MIN;\\n        for(auto i:mpp){\\n            x=max(i.second,x);\\n        }\\n        vector<int> v;\\n        vector<vector<int>> ans(x,v);\\n        for(auto &j:mpp){\\n            for(int k=0;k<j.second;k++){\\n                ans[k].push_back(j.first);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522693,
                "title": "python-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def findMatrix(self, nums):\\n        ans=[]\\n        while(len(nums)):\\n            temp = []\\n            for i in nums:\\n                if i not in temp:\\n                    temp.append(i)\\n            for j in temp:\\n                nums.remove(j)\\n            ans.append(temp)\\n        return ans\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def findMatrix(self, nums):\\n        ans=[]\\n        while(len(nums)):\\n            temp = []\\n            for i in nums:\\n                if i not in temp:\\n                    temp.append(i)\\n            for j in temp:\\n                nums.remove(j)\\n            ans.append(temp)\\n        return ans\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3462779,
                "title": "2610-javascript-clean-solution-with-map-o-n-79-ms-98-12",
                "content": "# Approach\\n1. Looping nums build Hash Map and output result.\\na. map - hash map of a number appear time equal to \"output\" index position.\\nb. arr - get the index of \"output\" and push \"num\" to \"arr\", then reassign.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\nvar findMatrix = function(nums) {\\n    let output = [];\\n    let map = new Map();\\n\\n    for(let num of nums){\\n        let idx = map.get(num) || 0;\\n        let arr = output[idx] || [];\\n\\n        arr.push(num);\\n        output[idx] = arr;\\n        map.set(num, idx + 1);\\n    }\\n    \\n    return output;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\nvar findMatrix = function(nums) {\\n    let output = [];\\n    let map = new Map();\\n\\n    for(let num of nums){\\n        let idx = map.get(num) || 0;\\n        let arr = output[idx] || [];\\n\\n        arr.push(num);\\n        output[idx] = arr;\\n        map.set(num, idx + 1);\\n    }\\n    \\n    return output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3391191,
                "title": "c-simple-and-understandable-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findMatrix(vector<int>& nums) {\\n        map<int,int> m;\\n        int q=0;\\n        vector<vector<int>> v;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            m[nums[i]]++;\\n        }\\n        int maxi=0;\\n        for(auto x:m){\\n            if(x.second>maxi){\\n                maxi=x.second;\\n            }\\n        }\\n        for(int i=0;i<maxi;i++){\\n        vector<int> a;\\n        for(auto &x:m){\\n            if(x.second>0){\\n               q=1;\\n               a.push_back(x.first);\\n               x.second--;\\n            }\\n        }\\n        if(q==0){\\n            return v;\\n        }\\n        else{\\n            v.push_back(a);\\n        }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findMatrix(vector<int>& nums) {\\n        map<int,int> m;\\n        int q=0;\\n        vector<vector<int>> v;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            m[nums[i]]++;\\n        }\\n        int maxi=0;\\n        for(auto x:m){\\n            if(x.second>maxi){\\n                maxi=x.second;\\n            }\\n        }\\n        for(int i=0;i<maxi;i++){\\n        vector<int> a;\\n        for(auto &x:m){\\n            if(x.second>0){\\n               q=1;\\n               a.push_back(x.first);\\n               x.second--;\\n            }\\n        }\\n        if(q==0){\\n            return v;\\n        }\\n        else{\\n            v.push_back(a);\\n        }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3373571,
                "title": "4-lines-code-in-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findMatrix(self, nums: List[int]) -> List[List[int]]:\\n        count=Counter(nums)\\n        maxi=max(count.values())\\n        list1=list(count.elements())\\n        return [list1[i::maxi] for i in range(maxi)]\\n        \\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findMatrix(self, nums: List[int]) -> List[List[int]]:\\n        count=Counter(nums)\\n        maxi=max(count.values())\\n        list1=list(count.elements())\\n        return [list1[i::maxi] for i in range(maxi)]\\n        \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371875,
                "title": "c-hashset",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWhen we want somthing *distinct*, hashing is the first that comes to mind. Let\\'s use `List<HashSet<int>>` for computation which we can finally turn into requried `IList<IList<int>>`  \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nA simple loop: we put item into the first HashSet which hasn\\'t such value. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n```\\npublic class Solution {\\n    public IList<IList<int>> FindMatrix(int[] nums) {\\n        List<HashSet<int>> unique = new();\\n\\n        foreach (var item in nums) {\\n            bool found = false;\\n\\n            foreach (HashSet<int> hs in unique)\\n                if (found = hs.Add(item)) \\n                    break;\\n\\n            if (!found)\\n                unique.Add(new HashSet<int>() {item});\\n        }     \\n\\n        return unique\\n            .Select(hs => hs.ToList() as IList<int>)\\n            .ToList();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public IList<IList<int>> FindMatrix(int[] nums) {\\n        List<HashSet<int>> unique = new();\\n\\n        foreach (var item in nums) {\\n            bool found = false;\\n\\n            foreach (HashSet<int> hs in unique)\\n                if (found = hs.Add(item)) \\n                    break;\\n\\n            if (!found)\\n                unique.Add(new HashSet<int>() {item});\\n        }     \\n\\n        return unique\\n            .Select(hs => hs.ToList() as IList<int>)\\n            .ToList();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371176,
                "title": "sort-them-to-avoid-count-them",
                "content": "\\n## Example \\nAssuming Input: nums = [1,3,4,1,2,3,1,1,3,4,1,2,3,1].\\nSort it. \\nnums = [1,1,1,1,1,1,2,2,3,3,4,4].\\n\\nThen we process each distinct element at a time.\\n1. we have __6__ 1\\'s, we have no choice but to put them into __6__ different groups. \\n\\n```text\\ngroup0: 1\\ngroup1: 1\\ngroup2: 1\\ngroup3: 1\\ngroup4: 1\\ngroup5: 1\\n```\\n2. we have __2__ 2\\'s, we put them into the first two groups.\\n\\n```text\\ngroup0: 1 2\\ngroup1: 1 2\\ngroup2: 1\\ngroup3: 1\\ngroup4: 1\\ngroup5: 1\\n```\\n3. we have __2__ 3\\'s\\n\\n```text\\ngroup0: 1 2 3\\ngroup1: 1 2 3\\ngroup2: 1\\ngroup3: 1\\ngroup4: 1\\ngroup5: 1\\n```\\n4. we have __2__ 4\\'s\\n\\n```text\\ngroup0: 1 2 3 4\\ngroup1: 1 2 3 4\\ngroup2: 1\\ngroup3: 1\\ngroup4: 1\\ngroup5: 1\\n```\\n\\n5. Voil\\xE0\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> findMatrix(vector<int>& nums) {\\n        vector<vector<int>> ret(1);\\n        int group = 0;\\n        \\n        // sort it, so that duplicated elements will be put next to each other.\\n        sort(begin(nums), end(nums));\\n\\n        // the first element surely should be put into the first group.\\n        ret[group ++].push_back(nums[0]);\\n        \\n        // iterate from the second element, \\n        for (int i = 1; i < nums.size(); ++i)\\n        {\\n            // if this is a new/non-duplicated element,\\n            // we can go back to group 0.\\n            if (nums[i] != nums[i - 1])\\n                group = 0;\\n            // if this is a duplicate element, \\n            // check if we have to extend a new group for it.\\n            else if (ret.size() <= group)\\n                ret.push_back({});\\n                \\n            // put this element into the right group\\n            ret[group ++].push_back(nums[i]);\\n        }\\n        \\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```text\\ngroup0: 1\\ngroup1: 1\\ngroup2: 1\\ngroup3: 1\\ngroup4: 1\\ngroup5: 1\\n```\n```text\\ngroup0: 1 2\\ngroup1: 1 2\\ngroup2: 1\\ngroup3: 1\\ngroup4: 1\\ngroup5: 1\\n```\n```text\\ngroup0: 1 2 3\\ngroup1: 1 2 3\\ngroup2: 1\\ngroup3: 1\\ngroup4: 1\\ngroup5: 1\\n```\n```text\\ngroup0: 1 2 3 4\\ngroup1: 1 2 3 4\\ngroup2: 1\\ngroup3: 1\\ngroup4: 1\\ngroup5: 1\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> findMatrix(vector<int>& nums) {\\n        vector<vector<int>> ret(1);\\n        int group = 0;\\n        \\n        // sort it, so that duplicated elements will be put next to each other.\\n        sort(begin(nums), end(nums));\\n\\n        // the first element surely should be put into the first group.\\n        ret[group ++].push_back(nums[0]);\\n        \\n        // iterate from the second element, \\n        for (int i = 1; i < nums.size(); ++i)\\n        {\\n            // if this is a new/non-duplicated element,\\n            // we can go back to group 0.\\n            if (nums[i] != nums[i - 1])\\n                group = 0;\\n            // if this is a duplicate element, \\n            // check if we have to extend a new group for it.\\n            else if (ret.size() <= group)\\n                ret.push_back({});\\n                \\n            // put this element into the right group\\n            ret[group ++].push_back(nums[i]);\\n        }\\n        \\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3369447,
                "title": "c-solution-unordered-map-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. The intuition behind this approach is that the unordered map allows the program to count the occurrences of each integer in the input vector in linear time.\\n2.  Then, extracting the unique integers and storing them in a vector allows the program to sort them in logarithmic time. \\n3. Finally, removing all occurrences of each unique integer from the map allows the program to group all occurrences of that integer together and store them in a sub-vector. \\n4. By doing this for all unique integers, the program is able to group all integers together as desired.\\n# Approach\\n1. Using unordered map to store the frequency of each element in the nums and put it into the 1D vector\\n2. Check the frequency if it becomes 0 after putting into the 1D vector than removes the element from the unordered_map \\n3. Run this loop untill all the element has frequecy 0 in the unordered_map.\\n4. lastly return the ans of vector of vector.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(NlogN) , where N is number of element in the nums\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n1. The time complexity of this program is O(N log N), where N is the number of elements in the input vector. The reason for this is because the program uses an unordered map to count the occurrences of each element in the input vector, which takes O(N) time. Then, it loops through the map to extract the unique elements and store them in a vector, which takes O(N log N) time due to sorting. Finally, it loops through the unique elements and removes them from the map, which takes another O(N) time. Therefore, the overall time complexity is O(N log N).\\n\\n2. The space complexity of this program is also O(N), where N is the number of elements in the input vector. This is because the program uses an unordered map to store the count of each element in the input vector, which takes up O(N) space. Additionally, the program stores the unique elements in a vector, which takes up another O(N) space in the worst case if all elements are unique. Finally, the program returns a 2D vector with the same number of elements as the input vector, which also takes up O(N) space. Therefore, the overall space complexity is O(N).\\n# Code\\n```\\n#include <bits/stdc++.h>\\nusing namespace std;\\n\\nclass Solution\\n{\\npublic:\\n    vector<vector<int>> findMatrix(vector<int> &nums)\\n    {\\n        unordered_map<int, int> m;\\n        for (int i : nums)\\n            m[i]++;\\n\\n        vector<vector<int>> ans;\\n        while (m.size() > 0)\\n        {\\n            vector<int> v;\\n            for (auto i : m)\\n            {\\n                v.push_back(i.first);\\n            }\\n            for (auto i : v)\\n            {\\n                m[i]--;\\n                if (m[i] == 0)\\n                {\\n                    m.erase(i);\\n                }\\n            }\\n            ans.push_back(v);\\n\\n           \\n        }\\n        return ans;\\n    }\\n};\\n\\n/* int main()\\n {\\n     Solution obj;\\n     vector<int> vec;\\n     vec = {1, 3, 4, 1, 2, 3, 1};\\n     vector<vector<int>>answer;\\n\\n\\n     answer=obj.findMatrix(vec);\\n     for(auto vector: answer){\\n         for(auto it1:vector){\\n             cout<<it1<<\" \";\\n         }\\n         cout<<endl;\\n     }\\n\\n    return 0;\\n }\\n```*/",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include <bits/stdc++.h>\\nusing namespace std;\\n\\nclass Solution\\n{\\npublic:\\n    vector<vector<int>> findMatrix(vector<int> &nums)\\n    {\\n        unordered_map<int, int> m;\\n        for (int i : nums)\\n            m[i]++;\\n\\n        vector<vector<int>> ans;\\n        while (m.size() > 0)\\n        {\\n            vector<int> v;\\n            for (auto i : m)\\n            {\\n                v.push_back(i.first);\\n            }\\n            for (auto i : v)\\n            {\\n                m[i]--;\\n                if (m[i] == 0)\\n                {\\n                    m.erase(i);\\n                }\\n            }\\n            ans.push_back(v);\\n\\n           \\n        }\\n        return ans;\\n    }\\n};\\n\\n/* int main()\\n {\\n     Solution obj;\\n     vector<int> vec;\\n     vec = {1, 3, 4, 1, 2, 3, 1};\\n     vector<vector<int>>answer;\\n\\n\\n     answer=obj.findMatrix(vec);\\n     for(auto vector: answer){\\n         for(auto it1:vector){\\n             cout<<it1<<\" \";\\n         }\\n         cout<<endl;\\n     }\\n\\n    return 0;\\n }\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3368845,
                "title": "handling-concurrency-exception-in-hashmap-in-java",
                "content": "# Complexity\\n- Time complexity:O(n)\\n\\n- Space complexity:O(n)\\n\\n![b427e686-2e5d-469a-8e7a-db5140022a6b_1677715904.0948765.png](https://assets.leetcode.com/users/images/feb5b6db-3337-4a90-b863-80ef32e1eb9e_1680412040.3597918.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> findMatrix(int[] nums) {\\n        List<List<Integer>> lst = new ArrayList<>();\\n        Map<Integer,Integer> map = new ConcurrentHashMap<Integer,Integer>();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            map.put(nums[i],map.getOrDefault(nums[i],0)+1);\\n        }\\n\\n        while(!map.isEmpty())\\n        {\\n            List<Integer> l = new ArrayList<>();\\n            \\n            for(Integer i:map.keySet())\\n            {\\n                l.add(i);\\n                map.put(i,map.get(i)-1);\\n                if(map.get(i)<=0)\\n                    map.remove(i);\\n            }\\n            \\n            lst.add(l);\\n        }\\n        return lst;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> findMatrix(int[] nums) {\\n        List<List<Integer>> lst = new ArrayList<>();\\n        Map<Integer,Integer> map = new ConcurrentHashMap<Integer,Integer>();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            map.put(nums[i],map.getOrDefault(nums[i],0)+1);\\n        }\\n\\n        while(!map.isEmpty())\\n        {\\n            List<Integer> l = new ArrayList<>();\\n            \\n            for(Integer i:map.keySet())\\n            {\\n                l.add(i);\\n                map.put(i,map.get(i)-1);\\n                if(map.get(i)<=0)\\n                    map.remove(i);\\n            }\\n            \\n            lst.add(l);\\n        }\\n        return lst;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368563,
                "title": "python-dict-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTask is to create a 2-D list with unique values and minimum number of rows.\\n* Point 1: Minimum number of rows will be the maximum number of duplicates in the array. For example if we have `[1,2,1,2,1,1]` then we have `{1: 4, 2: 2}` means we need at least 4 rows in the resultant list.\\n* Point 2: If we have count of the values then we can simply insert them into each row using a loop.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$ : Where n is the size of the elements in the nums\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$ : Because we have used extra space for ans array and frequency.\\n\\n# Code\\n```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def findMatrix(self, nums: List[int]) -> List[List[int]]:\\n        freq = Counter(nums)\\n        \\n        ans = []\\n        \\n        for key in freq:\\n            for val in range(freq[key]):\\n                if len(ans) <= val:\\n                    ans.append([])\\n                ans[val].append(key)\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def findMatrix(self, nums: List[int]) -> List[List[int]]:\\n        freq = Counter(nums)\\n        \\n        ans = []\\n        \\n        for key in freq:\\n            for val in range(freq[key]):\\n                if len(ans) <= val:\\n                    ans.append([])\\n                ans[val].append(key)\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368370,
                "title": "map-c-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findMatrix(vector<int>& nums) {\\n        int n = nums.size();\\n        map<int,int> mp;\\n         vector<vector<int>> ans;\\n        \\n        \\n       for(int i=0; i<nums.size(); i++){\\n           mp[nums[i]]++;\\n       }\\n        \\n        \\n        while(!mp.empty()){\\n            vector<int> temp1;\\n            vector<int> temp2;\\n            for(auto i:mp){\\n                temp1.push_back(i.first);\\n                mp[i.first]--;\\n                if(mp[i.first]==0){\\n                    temp2.push_back(i.first);\\n                }\\n                \\n            }\\n            ans.push_back(temp1);\\n            for(auto &i: temp2){\\n                mp.erase(i);\\n\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findMatrix(vector<int>& nums) {\\n        int n = nums.size();\\n        map<int,int> mp;\\n         vector<vector<int>> ans;\\n        \\n        \\n       for(int i=0; i<nums.size(); i++){\\n           mp[nums[i]]++;\\n       }\\n        \\n        \\n        while(!mp.empty()){\\n            vector<int> temp1;\\n            vector<int> temp2;\\n            for(auto i:mp){\\n                temp1.push_back(i.first);\\n                mp[i.first]--;\\n                if(mp[i.first]==0){\\n                    temp2.push_back(i.first);\\n                }\\n                \\n            }\\n            ans.push_back(temp1);\\n            for(auto &i: temp2){\\n                mp.erase(i);\\n\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3950852,
                "title": "easy-solution-using-maps-optimal-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findMatrix(vector<int>& nums) {\\n        map<int,int> mp;\\n        int max_rows=0;\\n        for(auto i:nums)\\n        {\\n            mp[i]++;\\n            max_rows=max(max_rows,mp[i]);\\n        }\\n        vector<vector<int>> v(max_rows);\\n        for(auto j:mp)\\n        {\\n            for(int i=0;i<j.second;i++)\\n            {\\n                v[i].push_back(j.first);\\n            }\\n        }\\n\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findMatrix(vector<int>& nums) {\\n        map<int,int> mp;\\n        int max_rows=0;\\n        for(auto i:nums)\\n        {\\n            mp[i]++;\\n            max_rows=max(max_rows,mp[i]);\\n        }\\n        vector<vector<int>> v(max_rows);\\n        for(auto j:mp)\\n        {\\n            for(int i=0;i<j.second;i++)\\n            {\\n                v[i].push_back(j.first);\\n            }\\n        }\\n\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3950393,
                "title": "easy-java-solution-beats-85",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> findMatrix(int[] nums) {\\n        ArrayList<Integer> temp = new ArrayList<>();\\n        for(int i = 0 ; i < nums.length ; i++){\\n            temp.add(nums[i]);\\n        }\\n        List<List<Integer>> ans = new ArrayList<>();\\n        while(temp.size() > 0){\\n            List<Integer> row = new ArrayList<>();\\n            row.clear();\\n            int i = 0;\\n            while(i < temp.size()){\\n                int a = temp.get(i);\\n                if(!row.contains(a)){\\n                    row.add(a);\\n                    temp.remove(i);\\n                }\\n                else{\\n                    i++;\\n                }\\n            }\\n            ans.add(row);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> findMatrix(int[] nums) {\\n        ArrayList<Integer> temp = new ArrayList<>();\\n        for(int i = 0 ; i < nums.length ; i++){\\n            temp.add(nums[i]);\\n        }\\n        List<List<Integer>> ans = new ArrayList<>();\\n        while(temp.size() > 0){\\n            List<Integer> row = new ArrayList<>();\\n            row.clear();\\n            int i = 0;\\n            while(i < temp.size()){\\n                int a = temp.get(i);\\n                if(!row.contains(a)){\\n                    row.add(a);\\n                    temp.remove(i);\\n                }\\n                else{\\n                    i++;\\n                }\\n            }\\n            ans.add(row);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3923149,
                "title": "c-javascript-easy-solution",
                "content": "# Complexity\\n- Time complexity: O(n * log n + m)\\n\\n- Space complexity: O(m), where m is the number of unique numbers in the nums array.\\n\\n# Code\\n# C++\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findMatrix(vector<int>& nums) {\\n        vector<vector<int>> v;\\n        map<int, int> m;  \\n        for (int i = 0; i < nums.size(); i++) m[nums[i]]++;\\n        int mx=0;\\n        for(auto k:m) mx=max(mx,k.second);\\n    \\n        for(int i=0;i<mx;i++){\\n            vector<int>vv;\\n            for(auto k:m){\\n               if(k.second!=0){\\n                    vv.push_back(k.first);\\n                    m[k.first] = k.second - 1;\\n               }\\n            }\\n            if(vv.size()!=0) v.push_back(vv);\\n        }\\n        return v;\\n    }\\n};\\n```\\n# JavaScript\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\nvar findMatrix = function(nums) {\\n    const sortedNums = nums.slice().sort((a, b) => b - a);\\n    const result = [];\\n\\n    for (const num of sortedNums) {\\n        let added = false;\\n        for (const row of result) {\\n            if (!row.includes(num)) {\\n                row.push(num);\\n                added = true;\\n                break;\\n            }\\n        }\\n        if (!added) {\\n            result.push([num]);\\n        }\\n    }\\n    return result;\\n\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "JavaScript",
                    "Array",
                    "Hash Table",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findMatrix(vector<int>& nums) {\\n        vector<vector<int>> v;\\n        map<int, int> m;  \\n        for (int i = 0; i < nums.size(); i++) m[nums[i]]++;\\n        int mx=0;\\n        for(auto k:m) mx=max(mx,k.second);\\n    \\n        for(int i=0;i<mx;i++){\\n            vector<int>vv;\\n            for(auto k:m){\\n               if(k.second!=0){\\n                    vv.push_back(k.first);\\n                    m[k.first] = k.second - 1;\\n               }\\n            }\\n            if(vv.size()!=0) v.push_back(vv);\\n        }\\n        return v;\\n    }\\n};\\n```\n```\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\nvar findMatrix = function(nums) {\\n    const sortedNums = nums.slice().sort((a, b) => b - a);\\n    const result = [];\\n\\n    for (const num of sortedNums) {\\n        let added = false;\\n        for (const row of result) {\\n            if (!row.includes(num)) {\\n                row.push(num);\\n                added = true;\\n                break;\\n            }\\n        }\\n        if (!added) {\\n            result.push([num]);\\n        }\\n    }\\n    return result;\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3852499,
                "title": "easy-and-direct-java-solution-by-using-only-one-array",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> findMatrix(int[] nums) {\\n    List<List<Integer>> ans=new ArrayList<>();\\n    int arr[]=new int[10001];\\n    \\n    int max=0;\\n    for(int i:nums){\\n        arr[i]++;  \\n    }\\n//finding number of rows \\n    for(int i:arr){\\n        if(i>max){\\n            max=i;\\n        }\\n    }\\n    while(max>0){\\n        List<Integer> list=new ArrayList<>();\\n        for(int i=0;i<arr.length;i++){\\n            if(arr[i]>0){\\n                list.add(i);\\n                arr[i]--;\\n            }\\n        }\\n        max--;\\n        ans.add(list);\\n    }\\n    return ans;\\n        }\\n    }\\n    ```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> findMatrix(int[] nums) {\\n    List<List<Integer>> ans=new ArrayList<>();\\n    int arr[]=new int[10001];\\n    \\n    int max=0;\\n    for(int i:nums){\\n        arr[i]++;  \\n    }\\n//finding number of rows \\n    for(int i:arr){\\n        if(i>max){\\n            max=i;\\n        }\\n    }\\n    while(max>0){\\n        List<Integer> list=new ArrayList<>();\\n        for(int i=0;i<arr.length;i++){\\n            if(arr[i]>0){\\n                list.add(i);\\n                arr[i]--;\\n            }\\n        }\\n        max--;\\n        ans.add(list);\\n    }\\n    return ans;\\n        }\\n    }\\n    ```",
                "codeTag": "Java"
            },
            {
                "id": 3814260,
                "title": "easy-c-solution-beginner-friendly-hash-map-approach",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findMatrix(vector<int>& nums) {\\n        map<int, int> mp;\\n        for(int i=0; i<nums.size(); i++)\\n            mp[nums[i]]++;\\n        int maxi = 0;\\n        for(auto i : mp)\\n            maxi = max(maxi, i.second);\\n        vector<vector<int>> ans;\\n        for(int i = 0; i < maxi; i++){\\n            vector<int> e;\\n            for(auto it = mp.begin(); it != mp.end(); it++){\\n                if(mp[it->first]!=0){\\n                    e.push_back(it->first);\\n                    mp[(it->first)]--;\\n                }\\n            }\\n            ans.push_back(e);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findMatrix(vector<int>& nums) {\\n        map<int, int> mp;\\n        for(int i=0; i<nums.size(); i++)\\n            mp[nums[i]]++;\\n        int maxi = 0;\\n        for(auto i : mp)\\n            maxi = max(maxi, i.second);\\n        vector<vector<int>> ans;\\n        for(int i = 0; i < maxi; i++){\\n            vector<int> e;\\n            for(auto it = mp.begin(); it != mp.end(); it++){\\n                if(mp[it->first]!=0){\\n                    e.push_back(it->first);\\n                    mp[(it->first)]--;\\n                }\\n            }\\n            ans.push_back(e);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3682728,
                "title": "c-understandable-counter-array-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nat first I wanted to use a dictionary to count all the numbers occurrences, but after i saw the **constrain: [1 <= nums[i] <= nums.length]** I knew I can use a counter array somehow\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSo I made a **CounterArray**, after that I needed to find the length of the list. After some thinking I found out that **the length should be the number with most occurrences** (e.g [1,3,4,3,1,2,1], 1 has the **max occurrences** which **is 3**, hence the list will have **3 rows/Sub-Lists**)\\n\\n**[nums[i] - 1]** ++;\\n the minus 1 is becuase of the **constrain: [1 <= nums[i] <= nums.length]** which states the **lowest number is 1**\\n\\nthe last part might be tricky, you are welcome to leave a comment with your questions if needed, I will answer them asap.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n- $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- $$O(n)$$ **(For the Counter Array)**\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\npublic class Solution {\\n    public IList<IList<int>> FindMatrix(int[] nums) {\\n        int[] counterArr = new int[nums.Length]; // constrain: [1 <= nums[i] <= nums.length]\\n        int maxCount = 0; // the count of the number with the most occurrences\\n        \\n        for(int i = 0; i < nums.Length; i++){\\n            counterArr[nums[i] - 1]++; // adding +1 to the counter array\\n            maxCount = Math.Max(maxCount, counterArr[nums[i]-1]); // checking for new number with the most occurrences\\n        }\\n\\n        // initialize list and sub-lists with the given length of max count\\n        List<IList<int>> result = new List<IList<int>>(maxCount);\\n        for(int i = 0; i < maxCount; i++)\\n            result.Add(new List<int>());\\n        \\n                \\n        // for each counterArr[i] add i+1 to all the lists in result\\n        // e.g if counterArr[i] = 3, add i+1 to result[0], result[1], result[2]\\n        for(int i = 0; i < counterArr.Length; i++)          \\n            for(int j = 0; j < counterArr[i]; j++)\\n                result[j].Add(i+1);                       \\n                                   \\n        return result;         \\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public IList<IList<int>> FindMatrix(int[] nums) {\\n        int[] counterArr = new int[nums.Length]; // constrain: [1 <= nums[i] <= nums.length]\\n        int maxCount = 0; // the count of the number with the most occurrences\\n        \\n        for(int i = 0; i < nums.Length; i++){\\n            counterArr[nums[i] - 1]++; // adding +1 to the counter array\\n            maxCount = Math.Max(maxCount, counterArr[nums[i]-1]); // checking for new number with the most occurrences\\n        }\\n\\n        // initialize list and sub-lists with the given length of max count\\n        List<IList<int>> result = new List<IList<int>>(maxCount);\\n        for(int i = 0; i < maxCount; i++)\\n            result.Add(new List<int>());\\n        \\n                \\n        // for each counterArr[i] add i+1 to all the lists in result\\n        // e.g if counterArr[i] = 3, add i+1 to result[0], result[1], result[2]\\n        for(int i = 0; i < counterArr.Length; i++)          \\n            for(int j = 0; j < counterArr[i]; j++)\\n                result[j].Add(i+1);                       \\n                                   \\n        return result;         \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3670814,
                "title": "o-n-solution",
                "content": "# Summary\\nIm sure there is a far better way to solve but I wasn\\'t able to see any O(N) solutions available so decided to post. \\n\\n# Approach\\nStep 1: Create a hashmap (mp1) to that maps elements of nums to their frequency and keep track of the maximum frequency (maxfreq).  \\n\\nStep 2: Create another hashmap (mp2) that uses mp1 to map the frequency to a list of elements in nums\\n\\nStep 3: Since the maximum frequency is the amount of lists in the result array, fill it up with empty arrays\\n\\nStep 4: Append each list of \\'num\\' with the same frequency to the ith location in the result array. Trick behind what makes this part O(N) is that you will only iterate through a total of sum(frequency) times, i.e. the length of nums. To reiterate, the sum of all \"freq\" in mp2 will only be the length of nums ==> O(N)Time.    \\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\n#O(N)Time O(infinity)Space\\nclass Solution:\\n    def findMatrix(self, nums: List[int]) -> List[List[int]]:\\n        maxfreq, res, mp1, mp2 = -1, [], {}, {}\\n        for num in nums:\\n            mp1[num] = mp1.get(num, 0) +1\\n            maxfreq = max(mp1[num], maxfreq)\\n        for num in mp1:\\n            freq = mp1[num]\\n            mp2[freq] = mp2.get(freq, [])\\n            mp2[freq].append(num)\\n        for i in range(maxfreq):\\n            res.append([])\\n        for freq in mp2: #Step4 Explains why this is still O(N)\\n            for i in range(freq): \\n                res[i] += mp2[freq]\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n#O(N)Time O(infinity)Space\\nclass Solution:\\n    def findMatrix(self, nums: List[int]) -> List[List[int]]:\\n        maxfreq, res, mp1, mp2 = -1, [], {}, {}\\n        for num in nums:\\n            mp1[num] = mp1.get(num, 0) +1\\n            maxfreq = max(mp1[num], maxfreq)\\n        for num in mp1:\\n            freq = mp1[num]\\n            mp2[freq] = mp2.get(freq, [])\\n            mp2[freq].append(num)\\n        for i in range(maxfreq):\\n            res.append([])\\n        for freq in mp2: #Step4 Explains why this is still O(N)\\n            for i in range(freq): \\n                res[i] += mp2[freq]\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3561782,
                "title": "easy-c-solution-using-unordered-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findMatrix(vector<int>& nums) {\\n        \\n        int no_of_arrays = 0;\\n        unordered_map<int,int>freq;\\n        for(auto i:nums)\\n            freq[i]++;\\n        for(auto i:freq)\\n            no_of_arrays = max(no_of_arrays,i.second);\\n        vector<vector<int>>ans(no_of_arrays);\\n        for(auto i:freq)\\n        {\\n            for(int j=0;j<i.second;j++)\\n                ans[j].push_back(i.first);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findMatrix(vector<int>& nums) {\\n        \\n        int no_of_arrays = 0;\\n        unordered_map<int,int>freq;\\n        for(auto i:nums)\\n            freq[i]++;\\n        for(auto i:freq)\\n            no_of_arrays = max(no_of_arrays,i.second);\\n        vector<vector<int>>ans(no_of_arrays);\\n        for(auto i:freq)\\n        {\\n            for(int j=0;j<i.second;j++)\\n                ans[j].push_back(i.first);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3539552,
                "title": "easy-to-understand-beginner-friendly-using-map",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findMatrix(vector<int>& nums) {\\n        int n=nums.size(),rowSize=0;;\\n        unordered_map<int,int>mp;\\n        for(auto i:nums) \\n        {\\n            mp[i]++;\\n            rowSize=max(rowSize,mp[i]);\\n        }\\n        vector<vector<int>>ans(rowSize);\\n        int k=0;\\n        for(auto i:mp)\\n        {\\n            int t=i.second;\\n            while(t--)\\n            {\\n                ans[k%rowSize].push_back(i.first);\\n                k++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findMatrix(vector<int>& nums) {\\n        int n=nums.size(),rowSize=0;;\\n        unordered_map<int,int>mp;\\n        for(auto i:nums) \\n        {\\n            mp[i]++;\\n            rowSize=max(rowSize,mp[i]);\\n        }\\n        vector<vector<int>>ans(rowSize);\\n        int k=0;\\n        for(auto i:mp)\\n        {\\n            int t=i.second;\\n            while(t--)\\n            {\\n                ans[k%rowSize].push_back(i.first);\\n                k++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3534274,
                "title": "c-easy-solution-using-only-one-hash-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing 1 Hash map\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findMatrix(vector<int>& nums) {\\n        vector<vector<int>>ans;\\n        map<int,set<int>>mp;\\n        int j=0;\\n        for(int i=0;i<nums.size();i++){\\n            j=0;\\n            for(auto it:mp){\\n                if(it.second.count(nums[i])){\\n                    j++;\\n                }   \\n            }  \\n            mp[j].insert(nums[i]);\\n        }\\n        for(auto it=mp.begin(); it!=mp.end();it++){\\n            vector<int>v;\\n            set<int>s = it->second;\\n            for(auto i:s){\\n                v.push_back(i);\\n            }\\n            ans.push_back(v);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findMatrix(vector<int>& nums) {\\n        vector<vector<int>>ans;\\n        map<int,set<int>>mp;\\n        int j=0;\\n        for(int i=0;i<nums.size();i++){\\n            j=0;\\n            for(auto it:mp){\\n                if(it.second.count(nums[i])){\\n                    j++;\\n                }   \\n            }  \\n            mp[j].insert(nums[i]);\\n        }\\n        for(auto it=mp.begin(); it!=mp.end();it++){\\n            vector<int>v;\\n            set<int>s = it->second;\\n            for(auto i:s){\\n                v.push_back(i);\\n            }\\n            ans.push_back(v);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3506120,
                "title": "keep-a-map-of-freq",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findMatrix(vector<int>& a) {\\n        unordered_map<int, int> mp,mp2;\\n        for(auto i: a)\\n        {\\n            mp[i]++;\\n        }\\n        bool t = true;\\n        vector<vector<int>> res;\\n        while(t)\\n        {\\n            vector<int > temp;\\n            t = false;\\n            mp2 = mp;\\n            for(auto i: mp2)\\n            {\\n                temp.push_back(i.first);\\n                mp[i.first]--;\\n                if(mp[i.first] == 0 ){\\n                    mp.erase(i.first);\\n                }\\n                t = true;\\n            }\\n            if(!t)\\n                break;\\n            res.push_back(temp);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findMatrix(vector<int>& a) {\\n        unordered_map<int, int> mp,mp2;\\n        for(auto i: a)\\n        {\\n            mp[i]++;\\n        }\\n        bool t = true;\\n        vector<vector<int>> res;\\n        while(t)\\n        {\\n            vector<int > temp;\\n            t = false;\\n            mp2 = mp;\\n            for(auto i: mp2)\\n            {\\n                temp.push_back(i.first);\\n                mp[i.first]--;\\n                if(mp[i.first] == 0 ){\\n                    mp.erase(i.first);\\n                }\\n                t = true;\\n            }\\n            if(!t)\\n                break;\\n            res.push_back(temp);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3491178,
                "title": "dart-simple-code",
                "content": "# Code\\n```\\nclass Solution {\\n    List<List<int>> findMatrix(List<int> nums) {\\n        List<List<int>> list = [];\\n        int l = 0;\\n\\n        for(int i = 0; i < nums.length; i++){\\n            if(list.length == l){\\n                list.add([]);\\n            }\\n            if(!list[l].contains(nums[i])){\\n                list[l].add(nums[i]);\\n                l = 0;\\n            }\\n            else if(list[l].contains(nums[i])){\\n                l++;\\n                i--;\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n    List<List<int>> findMatrix(List<int> nums) {\\n        List<List<int>> list = [];\\n        int l = 0;\\n\\n        for(int i = 0; i < nums.length; i++){\\n            if(list.length == l){\\n                list.add([]);\\n            }\\n            if(!list[l].contains(nums[i])){\\n                list[l].add(nums[i]);\\n                l = 0;\\n            }\\n            else if(list[l].contains(nums[i])){\\n                l++;\\n                i--;\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446343,
                "title": "python-brute-force-and-hashing-aproaches",
                "content": "# Intuition\\nQuestion is all about dividing array intto different arrays such that each array should contain different elements.\\n\\n# Approach\\nBRUTE FORCE\\nFor every index create a list and add elements if they are distinct and delete those elements from the list.But here for every element we check its right side elements(and have to check do they exists in the ans list if no then add) which is 0(N**2) complexity \\n\\nOPTIMAL APPROACH\\nI have created a dicitonary such that it contains frequency of elements.Now i transverse through the dictionary and add them into one list(even above(brute force approach there adding from given list) we done the same but in dictioanry there are no duplicates so no need to check into ans list while adding instead we can add them) and i delete those elements from the dictionary and then i transvers through the list until the dictioanry lenght becomes zero\\n\\n# Complexity\\n- Time complexity:\\nFinding frequency=0(N)\\nIn while loop i have run sum(d.values() i.e 0(N)) times and for deleteing those i have run 0(lenght of dciotnary (liner only)) so its complexity also 0(N) thats why total time complexity is 0(N)\\n\\n- Space complexity:\\nSpace complexity is )(N)\\n\\n# Code\\n```\\nclass Solution:\\n    def findMatrix(self, nums: List[int]) -> List[List[int]]:\\n        d={}#dicitonary for storing frequency\\n        ans=[]#answer variable to stare distinct list\\nfinding frequncies\\n        for i in nums:\\n            d[i]=d.get(i,0)+1 \\n        l=len(d)\\n\\n        while len(d): #while some element exists in dictionary\\n            ans.append([])#creatinf list for every transverse\\n            delitems=[]#items to be deleted after adding them to ans\\n            for i,j in d.items():\\n                ans[-1].append(i)\\n                d[i]-=1 \\n                if d[i]==0:#if that element frequency becomes zero then we can delete that element from dictioanry\\n                    delitems.append(i)\\n            for i in delitems:\\n                del d[i]#deleting elemtns whose frequncy is zero\\n                \\n        return ans#returing the answer\\n                \\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def findMatrix(self, nums: List[int]) -> List[List[int]]:\\n        d={}#dicitonary for storing frequency\\n        ans=[]#answer variable to stare distinct list\\nfinding frequncies\\n        for i in nums:\\n            d[i]=d.get(i,0)+1 \\n        l=len(d)\\n\\n        while len(d): #while some element exists in dictionary\\n            ans.append([])#creatinf list for every transverse\\n            delitems=[]#items to be deleted after adding them to ans\\n            for i,j in d.items():\\n                ans[-1].append(i)\\n                d[i]-=1 \\n                if d[i]==0:#if that element frequency becomes zero then we can delete that element from dictioanry\\n                    delitems.append(i)\\n            for i in delitems:\\n                del d[i]#deleting elemtns whose frequncy is zero\\n                \\n        return ans#returing the answer\\n                \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3432403,
                "title": "using-cpp-easy-solution",
                "content": "![UPvote.jpg](https://assets.leetcode.com/users/images/1c4cf841-4c2f-41c6-9f18-7f17d4b54107_1681844342.4376335.jpeg)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findMatrix(vector<int>& nums) {\\n        vector<vector<int>>res;\\n        vector<int>v;\\n        while(nums.size()){\\n            for(int i=0;i<nums.size();i++){\\n                bool exists = false;\\n                for(int j = 0;j<v.size();j++){\\n                    if(nums[i]==v[j]){\\n                        exists = true;\\n                        break;\\n                    }\\n                }\\n                if(!exists){\\n                    v.push_back(nums[i]);\\n                    nums.erase(nums.begin()+i);\\n                    i--;\\n                }\\n            }\\n            res.push_back(v);\\n            v.clear();\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findMatrix(vector<int>& nums) {\\n        vector<vector<int>>res;\\n        vector<int>v;\\n        while(nums.size()){\\n            for(int i=0;i<nums.size();i++){\\n                bool exists = false;\\n                for(int j = 0;j<v.size();j++){\\n                    if(nums[i]==v[j]){\\n                        exists = true;\\n                        break;\\n                    }\\n                }\\n                if(!exists){\\n                    v.push_back(nums[i]);\\n                    nums.erase(nums.begin()+i);\\n                    i--;\\n                }\\n            }\\n            res.push_back(v);\\n            v.clear();\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3415005,
                "title": "sort-and-put",
                "content": "# Approach\\n- Sort the numbers in ascending order.\\n- Put numbers one by one into vectors.\\n  - expand the vector during iteration.\\n  - clear the points(index, prevNum) if it\\'s not the same number\\n\\n# Complexity\\n- Time complexity: O(n logn)\\n\\n# Code\\n```\\nclass Bucket {\\npublic:\\n    void Put(int num) {\\n        if (isNewNumber(num)) clearForNext();\\n        if (shouldExpand()) expandVector();\\n\\n        putNumber(num);\\n    }\\n\\n    vector<vector<int>>& Get() {\\n        return storage;\\n    }\\n\\nprivate:\\n    bool shouldExpand() {\\n        return storage.size() <= index;\\n    }\\n\\n    void expandVector() {\\n        storage.push_back(vector<int>());\\n    }\\n\\n    bool isNewNumber(int num) {\\n        return num != prevNum;\\n    }\\n\\n    void clearForNext() {\\n        prevNum = -1;\\n        index = 0;\\n    }\\n\\n    void putNumber(int num) {\\n        storage[index].push_back(num);\\n        prevNum = num;\\n        index++;\\n    }\\n\\n    vector<vector<int>> storage;\\n    int prevNum = -1;\\n    int index = 0;\\n};\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> findMatrix(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n\\n        Bucket bucket;\\n\\n        for (auto &num : nums) {\\n            bucket.Put(num);\\n        }\\n\\n        return bucket.Get();\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Bucket {\\npublic:\\n    void Put(int num) {\\n        if (isNewNumber(num)) clearForNext();\\n        if (shouldExpand()) expandVector();\\n\\n        putNumber(num);\\n    }\\n\\n    vector<vector<int>>& Get() {\\n        return storage;\\n    }\\n\\nprivate:\\n    bool shouldExpand() {\\n        return storage.size() <= index;\\n    }\\n\\n    void expandVector() {\\n        storage.push_back(vector<int>());\\n    }\\n\\n    bool isNewNumber(int num) {\\n        return num != prevNum;\\n    }\\n\\n    void clearForNext() {\\n        prevNum = -1;\\n        index = 0;\\n    }\\n\\n    void putNumber(int num) {\\n        storage[index].push_back(num);\\n        prevNum = num;\\n        index++;\\n    }\\n\\n    vector<vector<int>> storage;\\n    int prevNum = -1;\\n    int index = 0;\\n};\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> findMatrix(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n\\n        Bucket bucket;\\n\\n        for (auto &num : nums) {\\n            bucket.Put(num);\\n        }\\n\\n        return bucket.Get();\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3413648,
                "title": "convert-an-array-into-a-2d-array-with-conditions-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findMatrix(vector<int>& nums) {\\n        vector<int> temp;\\n        vector<vector<int>> ans;\\n        while(nums.size()>0)\\n        {\\n            temp.push_back(nums[0]);\\n            nums.erase(nums.begin()+0);\\n            int i=0;\\n            while(i<nums.size())\\n            {\\n                if(count(temp.begin(), temp.end(), nums[i])==0)\\n                {\\n                    temp.push_back(nums[i]);\\n                    nums.erase(nums.begin()+i);\\n                }\\n                else\\n                {\\n                    i++;\\n                }\\n            }\\n            ans.push_back(temp);\\n            temp.clear();\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/792a2ee3-fa92-4936-9a87-216cd9a9ac02_1682613207.1269994.jpeg)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findMatrix(vector<int>& nums) {\\n        vector<int> temp;\\n        vector<vector<int>> ans;\\n        while(nums.size()>0)\\n        {\\n            temp.push_back(nums[0]);\\n            nums.erase(nums.begin()+0);\\n            int i=0;\\n            while(i<nums.size())\\n            {\\n                if(count(temp.begin(), temp.end(), nums[i])==0)\\n                {\\n                    temp.push_back(nums[i]);\\n                    nums.erase(nums.begin()+i);\\n                }\\n                else\\n                {\\n                    i++;\\n                }\\n            }\\n            ans.push_back(temp);\\n            temp.clear();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3410576,
                "title": "simple-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def findMatrix(self, nums: List[int]) -> List[List[int]]:\\n        output = []\\n\\n        while len(nums):\\n            output.append(list(set(nums)))\\n            for i in output[-1]:\\n                nums.pop(nums.index(i))\\n        \\n        return output\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findMatrix(self, nums: List[int]) -> List[List[int]]:\\n        output = []\\n\\n        while len(nums):\\n            output.append(list(set(nums)))\\n            for i in output[-1]:\\n                nums.pop(nums.index(i))\\n        \\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3404442,
                "title": "c-solution-hashing",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findMatrix(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        map<int,int> mp;\\n        for (auto val: nums)mp[val]++;\\n        while (!mp.empty()){\\n            vector<int> tmp;\\n            for (auto it: mp){ \\n                tmp.push_back(it.first);\\n                //mp[it.first]--;\\n            }\\n            for (auto it: tmp){\\n                if (--mp[it]==0)mp.erase(it);\\n            }\\n            ans.push_back(tmp);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findMatrix(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        map<int,int> mp;\\n        for (auto val: nums)mp[val]++;\\n        while (!mp.empty()){\\n            vector<int> tmp;\\n            for (auto it: mp){ \\n                tmp.push_back(it.first);\\n                //mp[it.first]--;\\n            }\\n            for (auto it: tmp){\\n                if (--mp[it]==0)mp.erase(it);\\n            }\\n            ans.push_back(tmp);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3392334,
                "title": "python3-hash-map-counter-o-n-max-frequency-time-o-1-space",
                "content": "# Intuition\\nWe create the 2D array map with the number of subarrays equal to max frequency that a number in `nums` can occur, representing the minimum rows that we have to have since we must have unique numbers in each row. For example, if the array is `[1,3,4,1,2,3,1]`, we must have at least 3 rows to accommodate all the 1s.\\n\\nHence, I chose to use `Counter` to solve this problem.\\n\\n# Approach\\nI find the frequencies of each number in `nums`, using `Counter`. Then, I initialize the `result` to be the 2D array with `max(list(counter.values())` rows.\\n\\nThen, for each number, I spread it over each row to fulfill the unique numbers condition, and the decrementing its appearance along the way.\\n\\nThen, I return the `result` array.\\n\\n# Complexity\\n- Time complexity: `O(n*max(frequencies))`\\n- Space complexity: `O(n)` for the `counter` dictionary \\n\\n# Code\\n```\\nclass Solution:\\n    def findMatrix(self, nums: List[int]) -> List[List[int]]:\\n        counter = collections.Counter(nums)\\n        result = [[0] for _ in range(max(list(counter.values())))]\\n\\n        for i in range(len(nums)):\\n            j = 0\\n            while counter[nums[i]] > 0:\\n                result[j].append(nums[i])\\n                j += 1\\n                counter[nums[i]] -= 1\\n        \\n        return [r[1:] for r in result]\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def findMatrix(self, nums: List[int]) -> List[List[int]]:\\n        counter = collections.Counter(nums)\\n        result = [[0] for _ in range(max(list(counter.values())))]\\n\\n        for i in range(len(nums)):\\n            j = 0\\n            while counter[nums[i]] > 0:\\n                result[j].append(nums[i])\\n                j += 1\\n                counter[nums[i]] -= 1\\n        \\n        return [r[1:] for r in result]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3391192,
                "title": "c-simple-and-understandable-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findMatrix(vector<int>& nums) {\\n        map<int,int> m;\\n        int q=0;\\n        vector<vector<int>> v;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            m[nums[i]]++;\\n        }\\n        int maxi=0;\\n        for(auto x:m){\\n            if(x.second>maxi){\\n                maxi=x.second;\\n            }\\n        }\\n        for(int i=0;i<maxi;i++){\\n        vector<int> a;\\n        for(auto &x:m){\\n            if(x.second>0){\\n               q=1;\\n               a.push_back(x.first);\\n               x.second--;\\n            }\\n        }\\n        if(q==0){\\n            return v;\\n        }\\n        else{\\n            v.push_back(a);\\n        }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findMatrix(vector<int>& nums) {\\n        map<int,int> m;\\n        int q=0;\\n        vector<vector<int>> v;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            m[nums[i]]++;\\n        }\\n        int maxi=0;\\n        for(auto x:m){\\n            if(x.second>maxi){\\n                maxi=x.second;\\n            }\\n        }\\n        for(int i=0;i<maxi;i++){\\n        vector<int> a;\\n        for(auto &x:m){\\n            if(x.second>0){\\n               q=1;\\n               a.push_back(x.first);\\n               x.second--;\\n            }\\n        }\\n        if(q==0){\\n            return v;\\n        }\\n        else{\\n            v.push_back(a);\\n        }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3391182,
                "title": "c-esay-to-understand",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findMatrix(vector<int>& nums) {\\n        vector<vector<int>> re;\\n        unordered_map<int, int> tem;\\n        for(auto x:nums) tem[x]++;\\n        vector<int> he;\\n        while(!tem.empty()) {\\n            for(auto& x : tem) {\\n                if(x.second > 0) {\\n                    he.push_back(x.first);\\n                    x.second--; \\n                }\\n            }\\n            re.push_back(he);\\n            he.clear();\\n            for(auto it = tem.begin(); it != tem.end(); ) {\\n                if(it->second == 0) {\\n                    it = tem.erase(it); \\n                } else {\\n                    ++it;\\n                }\\n            }\\n        }\\n        return re;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findMatrix(vector<int>& nums) {\\n        vector<vector<int>> re;\\n        unordered_map<int, int> tem;\\n        for(auto x:nums) tem[x]++;\\n        vector<int> he;\\n        while(!tem.empty()) {\\n            for(auto& x : tem) {\\n                if(x.second > 0) {\\n                    he.push_back(x.first);\\n                    x.second--; \\n                }\\n            }\\n            re.push_back(he);\\n            he.clear();\\n            for(auto it = tem.begin(); it != tem.end(); ) {\\n                if(it->second == 0) {\\n                    it = tem.erase(it); \\n                } else {\\n                    ++it;\\n                }\\n            }\\n        }\\n        return re;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3390133,
                "title": "python3-one-liner",
                "content": "```\\nclass Solution:\\n    def findMatrix(self, nums: List[int]) -> List[List[int]]:\\n        return [[x for x in arr if x] for arr in zip_longest(*[(n,)*f for n, f in Counter(nums).items()], fillvalue=0)]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findMatrix(self, nums: List[int]) -> List[List[int]]:\\n        return [[x for x in arr if x] for arr in zip_longest(*[(n,)*f for n, f in Counter(nums).items()], fillvalue=0)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3387836,
                "title": "python-creating-matrix-while-passing-through-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHold the number of the next line in the matrix for each distinct integer.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse a dictionary to hold the next index in the matrix for each distinct integer.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$: One pass through the input array. \\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$: In the worst case each integer could be unique.\\n\\n---\\n* You could find some other extraordinary solutions in my [profile](https://leetcode.com/almostmonday/) on the Solutions tab (I don\\'t post obvious or not interesting solutions at all.)\\n* If this was helpful, please upvote so that others can see this solution too.\\n---\\n\\n# Code\\n```\\nclass Solution(object):\\n    def findMatrix(self, nums):\\n        d = {}\\n        res = [[]]\\n        for x in nums:\\n            d[x] = d.get(x, -1) + 1\\n            if d[x] == len(res): res.append([])\\n            res[d[x]].append(x)\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution(object):\\n    def findMatrix(self, nums):\\n        d = {}\\n        res = [[]]\\n        for x in nums:\\n            d[x] = d.get(x, -1) + 1\\n            if d[x] == len(res): res.append([])\\n            res[d[x]].append(x)\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3382257,
                "title": "c-hash-table-faster-easy-to-understand",
                "content": "* ***Hash Table***\\n\\n* ***Time Complexity :- O(N)***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findMatrix(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        // declare an unordered map\\n        \\n        unordered_map<int, int> mp;\\n        \\n        // store the frequency of each element\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            mp[nums[i]]++;\\n        }\\n        \\n        // now traverse over the map and create new 2D array\\n        \\n        vector<vector<int>> res;\\n        \\n        while(1)\\n        {\\n            vector<int> row;\\n            \\n            bool flag = true;\\n            \\n            for(auto x : mp)\\n            {\\n                if(x.second > 0)\\n                {\\n                    flag = false;\\n                    \\n                    row.push_back(x.first);\\n                    \\n                    mp[x.first]--;\\n                }\\n            }\\n            \\n            // if no element is remaining\\n            \\n            if(flag)\\n            {\\n                return res;\\n            }\\n            \\n            res.push_back(row);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findMatrix(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        // declare an unordered map\\n        \\n        unordered_map<int, int> mp;\\n        \\n        // store the frequency of each element\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            mp[nums[i]]++;\\n        }\\n        \\n        // now traverse over the map and create new 2D array\\n        \\n        vector<vector<int>> res;\\n        \\n        while(1)\\n        {\\n            vector<int> row;\\n            \\n            bool flag = true;\\n            \\n            for(auto x : mp)\\n            {\\n                if(x.second > 0)\\n                {\\n                    flag = false;\\n                    \\n                    row.push_back(x.first);\\n                    \\n                    mp[x.first]--;\\n                }\\n            }\\n            \\n            // if no element is remaining\\n            \\n            if(flag)\\n            {\\n                return res;\\n            }\\n            \\n            res.push_back(row);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3381735,
                "title": "100-faster-java-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n * (frequency of i))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n^2)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> findMatrix(int[] nums) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        int[] freq = new int[201];\\n        int maxFreq = 0;\\n        \\n        for(int val : nums) {\\n            freq[val]++;\\n            maxFreq = Math.max(maxFreq, freq[val]);\\n        }\\n        \\n        for(int i = 0; i < maxFreq; i++) {\\n            ans.add(new ArrayList<>());\\n        }\\n        \\n        for(int i = 0; i < 201; i++) {\\n            if(freq[i] == 0) continue;\\n            \\n            int j = 0;\\n            for(int k = 0; k < freq[i]; k++) {\\n                ans.get(j++).add(i);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> findMatrix(int[] nums) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        int[] freq = new int[201];\\n        int maxFreq = 0;\\n        \\n        for(int val : nums) {\\n            freq[val]++;\\n            maxFreq = Math.max(maxFreq, freq[val]);\\n        }\\n        \\n        for(int i = 0; i < maxFreq; i++) {\\n            ans.add(new ArrayList<>());\\n        }\\n        \\n        for(int i = 0; i < 201; i++) {\\n            if(freq[i] == 0) continue;\\n            \\n            int j = 0;\\n            for(int k = 0; k < freq[i]; k++) {\\n                ans.get(j++).add(i);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3380499,
                "title": "python3-set",
                "content": "\\n\\n# Complexity \\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findMatrix(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        while len(nums) > 0:\\n            a = set(nums)\\n            res.append(list(a))\\n            for i in a:\\n                nums.remove(i)\\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Sort"
                ],
                "code": "```\\nclass Solution:\\n    def findMatrix(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        while len(nums) > 0:\\n            a = set(nums)\\n            res.append(list(a))\\n            for i in a:\\n                nums.remove(i)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3379861,
                "title": "best-solution-c-hash-map",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findMatrix(vector<int>& nums) {\\n        int n = nums.size();\\n       \\n       vector<int>count(201, 0);\\n        for(int i = 0; i<n; i++)\\n        {\\n            count[nums[i]]++;\\n        }\\n        vector<pair<int, int>>v;\\n        for(int i = 0; i<201; i++)\\n        {\\n            if(count[i]>0)\\n            {\\n                v.push_back({count[i], i});\\n            }\\n        }\\n        sort(v.begin(), v.end());\\n        int m = v[v.size()-1].first;\\n        int k = 0;\\n        vector<int>ans[m];\\n        for(int i = v.size()-1; i>=0; i--)\\n        {\\n            int c = 0;\\n            while(v[i].first>0)\\n            {\\n                c++;\\n                ans[k].push_back(v[i].second);\\n                k++;\\n                v[i].first--;\\n            }\\n            k = k-c;\\n        }\\n        vector<vector<int>>res;\\n        for(int i = 0; i<m; i++)\\n        {\\n            vector<int>a;\\n            for(int j = 0; j<ans[i].size(); j++)\\n            {\\n                a.push_back(ans[i][j]);\\n            }\\n            res.push_back(a);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Hash Function"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findMatrix(vector<int>& nums) {\\n        int n = nums.size();\\n       \\n       vector<int>count(201, 0);\\n        for(int i = 0; i<n; i++)\\n        {\\n            count[nums[i]]++;\\n        }\\n        vector<pair<int, int>>v;\\n        for(int i = 0; i<201; i++)\\n        {\\n            if(count[i]>0)\\n            {\\n                v.push_back({count[i], i});\\n            }\\n        }\\n        sort(v.begin(), v.end());\\n        int m = v[v.size()-1].first;\\n        int k = 0;\\n        vector<int>ans[m];\\n        for(int i = v.size()-1; i>=0; i--)\\n        {\\n            int c = 0;\\n            while(v[i].first>0)\\n            {\\n                c++;\\n                ans[k].push_back(v[i].second);\\n                k++;\\n                v[i].first--;\\n            }\\n            k = k-c;\\n        }\\n        vector<vector<int>>res;\\n        for(int i = 0; i<m; i++)\\n        {\\n            vector<int>a;\\n            for(int j = 0; j<ans[i].size(); j++)\\n            {\\n                a.push_back(ans[i][j]);\\n            }\\n            res.push_back(a);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3379602,
                "title": "c-easy-to-understand-using-map-easy-approach",
                "content": "# Intuition\\nno need to minimize row as each distinct element present in distinct rows that will return exactly the required row we want .\\n\\n# Approach\\nIn order to implement it we can use map to store the number and its freq. Now we can easily iterate over map and put all the keys in the ans and decrease the freq. We will repeat this till all the keys have value equals to zero. This will result in the required 2D array.\\n\\n# Complexity\\nTime complexity: O(N)\\nSpace complexity: O(N)\\n\\neg: [1,3,4,1,2,3,1]\\nmap:\\nelement->frequency\\n{\\n [1->2]\\n [3->2]\\n [4->1]\\n [2->1]\\n}\\nso, maxi. frequency is 2\\nunique element are 4\\n=>O(maxi. frequency*unique element)~no. of element=>O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findMatrix(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<vector<int>>ans;\\n        unordered_map<int,int>mp;\\n        for(int i=n-1;i>=0;i--){     //O(n)\\n            mp[nums[i]]++;\\n        }\\n        while(true){              //O(maxi. frequency*unique element)\\n            vector<int>temp;\\n            int f=0;\\n            for(auto it:mp){\\n                if(it.second>0)\\n                {\\n                    f=1;\\n                    temp.push_back(it.first);\\n                    mp[it.first]--;\\n                }\\n            }\\n            if(f==0)\\n                break;\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findMatrix(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<vector<int>>ans;\\n        unordered_map<int,int>mp;\\n        for(int i=n-1;i>=0;i--){     //O(n)\\n            mp[nums[i]]++;\\n        }\\n        while(true){              //O(maxi. frequency*unique element)\\n            vector<int>temp;\\n            int f=0;\\n            for(auto it:mp){\\n                if(it.second>0)\\n                {\\n                    f=1;\\n                    temp.push_back(it.first);\\n                    mp[it.first]--;\\n                }\\n            }\\n            if(f==0)\\n                break;\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3378877,
                "title": "13-line-solution-in-c-time-o-n-log-n-space-o-n",
                "content": "# Description\\nThe time complexity of this code is O(n log n), where n is the size of the input vector `nums`. This is because the unordered_map `table` is iterated through once to count the frequency of each number, which takes O(n) time. Then, the maximum frequency of any number is found, which takes O(n) time. Finally, the vector `res` is constructed by iterating through `mx` times, where `mx` is the maximum frequency of any number. Within each iteration, a new vector `unique` is constructed and iterated through, which takes O(n) time in total. Therefore, the total time complexity is O(n log n).\\n\\nThe space complexity of this code is O(n), where n is the size of the input vector `nums`. This is because the unordered_map `table` is created to store the frequency of each number, which takes O(n) space. Additionally, the vector `res` is created to store the result, which takes O(n) space in total, since each vector within `res` has a size of at most n.\\n\\n# Complexity\\n- Time complexity: O(n log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> findMatrix(vector<int>& nums) {\\n        unordered_map<int, int> table;\\n\\t    int mx = 0;\\n\\t    for (auto&& n : nums) table[n]++, mx = max(mx, table[n]);\\n\\t    vector<vector<int>> res(mx);\\n\\t    for (auto&& r : res) {\\n\\t\\t    vector<int> unique;\\n\\t\\t    for (auto&& [num, amount] : table) {\\n\\t\\t\\t    if (amount > 0) unique.push_back(num);\\n\\t\\t\\t    amount--;\\n\\t\\t    }\\n\\t\\t    r = unique;\\n\\t    }\\n\\t    return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> findMatrix(vector<int>& nums) {\\n        unordered_map<int, int> table;\\n\\t    int mx = 0;\\n\\t    for (auto&& n : nums) table[n]++, mx = max(mx, table[n]);\\n\\t    vector<vector<int>> res(mx);\\n\\t    for (auto&& r : res) {\\n\\t\\t    vector<int> unique;\\n\\t\\t    for (auto&& [num, amount] : table) {\\n\\t\\t\\t    if (amount > 0) unique.push_back(num);\\n\\t\\t\\t    amount--;\\n\\t\\t    }\\n\\t\\t    r = unique;\\n\\t    }\\n\\t    return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3370127,
                "title": "c-hash-table-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:$$O(n*m)$$\\n\\n- Space complexity:$$O(n*m)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findMatrix(vector<int>& nums) {\\n        vector<vector<int>>ans;\\n        unordered_map<int, int>m;\\n        for(int i=0; i<nums.size(); i++){m[nums[i]]++;}\\n        int n=1;\\n        for(auto it: m){\\n            n=max(n, it.second);\\n        }\\n        vector<int>adj[n];\\n        for(int i=0; i<nums.size(); i++){\\n            if(m.find(nums[i])!=m.end()){\\n                int sz=m[nums[i]];\\n                for(int j=0; j<sz; j++){\\n                    adj[j].push_back(nums[i]);\\n                }\\n                m.erase(nums[i]);\\n            }\\n        }\\n        for(int i=0; i<n; i++){\\n            vector<int>v;\\n            for(int j=0; j<adj[i].size(); j++){\\n                v.push_back(adj[i][j]);\\n            }\\n            ans.push_back(v);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findMatrix(vector<int>& nums) {\\n        vector<vector<int>>ans;\\n        unordered_map<int, int>m;\\n        for(int i=0; i<nums.size(); i++){m[nums[i]]++;}\\n        int n=1;\\n        for(auto it: m){\\n            n=max(n, it.second);\\n        }\\n        vector<int>adj[n];\\n        for(int i=0; i<nums.size(); i++){\\n            if(m.find(nums[i])!=m.end()){\\n                int sz=m[nums[i]];\\n                for(int j=0; j<sz; j++){\\n                    adj[j].push_back(nums[i]);\\n                }\\n                m.erase(nums[i]);\\n            }\\n        }\\n        for(int i=0; i<n; i++){\\n            vector<int>v;\\n            for(int j=0; j<adj[i].size(); j++){\\n                v.push_back(adj[i][j]);\\n            }\\n            ans.push_back(v);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3369865,
                "title": "simple-solution-using-hashset",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimple Solution\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nkeep a counter variable to track frequency of each element\\nso for this we can make an array of frequency\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> findMatrix(int[] nums) {\\n        int sum=0;\\n     //   ArrayList<ArrayList<Integer>>list=new ArrayList();\\n        List<List<Integer>> list = new ArrayList();\\n        Arrays.sort(nums);\\n      HashSet<Integer>set=new HashSet<>();\\n        for(int i=0;i<nums.length;i++){\\n            set.add(nums[i]);\\n        }\\n        int []arr=new int[set.size()];\\n     int a=0;\\n        for(int j:set){\\n            arr[a++]=j;\\n        }\\n        int []freq=new int[arr.length];\\n        int c=0;\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            c=0;\\n            for(int k=0;k<nums.length;k++)\\n            {\\n                if(arr[i]==nums[k]){\\n                    c++;\\n                }\\n            }\\n            freq[i]=c;\\n        }\\n        for(int i=0;i<freq.length;i++){\\n            sum=sum+freq[i];\\n        }\\n        while(sum>0){\\n            ArrayList<Integer>single=new ArrayList<>();\\n            for(int k=0;k<freq.length;k++){\\n                if(freq[k]>0){\\n                    single.add(arr[k]);\\n                    freq[k]=freq[k]-1;\\n                    sum=sum-1;\\n                }\\n            }\\n            list.add(single);\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> findMatrix(int[] nums) {\\n        int sum=0;\\n     //   ArrayList<ArrayList<Integer>>list=new ArrayList();\\n        List<List<Integer>> list = new ArrayList();\\n        Arrays.sort(nums);\\n      HashSet<Integer>set=new HashSet<>();\\n        for(int i=0;i<nums.length;i++){\\n            set.add(nums[i]);\\n        }\\n        int []arr=new int[set.size()];\\n     int a=0;\\n        for(int j:set){\\n            arr[a++]=j;\\n        }\\n        int []freq=new int[arr.length];\\n        int c=0;\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            c=0;\\n            for(int k=0;k<nums.length;k++)\\n            {\\n                if(arr[i]==nums[k]){\\n                    c++;\\n                }\\n            }\\n            freq[i]=c;\\n        }\\n        for(int i=0;i<freq.length;i++){\\n            sum=sum+freq[i];\\n        }\\n        while(sum>0){\\n            ArrayList<Integer>single=new ArrayList<>();\\n            for(int k=0;k<freq.length;k++){\\n                if(freq[k]>0){\\n                    single.add(arr[k]);\\n                    freq[k]=freq[k]-1;\\n                    sum=sum-1;\\n                }\\n            }\\n            list.add(single);\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3369794,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.util.*;\\nimport java.lang.*;\\n\\n\\nclass Solution {\\n     Map<Integer,Integer> map=new HashMap<>();\\n    int ifany(Map<Integer,Integer> map)\\n    {\\n        for(int i:map.keySet())\\n        {\\n            if(map.get(i)>=1)\\n                return 1;\\n        }\\n        return 0;\\n        \\n    }\\n    \\n    \\n    public List<List<Integer>> findMatrix(int[] nums) {\\n        \\n        List<Integer> temp=new ArrayList<>();\\n        List<List<Integer>> ans=new ArrayList<>();\\n       \\n        for(int i=0;i<nums.length;i++)\\n        {\\n            map.put(nums[i],1+map.getOrDefault(nums[i],0));\\n        }\\n        while(ifany(map)==1)\\n        {\\n        for(int i:map.keySet())\\n        {\\n            if(map.get(i)>=1)\\n            {\\n                temp.add(i);\\n                map.put(i,map.get(i)-1);\\n                \\n            }\\n        }\\n            ans.add(new ArrayList<>(temp));\\n            temp.clear();\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.*;\\nimport java.lang.*;\\n\\n\\nclass Solution {\\n     Map<Integer,Integer> map=new HashMap<>();\\n    int ifany(Map<Integer,Integer> map)\\n    {\\n        for(int i:map.keySet())\\n        {\\n            if(map.get(i)>=1)\\n                return 1;\\n        }\\n        return 0;\\n        \\n    }\\n    \\n    \\n    public List<List<Integer>> findMatrix(int[] nums) {\\n        \\n        List<Integer> temp=new ArrayList<>();\\n        List<List<Integer>> ans=new ArrayList<>();\\n       \\n        for(int i=0;i<nums.length;i++)\\n        {\\n            map.put(nums[i],1+map.getOrDefault(nums[i],0));\\n        }\\n        while(ifany(map)==1)\\n        {\\n        for(int i:map.keySet())\\n        {\\n            if(map.get(i)>=1)\\n            {\\n                temp.add(i);\\n                map.put(i,map.get(i)-1);\\n                \\n            }\\n        }\\n            ans.add(new ArrayList<>(temp));\\n            temp.clear();\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3369708,
                "title": "java-map-set-exhausting-frequencies",
                "content": "# Code:\\n```\\nclass Solution {\\n    public List<List<Integer>> findMatrix(int[] nums) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        Set<Integer> set = new HashSet<>();\\n        // create the frequency map and\\n        // populate the set for unique values in nums\\n        for (int i : nums) {\\n            map.put(i, 1 + map.getOrDefault(i, 0));\\n            set.add(i);\\n        }\\n        \\n        List<List<Integer>> ans = new ArrayList<>();\\n        // fill the ans list till map is empty (exhaust the frequencies)\\n        while (!map.isEmpty()) {\\n            List<Integer> row = new ArrayList<>();\\n            // go through the unique set of numbers \\n            for (int key : set) {\\n                // if frequency not exhausted yet\\n                if (map.containsKey(key)) {\\n                    // get the count / frequency\\n                    int cnt = map.get(key); \\n                    // add that number to current row\\n                    row.add(key);   \\n                    // if it was the last one of a particular number\\n                    if (cnt == 1) {\\n                        map.remove(key);    // exhaust it\\n                    } else {\\n                        // decrement count coz it\\'s been used just now\\n                        map.put(key, --cnt);\\n                    } \\n                }  \\n            }\\n            // add that row to ans list\\n            ans.add(row);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```\\n---\\n### Clean solution:\\n```\\nclass Solution {\\n    public List<List<Integer>> findMatrix(int[] nums) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        Set<Integer> set = new HashSet<>();\\n        for (int i : nums) {\\n            map.put(i, 1 + map.getOrDefault(i, 0));\\n            set.add(i);\\n        }\\n        \\n        List<List<Integer>> ans = new ArrayList<>();\\n        while (!map.isEmpty()) {\\n            List<Integer> row = new ArrayList<>();\\n            for (int key : set) {\\n                if (map.containsKey(key)) {\\n                    int cnt = map.get(key); \\n                    row.add(key);   \\n                    if (cnt == 1) {\\n                        map.remove(key);   \\n                    } else {\\n                        map.put(key, --cnt);\\n                    } \\n                }  \\n            }\\n            ans.add(row);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```\\nLet $$n$$ be the number of unique elements in `nums`.\\n##### Time complexity: $$O(n) + O(n^2)$$\\n##### Space complexity: $$O(3.n)$$",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> findMatrix(int[] nums) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        Set<Integer> set = new HashSet<>();\\n        // create the frequency map and\\n        // populate the set for unique values in nums\\n        for (int i : nums) {\\n            map.put(i, 1 + map.getOrDefault(i, 0));\\n            set.add(i);\\n        }\\n        \\n        List<List<Integer>> ans = new ArrayList<>();\\n        // fill the ans list till map is empty (exhaust the frequencies)\\n        while (!map.isEmpty()) {\\n            List<Integer> row = new ArrayList<>();\\n            // go through the unique set of numbers \\n            for (int key : set) {\\n                // if frequency not exhausted yet\\n                if (map.containsKey(key)) {\\n                    // get the count / frequency\\n                    int cnt = map.get(key); \\n                    // add that number to current row\\n                    row.add(key);   \\n                    // if it was the last one of a particular number\\n                    if (cnt == 1) {\\n                        map.remove(key);    // exhaust it\\n                    } else {\\n                        // decrement count coz it\\'s been used just now\\n                        map.put(key, --cnt);\\n                    } \\n                }  \\n            }\\n            // add that row to ans list\\n            ans.add(row);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public List<List<Integer>> findMatrix(int[] nums) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        Set<Integer> set = new HashSet<>();\\n        for (int i : nums) {\\n            map.put(i, 1 + map.getOrDefault(i, 0));\\n            set.add(i);\\n        }\\n        \\n        List<List<Integer>> ans = new ArrayList<>();\\n        while (!map.isEmpty()) {\\n            List<Integer> row = new ArrayList<>();\\n            for (int key : set) {\\n                if (map.containsKey(key)) {\\n                    int cnt = map.get(key); \\n                    row.add(key);   \\n                    if (cnt == 1) {\\n                        map.remove(key);   \\n                    } else {\\n                        map.put(key, --cnt);\\n                    } \\n                }  \\n            }\\n            ans.add(row);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3369535,
                "title": "python-dictionary",
                "content": "# Intuition\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findMatrix(self, nums: List[int]) -> List[List[int]]:\\n        d = defaultdict(list)\\n        for num in nums:\\n            if num not in d[0]:\\n                d[0].append(num)\\n            else:\\n                j = 0\\n                while num in d[j]:\\n                    j += 1\\n                d[j].append(num)\\n        grid = []\\n        for v in d.values():\\n            grid.append(v)\\n        return(grid)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findMatrix(self, nums: List[int]) -> List[List[int]]:\\n        d = defaultdict(list)\\n        for num in nums:\\n            if num not in d[0]:\\n                d[0].append(num)\\n            else:\\n                j = 0\\n                while num in d[j]:\\n                    j += 1\\n                d[j].append(num)\\n        grid = []\\n        for v in d.values():\\n            grid.append(v)\\n        return(grid)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3369436,
                "title": "python-counter-max-frequency",
                "content": "**Intuition:**\\n* Minimum number of rows would be the count of the most common element in `nums` as we need 1 of each in each row.\\n* Split `nums` into rows, since order doesn\\'t matter, we can just allocate in a simple for loop.\\n\\n**Code:**\\n```\\nclass Solution:\\n    def findMatrix(self, nums: List[int]) -> List[List[int]]:\\n        count = Counter(nums)\\n        max_freq = max(count.values())\\n        matrix = [[] for _ in range(max_freq)]\\n        i = 0\\n        for num, freq in count.items():\\n            for _ in range(freq):\\n                matrix[i].append(num)\\n                i = (i+1)%len(matrix)\\n        return matrix        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findMatrix(self, nums: List[int]) -> List[List[int]]:\\n        count = Counter(nums)\\n        max_freq = max(count.values())\\n        matrix = [[] for _ in range(max_freq)]\\n        i = 0\\n        for num, freq in count.items():\\n            for _ in range(freq):\\n                matrix[i].append(num)\\n                i = (i+1)%len(matrix)\\n        return matrix        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3369223,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def findMatrix(self, nums: List[int]) -> List[List[int]]:\\n        ans=[]\\n        count=Counter(nums)\\n        while count:\\n            val=[]\\n            drop=[]\\n            for k,v in count.items():\\n                val.append(k)\\n                count[k]-=1\\n                if count[k]==0:\\n                    drop.append(k)\\n\\n            for k in drop:\\n                count.pop(k)\\n\\n            ans.append(val)\\n\\n        return ans                \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findMatrix(self, nums: List[int]) -> List[List[int]]:\\n        ans=[]\\n        count=Counter(nums)\\n        while count:\\n            val=[]\\n            drop=[]\\n            for k,v in count.items():\\n                val.append(k)\\n                count[k]-=1\\n                if count[k]==0:\\n                    drop.append(k)\\n\\n            for k in drop:\\n                count.pop(k)\\n\\n            ans.append(val)\\n\\n        return ans                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3369106,
                "title": "simple-and-easy-answer-c",
                "content": "# Intuition\\n\\n\\n# Approach\\n\\n# Complexity\\n- Time complexity:\\nO(n*n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findMatrix(vector<int>& nums) {\\n        int n=nums.size();\\n        map<int,int>m;\\n        for(auto it:nums){\\n            m[it]++;\\n        }\\n        int cnt=0;\\n        for(auto it:m){\\n            cnt=max(cnt,it.second);\\n        }\\n        vector<vector<int>>v(cnt);\\n        for(int i=0;i<cnt;i++){\\n            for(auto it:m){\\n                if(it.second>0){\\n                    v[i].push_back(it.first);\\n                    m[it.first]--;\\n                }\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findMatrix(vector<int>& nums) {\\n        int n=nums.size();\\n        map<int,int>m;\\n        for(auto it:nums){\\n            m[it]++;\\n        }\\n        int cnt=0;\\n        for(auto it:m){\\n            cnt=max(cnt,it.second);\\n        }\\n        vector<vector<int>>v(cnt);\\n        for(int i=0;i<cnt;i++){\\n            for(auto it:m){\\n                if(it.second>0){\\n                    v[i].push_back(it.first);\\n                    m[it.first]--;\\n                }\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368703,
                "title": "c-code-using-counter-with-comments-and-explanation",
                "content": "\\n# Approach\\n1. We create a map to store the frequency of all the elements.\\n2. We create a count variable, which stores, no. of. elements available in the map with frequency greater than 0.\\n3. We itterate over the map and create the vector(temp) with elements whose frequency is greater than 0... Then we push it to the answer vector,\\n4. while creating the (temp)vector, we reduce the frequency of every used element, if any elements frequency becomes 0, we do a count--.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findMatrix(vector<int>& nums) {\\n        //we store the frequency of each element in map mp... and count stores no of unique elements\\n        unordered_map<int,int>mp;\\n        int count=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(mp.find(nums[i])==mp.end())count++;\\n            mp[nums[i]]++;\\n        }\\n\\n        //we itterate over map once and store the available elements in temp and insert the temp vector in the ans vector.\\n        vector<vector<int>>ans;\\n        vector<int> temp;\\n        \\n        while(count>0){ //when count becomes 0, frequency of every element has become 0.\\n            temp.clear();\\n            for(auto &it:mp){   //we itterate over the map and create a vector of available elements              \\n                if(it.second!=0){\\n                    temp.push_back(it.first);//element is inserted only if element\\'s frequency is not 0.\\n                    it.second--;\\n                    if(it.second==0){count--;}  //count is reduced everytime a elements frequency becomes 0.                 \\n                }\\n            }\\n            ans.push_back(temp);\\n        }\\n        \\n        \\n    return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findMatrix(vector<int>& nums) {\\n        //we store the frequency of each element in map mp... and count stores no of unique elements\\n        unordered_map<int,int>mp;\\n        int count=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(mp.find(nums[i])==mp.end())count++;\\n            mp[nums[i]]++;\\n        }\\n\\n        //we itterate over map once and store the available elements in temp and insert the temp vector in the ans vector.\\n        vector<vector<int>>ans;\\n        vector<int> temp;\\n        \\n        while(count>0){ //when count becomes 0, frequency of every element has become 0.\\n            temp.clear();\\n            for(auto &it:mp){   //we itterate over the map and create a vector of available elements              \\n                if(it.second!=0){\\n                    temp.push_back(it.first);//element is inserted only if element\\'s frequency is not 0.\\n                    it.second--;\\n                    if(it.second==0){count--;}  //count is reduced everytime a elements frequency becomes 0.                 \\n                }\\n            }\\n            ans.push_back(temp);\\n        }\\n        \\n        \\n    return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368618,
                "title": "c-counting-vector-based-beginner-friendly-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findMatrix(vector<int>& nums) {\\n        vector<int>v(205,0);\\n        vector<vector<int>>res;\\n        vector<int>t;\\n        int n=nums.size();\\n        for(auto x:nums){\\n            v[x]++;\\n        }\\n        int i=0,cnt=0;\\n        while(n!=cnt){\\n            if(v[i]>0){\\n                cnt++;\\n                t.push_back(i);\\n                v[i]--;\\n            }\\n            if(i==201){\\n                res.push_back(t);\\n                t.clear();\\n                i=0;\\n            }\\n            i++;\\n        }\\n        res.push_back(t);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findMatrix(vector<int>& nums) {\\n        vector<int>v(205,0);\\n        vector<vector<int>>res;\\n        vector<int>t;\\n        int n=nums.size();\\n        for(auto x:nums){\\n            v[x]++;\\n        }\\n        int i=0,cnt=0;\\n        while(n!=cnt){\\n            if(v[i]>0){\\n                cnt++;\\n                t.push_back(i);\\n                v[i]--;\\n            }\\n            if(i==201){\\n                res.push_back(t);\\n                t.clear();\\n                i=0;\\n            }\\n            i++;\\n        }\\n        res.push_back(t);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368605,
                "title": "very-easy-c-solution-without-hashmap",
                "content": "# Code\\n```\\n/* Every time a duplicate element comes check for it in next vector\\n inside the 2d vector and if no other vector is available create new one.*/\\nclass Solution {\\npublic:\\n    vector<vector<int>> findMatrix(vector<int>& nums) {\\n        vector<vector<int>>res;\\n        vector<int>temp;\\n        res.push_back(temp);\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=0;j<res.size();j++){\\n                if(find(res[j].begin(),res[j].end(),nums[i])==res[j].end()){\\n                    res[j].push_back(nums[i]);\\n                    break;\\n                }\\n                else if(j==res.size()-1) res.push_back({});\\n        }\\n      }\\n    return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/* Every time a duplicate element comes check for it in next vector\\n inside the 2d vector and if no other vector is available create new one.*/\\nclass Solution {\\npublic:\\n    vector<vector<int>> findMatrix(vector<int>& nums) {\\n        vector<vector<int>>res;\\n        vector<int>temp;\\n        res.push_back(temp);\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=0;j<res.size();j++){\\n                if(find(res[j].begin(),res[j].end(),nums[i])==res[j].end()){\\n                    res[j].push_back(nums[i]);\\n                    break;\\n                }\\n                else if(j==res.size()-1) res.push_back({});\\n        }\\n      }\\n    return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368578,
                "title": "easy-and-fast-solution-o-n-time-o-n-space",
                "content": "\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\nvar findMatrix = function(nums) {\\n    let map = new Map();\\n    for(let i of nums){\\n        if(map.has(i)) map.set(i,map.get(i)+1);\\n        else map.set(i,1);\\n    }\\n    let arr= [...map];\\n    let res=[];\\n    while(1){\\n        let temp=[];\\n        for(let i=0;i<arr.length;i++){\\n            if(arr[i][1]!=0){\\n                temp.push(arr[i][0]);\\n                arr[i][1]--;\\n            }\\n        }\\n        if(!temp.length) return res;\\n        res.push(temp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\nvar findMatrix = function(nums) {\\n    let map = new Map();\\n    for(let i of nums){\\n        if(map.has(i)) map.set(i,map.get(i)+1);\\n        else map.set(i,1);\\n    }\\n    let arr= [...map];\\n    let res=[];\\n    while(1){\\n        let temp=[];\\n        for(let i=0;i<arr.length;i++){\\n            if(arr[i][1]!=0){\\n                temp.push(arr[i][0]);\\n                arr[i][1]--;\\n            }\\n        }\\n        if(!temp.length) return res;\\n        res.push(temp);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3368517,
                "title": "counting-then-spreading-o-n-and-beats-100-rust",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npub fn find_matrix(nums: Vec<i32>) -> Vec<Vec<i32>> {\\n    let mut ans = Vec::new();\\n    let mut freq = vec![0; nums.len() + 1];\\n    nums.iter().for_each(|&x| freq[x as usize] += 1);\\n\\n    for (i, &num) in freq.iter().enumerate() {\\n        for j in 0..num {\\n            if j >= ans.len() { ans.push(Vec::new()) };\\n            ans[j].push(i as i32);\\n        }\\n    }\\n    \\n    ans\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\npub fn find_matrix(nums: Vec<i32>) -> Vec<Vec<i32>> {\\n    let mut ans = Vec::new();\\n    let mut freq = vec![0; nums.len() + 1];\\n    nums.iter().for_each(|&x| freq[x as usize] += 1);\\n\\n    for (i, &num) in freq.iter().enumerate() {\\n        for j in 0..num {\\n            if j >= ans.len() { ans.push(Vec::new()) };\\n            ans[j].push(i as i32);\\n        }\\n    }\\n    \\n    ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3368479,
                "title": "using-hash-table-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom collections import defaultdict\\nclass Solution(object):\\n    def findMatrix(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        count=defaultdict(int)\\n        for n in nums:\\n            count[n] +=1\\n            \\n        res =[]\\n        \\n        while True:\\n            cur=[]\\n            for k,v in count.items():\\n                if v > 0:\\n                    cur.append(k)\\n                    count[k] -=1\\n            if not cur:\\n                break\\n            res.append(cur)\\n        return res\\n            \\n        \\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution(object):\\n    def findMatrix(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        count=defaultdict(int)\\n        for n in nums:\\n            count[n] +=1\\n            \\n        res =[]\\n        \\n        while True:\\n            cur=[]\\n            for k,v in count.items():\\n                if v > 0:\\n                    cur.append(k)\\n                    count[k] -=1\\n            if not cur:\\n                break\\n            res.append(cur)\\n        return res\\n            \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368439,
                "title": "short-simple-java-solution-hashmap",
                "content": "Time complexity:O(N)\\nSpace complexity:O(N)\\n\\n# Code\\n```\\nclass Solution {\\n  public List < List < Integer >> findMatrix(int[] nums) {\\n    List < List < Integer >> ans = new ArrayList < > ();\\n    HashMap < Integer, Integer > map = new HashMap < > ();\\n    for (int i = 0; i < nums.length; i++) map.put(nums[i], map.getOrDefault(nums[i], 0) + 1);\\n    while (map.size() != 0) {\\n      ArrayList < Integer > temp = new ArrayList < > ();\\n      for (Integer key: map.keySet()) {\\n        if (map.get(key) > 0) temp.add(key);\\n        map.put(key, map.get(key) - 1);\\n      }\\n      if (temp.size() == 0) break;\\n      ans.add(new ArrayList < > (temp));\\n    }\\n    return ans;\\n  }\\n}//Upvote if helpful...\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public List < List < Integer >> findMatrix(int[] nums) {\\n    List < List < Integer >> ans = new ArrayList < > ();\\n    HashMap < Integer, Integer > map = new HashMap < > ();\\n    for (int i = 0; i < nums.length; i++) map.put(nums[i], map.getOrDefault(nums[i], 0) + 1);\\n    while (map.size() != 0) {\\n      ArrayList < Integer > temp = new ArrayList < > ();\\n      for (Integer key: map.keySet()) {\\n        if (map.get(key) > 0) temp.add(key);\\n        map.put(key, map.get(key) - 1);\\n      }\\n      if (temp.size() == 0) break;\\n      ans.add(new ArrayList < > (temp));\\n    }\\n    return ans;\\n  }\\n}//Upvote if helpful...\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368423,
                "title": "c-using-maps",
                "content": "Create a map of these vector for each row, and for each number check if it is present in that row or not. If we found the element, then move to next row and if we reach end insert a new row.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findMatrix(vector<int>& nums) {\\n       vector<vector<int>> res;\\n        unordered_map<int, map<int,int>>mp;\\n       for(auto it: nums){\\n           int f = 0 ;\\n           int r = res.size();\\n           for(int i = 0 ; i < r ; i++){\\n               auto x = mp[i] ;\\n               if(x.find(it) == x.end()){\\n                   res[i].push_back(it);\\n                   mp[i][it] = 1;\\n                   f = 1;\\n                   break;\\n               }\\n           }\\n           if( f == 0 ){\\n               res.push_back({it});\\n               int i = res.size();\\n               mp[i-1][it] = 1;\\n           }\\n       }\\n        return res ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findMatrix(vector<int>& nums) {\\n       vector<vector<int>> res;\\n        unordered_map<int, map<int,int>>mp;\\n       for(auto it: nums){\\n           int f = 0 ;\\n           int r = res.size();\\n           for(int i = 0 ; i < r ; i++){\\n               auto x = mp[i] ;\\n               if(x.find(it) == x.end()){\\n                   res[i].push_back(it);\\n                   mp[i][it] = 1;\\n                   f = 1;\\n                   break;\\n               }\\n           }\\n           if( f == 0 ){\\n               res.push_back({it});\\n               int i = res.size();\\n               mp[i-1][it] = 1;\\n           }\\n       }\\n        return res ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368408,
                "title": "simplest-c-solution-using-map-with-explanation",
                "content": "# Complexity\\n- Time complexity:\\nO(n * m) **where n is number of unique elements and m is maximum frequency**\\n\\n- Space complexity:\\nO(n) **where n is unique elements**\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findMatrix(vector<int>& nums) {\\n        \\n        vector<vector<int>> ans;\\n        vector<int> unique;\\n        \\n        unordered_map<int, int> mp;\\n        \\n        for(int i=0; i<nums.size(); i++) {\\n            \\n            //Push unique elements into the vector.\\n            if(mp[nums[i]] == 0) unique.push_back(nums[i]);\\n            \\n            //Increament the frequency of the element in the map.\\n            mp[nums[i]]++;\\n            \\n        }\\n        \\n        int max = 0;\\n        \\n        for(int i=0; i<nums.size(); i++) {\\n            \\n            //Find the maximum frequency in the map.\\n            //Our answer size will also be max.\\n            if(mp[nums[i]] > max) max = mp[nums[i]];\\n            \\n        }\\n        \\n        for(int i=0; i<max; i++) {\\n            vector<int> temp;\\n            for(int i=0; i<unique.size(); i++) {\\n                if(mp[unique[i]] > 0) {\\n                    \\n                    //Now push unique elements in temp and decreament the frequency in map.\\n                    temp.push_back(unique[i]);\\n                    mp[unique[i]]--;\\n                    \\n                }\\n            }\\n            \\n            //push the temp into the answer.\\n            ans.push_back(temp);\\n            \\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findMatrix(vector<int>& nums) {\\n        \\n        vector<vector<int>> ans;\\n        vector<int> unique;\\n        \\n        unordered_map<int, int> mp;\\n        \\n        for(int i=0; i<nums.size(); i++) {\\n            \\n            //Push unique elements into the vector.\\n            if(mp[nums[i]] == 0) unique.push_back(nums[i]);\\n            \\n            //Increament the frequency of the element in the map.\\n            mp[nums[i]]++;\\n            \\n        }\\n        \\n        int max = 0;\\n        \\n        for(int i=0; i<nums.size(); i++) {\\n            \\n            //Find the maximum frequency in the map.\\n            //Our answer size will also be max.\\n            if(mp[nums[i]] > max) max = mp[nums[i]];\\n            \\n        }\\n        \\n        for(int i=0; i<max; i++) {\\n            vector<int> temp;\\n            for(int i=0; i<unique.size(); i++) {\\n                if(mp[unique[i]] > 0) {\\n                    \\n                    //Now push unique elements in temp and decreament the frequency in map.\\n                    temp.push_back(unique[i]);\\n                    mp[unique[i]]--;\\n                    \\n                }\\n            }\\n            \\n            //push the temp into the answer.\\n            ans.push_back(temp);\\n            \\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368403,
                "title": "easy-understanding-map-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findMatrix(vector<int>& nums) {\\n        map<int,int>mp;\\n        for(auto x:nums)mp[x]++;\\n        int maxi = 0;\\n        \\n        vector<vector<int>>ans;\\n        while(1)\\n        {\\n            vector<int>temp;\\n            for(auto x:mp)\\n            {\\n                if(x.second>0)\\n                {\\n                    temp.push_back(x.first);\\n                }\\n                mp[x.first]--;\\n            }\\n            if(temp.empty())break;\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findMatrix(vector<int>& nums) {\\n        map<int,int>mp;\\n        for(auto x:nums)mp[x]++;\\n        int maxi = 0;\\n        \\n        vector<vector<int>>ans;\\n        while(1)\\n        {\\n            vector<int>temp;\\n            for(auto x:mp)\\n            {\\n                if(x.second>0)\\n                {\\n                    temp.push_back(x.first);\\n                }\\n                mp[x.first]--;\\n            }\\n            if(temp.empty())break;\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368356,
                "title": "brute-force-o-nlog-2-n",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findMatrix(vector<int>& nums, vector<vector<int>> res = {}) {\\n        sort(nums.begin(), nums.end());\\n        for (auto ele : nums) {\\n            bool flag = 0;\\n            for (auto& num:res) {\\n                if (!binary_search(begin(num), end(num), ele)) {\\n                    num.push_back(ele);\\n                    flag = 1;\\n                    break;\\n                }\\n            }\\n            if (!flag)res.push_back({ele});\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findMatrix(vector<int>& nums, vector<vector<int>> res = {}) {\\n        sort(nums.begin(), nums.end());\\n        for (auto ele : nums) {\\n            bool flag = 0;\\n            for (auto& num:res) {\\n                if (!binary_search(begin(num), end(num), ele)) {\\n                    num.push_back(ele);\\n                    flag = 1;\\n                    break;\\n                }\\n            }\\n            if (!flag)res.push_back({ele});\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368353,
                "title": "easy-to-understand-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findMatrix(vector<int>& nums) {\\n        map<int,int>m;\\n        for(int i=0;i<nums.size();i++){\\n            m[nums[i]]++;\\n        }\\n       \\n        \\n        vector<vector<int>>ans;\\n       \\n    \\n      while(!m.empty()){\\n         \\n        vector<int>res;\\n          vector<int>v;\\n        for(auto it:m){\\n           \\n            res.push_back(it.first);\\n            m[it.first]--;\\n            if(m[it.first]==0){\\n                v.push_back(it.first);\\n            }\\n            \\n        }\\n        \\n        ans.push_back(res);\\n        for(auto i:v){\\n            m.erase(i);\\n        }\\n         \\n      }   \\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findMatrix(vector<int>& nums) {\\n        map<int,int>m;\\n        for(int i=0;i<nums.size();i++){\\n            m[nums[i]]++;\\n        }\\n       \\n        \\n        vector<vector<int>>ans;\\n       \\n    \\n      while(!m.empty()){\\n         \\n        vector<int>res;\\n          vector<int>v;\\n        for(auto it:m){\\n           \\n            res.push_back(it.first);\\n            m[it.first]--;\\n            if(m[it.first]==0){\\n                v.push_back(it.first);\\n            }\\n            \\n        }\\n        \\n        ans.push_back(res);\\n        for(auto i:v){\\n            m.erase(i);\\n        }\\n         \\n      }   \\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368315,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> findMatrix(int[] nums) {\\n        List<List<Integer>> ans=new ArrayList<>();\\n        int arr[]=new int[nums.length+1];\\n        Arrays.fill(arr,-1);\\n        List<Integer> l=new ArrayList<>();\\n        ans.add(l);\\n        int size=1;\\n        for(int i=0;i<nums.length;i++){\\n            if(arr[nums[i]]==-1){\\n            l.add(nums[i]);\\n                arr[nums[i]]=0;\\n            }\\n            else{\\n                boolean ref=false;\\n                for(int k=0;k<ans.size();k++){\\n                    List<Integer> lo=ans.get(k);\\n                    if(!lo.contains(nums[i])){\\n                        lo.add(nums[i]);\\n                        arr[nums[i]]=0;\\n                        ref=true;\\n                        break;\\n                    }\\n                }\\n                if(ref==false){\\n                List<Integer> ll=new ArrayList<>();\\n                ll.add(nums[i]);\\n                arr[nums[i]]=0;\\n                    ans.add(ll);\\n                    size++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> findMatrix(int[] nums) {\\n        List<List<Integer>> ans=new ArrayList<>();\\n        int arr[]=new int[nums.length+1];\\n        Arrays.fill(arr,-1);\\n        List<Integer> l=new ArrayList<>();\\n        ans.add(l);\\n        int size=1;\\n        for(int i=0;i<nums.length;i++){\\n            if(arr[nums[i]]==-1){\\n            l.add(nums[i]);\\n                arr[nums[i]]=0;\\n            }\\n            else{\\n                boolean ref=false;\\n                for(int k=0;k<ans.size();k++){\\n                    List<Integer> lo=ans.get(k);\\n                    if(!lo.contains(nums[i])){\\n                        lo.add(nums[i]);\\n                        arr[nums[i]]=0;\\n                        ref=true;\\n                        break;\\n                    }\\n                }\\n                if(ref==false){\\n                List<Integer> ll=new ArrayList<>();\\n                ll.add(nums[i]);\\n                arr[nums[i]]=0;\\n                    ans.add(ll);\\n                    size++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368295,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findMatrix(vector<int>& nums) {\\n        map<int,int>mp;\\n        for(auto i:nums)\\n            mp[i]++;\\n        vector<vector<int>>ans;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            vector<int>temp;\\n            for(auto j:mp)\\n            {\\n                if(j.second>0)\\n                {\\n                    temp.push_back(j.first);\\n                    mp[j.first]--;\\n                }\\n            }\\n            if(temp.size()>0)\\n                ans.push_back(temp);\\n            else\\n                break;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findMatrix(vector<int>& nums) {\\n        map<int,int>mp;\\n        for(auto i:nums)\\n            mp[i]++;\\n        vector<vector<int>>ans;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            vector<int>temp;\\n            for(auto j:mp)\\n            {\\n                if(j.second>0)\\n                {\\n                    temp.push_back(j.first);\\n                    mp[j.first]--;\\n                }\\n            }\\n            if(temp.size()>0)\\n                ans.push_back(temp);\\n            else\\n                break;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368286,
                "title": "c-map-use",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findMatrix(vector<int>& nums) {\\n        unordered_map<int,int> mp;\\n        for(auto i : nums) mp[i] += 1;\\n        vector<vector<int>> ans;\\n        while(1){\\n            set<int> temp;\\n            for(auto i : nums){\\n                if(mp[i]>0 && temp.count(i)==0){\\n                    temp.insert(i);\\n                    mp[i] -= 1;\\n                }\\n            }\\n            vector<int> t;\\n            for(auto i : temp) t.push_back(i);\\n            ans.push_back(t);\\n            bool check=false;\\n            for(auto i : nums){\\n                if(mp[i]>0){\\n                    check = true;\\n                    break;\\n                }\\n            }\\n            if(!check) break;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findMatrix(vector<int>& nums) {\\n        unordered_map<int,int> mp;\\n        for(auto i : nums) mp[i] += 1;\\n        vector<vector<int>> ans;\\n        while(1){\\n            set<int> temp;\\n            for(auto i : nums){\\n                if(mp[i]>0 && temp.count(i)==0){\\n                    temp.insert(i);\\n                    mp[i] -= 1;\\n                }\\n            }\\n            vector<int> t;\\n            for(auto i : temp) t.push_back(i);\\n            ans.push_back(t);\\n            bool check=false;\\n            for(auto i : nums){\\n                if(mp[i]>0){\\n                    check = true;\\n                    break;\\n                }\\n            }\\n            if(!check) break;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4100254,
                "title": "c-easy-solution-using-map",
                "content": "\\n\\t\\t\\n\\t\\tint maxi=INT_MIN; unordered_map<int,int>mp; \\n        for(auto i : nums)\\n        {\\n            mp[i]++;\\n            if(mp[i]>maxi) maxi=mp[i];\\n        } \\n        vector<vector<int>>vec(maxi);\\n         for( auto i : mp) for(int j=0;j<i.second;j++) vec[j].push_back(i.first);\\n        return vec;",
                "solutionTags": [],
                "code": "\\n\\t\\t\\n\\t\\tint maxi=INT_MIN; unordered_map<int,int>mp; \\n        for(auto i : nums)\\n        {\\n            mp[i]++;\\n            if(mp[i]>maxi) maxi=mp[i];\\n        } \\n        vector<vector<int>>vec(maxi);\\n         for( auto i : mp) for(int j=0;j<i.second;j++) vec[j].push_back(i.first);\\n        return vec;",
                "codeTag": "Unknown"
            },
            {
                "id": 4099559,
                "title": "java-solution-95",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n  public static List<List<Integer>> findMatrix(int[] nums) {\\n    var result = new ArrayList<List<Integer>>();\\n    var temp =  new ArrayList<Integer>();\\n    var i =0;\\n    var k =0;\\n    var l =nums.length;\\n    while(i != l){\\n      var current =nums[k];\\n      if(current >=0 && !temp.contains(current)){\\n        temp.add(current);\\n        i++;\\n        nums[k] =-1;\\n      }\\n      k++;\\n      if(i == l || k >= nums.length){\\n      result.add(temp);\\n        temp = new ArrayList<>();\\n      k=0;\\n      }\\n    }\\n    return result;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public static List<List<Integer>> findMatrix(int[] nums) {\\n    var result = new ArrayList<List<Integer>>();\\n    var temp =  new ArrayList<Integer>();\\n    var i =0;\\n    var k =0;\\n    var l =nums.length;\\n    while(i != l){\\n      var current =nums[k];\\n      if(current >=0 && !temp.contains(current)){\\n        temp.add(current);\\n        i++;\\n        nums[k] =-1;\\n      }\\n      k++;\\n      if(i == l || k >= nums.length){\\n      result.add(temp);\\n        temp = new ArrayList<>();\\n      k=0;\\n      }\\n    }\\n    return result;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4084523,
                "title": "simple-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def findMatrix(self, nums: List[int]) -> List[List[int]]:\\n        #result list\\n        output = list()\\n        # check for each number\\n        for i in nums:\\n            flag = 0\\n            for j in output:\\n                #add to existing list if not in list\\n                if i not in j:\\n                    j.append(i)\\n                    flag=1\\n                    break\\n                else:\\n                    pass\\n            if flag == 0:\\n                output.append([i])\\n            else:\\n                pass\\n        return output\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findMatrix(self, nums: List[int]) -> List[List[int]]:\\n        #result list\\n        output = list()\\n        # check for each number\\n        for i in nums:\\n            flag = 0\\n            for j in output:\\n                #add to existing list if not in list\\n                if i not in j:\\n                    j.append(i)\\n                    flag=1\\n                    break\\n                else:\\n                    pass\\n            if flag == 0:\\n                output.append([i])\\n            else:\\n                pass\\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4084234,
                "title": "python-very-easy-solution-with-set",
                "content": "# Code\\n```\\nclass Solution:\\n    def findMatrix(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        while nums:\\n            row = list(set(nums))\\n            for el in row: nums.remove(el)\\n            res.append(row)\\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def findMatrix(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        while nums:\\n            row = list(set(nums))\\n            for el in row: nums.remove(el)\\n            res.append(row)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4079236,
                "title": "98-87-very-optimal-approch-in-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> findMatrix(int[] nums) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        int max = -1;\\n        for(int i = 0; i < nums.length; i++){\\n            map.putIfAbsent(nums[i], 1);\\n            map.put(nums[i], map.get(nums[i])+1);\\n            max = Math.max(max, map.get(nums[i]));\\n        }\\n        ArrayList<List<Integer>> ans = new ArrayList<>();\\n        while(max-- > 1){\\n            ArrayList<Integer> list = new ArrayList<>();\\n        for(int i : map.keySet()){\\n            if(map.get(i) > 1) {\\n            list.add(i);\\n            map.put(i, map.get(i)-1);\\n            }\\n        }\\n        ans.add(list);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> findMatrix(int[] nums) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        int max = -1;\\n        for(int i = 0; i < nums.length; i++){\\n            map.putIfAbsent(nums[i], 1);\\n            map.put(nums[i], map.get(nums[i])+1);\\n            max = Math.max(max, map.get(nums[i]));\\n        }\\n        ArrayList<List<Integer>> ans = new ArrayList<>();\\n        while(max-- > 1){\\n            ArrayList<Integer> list = new ArrayList<>();\\n        for(int i : map.keySet()){\\n            if(map.get(i) > 1) {\\n            list.add(i);\\n            map.put(i, map.get(i)-1);\\n            }\\n        }\\n        ans.add(list);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4074929,
                "title": "hashmap-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> findMatrix(int[] nums) {\\n       Map<Integer,Integer> map = new HashMap<>();\\n       int max = 0;\\n       for(int i = 0 ; i<nums.length;i++){\\n           map.put(nums[i],map.getOrDefault(nums[i],0)+1);\\n           max = Math.max(max,map.get(nums[i]));\\n       }\\n       List<List<Integer>> ans = new ArrayList<>();\\n       for(int i = 0; i<max;i++)\\n       ans.add(new ArrayList<>());\\n\\n       int j = 0;\\n       boolean[] added = new boolean[nums.length];\\n       while(j<max){\\n           int i = 0;\\n           List<Integer> list = ans.get(j);\\n           while(i<nums.length){\\n               if(!list.contains(nums[i]) && !added[i]){\\n               list.add(nums[i]);\\n               added[i] = true;\\n           }\\n            i++;\\n           }\\n           j++;\\n       }\\n       return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> findMatrix(int[] nums) {\\n       Map<Integer,Integer> map = new HashMap<>();\\n       int max = 0;\\n       for(int i = 0 ; i<nums.length;i++){\\n           map.put(nums[i],map.getOrDefault(nums[i],0)+1);\\n           max = Math.max(max,map.get(nums[i]));\\n       }\\n       List<List<Integer>> ans = new ArrayList<>();\\n       for(int i = 0; i<max;i++)\\n       ans.add(new ArrayList<>());\\n\\n       int j = 0;\\n       boolean[] added = new boolean[nums.length];\\n       while(j<max){\\n           int i = 0;\\n           List<Integer> list = ans.get(j);\\n           while(i<nums.length){\\n               if(!list.contains(nums[i]) && !added[i]){\\n               list.add(nums[i]);\\n               added[i] = true;\\n           }\\n            i++;\\n           }\\n           j++;\\n       }\\n       return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4071864,
                "title": "js-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\nvar findMatrix = function(nums) {\\n    const result = [];\\n    let tempArray = [];\\n\\n\\n    for (let i = 0; i < nums.length; i++) {\\n      for (let j = 0; j < nums.length; j++) {\\n        const num = nums[j];\\n        \\n        if (num !== 0) {\\n          if (!tempArray.includes(num)) {\\n            tempArray.push(num);\\n            nums[j] = 0;          \\n          } \\n        }\\n      }\\n\\n      if (tempArray.length > 0) {\\n        result.push(tempArray);\\n      }\\n\\n      tempArray = [];\\n    }\\n\\n    return result;\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\nvar findMatrix = function(nums) {\\n    const result = [];\\n    let tempArray = [];\\n\\n\\n    for (let i = 0; i < nums.length; i++) {\\n      for (let j = 0; j < nums.length; j++) {\\n        const num = nums[j];\\n        \\n        if (num !== 0) {\\n          if (!tempArray.includes(num)) {\\n            tempArray.push(num);\\n            nums[j] = 0;          \\n          } \\n        }\\n      }\\n\\n      if (tempArray.length > 0) {\\n        result.push(tempArray);\\n      }\\n\\n      tempArray = [];\\n    }\\n\\n    return result;\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4069967,
                "title": "easy-to-understand-python3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findMatrix(self, nums: List[int]) -> List[List[int]]:\\n        d = {}\\n        for i in nums:\\n            if i in d:\\n                d[i] += 1\\n            else:\\n                d[i] = 1\\n        \\n        res = []\\n\\n        while len(d) > 0:\\n            intermediate = []\\n\\n            for key in list(d.keys()):\\n                intermediate.append(key)\\n                d[key] -= 1\\n                if d[key] == 0:\\n                    del d[key]\\n\\n            res.append(intermediate)\\n        \\n        return res\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findMatrix(self, nums: List[int]) -> List[List[int]]:\\n        d = {}\\n        for i in nums:\\n            if i in d:\\n                d[i] += 1\\n            else:\\n                d[i] = 1\\n        \\n        res = []\\n\\n        while len(d) > 0:\\n            intermediate = []\\n\\n            for key in list(d.keys()):\\n                intermediate.append(key)\\n                d[key] -= 1\\n                if d[key] == 0:\\n                    del d[key]\\n\\n            res.append(intermediate)\\n        \\n        return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4064850,
                "title": "java-clean-solution-both-runtime-and-memory-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse Map to count how many numbers for each existing numbers.\\nIterating through keySet() put them into solution.  Basically O(N) RunTime\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> findMatrix(int[] nums) {\\n        List<List<Integer>> res = new ArrayList();\\n        Map<Integer, Integer> map = new HashMap<Integer,Integer>();\\n\\n        for (int num : nums) {\\n            map.put(num, map.getOrDefault(num,0)+1);\\n        }\\n        for (int num : map.keySet()) {\\n            int c = map.get(num);\\n            while(res.size() < c) {\\n                List<Integer> tmpRes = new ArrayList();\\n                res.add(tmpRes);\\n            }\\n            for (int i = 0 ; i < c ; i++) \\n            {\\n                res.get(i).add(num);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> findMatrix(int[] nums) {\\n        List<List<Integer>> res = new ArrayList();\\n        Map<Integer, Integer> map = new HashMap<Integer,Integer>();\\n\\n        for (int num : nums) {\\n            map.put(num, map.getOrDefault(num,0)+1);\\n        }\\n        for (int num : map.keySet()) {\\n            int c = map.get(num);\\n            while(res.size() < c) {\\n                List<Integer> tmpRes = new ArrayList();\\n                res.add(tmpRes);\\n            }\\n            for (int i = 0 ; i < c ; i++) \\n            {\\n                res.get(i).add(num);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4064527,
                "title": "java-easiest-to-understand-with-less-space-complexity",
                "content": "# Intuition\\nEasiet Understandable cod ein Java\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> findMatrix(int[] nums) {\\n        List<List<Integer>> allRows;\\n\\n        int totalRows=1;\\n\\n        //Get unique elements\\n        Set<Integer> uniqueElements = Arrays.stream(nums).boxed().collect(Collectors.toSet());\\n\\n        //Get element with highest frequency\\n        for (int key : uniqueElements)\\n        {\\n            int frequency=getFrequency(nums, key);\\n            if(frequency > totalRows)\\n                totalRows=frequency;\\n        } \\n\\n        //Create arraylist with capacity of highest frequency\\n        allRows=new ArrayList<>(totalRows);   \\n\\n        for(int i = 0; i < totalRows; i++) {\\n            allRows.add(new ArrayList<>());\\n        }\\n\\n\\n        for(int i=0;i<nums.length;i++){\\n            //for each element\\n\\n            for(int j=0;j<totalRows;j++){\\n                //check if already exist in each row\\n                if(!((allRows.get(j)).contains(nums[i])))\\n                {\\n                    (allRows.get(j)).add(nums[i]);\\n                    break;\\n                }\\n            }            \\n        }\\n        return allRows;\\n    }\\n\\n    public int getFrequency(int[] nums, int key){\\n        int counter=0;\\n\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==key){\\n                counter++;\\n            }\\n        }\\n        return counter;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> findMatrix(int[] nums) {\\n        List<List<Integer>> allRows;\\n\\n        int totalRows=1;\\n\\n        //Get unique elements\\n        Set<Integer> uniqueElements = Arrays.stream(nums).boxed().collect(Collectors.toSet());\\n\\n        //Get element with highest frequency\\n        for (int key : uniqueElements)\\n        {\\n            int frequency=getFrequency(nums, key);\\n            if(frequency > totalRows)\\n                totalRows=frequency;\\n        } \\n\\n        //Create arraylist with capacity of highest frequency\\n        allRows=new ArrayList<>(totalRows);   \\n\\n        for(int i = 0; i < totalRows; i++) {\\n            allRows.add(new ArrayList<>());\\n        }\\n\\n\\n        for(int i=0;i<nums.length;i++){\\n            //for each element\\n\\n            for(int j=0;j<totalRows;j++){\\n                //check if already exist in each row\\n                if(!((allRows.get(j)).contains(nums[i])))\\n                {\\n                    (allRows.get(j)).add(nums[i]);\\n                    break;\\n                }\\n            }            \\n        }\\n        return allRows;\\n    }\\n\\n    public int getFrequency(int[] nums, int key){\\n        int counter=0;\\n\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==key){\\n                counter++;\\n            }\\n        }\\n        return counter;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4063812,
                "title": "php-11ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    /**\\n     * @param Integer[] $nums\\n     * @return Integer[][]\\n     */\\n    function findMatrix($nums) {\\n        $arr = [];\\n        $n = [];\\n\\n        foreach ($nums as $num) {\\n            $n[$num]++;\\n            $arr[$n[$num]][] = $num;\\n        }\\n        return $arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nclass Solution {\\n\\n    /**\\n     * @param Integer[] $nums\\n     * @return Integer[][]\\n     */\\n    function findMatrix($nums) {\\n        $arr = [];\\n        $n = [];\\n\\n        foreach ($nums as $num) {\\n            $n[$num]++;\\n            $arr[$n[$num]][] = $num;\\n        }\\n        return $arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4059932,
                "title": "my-brute-force-code",
                "content": "# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> findMatrix(int[] nums) {\\n        List<List<Integer>> answer = new ArrayList<>();\\n        while(true) {\\n            Set<Integer> running = new HashSet<>();\\n            for(int i = 0; i < nums.length; i++) {\\n                if(!running.contains(nums[i]) && nums[i] != -1) {\\n                    running.add(nums[i]);\\n                    nums[i] = -1;\\n                }\\n            }\\n            if(running.isEmpty()) {\\n                break;\\n            } else {\\n                answer.add(List.copyOf(running));\\n            }\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> findMatrix(int[] nums) {\\n        List<List<Integer>> answer = new ArrayList<>();\\n        while(true) {\\n            Set<Integer> running = new HashSet<>();\\n            for(int i = 0; i < nums.length; i++) {\\n                if(!running.contains(nums[i]) && nums[i] != -1) {\\n                    running.add(nums[i]);\\n                    nums[i] = -1;\\n                }\\n            }\\n            if(running.isEmpty()) {\\n                break;\\n            } else {\\n                answer.add(List.copyOf(running));\\n            }\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4055637,
                "title": "simple-noob-solution-in-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n(I am a noob at this so please feel free to critique and provide tips in the comments!)\\nMy approach to his problem was to loop through the given array and check if that value was in the first list I created. If it was I create a new list. I keep doing this with all the values.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Create a dictionary/hashmap with list/array as the default values for any key\\n2. Loop through all the values in the list/array\\n3. Check whether the first list/array contains the value\\n4. If the above is true, keep looping through the other lists till you find one it\\'s not in\\n5. Append the value to the list\\n6. Returns all the lists/arrays in the dictionary/hashmap as a single array\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(m*n) / O(n^2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution:\\n    def findMatrix(self, nums: List[int]) -> List[List[int]]:\\n        hashmap = defaultdict(list)\\n        for num in nums:\\n            list_no = 1\\n            while num in hashmap[list_no]:\\n                list_no += 1\\n            \\n            hashmap[list_no].append(num)\\n        \\n        return list(hashmap.values())\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def findMatrix(self, nums: List[int]) -> List[List[int]]:\\n        hashmap = defaultdict(list)\\n        for num in nums:\\n            list_no = 1\\n            while num in hashmap[list_no]:\\n                list_no += 1\\n            \\n            hashmap[list_no].append(num)\\n        \\n        return list(hashmap.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4051369,
                "title": "lesgoo",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  static boolean check(List<Integer> list , int n){\\n     for(int i=0;i<list.size();i++){\\n         if(list.get(i)==n){\\n             return false;\\n         }\\n     }\\n     return true;\\n }\\n static int size(List<List<Integer>> list){\\n     int ans=0;\\n     for(int i=0;i<list.size();i++){\\n         ans+=list.get(i).size();\\n     }\\n     return ans;\\n }\\n    public static int[] mergesort(int[] arr){\\n        if(arr.length<=1){\\n            return arr;\\n        }\\n        int mid = (arr.length)/2;\\n        int[] arr1 = Arrays.copyOfRange(arr,0,mid);\\n        arr1 = mergesort(arr1);\\n        int[] arr2 = Arrays.copyOfRange(arr,mid,arr.length);\\n        arr2 = mergesort(arr2);\\n\\n        int[] ans = new int[arr.length];\\n        int i=0,j=0;\\n        while( i<arr1.length && j<arr2.length){\\n            if(arr1[i] > arr2[j]){\\n                ans[i+j]=arr2[j];\\n                j++;\\n            }else {\\n                ans[i+j]=arr1[i];\\n                i++;\\n            }\\n        }\\n        if(i==arr1.length){\\n            for(;j<arr2.length;j++){\\n                ans[arr1.length+j]=arr2[j];\\n            }\\n\\n        }else if (j==arr2.length){\\n            for(;i<arr1.length;i++){\\n                ans[arr2.length+i]=arr1[i];\\n            }\\n        }\\n        return ans;\\n    }\\n    public List<List<Integer>> findMatrix(int[] arr) {\\n     int[] nums=mergesort(arr);\\n       List<List<Integer>>  ans = new ArrayList<>();\\n       List<Integer> arr2=new ArrayList<>();\\n       int s=0;\\n       while(s<nums.length){\\n           List<Integer> list = new ArrayList<>();\\n           for(int i=0;i<nums.length;i++){\\n               if(check(arr2,i) && check(list,nums[i])){\\n                   list.add(nums[i]);\\n                   arr2.add(i);\\n               }\\n           }\\n           ans.add(list);\\n           s+=list.size();\\n       }\\n       return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  static boolean check(List<Integer> list , int n){\\n     for(int i=0;i<list.size();i++){\\n         if(list.get(i)==n){\\n             return false;\\n         }\\n     }\\n     return true;\\n }\\n static int size(List<List<Integer>> list){\\n     int ans=0;\\n     for(int i=0;i<list.size();i++){\\n         ans+=list.get(i).size();\\n     }\\n     return ans;\\n }\\n    public static int[] mergesort(int[] arr){\\n        if(arr.length<=1){\\n            return arr;\\n        }\\n        int mid = (arr.length)/2;\\n        int[] arr1 = Arrays.copyOfRange(arr,0,mid);\\n        arr1 = mergesort(arr1);\\n        int[] arr2 = Arrays.copyOfRange(arr,mid,arr.length);\\n        arr2 = mergesort(arr2);\\n\\n        int[] ans = new int[arr.length];\\n        int i=0,j=0;\\n        while( i<arr1.length && j<arr2.length){\\n            if(arr1[i] > arr2[j]){\\n                ans[i+j]=arr2[j];\\n                j++;\\n            }else {\\n                ans[i+j]=arr1[i];\\n                i++;\\n            }\\n        }\\n        if(i==arr1.length){\\n            for(;j<arr2.length;j++){\\n                ans[arr1.length+j]=arr2[j];\\n            }\\n\\n        }else if (j==arr2.length){\\n            for(;i<arr1.length;i++){\\n                ans[arr2.length+i]=arr1[i];\\n            }\\n        }\\n        return ans;\\n    }\\n    public List<List<Integer>> findMatrix(int[] arr) {\\n     int[] nums=mergesort(arr);\\n       List<List<Integer>>  ans = new ArrayList<>();\\n       List<Integer> arr2=new ArrayList<>();\\n       int s=0;\\n       while(s<nums.length){\\n           List<Integer> list = new ArrayList<>();\\n           for(int i=0;i<nums.length;i++){\\n               if(check(arr2,i) && check(list,nums[i])){\\n                   list.add(nums[i]);\\n                   arr2.add(i);\\n               }\\n           }\\n           ans.add(list);\\n           s+=list.size();\\n       }\\n       return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4045445,
                "title": "beginner-friendly-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findMatrix(vector<int>& nums) {\\n        map<int,int>mp;\\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            mp[nums[i]]++;\\n        }\\n\\n        int maxi=0;\\n        for(auto i:mp)\\n        {\\n            maxi=max(maxi,i.second);\\n        }\\n        vector<vector<int>>ans;\\n\\n        for(int i=0;i<maxi;i++)\\n        {\\n            vector<int>v;\\n            for(auto it=mp.begin();it!=mp.end();it++)\\n            {\\n                if(mp[it->first]!=0)\\n                {\\n                    v.push_back(it->first);\\n                    mp[(it->first)]--;\\n                }\\n            }\\n            ans.push_back(v);\\n        }\\n        return ans;\\n       \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findMatrix(vector<int>& nums) {\\n        map<int,int>mp;\\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            mp[nums[i]]++;\\n        }\\n\\n        int maxi=0;\\n        for(auto i:mp)\\n        {\\n            maxi=max(maxi,i.second);\\n        }\\n        vector<vector<int>>ans;\\n\\n        for(int i=0;i<maxi;i++)\\n        {\\n            vector<int>v;\\n            for(auto it=mp.begin();it!=mp.end();it++)\\n            {\\n                if(mp[it->first]!=0)\\n                {\\n                    v.push_back(it->first);\\n                    mp[(it->first)]--;\\n                }\\n            }\\n            ans.push_back(v);\\n        }\\n        return ans;\\n       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4039044,
                "title": "swift-easy-to-understand-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    func findMatrix(_ nums: [Int]) -> [[Int]] {\\n         var array = [[Int]]()\\n    \\n    for n in nums {\\n        \\n        if array.isEmpty {\\n            array.append([n])\\n        } else if array.last!.contains(n) {\\n            array.append([n])\\n        } else {\\n            array[array.firstIndex(where: { !$0.contains(n) })!].append(n)\\n        }\\n        \\n    }\\n    \\n    return array\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func findMatrix(_ nums: [Int]) -> [[Int]] {\\n         var array = [[Int]]()\\n    \\n    for n in nums {\\n        \\n        if array.isEmpty {\\n            array.append([n])\\n        } else if array.last!.contains(n) {\\n            array.append([n])\\n        } else {\\n            array[array.firstIndex(where: { !$0.contains(n) })!].append(n)\\n        }\\n        \\n    }\\n    \\n    return array\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4038924,
                "title": "using-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findMatrix(self, nums: List[int]) -> List[List[int]]:\\n        ans = []\\n        while len(nums) > 0:\\n            lst = list(set(nums))\\n            for i in lst:\\n                nums.remove(i)\\n            ans.append(lst)\\n        return ans\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findMatrix(self, nums: List[int]) -> List[List[int]]:\\n        ans = []\\n        while len(nums) > 0:\\n            lst = list(set(nums))\\n            for i in lst:\\n                nums.remove(i)\\n            ans.append(lst)\\n        return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4036678,
                "title": "o-n-time-complexity-c-solution-with-additional-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nDecided to utilize an aditional hashmap to reduce time complexity by having the hashmap keep track of where the next position a value would go if found\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> findMatrix(int[] nums) {\\n        List<List<Integer>> arr2d = new ArrayList<List<Integer>>();\\n        HashMap<Integer, Integer> dict = new HashMap<Integer,Integer>();\\n        int highest=0;\\n        for(int a: nums) {\\n            dict.putIfAbsent(a,0);\\n            dict.put(a,dict.get(a)+1);\\n            if(dict.get(a) > highest) {\\n                arr2d.add(new ArrayList<Integer>());\\n                highest++;\\n            }\\n            arr2d.get(dict.get(a)-1).add(a);\\n        }\\n        return arr2d;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> findMatrix(int[] nums) {\\n        List<List<Integer>> arr2d = new ArrayList<List<Integer>>();\\n        HashMap<Integer, Integer> dict = new HashMap<Integer,Integer>();\\n        int highest=0;\\n        for(int a: nums) {\\n            dict.putIfAbsent(a,0);\\n            dict.put(a,dict.get(a)+1);\\n            if(dict.get(a) > highest) {\\n                arr2d.add(new ArrayList<Integer>());\\n                highest++;\\n            }\\n            arr2d.get(dict.get(a)-1).add(a);\\n        }\\n        return arr2d;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4020251,
                "title": "java-simple-solution-using-lists-3ms",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> findMatrix(int[] nums) {\\n        List<List<Integer>>list3 = new ArrayList<>();\\n        List<Integer>list1 = new ArrayList<>();\\n        if(nums.length==1){\\n            list1.add(nums[0]);\\n            list3.add(list1);\\n            return list3;\\n        }\\n        int sum = 0;\\n        int p = nums.length-1;\\n        for(int i = 0;i<nums.length;i++){\\n            list1.add(nums[i]);\\n        }\\n        while(p>=sum){\\n            List<Integer>list2 = new ArrayList<>();\\n            for(int i = 0;i<list1.size();i++){\\n                if(!list2.contains(list1.get(i))){\\n                    list2.add(list1.get(i));\\n                    sum++;\\n                    list1.remove(i);\\n                    i--;\\n                }\\n                \\n            }\\n            if(list2.size()!=0)\\n            list3.add(list2);\\n        }\\n        return list3;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> findMatrix(int[] nums) {\\n        List<List<Integer>>list3 = new ArrayList<>();\\n        List<Integer>list1 = new ArrayList<>();\\n        if(nums.length==1){\\n            list1.add(nums[0]);\\n            list3.add(list1);\\n            return list3;\\n        }\\n        int sum = 0;\\n        int p = nums.length-1;\\n        for(int i = 0;i<nums.length;i++){\\n            list1.add(nums[i]);\\n        }\\n        while(p>=sum){\\n            List<Integer>list2 = new ArrayList<>();\\n            for(int i = 0;i<list1.size();i++){\\n                if(!list2.contains(list1.get(i))){\\n                    list2.add(list1.get(i));\\n                    sum++;\\n                    list1.remove(i);\\n                    i--;\\n                }\\n                \\n            }\\n            if(list2.size()!=0)\\n            list3.add(list2);\\n        }\\n        return list3;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4020004,
                "title": "python-solution-easy-using-hashmap-dictionary",
                "content": "# Intuition\\nThe number of rows in the result will be equal to the maximum nnumber of times a digit is repeating.\\n\\n# Approach\\nWe find which digit repeats the most and based on that we append values into the list.\\n\\n# Complexity\\n- Time complexity:O(n), two loops are being used\\n\\n- Space complexity:O(n), for the hashmap\\n\\n# Code\\n```\\nclass Solution:\\n    def findMatrix(self, nums: List[int]) -> List[List[int]]:\\n        d={}\\n        for i in nums:\\n            d[i]=d.get(i,0)+1\\n        a=max(list(d.values()))\\n        res=[None]*a\\n        for i in d:\\n            k=0\\n            while d[i]!=0:\\n                if res[k]==None:\\n                    res[k]=[i]\\n                    k+=1\\n                    d[i]-=1\\n                else:\\n                    res[k].append(i)\\n                    k+=1\\n                    d[i]-=1\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findMatrix(self, nums: List[int]) -> List[List[int]]:\\n        d={}\\n        for i in nums:\\n            d[i]=d.get(i,0)+1\\n        a=max(list(d.values()))\\n        res=[None]*a\\n        for i in d:\\n            k=0\\n            while d[i]!=0:\\n                if res[k]==None:\\n                    res[k]=[i]\\n                    k+=1\\n                    d[i]-=1\\n                else:\\n                    res[k].append(i)\\n                    k+=1\\n                    d[i]-=1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4016764,
                "title": "beats-100-time",
                "content": "My first solution with this achievement:\\n\\n![Screenshot 2023-09-08 103528.png](https://assets.leetcode.com/users/images/67966963-a8f2-4789-a63e-47d07f00d0b5_1694149542.3124268.png)\\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def findMatrix(self, nums: List[int]) -> List[List[int]]:\\n        arr2D = [[nums[0]]]\\n        for num in nums[1: ]:\\n            temp = True\\n            for row in arr2D:\\n                if num not in row:\\n                    row.append(num)\\n                    temp = False\\n                    break\\n            if temp:\\n                arr2D.append([num])\\n\\n        return arr2D\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findMatrix(self, nums: List[int]) -> List[List[int]]:\\n        arr2D = [[nums[0]]]\\n        for num in nums[1: ]:\\n            temp = True\\n            for row in arr2D:\\n                if num not in row:\\n                    row.append(num)\\n                    temp = False\\n                    break\\n            if temp:\\n                arr2D.append([num])\\n\\n        return arr2D\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4010408,
                "title": "i-have-also-copied-this-solution-but-this-is-best-for-beginners-without-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> findMatrix(int[] nums) {\\n        ArrayList<Integer> temp = new ArrayList<>();\\n        for(int i = 0 ; i < nums.length ; i++){\\n            temp.add(nums[i]);\\n        }\\n        List<List<Integer>> ans = new ArrayList<>();\\n        while(temp.size() > 0){\\n            List<Integer> row = new ArrayList<>();\\n            row.clear();\\n            int i = 0;\\n            while(i < temp.size()){\\n                int a = temp.get(i);\\n                if(!row.contains(a)){\\n                    row.add(a);\\n                    temp.remove(i);\\n                }\\n                else{\\n                    i++;\\n                }\\n            }\\n            ans.add(row);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> findMatrix(int[] nums) {\\n        ArrayList<Integer> temp = new ArrayList<>();\\n        for(int i = 0 ; i < nums.length ; i++){\\n            temp.add(nums[i]);\\n        }\\n        List<List<Integer>> ans = new ArrayList<>();\\n        while(temp.size() > 0){\\n            List<Integer> row = new ArrayList<>();\\n            row.clear();\\n            int i = 0;\\n            while(i < temp.size()){\\n                int a = temp.get(i);\\n                if(!row.contains(a)){\\n                    row.add(a);\\n                    temp.remove(i);\\n                }\\n                else{\\n                    i++;\\n                }\\n            }\\n            ans.add(row);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4007726,
                "title": "python3-using-dict-and-list",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findMatrix(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        resList = []\\n        data = {}\\n\\n        for num in nums:\\n            if num in data:\\n                data[num]+=1\\n            else:\\n                data[num]=1\\n        # find most frequent elemtent\\n        maxFreq = -1\\n        for key in data:\\n            maxFreq = max(maxFreq, data[key])\\n\\n        for i in range(0, maxFreq):\\n            resList.append([])\\n        \\n        for key in data:\\n            i=0\\n            while i<data[key]:\\n                resList[i].append(key)\\n                i+=1\\n        \\n        return resList\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findMatrix(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        resList = []\\n        data = {}\\n\\n        for num in nums:\\n            if num in data:\\n                data[num]+=1\\n            else:\\n                data[num]=1\\n        # find most frequent elemtent\\n        maxFreq = -1\\n        for key in data:\\n            maxFreq = max(maxFreq, data[key])\\n\\n        for i in range(0, maxFreq):\\n            resList.append([])\\n        \\n        for key in data:\\n            i=0\\n            while i<data[key]:\\n                resList[i].append(key)\\n                i+=1\\n        \\n        return resList\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4006018,
                "title": "4ma-60-java-hashmap-explained",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Get Frequency of each element by using hashmap and maintain maxfreq to get the size of 2d array i.e number of rows required\\n- Initialise no. of lists required\\n- travel through hashmap for each entry add key in list form index 0 to (value-1) so that no element occurs twice in a row\\n\\n# Complexity\\n- Time complexity: O(n) n -> nums.length\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> findMatrix(int[] nums) {\\n        HashMap<Integer, Integer> mp = new HashMap<>();\\n        int size = 0;\\n        for(int i : nums){\\n            if(mp.containsKey(i)) mp.put(i, mp.get(i)+1);\\n            else mp.put(i,1);\\n            \\n            if(size<mp.get(i)) size = mp.get(i);\\n        }\\n\\n        List<List<Integer>> ans = new LinkedList<>();\\n\\n        while(size>0){\\n            ans.add(new LinkedList<Integer>());\\n            size--;\\n        }\\n\\n        for(var e : mp.entrySet()){\\n            int j = e.getValue();\\n            for(int i=0; i<j; i++){\\n                ans.get(i).add(e.getKey());\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> findMatrix(int[] nums) {\\n        HashMap<Integer, Integer> mp = new HashMap<>();\\n        int size = 0;\\n        for(int i : nums){\\n            if(mp.containsKey(i)) mp.put(i, mp.get(i)+1);\\n            else mp.put(i,1);\\n            \\n            if(size<mp.get(i)) size = mp.get(i);\\n        }\\n\\n        List<List<Integer>> ans = new LinkedList<>();\\n\\n        while(size>0){\\n            ans.add(new LinkedList<Integer>());\\n            size--;\\n        }\\n\\n        for(var e : mp.entrySet()){\\n            int j = e.getValue();\\n            for(int i=0; i<j; i++){\\n                ans.get(i).add(e.getKey());\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4005745,
                "title": "vector-map-game-easy-explanation-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findMatrix(vector<int>& nums) {\\n        map<int, int> mp;\\n        for(auto it: nums){\\n            mp[it]++;\\n        }\\n        \\n        vector<pair<int, int>> v;\\n        for(auto it: mp){\\n            v.push_back({it.second, it.first});\\n        }\\n        \\n        sort(v.begin(), v.end());\\n        reverse(v.begin(), v.end());\\n        \\n        int maxSize = v[0].first;\\n        int temp = 0;\\n        \\n        vector<int> filler;\\n        vector<vector<int>>ans;\\n        for(int i=0; i<v.size(); i++){\\n            temp = 0;\\n            while(v[i].first != 0){\\n                filler.push_back(v[i].second);\\n                v[i].first --;\\n                temp ++;\\n            }\\n            \\n            while(temp < maxSize){\\n                filler.push_back(-1);\\n                temp++;\\n            }\\n            \\n            ans.push_back(filler);\\n            filler.clear();\\n        }\\n        \\n        vector<vector<int>>transpose;   \\n        for(int i=0; i<ans[0].size(); i++){\\n            filler.clear();\\n            for(int j=0; j<ans.size(); j++){\\n                filler.push_back(ans[j][i]);\\n            }\\n            transpose.push_back(filler);         \\n        }\\n        \\n        temp = 2*transpose.size();\\n        while(temp != 0){\\n            for(int i=0; i<transpose.size(); i++){\\n                for(int j=0; j<transpose[i].size(); j++){\\n                    if(transpose[i][j] == -1){\\n                        transpose[i].erase(transpose[i].begin() + j);\\n                    }\\n                }\\n            }\\n            temp --;\\n        }\\n        \\n        \\n                                    \\n        \\n        return transpose;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findMatrix(vector<int>& nums) {\\n        map<int, int> mp;\\n        for(auto it: nums){\\n            mp[it]++;\\n        }\\n        \\n        vector<pair<int, int>> v;\\n        for(auto it: mp){\\n            v.push_back({it.second, it.first});\\n        }\\n        \\n        sort(v.begin(), v.end());\\n        reverse(v.begin(), v.end());\\n        \\n        int maxSize = v[0].first;\\n        int temp = 0;\\n        \\n        vector<int> filler;\\n        vector<vector<int>>ans;\\n        for(int i=0; i<v.size(); i++){\\n            temp = 0;\\n            while(v[i].first != 0){\\n                filler.push_back(v[i].second);\\n                v[i].first --;\\n                temp ++;\\n            }\\n            \\n            while(temp < maxSize){\\n                filler.push_back(-1);\\n                temp++;\\n            }\\n            \\n            ans.push_back(filler);\\n            filler.clear();\\n        }\\n        \\n        vector<vector<int>>transpose;   \\n        for(int i=0; i<ans[0].size(); i++){\\n            filler.clear();\\n            for(int j=0; j<ans.size(); j++){\\n                filler.push_back(ans[j][i]);\\n            }\\n            transpose.push_back(filler);         \\n        }\\n        \\n        temp = 2*transpose.size();\\n        while(temp != 0){\\n            for(int i=0; i<transpose.size(); i++){\\n                for(int j=0; j<transpose[i].size(); j++){\\n                    if(transpose[i][j] == -1){\\n                        transpose[i].erase(transpose[i].begin() + j);\\n                    }\\n                }\\n            }\\n            temp --;\\n        }\\n        \\n        \\n                                    \\n        \\n        return transpose;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4002607,
                "title": "2610-convert-an-array-into-a-2d-array-with-conditions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nusing hashmap\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> findMatrix(int[] nums) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        HashMap<Integer, Integer> hm = new HashMap<>(nums.length);\\n        for (int num : nums) {\\n            hm.put(num, hm.getOrDefault(num, 0) + 1);\\n        }\\n\\n        \\n        while (!hm.isEmpty()) {\\n            List<Integer> al = new ArrayList<>();\\n            ArrayList<Integer> keysToRemove = new ArrayList<>();\\n\\n            for (int num : hm.keySet()) {\\n                al.add(num);\\n                hm.put(num, hm.get(num) - 1);\\n                if (hm.get(num) == 0) {\\n                    keysToRemove.add(num);\\n                }\\n            }\\n\\n           \\n            for (int key : keysToRemove) {\\n                hm.remove(key);\\n            }\\n\\n            result.add(al);\\n        }\\n        return result;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> findMatrix(int[] nums) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        HashMap<Integer, Integer> hm = new HashMap<>(nums.length);\\n        for (int num : nums) {\\n            hm.put(num, hm.getOrDefault(num, 0) + 1);\\n        }\\n\\n        \\n        while (!hm.isEmpty()) {\\n            List<Integer> al = new ArrayList<>();\\n            ArrayList<Integer> keysToRemove = new ArrayList<>();\\n\\n            for (int num : hm.keySet()) {\\n                al.add(num);\\n                hm.put(num, hm.get(num) - 1);\\n                if (hm.get(num) == 0) {\\n                    keysToRemove.add(num);\\n                }\\n            }\\n\\n           \\n            for (int key : keysToRemove) {\\n                hm.remove(key);\\n            }\\n\\n            result.add(al);\\n        }\\n        return result;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3997537,
                "title": "c-solutions-for-beginners",
                "content": "# Algorithm\\n1. Create a frequency map from the given elements.\\n2. While the map is not empty, add all the keys of the map into a vector and store it in your answer\\n3. Decrement the frequency by one on doing so\\n4. if frequency becomes 0 after decrementing, then delete the key from the map\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findMatrix(vector<int>& arr) {\\n        int n = arr.size();\\n\\n        unordered_map<int, int> mp;\\n        for(int i = 0; i<n; i++){\\n            mp[arr[i]]++;\\n        }\\n        vector<vector<int>> ans;\\n        vector<int> result;\\n\\n        while(mp.size()){\\n            vector<int>key;\\n            for(auto& it: mp){\\n                result.push_back(it.first);\\n                it.second--;\\n                if(it.second == 0)\\n                    key.push_back(it.first);\\n            }\\n            for(auto k : key){\\n                mp.erase(k);\\n            }\\n            ans.push_back(result);\\n            result.clear();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findMatrix(vector<int>& arr) {\\n        int n = arr.size();\\n\\n        unordered_map<int, int> mp;\\n        for(int i = 0; i<n; i++){\\n            mp[arr[i]]++;\\n        }\\n        vector<vector<int>> ans;\\n        vector<int> result;\\n\\n        while(mp.size()){\\n            vector<int>key;\\n            for(auto& it: mp){\\n                result.push_back(it.first);\\n                it.second--;\\n                if(it.second == 0)\\n                    key.push_back(it.first);\\n            }\\n            for(auto k : key){\\n                mp.erase(k);\\n            }\\n            ans.push_back(result);\\n            result.clear();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3995166,
                "title": "python",
                "content": "# Code\\n```\\nclass Solution:\\n    def findMatrix(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        n = len(nums)\\n        c = 0\\n        nums.sort()\\n        while c < n:\\n            i = 0\\n            l = []\\n            while i < len(nums):\\n                if nums[i] not in l:\\n                    l.append(nums[i])\\n                    nums = nums[:i] + nums[i+1:]\\n                else:\\n                    i += 1\\n            \\n            res.append(l)\\n            c += len(l)\\n    \\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findMatrix(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        n = len(nums)\\n        c = 0\\n        nums.sort()\\n        while c < n:\\n            i = 0\\n            l = []\\n            while i < len(nums):\\n                if nums[i] not in l:\\n                    l.append(nums[i])\\n                    nums = nums[:i] + nums[i+1:]\\n                else:\\n                    i += 1\\n            \\n            res.append(l)\\n            c += len(l)\\n    \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3990002,
                "title": "racket-scheme-hashtable",
                "content": "**Time** :: O(n)\\n\\n```\\n(define/contract (find-matrix nums)\\n  (-> (listof exact-integer?) (listof (listof exact-integer?)))\\n  (define ht \\n    (let gen-hashtable ([ht (make-hash)]\\n                        [nums nums])\\n      (cond\\n        [(empty? nums) ht]\\n        [else\\n          (hash-set! ht (first nums) (+ (hash-ref ht (first nums) 0) 1))\\n          (gen-hashtable ht (rest nums))])))\\n\\n  (let gen-matrix ([ht ht])\\n    (cond\\n      [(hash-empty? ht) \\'()]\\n      [else\\n        (cons (hash-map ht (lambda (k v)\\n                 (hash-set! ht k (- v 1))\\n                 (when (<= (- v 1) 0)\\n                       (hash-remove! ht k))\\n                 k))\\n               (gen-matrix ht))])))\\n```",
                "solutionTags": [
                    "Racket"
                ],
                "code": "```\\n(define/contract (find-matrix nums)\\n  (-> (listof exact-integer?) (listof (listof exact-integer?)))\\n  (define ht \\n    (let gen-hashtable ([ht (make-hash)]\\n                        [nums nums])\\n      (cond\\n        [(empty? nums) ht]\\n        [else\\n          (hash-set! ht (first nums) (+ (hash-ref ht (first nums) 0) 1))\\n          (gen-hashtable ht (rest nums))])))\\n\\n  (let gen-matrix ([ht ht])\\n    (cond\\n      [(hash-empty? ht) \\'()]\\n      [else\\n        (cons (hash-map ht (lambda (k v)\\n                 (hash-set! ht k (- v 1))\\n                 (when (<= (- v 1) 0)\\n                       (hash-remove! ht k))\\n                 k))\\n               (gen-matrix ht))])))\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3988430,
                "title": "o-n-simple-c-solution",
                "content": "# Intuition\\nMaximum number of rows is the maximum frequency of the ekament in the row\\n# Approach\\nrecord frequency of every element in the vector. create a matrix with the number of rows with the maximum frequency. Iterate through the map and insert the element in number of rows as per the frequency \\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n- Space complexity:\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findMatrix(vector<int>& nums) {\\n        unordered_map<int, int> uniqMap;\\n        int idx=0;\\n        int maxArrSize = INT_MIN;\\n        vector<vector<int>> result;\\n        vector<int> output;\\n        while(idx<nums.size())\\n        {\\n            uniqMap[nums[idx]]++;\\n            if (maxArrSize < uniqMap[nums[idx]])\\n            {\\n                maxArrSize = uniqMap[nums[idx]];\\n                // Max number of rows is max frequency\\n                result.push_back(output);\\n            }\\n            idx++;\\n        }\\n        \\n        for (auto itr : uniqMap)\\n        {\\n            int freq = itr.second;\\n            idx=0;\\n            while(idx < freq)\\n            {\\n                result[idx].push_back(itr.first);\\n                idx++;\\n            }   \\n\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findMatrix(vector<int>& nums) {\\n        unordered_map<int, int> uniqMap;\\n        int idx=0;\\n        int maxArrSize = INT_MIN;\\n        vector<vector<int>> result;\\n        vector<int> output;\\n        while(idx<nums.size())\\n        {\\n            uniqMap[nums[idx]]++;\\n            if (maxArrSize < uniqMap[nums[idx]])\\n            {\\n                maxArrSize = uniqMap[nums[idx]];\\n                // Max number of rows is max frequency\\n                result.push_back(output);\\n            }\\n            idx++;\\n        }\\n        \\n        for (auto itr : uniqMap)\\n        {\\n            int freq = itr.second;\\n            idx=0;\\n            while(idx < freq)\\n            {\\n                result[idx].push_back(itr.first);\\n                idx++;\\n            }   \\n\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3986706,
                "title": "python-easy-logic-counter-explained-codeplug",
                "content": "# Intuition\\nFirst we need to identify unique number and fill all possible unique numbers in a row which will consume the amx number of elements in a row. Likewise we can continue with the next set of unique leftout numbers and build consecutive rows.\\n\\n# Approach\\nWe can use a Counter dictionary to keep track of unique keys and their counts. If a number gets used, we reduce its count and when the count becomes 0, we remove the number from the dictionary. This is how we can construct minimum rows with maximum columns.\\n\\n**Hope it helps :)**\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```python []\\nclass Solution:\\n    def findMatrix(self, nums: List[int]) -> List[List[int]]:\\n        counts = Counter(nums)\\n        res = []\\n\\n        while counts:\\n            row = []\\n            remove = []\\n\\n            for num, count in counts.items():\\n                row.append(num)\\n                counts[num] -= 1\\n\\n                if counts[num] == 0: \\n                    remove.append(num)\\n            \\n            for num in remove:\\n                del counts[num]\\n                \\n            res.append(row)\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Hash Table"
                ],
                "code": "```python []\\nclass Solution:\\n    def findMatrix(self, nums: List[int]) -> List[List[int]]:\\n        counts = Counter(nums)\\n        res = []\\n\\n        while counts:\\n            row = []\\n            remove = []\\n\\n            for num, count in counts.items():\\n                row.append(num)\\n                counts[num] -= 1\\n\\n                if counts[num] == 0: \\n                    remove.append(num)\\n            \\n            for num in remove:\\n                del counts[num]\\n                \\n            res.append(row)\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3982089,
                "title": "c-easy-to-understand-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findMatrix(vector<int>& nums) {\\n        unordered_map<int,int> mp;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            mp[nums[i]]++;\\n        }\\n        vector<vector<int>> ans;\\n        while(!mp.empty())\\n        {\\n            vector<int> temp;\\n            for (auto it = mp.begin(); it != mp.end(); ) {\\n    if (it->second >= 1) {\\n        temp.push_back(it->first);\\n        it->second--;\\n\\n        if (it->second == 0) {\\n            it = mp.erase(it);  // Erase the element and get the next iterator\\n        } else {\\n            ++it;  // Move to the next element\\n        }\\n    } else {\\n        ++it;  // Move to the next element\\n    }\\n}\\n\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findMatrix(vector<int>& nums) {\\n        unordered_map<int,int> mp;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            mp[nums[i]]++;\\n        }\\n        vector<vector<int>> ans;\\n        while(!mp.empty())\\n        {\\n            vector<int> temp;\\n            for (auto it = mp.begin(); it != mp.end(); ) {\\n    if (it->second >= 1) {\\n        temp.push_back(it->first);\\n        it->second--;\\n\\n        if (it->second == 0) {\\n            it = mp.erase(it);  // Erase the element and get the next iterator\\n        } else {\\n            ++it;  // Move to the next element\\n        }\\n    } else {\\n        ++it;  // Move to the next element\\n    }\\n}\\n\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3980008,
                "title": "optimal-java-solution-o-n",
                "content": "# Approach\\n1. Form a frequency HashMap\\n2. We know that the end result must have as many rows as the maximum frequency of an element - in order to guarantee that the element isn\\'t repeated across rows\\n3. Find the max frequency, create the ArrayList and add that many rows\\n4. Go through our HashMap and distribute the elements across the rows to ensure no duplication within the same row (necessary condition for solution)\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$ (in the worst case where each element has frequency 1)\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> findMatrix(int[] nums) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for(int n: nums) map.put(n, map.getOrDefault(n, 0) + 1);\\n\\n        int maxFreq = 0;\\n        for (int n: nums) { \\n            maxFreq = Math.max(maxFreq, map.get(n));\\n        }\\n\\n        List<List<Integer>> ans = new ArrayList<>();\\n        while(maxFreq > 0) {\\n            ans.add(new ArrayList<>());\\n            maxFreq--;\\n        }\\n\\n        for(Map.Entry<Integer, Integer> pair: map.entrySet()) {\\n            int elem = pair.getKey();\\n            int freq = pair.getValue();\\n            for(int i = 0; i < freq; i++) {\\n                ans.get(i).add(elem);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> findMatrix(int[] nums) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for(int n: nums) map.put(n, map.getOrDefault(n, 0) + 1);\\n\\n        int maxFreq = 0;\\n        for (int n: nums) { \\n            maxFreq = Math.max(maxFreq, map.get(n));\\n        }\\n\\n        List<List<Integer>> ans = new ArrayList<>();\\n        while(maxFreq > 0) {\\n            ans.add(new ArrayList<>());\\n            maxFreq--;\\n        }\\n\\n        for(Map.Entry<Integer, Integer> pair: map.entrySet()) {\\n            int elem = pair.getKey();\\n            int freq = pair.getValue();\\n            for(int i = 0; i < freq; i++) {\\n                ans.get(i).add(elem);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3976149,
                "title": "java-solution-priority-queue-lambda-function-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> findMatrix(int[] nums) {\\n        //it is used to store count and num \\n        //maxHeap based on count of num\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> (b[0]-a[0]));\\n        int[] cnt = new int[201];\\n        for(int i = 0; i < nums.length; i++){\\n            ++cnt[nums[i]];\\n        }\\n        for(int i = 0; i < 201; i++){\\n            if(cnt[i] > 0)pq.add(new int[]{cnt[i], i});\\n        }\\n        //size of resultant list will be maxCount of peek num in heap\\n        List<List<Integer>> result = new ArrayList<>();\\n        for(int i = 0; i < pq.peek()[0]; i++){\\n            result.add(new ArrayList<>());\\n        }\\n        \\n        while(pq.size() > 0){\\n            int[] arr = pq.poll();\\n            int num = arr[1];\\n            int size = arr[0];\\n            for(int i = 0; i < size; i++){\\n                result.get(i).add(num);\\n            }\\n        }\\n        return result;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> findMatrix(int[] nums) {\\n        //it is used to store count and num \\n        //maxHeap based on count of num\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> (b[0]-a[0]));\\n        int[] cnt = new int[201];\\n        for(int i = 0; i < nums.length; i++){\\n            ++cnt[nums[i]];\\n        }\\n        for(int i = 0; i < 201; i++){\\n            if(cnt[i] > 0)pq.add(new int[]{cnt[i], i});\\n        }\\n        //size of resultant list will be maxCount of peek num in heap\\n        List<List<Integer>> result = new ArrayList<>();\\n        for(int i = 0; i < pq.peek()[0]; i++){\\n            result.add(new ArrayList<>());\\n        }\\n        \\n        while(pq.size() > 0){\\n            int[] arr = pq.poll();\\n            int num = arr[1];\\n            int size = arr[0];\\n            for(int i = 0; i < size; i++){\\n                result.get(i).add(num);\\n            }\\n        }\\n        return result;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3975926,
                "title": "easy-java-solution-with-array-self-descriptive-without-dp-or-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBeginner friendly solution without DP.\\n\\n\\n\\n- Counting the number of frequency of each element\\n- Since the number is small `1 <= nums.length <= 200` and\\n`1 <= nums[i] <= nums.length`, used an integer array and counted frequency.\\n- Using the occurrence array iterate from 1 to max and add the distinct elements to a new list and add to the result.\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> findMatrix(int[] nums) {\\n        \\n        int len = nums.length;\\n        int[] arr = new int[201];\\n        for (int num : nums) {\\n            arr[num]++;\\n        }\\n\\n        List<List<Integer>> result = new ArrayList<>();\\n        for (int i = 0; i < len; i++) {\\n            List<Integer> list = new ArrayList<>();\\n            for (int j = 0; j <= len; j++) {\\n                if (arr[j] != 0) {\\n                    list.add(j);\\n                    arr[j]--;\\n                }\\n            }\\n            if (list.size() > 0) result.add(list);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> findMatrix(int[] nums) {\\n        \\n        int len = nums.length;\\n        int[] arr = new int[201];\\n        for (int num : nums) {\\n            arr[num]++;\\n        }\\n\\n        List<List<Integer>> result = new ArrayList<>();\\n        for (int i = 0; i < len; i++) {\\n            List<Integer> list = new ArrayList<>();\\n            for (int j = 0; j <= len; j++) {\\n                if (arr[j] != 0) {\\n                    list.add(j);\\n                    arr[j]--;\\n                }\\n            }\\n            if (list.size() > 0) result.add(list);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3969162,
                "title": "c-unordered-map-slightly-optimized",
                "content": "# Intuition\\nJust count all numbers and iteratively put into vectors all distinctive numbers, reducing the count.\\n\\n# Approach\\nUse `unordered_map` to count numbers. Iterate until there\\'s at least one number in the map.\\n\\nThe size of the next vector in `result` is the number of distinctive numbers left in the map, so just map size. We can emplace it directly in `result`, to avoid copying/moving it later.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n) where n is number of distinctive numbers in `nums`\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findMatrix(vector<int>& nums) {\\n        unordered_map<int, int> nums_map{};\\n\\n        for (int n : nums) {\\n            nums_map[n]++;\\n        }\\n\\n        vector<vector<int>> result;\\n        while (!nums_map.empty()) {\\n            auto &vec = result.emplace_back(nums_map.size());\\n            int index = 0;\\n            for (auto it = nums_map.begin(); it != nums_map.end();) {\\n                vec[index++] = it->first;\\n                if (it->second == 1) {\\n                    it = nums_map.erase(it);\\n                } else {\\n                    --it->second;\\n                    it++;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findMatrix(vector<int>& nums) {\\n        unordered_map<int, int> nums_map{};\\n\\n        for (int n : nums) {\\n            nums_map[n]++;\\n        }\\n\\n        vector<vector<int>> result;\\n        while (!nums_map.empty()) {\\n            auto &vec = result.emplace_back(nums_map.size());\\n            int index = 0;\\n            for (auto it = nums_map.begin(); it != nums_map.end();) {\\n                vec[index++] = it->first;\\n                if (it->second == 1) {\\n                    it = nums_map.erase(it);\\n                } else {\\n                    --it->second;\\n                    it++;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3965369,
                "title": "rust-sorting-binary-search",
                "content": "# Intuition\\n\\nCount each distinct elements in the array!!\\n\\n# Approach\\n\\nRemove each row from the array greedily.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n \\\\log n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\npub fn to_map<T: std::cmp::Ord>(mut vec: Vec<T>) -> Vec<(usize, T)> {\\n    vec.sort_unstable();\\n    vec.reverse();\\n\\n    let mut ret = vec![];\\n\\n    while let Some(e) = vec.pop() {\\n        let ptr = vec.partition_point(|e0| e0 > &e);\\n        let count = vec.len() + 1 - ptr;\\n\\n        vec.truncate(ptr);\\n\\n        ret.push((count, e));\\n    }\\n\\n    ret\\n}\\n\\nimpl Solution {\\n    pub fn find_matrix(vec: Vec<i32>) -> Vec<Vec<i32>> {\\n        let mut count_vec = to_map(vec);\\n        count_vec.sort_unstable();\\n\\n        let mut ret = vec![];\\n\\n        let mut ptr = usize::MIN;\\n        let mut water_table = usize::MIN;\\n        while ptr < count_vec.len() {\\n            let _ret = count_vec.iter()\\n                .skip(ptr)\\n                .map(|&(_, e)| e as i32)\\n                .collect::<Vec<_>>();\\n            ret.push(_ret);\\n\\n            water_table += 1;\\n            ptr = count_vec.partition_point(\\n                |&(_count, _)| _count <= water_table,\\n            );\\n        }\\n\\n        ret\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Binary Search",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\npub fn to_map<T: std::cmp::Ord>(mut vec: Vec<T>) -> Vec<(usize, T)> {\\n    vec.sort_unstable();\\n    vec.reverse();\\n\\n    let mut ret = vec![];\\n\\n    while let Some(e) = vec.pop() {\\n        let ptr = vec.partition_point(|e0| e0 > &e);\\n        let count = vec.len() + 1 - ptr;\\n\\n        vec.truncate(ptr);\\n\\n        ret.push((count, e));\\n    }\\n\\n    ret\\n}\\n\\nimpl Solution {\\n    pub fn find_matrix(vec: Vec<i32>) -> Vec<Vec<i32>> {\\n        let mut count_vec = to_map(vec);\\n        count_vec.sort_unstable();\\n\\n        let mut ret = vec![];\\n\\n        let mut ptr = usize::MIN;\\n        let mut water_table = usize::MIN;\\n        while ptr < count_vec.len() {\\n            let _ret = count_vec.iter()\\n                .skip(ptr)\\n                .map(|&(_, e)| e as i32)\\n                .collect::<Vec<_>>();\\n            ret.push(_ret);\\n\\n            water_table += 1;\\n            ptr = count_vec.partition_point(\\n                |&(_count, _)| _count <= water_table,\\n            );\\n        }\\n\\n        ret\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3957553,
                "title": "easy-understandable",
                "content": "\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findMatrix(vector<int>& nums) {\\n        unordered_map<int, int>mapping;\\n        int max = 0;\\n        for(auto i : nums){\\n            mapping[i]++;\\n            if(mapping[i]>max)max=mapping[i];\\n        }\\n        vector<vector<int>>result;\\n        int point = 1;\\n        for(int i = 0; i < max; i++){\\n            vector<int>temp;\\n            for(auto j : mapping){\\n                if(j.second >= point){\\n                    temp.push_back(j.first);\\n                }\\n            }\\n            point++;\\n            result.push_back(temp);\\n        }\\n        return result;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findMatrix(vector<int>& nums) {\\n        unordered_map<int, int>mapping;\\n        int max = 0;\\n        for(auto i : nums){\\n            mapping[i]++;\\n            if(mapping[i]>max)max=mapping[i];\\n        }\\n        vector<vector<int>>result;\\n        int point = 1;\\n        for(int i = 0; i < max; i++){\\n            vector<int>temp;\\n            for(auto j : mapping){\\n                if(j.second >= point){\\n                    temp.push_back(j.first);\\n                }\\n            }\\n            point++;\\n            result.push_back(temp);\\n        }\\n        return result;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3956337,
                "title": "python-easy-code-light",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findMatrix(self, nums: List[int]) -> List[List[int]]:\\n        l = []\\n        while True:\\n            st = set(nums)\\n            l.append(list(st))\\n            for i in st:\\n                nums.remove(i)\\n            if len(nums)==0:\\n                return l\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findMatrix(self, nums: List[int]) -> List[List[int]]:\\n        l = []\\n        while True:\\n            st = set(nums)\\n            l.append(list(st))\\n            for i in st:\\n                nums.remove(i)\\n            if len(nums)==0:\\n                return l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3955120,
                "title": "simple-java-solution-using-hashmap-o-n-complexity",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$ \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$ \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> findMatrix(int[] nums) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        Map<Integer,Integer> map = new HashMap<>();\\n        for(int x:nums){\\n            map.put(x,map.getOrDefault(x,0)+1);\\n            int idx = map.get(x);\\n            if(res.size()<idx){\\n                res.add(new ArrayList<>());\\n            }\\n            res.get(idx-1).add(x);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> findMatrix(int[] nums) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        Map<Integer,Integer> map = new HashMap<>();\\n        for(int x:nums){\\n            map.put(x,map.getOrDefault(x,0)+1);\\n            int idx = map.get(x);\\n            if(res.size()<idx){\\n                res.add(new ArrayList<>());\\n            }\\n            res.get(idx-1).add(x);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3953024,
                "title": "easy-intuitive-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> findMatrix(int[] nums) {\\n        List<List<Integer>> l=new ArrayList<>();\\n        int x=0;\\n        l.add(new ArrayList<>());\\n        \\n        for(int i:nums){\\n             x=0;\\n            if(!l.get(x).contains(i)){\\n                l.get(x).add(i);\\n            }\\n            else{\\n                while(x<l.size() && l.get(x).contains(i)){\\n                    x++;\\n                }\\n                if(x>=l.size()){\\n                    l.add(new ArrayList<>());\\n                }\\n                l.get(x).add(i);\\n            }\\n        }\\n        return l;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> findMatrix(int[] nums) {\\n        List<List<Integer>> l=new ArrayList<>();\\n        int x=0;\\n        l.add(new ArrayList<>());\\n        \\n        for(int i:nums){\\n             x=0;\\n            if(!l.get(x).contains(i)){\\n                l.get(x).add(i);\\n            }\\n            else{\\n                while(x<l.size() && l.get(x).contains(i)){\\n                    x++;\\n                }\\n                if(x>=l.size()){\\n                    l.add(new ArrayList<>());\\n                }\\n                l.get(x).add(i);\\n            }\\n        }\\n        return l;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3951904,
                "title": "python-easy-clean-solution",
                "content": "# Complexity\\n- Time complexity: O(n\\u02C62)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findMatrix(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        cnt = Counter(nums)\\n        for i, v in cnt.items():\\n            for j in range(v):\\n                if len(res) > j:\\n                    res[j].append(i)\\n                else:\\n                    res.append([i])\\n        return res\\n```\\n![catty.png](https://assets.leetcode.com/users/images/d9f0a58a-d47b-458f-9dd4-b28dc45b7a1c_1692825323.6315196.png)\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findMatrix(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        cnt = Counter(nums)\\n        for i, v in cnt.items():\\n            for j in range(v):\\n                if len(res) > j:\\n                    res[j].append(i)\\n                else:\\n                    res.append([i])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3944732,
                "title": "swift-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    func findMatrix(_ nums: [Int]) -> [[Int]] {\\n            var current = nums\\n    var matrix: [[Int]] = [[current.removeFirst()]]\\n    \\n    while current.count > 0 {\\n        let value = current.removeFirst()\\n        var isAdded = false\\n        for i in 0..<matrix.count {\\n            if !matrix[i].contains(where: {value == $0}) {\\n                matrix[i].append(value)\\n                isAdded = true\\n                break\\n            }\\n        }\\n        \\n        if isAdded == false {\\n            matrix.append([value])\\n        }\\n        \\n    }\\n    return matrix\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func findMatrix(_ nums: [Int]) -> [[Int]] {\\n            var current = nums\\n    var matrix: [[Int]] = [[current.removeFirst()]]\\n    \\n    while current.count > 0 {\\n        let value = current.removeFirst()\\n        var isAdded = false\\n        for i in 0..<matrix.count {\\n            if !matrix[i].contains(where: {value == $0}) {\\n                matrix[i].append(value)\\n                isAdded = true\\n                break\\n            }\\n        }\\n        \\n        if isAdded == false {\\n            matrix.append([value])\\n        }\\n        \\n    }\\n    return matrix\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3944189,
                "title": "96-beats-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ncreate an vector array of  size(nums.size + 1) because given that elements nums can\\'t greater than nums.size+1.now store the count of each number in this array.Than traverse this array push the elements of array single time in a vector and decrement the count in the array when you complete one traversal of vector than push this vector in ans and repeat while count is less than nums.size()\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findMatrix(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        vector<int> tmp;\\n        vector<int> arr(nums.size()+1,0);\\n        for(auto i:nums){\\n            arr[i]++;\\n        }\\n        int count=0;\\n        while(count<nums.size()){\\n        for(int i=0;i<arr.size();i++){\\n            if(arr[i]>0){\\n                arr[i]--;\\n                tmp.push_back(i);\\n                count++;\\n            }\\n        }\\n        ans.push_back(tmp);\\n        tmp.clear();\\n        }\\n        \\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findMatrix(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        vector<int> tmp;\\n        vector<int> arr(nums.size()+1,0);\\n        for(auto i:nums){\\n            arr[i]++;\\n        }\\n        int count=0;\\n        while(count<nums.size()){\\n        for(int i=0;i<arr.size();i++){\\n            if(arr[i]>0){\\n                arr[i]--;\\n                tmp.push_back(i);\\n                count++;\\n            }\\n        }\\n        ans.push_back(tmp);\\n        tmp.clear();\\n        }\\n        \\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3944173,
                "title": "beats-81-28-of-users-with-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe code appears to tackle an array processing task by sorting the input array and then organizing the numbers into a matrix based on their frequencies. The initial insight suggests that the code creates a frequency map, converts it to a sorted array, and finally constructs a matrix with repeated numbers.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- The input array nums is sorted.\\n- Using a hashMap, the code tracks the frequency of numbers.\\n- The hashMap is transformed into a sorted array mapToArray.\\n- The final matrix res is initialized.\\n- The code iterates through mapToArray, adding numbers to res based on frequency.\\n\\n# Complexity\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Time complexity: $$O(n log n)$$ Dominated by sorting the mapToArray array, taking O(n log n), where n is distinct element count. Other loops contribute too.\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n- Space complexity: $$O(n)$$ Dictated by storage for hashMap and mapToArray, both O(n) due to distinct elements. res matrix size also counts but is limited by input.\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\nvar findMatrix = function (nums) {\\n  let sortedArr = nums.sort();\\n\\n  let hashMap = new Map();\\n  nums.forEach((num) => {\\n    if (hashMap.has(num)) {\\n      hashMap.set(num, hashMap.get(num) + 1);\\n    } else {\\n      hashMap.set(num, 1);\\n    }\\n  });\\n\\n  let mapToArray = Array.from(hashMap);\\n  mapToArray.sort((a, b) => b[1] - a[1]);\\n\\n  let res = [];\\n  for (let i = 0; i < mapToArray.length; i++) {\\n    for (let j = 0; j < mapToArray[i][1]; j++) {\\n      if (i === 0) res.push([mapToArray[i][0]]);\\n      else res[j].push(mapToArray[i][0]);\\n    }\\n  }\\n\\n  return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Hash Table",
                    "Sorting"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\nvar findMatrix = function (nums) {\\n  let sortedArr = nums.sort();\\n\\n  let hashMap = new Map();\\n  nums.forEach((num) => {\\n    if (hashMap.has(num)) {\\n      hashMap.set(num, hashMap.get(num) + 1);\\n    } else {\\n      hashMap.set(num, 1);\\n    }\\n  });\\n\\n  let mapToArray = Array.from(hashMap);\\n  mapToArray.sort((a, b) => b[1] - a[1]);\\n\\n  let res = [];\\n  for (let i = 0; i < mapToArray.length; i++) {\\n    for (let j = 0; j < mapToArray[i][1]; j++) {\\n      if (i === 0) res.push([mapToArray[i][0]]);\\n      else res[j].push(mapToArray[i][0]);\\n    }\\n  }\\n\\n  return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3938013,
                "title": "easiest-java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> findMatrix(int[] nums) {\\n        \\n\\n        int[] count = new int[nums.length];\\n\\n        for(int i = 0; i<nums.length ; i++){\\n            count[nums[i]-1]++; //Counting the occurence of each element\\n        }\\n\\n        int ind = 0; // to track number of elements already covered\\n        List<List<Integer>> result = new ArrayList<>(); //Resultant ArrayList\\n\\n\\n// now understand\\n        while(ind<nums.length){ // to track all the elements are covered\\n            List<Integer> temp = new ArrayList<>();\\n            for(int i = 0; i<nums.length ; i++){\\n                if(count[i]>0){\\n                temp.add(i+1);\\n                count[i]--; \\n                ind++;\\n                } \\n            }\\n            result.add(temp);   \\n        }\\n        \\n\\n        return result;\\n\\n\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> findMatrix(int[] nums) {\\n        \\n\\n        int[] count = new int[nums.length];\\n\\n        for(int i = 0; i<nums.length ; i++){\\n            count[nums[i]-1]++; //Counting the occurence of each element\\n        }\\n\\n        int ind = 0; // to track number of elements already covered\\n        List<List<Integer>> result = new ArrayList<>(); //Resultant ArrayList\\n\\n\\n// now understand\\n        while(ind<nums.length){ // to track all the elements are covered\\n            List<Integer> temp = new ArrayList<>();\\n            for(int i = 0; i<nums.length ; i++){\\n                if(count[i]>0){\\n                temp.add(i+1);\\n                count[i]--; \\n                ind++;\\n                } \\n            }\\n            result.add(temp);   \\n        }\\n        \\n\\n        return result;\\n\\n\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3937882,
                "title": "java-array-frequencies-count-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> findMatrix(int[] nums) {\\n        int[] frequencies = new int[201];\\n        int max = 0;\\n        List<List<Integer>> list = new ArrayList<List<Integer>>();\\n        for (int num: nums){\\n            frequencies[num] += 1;\\n            max = Math.max(max,frequencies[num]);\\n        }\\n        for (int i = 0; i < max; i++) list.add(new ArrayList<Integer>());\\n        int[] next = getMax(frequencies);\\n        while(next[0] != 0 && next[1] != 0){\\n            for (int i = 0; i < next[1]; i++){\\n                list.get(i).add(next[0]);\\n            }\\n            next = getMax(frequencies);\\n        }\\n        return list;\\n    }\\n\\n    public int[] getMax(int[] frequencies){\\n        int max = 0;\\n        int starting = 0;\\n        for (int i = 0; i < frequencies.length; i++){\\n            if (frequencies[i] > max){\\n                max = frequencies[i];\\n                starting = i;\\n            }\\n        }\\n        frequencies[starting] = 0;\\n        return new int[]{starting,max};\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> findMatrix(int[] nums) {\\n        int[] frequencies = new int[201];\\n        int max = 0;\\n        List<List<Integer>> list = new ArrayList<List<Integer>>();\\n        for (int num: nums){\\n            frequencies[num] += 1;\\n            max = Math.max(max,frequencies[num]);\\n        }\\n        for (int i = 0; i < max; i++) list.add(new ArrayList<Integer>());\\n        int[] next = getMax(frequencies);\\n        while(next[0] != 0 && next[1] != 0){\\n            for (int i = 0; i < next[1]; i++){\\n                list.get(i).add(next[0]);\\n            }\\n            next = getMax(frequencies);\\n        }\\n        return list;\\n    }\\n\\n    public int[] getMax(int[] frequencies){\\n        int max = 0;\\n        int starting = 0;\\n        for (int i = 0; i < frequencies.length; i++){\\n            if (frequencies[i] > max){\\n                max = frequencies[i];\\n                starting = i;\\n            }\\n        }\\n        frequencies[starting] = 0;\\n        return new int[]{starting,max};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3937544,
                "title": "your-opinions-please",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nHashMap\\n\\n# Complexity\\n- Time complexity:\\n $$O(n)$$\\n\\n\\n\\n# Code\\n```\\nvar findMatrix = function(nums) {\\n    \\n    const freq = new Map();\\n    var res = [];\\n    nums.sort((a,b)=>a-b);\\n\\n\\n\\n   var count=0;\\n   var curr=nums[0];\\n    for (let i = 0; i < nums.length; i++) \\n    {\\n        if(curr === nums[i])\\n        {\\n            count++;\\n            if(freq.has(count))\\n            {\\n                freq.get(count).push(nums[i]);\\n            }else\\n            {\\n                var newlist = [];\\n                freq.set(count,newlist)\\n                newlist.push(nums[i]);\\n                res.push(newlist);\\n            }\\n        }else\\n        {\\n            curr = nums[i];\\n                count = 1;\\n                freq.get(count).push(nums[i]);\\n        }        \\n    }\\n    \\nreturn res;\\n\\n\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar findMatrix = function(nums) {\\n    \\n    const freq = new Map();\\n    var res = [];\\n    nums.sort((a,b)=>a-b);\\n\\n\\n\\n   var count=0;\\n   var curr=nums[0];\\n    for (let i = 0; i < nums.length; i++) \\n    {\\n        if(curr === nums[i])\\n        {\\n            count++;\\n            if(freq.has(count))\\n            {\\n                freq.get(count).push(nums[i]);\\n            }else\\n            {\\n                var newlist = [];\\n                freq.set(count,newlist)\\n                newlist.push(nums[i]);\\n                res.push(newlist);\\n            }\\n        }else\\n        {\\n            curr = nums[i];\\n                count = 1;\\n                freq.get(count).push(nums[i]);\\n        }        \\n    }\\n    \\nreturn res;\\n\\n\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3937184,
                "title": "python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def findMatrix(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        x = []\\n        while nums:\\n            y = list(set(nums))\\n            x.append(y)\\n            for i in y:\\n                nums.remove(i)\\n        return x\\n            \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def findMatrix(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        x = []\\n        while nums:\\n            y = list(set(nums))\\n            x.append(y)\\n            for i in y:\\n                nums.remove(i)\\n        return x\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3930841,
                "title": "python-3-99-simply-solution",
                "content": "# Intuition\\nFor each number in nums, we check if there is a row in the current output matrix that does not contain it. \\nThe first row we find that does not contain the number, we add the number to. If no such row is found in the current output matrix, we update the output matrix by appending a new row to it containing the number of consideration.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def findMatrix(self, nums: List[int]) -> List[List[int]]:\\n        result = []\\n        for num in nums:\\n            added = False\\n            for row in result:\\n                if num not in row:\\n                    row.append(num)\\n                    added = True\\n                    break\\n            if not added:\\n                result.append([num])\\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findMatrix(self, nums: List[int]) -> List[List[int]]:\\n        result = []\\n        for num in nums:\\n            added = False\\n            for row in result:\\n                if num not in row:\\n                    row.append(num)\\n                    added = True\\n                    break\\n            if not added:\\n                result.append([num])\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3927757,
                "title": "c-easy-to-understand-map-o-n-solution",
                "content": "# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findMatrix(vector<int>& nums) {\\n        unordered_map<int,int>m;\\n        int freq=0;\\n        for(auto num:nums){\\n            m[num]++;\\n            if(m[num]>freq) freq=m[num];\\n        }\\n        vector<vector<int>>ans(freq);\\n        for(auto it=m.begin(); it!=m.end(); it++){\\n            int a=it->first;\\n            int b=it->second,i=0;\\n            while(b--){\\n                ans[i].push_back(a); \\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findMatrix(vector<int>& nums) {\\n        unordered_map<int,int>m;\\n        int freq=0;\\n        for(auto num:nums){\\n            m[num]++;\\n            if(m[num]>freq) freq=m[num];\\n        }\\n        vector<vector<int>>ans(freq);\\n        for(auto it=m.begin(); it!=m.end(); it++){\\n            int a=it->first;\\n            int b=it->second,i=0;\\n            while(b--){\\n                ans[i].push_back(a); \\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3927091,
                "title": "nice-and-elegant-solution-in-java-beats-100-rt-and-98-memory",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> findMatrix(int[] nums) {\\n        int[] freq = new int[201];\\n        int maxOcc = Integer.MIN_VALUE;\\n        int l = 0;\\n        int max = Integer.MIN_VALUE;\\n        int min = Integer.MAX_VALUE;\\n        for (int i : nums) {\\n            freq[i]++;\\n            maxOcc = Math.max(maxOcc, freq[i]);\\n            l = freq[i] == 1 ? ++l : l;\\n            max = Math.max(max, i);\\n            min = Math.min(min, i);\\n        }\\n        List<List<Integer>> output = new ArrayList<>();\\n        for (int i = 0; i < maxOcc; i++) {\\n            List<Integer> row = new ArrayList<>();\\n            int j = min;\\n            while (j <= max) {\\n                if (!row.contains(j) && freq[j] > 0) {\\n                    row.add(j);\\n                    freq[j++]--;\\n                } else {\\n                    j++;\\n                }\\n            }\\n            output.add(row);\\n        }\\n        return output;        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> findMatrix(int[] nums) {\\n        int[] freq = new int[201];\\n        int maxOcc = Integer.MIN_VALUE;\\n        int l = 0;\\n        int max = Integer.MIN_VALUE;\\n        int min = Integer.MAX_VALUE;\\n        for (int i : nums) {\\n            freq[i]++;\\n            maxOcc = Math.max(maxOcc, freq[i]);\\n            l = freq[i] == 1 ? ++l : l;\\n            max = Math.max(max, i);\\n            min = Math.min(min, i);\\n        }\\n        List<List<Integer>> output = new ArrayList<>();\\n        for (int i = 0; i < maxOcc; i++) {\\n            List<Integer> row = new ArrayList<>();\\n            int j = min;\\n            while (j <= max) {\\n                if (!row.contains(j) && freq[j] > 0) {\\n                    row.add(j);\\n                    freq[j++]--;\\n                } else {\\n                    j++;\\n                }\\n            }\\n            output.add(row);\\n        }\\n        return output;        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3925874,
                "title": "easy-solution-in-c",
                "content": "# Intuition\\n\\n\\n# Approach\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findMatrix(vector<int>& nums) {\\n        vector<vector<int>>ans;\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]++;\\n        }\\n        while(!mp.empty()){\\n            vector<int> v;\\n        for (auto const& p : mp) {\\n            v.push_back(p.first);\\n        }\\n        for (int num : v) {\\n            mp[num]--;\\n            if (mp[num] == 0) {\\n                mp.erase(num);\\n            }\\n        }\\n         ans.push_back(v);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findMatrix(vector<int>& nums) {\\n        vector<vector<int>>ans;\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]++;\\n        }\\n        while(!mp.empty()){\\n            vector<int> v;\\n        for (auto const& p : mp) {\\n            v.push_back(p.first);\\n        }\\n        for (int num : v) {\\n            mp[num]--;\\n            if (mp[num] == 0) {\\n                mp.erase(num);\\n            }\\n        }\\n         ans.push_back(v);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3922388,
                "title": "easy-java-solution-using-hash-map-as-utility-data-structure",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> findMatrix(int[] nums) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n\\n        HashMap<Integer, Integer> hashMap = new HashMap<>();\\n\\n        for (Integer x:\\n             nums) {\\n            hashMap.put(x,hashMap.getOrDefault(x,0)+1);\\n        }\\n\\n        boolean flag = true;\\n\\n        while (flag){\\n            flag = false;\\n            List<Integer> temp = new ArrayList<>();\\n            for (Integer key:\\n                 hashMap.keySet()) {\\n                int instances = hashMap.get(key);\\n\\n                if (instances > 0){\\n                    temp.add(key);\\n                    hashMap.put(key,instances-1);\\n                    flag = true;\\n                }\\n            }\\n            if (temp.size() > 0){\\n                ans.add(temp);   \\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> findMatrix(int[] nums) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n\\n        HashMap<Integer, Integer> hashMap = new HashMap<>();\\n\\n        for (Integer x:\\n             nums) {\\n            hashMap.put(x,hashMap.getOrDefault(x,0)+1);\\n        }\\n\\n        boolean flag = true;\\n\\n        while (flag){\\n            flag = false;\\n            List<Integer> temp = new ArrayList<>();\\n            for (Integer key:\\n                 hashMap.keySet()) {\\n                int instances = hashMap.get(key);\\n\\n                if (instances > 0){\\n                    temp.add(key);\\n                    hashMap.put(key,instances-1);\\n                    flag = true;\\n                }\\n            }\\n            if (temp.size() > 0){\\n                ans.add(temp);   \\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3918712,
                "title": "c-solution-using-count-faster-than-100",
                "content": "# Complexity\\n- Time complexity: O(n^2) in worst case when all elements are equal\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findMatrix(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<vector<int>> ans;\\n        vector<int> count(n+1,0); //1-based indexing\\n\\n        for(int i:nums)\\n            count[i]++;\\n        \\n        \\n        bool allclear;\\n        while(1)\\n        {\\n            allclear=true;\\n            nums.clear();\\n            for(int i=0;i<n+1;i++)\\n            {\\n                \\n                if(count[i]>0)\\n                {\\n                    nums.push_back(i);\\n                    count[i]--;\\n                    allclear=false;\\n                }\\n            }\\n            if(allclear)\\n                break;\\n            ans.push_back(nums);\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findMatrix(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<vector<int>> ans;\\n        vector<int> count(n+1,0); //1-based indexing\\n\\n        for(int i:nums)\\n            count[i]++;\\n        \\n        \\n        bool allclear;\\n        while(1)\\n        {\\n            allclear=true;\\n            nums.clear();\\n            for(int i=0;i<n+1;i++)\\n            {\\n                \\n                if(count[i]>0)\\n                {\\n                    nums.push_back(i);\\n                    count[i]--;\\n                    allclear=false;\\n                }\\n            }\\n            if(allclear)\\n                break;\\n            ans.push_back(nums);\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3917878,
                "title": "c-hashmap",
                "content": "\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findMatrix(vector<int>& nums) {\\n        int maxFreq=0;\\n        unordered_map<int,int> freq;\\n        for(auto data: nums) {\\n            freq[data]++;\\n            maxFreq=max(maxFreq,freq[data]);\\n        }\\n\\n        vector<vector<int>> ans;\\n\\n        bool allFreqZero=false;\\n\\n        while(true) {\\n            vector<int> temp;\\n            int zeroFreqCount=0;\\n            for(auto it=freq.begin();it!=freq.end();it++) {\\n                if(it->second==0) {\\n                    zeroFreqCount++;\\n                } else {\\n                    temp.push_back(it->first);\\n                    it->second--;\\n                }\\n            }\\n            if(zeroFreqCount==freq.size())\\n                break;\\n            ans.push_back(temp);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findMatrix(vector<int>& nums) {\\n        int maxFreq=0;\\n        unordered_map<int,int> freq;\\n        for(auto data: nums) {\\n            freq[data]++;\\n            maxFreq=max(maxFreq,freq[data]);\\n        }\\n\\n        vector<vector<int>> ans;\\n\\n        bool allFreqZero=false;\\n\\n        while(true) {\\n            vector<int> temp;\\n            int zeroFreqCount=0;\\n            for(auto it=freq.begin();it!=freq.end();it++) {\\n                if(it->second==0) {\\n                    zeroFreqCount++;\\n                } else {\\n                    temp.push_back(it->first);\\n                    it->second--;\\n                }\\n            }\\n            if(zeroFreqCount==freq.size())\\n                break;\\n            ans.push_back(temp);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3916110,
                "title": "java-5ms-beats-40-61",
                "content": "\\n\\n# Code\\n```\\nimport java.util.SortedMap;\\n\\nclass Solution {\\n    public List<List<Integer>> findMatrix(int[] nums) {\\n\\n        // count frequency of each element in `nums`\\n        int[] numberFrequencies = new int[201];\\n        for (int n : nums) {\\n            ++numberFrequencies[n];\\n        }\\n\\n        // count the number of `nums` elements for each frequency\\n        SortedMap<Integer, LinkedList<Integer>> frequenciesToNumbers = new TreeMap<>(Comparator.reverseOrder());\\n        for (int i = 0; i < numberFrequencies.length; ++i) {\\n            if (numberFrequencies[i] == 0) {\\n                continue;\\n            }\\n            if (!frequenciesToNumbers.containsKey(numberFrequencies[i])) {\\n                frequenciesToNumbers.put(numberFrequencies[i], new LinkedList<Integer>());\\n            }\\n            frequenciesToNumbers.get(numberFrequencies[i]).add(i);\\n        }\\n\\n        List<List<Integer>> res = new LinkedList<>();  // what we\\'ll return\\n        int idxIntoRes = 0;  // we use this to access the previous list in `res`\\n\\n        int prevFrequency = -1;\\n\\n        for (var me : frequenciesToNumbers.entrySet()) {\\n            \\n            List<Integer> newList = new LinkedList<>();\\n\\n            if (idxIntoRes > 0) {  // if this isn\\'t our first row...\\n                // if the previous frequency is more than 1 greater than the current frequency, insert duplicate rows\\n                int frequencyDiff = prevFrequency - me.getKey();\\n                while (frequencyDiff > 1) {\\n                    res.add(new LinkedList<>(res.get(idxIntoRes++ - 1)));\\n                    --frequencyDiff;\\n                }\\n\\n                // copy prev row values into the current row\\n                for (int k = 0; k < res.get(idxIntoRes - 1).size(); ++k) {\\n                    newList.add(res.get(idxIntoRes - 1).get(k));\\n                }\\n            }\\n\\n            // now add the new values to the current row\\n            for (int m = 0; m < me.getValue().size(); ++m) {\\n                newList.add(me.getValue().get(m));\\n            }\\n\\n            // then add curRow to res\\n            res.add(newList);\\n\\n            ++idxIntoRes;\\n            prevFrequency = me.getKey();\\n        }\\n        \\n        while (prevFrequency-- > 1) {\\n            res.add(new LinkedList<>(res.get(res.size() - 1)));\\n        }\\n\\n        return res;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.SortedMap;\\n\\nclass Solution {\\n    public List<List<Integer>> findMatrix(int[] nums) {\\n\\n        // count frequency of each element in `nums`\\n        int[] numberFrequencies = new int[201];\\n        for (int n : nums) {\\n            ++numberFrequencies[n];\\n        }\\n\\n        // count the number of `nums` elements for each frequency\\n        SortedMap<Integer, LinkedList<Integer>> frequenciesToNumbers = new TreeMap<>(Comparator.reverseOrder());\\n        for (int i = 0; i < numberFrequencies.length; ++i) {\\n            if (numberFrequencies[i] == 0) {\\n                continue;\\n            }\\n            if (!frequenciesToNumbers.containsKey(numberFrequencies[i])) {\\n                frequenciesToNumbers.put(numberFrequencies[i], new LinkedList<Integer>());\\n            }\\n            frequenciesToNumbers.get(numberFrequencies[i]).add(i);\\n        }\\n\\n        List<List<Integer>> res = new LinkedList<>();  // what we\\'ll return\\n        int idxIntoRes = 0;  // we use this to access the previous list in `res`\\n\\n        int prevFrequency = -1;\\n\\n        for (var me : frequenciesToNumbers.entrySet()) {\\n            \\n            List<Integer> newList = new LinkedList<>();\\n\\n            if (idxIntoRes > 0) {  // if this isn\\'t our first row...\\n                // if the previous frequency is more than 1 greater than the current frequency, insert duplicate rows\\n                int frequencyDiff = prevFrequency - me.getKey();\\n                while (frequencyDiff > 1) {\\n                    res.add(new LinkedList<>(res.get(idxIntoRes++ - 1)));\\n                    --frequencyDiff;\\n                }\\n\\n                // copy prev row values into the current row\\n                for (int k = 0; k < res.get(idxIntoRes - 1).size(); ++k) {\\n                    newList.add(res.get(idxIntoRes - 1).get(k));\\n                }\\n            }\\n\\n            // now add the new values to the current row\\n            for (int m = 0; m < me.getValue().size(); ++m) {\\n                newList.add(me.getValue().get(m));\\n            }\\n\\n            // then add curRow to res\\n            res.add(newList);\\n\\n            ++idxIntoRes;\\n            prevFrequency = me.getKey();\\n        }\\n        \\n        while (prevFrequency-- > 1) {\\n            res.add(new LinkedList<>(res.get(res.size() - 1)));\\n        }\\n\\n        return res;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3906245,
                "title": "c-map",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findMatrix(vector<int>& nums) {\\n        \\n        map<int,int> m;\\n           \\n            for(auto i : nums){\\n               m[i]++;\\n            }\\n\\n        vector<vector<int>> ans;\\n        bool flag = true;\\n\\n\\n        while(flag){\\n     \\n            vector<int> temp;\\n            flag = false;\\n\\n            for (auto const& [key, val] : m){\\n            \\n                if(val != 0){\\n                    temp.push_back(key);\\n                    m[key]--;\\n                }\\n            \\n                if(val > 0){\\n                    flag = true;\\n                }\\n\\n            }\\n\\n        ans.push_back(temp);\\n\\n        }\\n\\n            return ans;\\n      \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findMatrix(vector<int>& nums) {\\n        \\n        map<int,int> m;\\n           \\n            for(auto i : nums){\\n               m[i]++;\\n            }\\n\\n        vector<vector<int>> ans;\\n        bool flag = true;\\n\\n\\n        while(flag){\\n     \\n            vector<int> temp;\\n            flag = false;\\n\\n            for (auto const& [key, val] : m){\\n            \\n                if(val != 0){\\n                    temp.push_back(key);\\n                    m[key]--;\\n                }\\n            \\n                if(val > 0){\\n                    flag = true;\\n                }\\n\\n            }\\n\\n        ans.push_back(temp);\\n\\n        }\\n\\n            return ans;\\n      \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3901401,
                "title": "simple-python3-solution-o-n-time-and-space-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo create a minimal 2D array, we can group the numbers that occur at least once, twice, three times, etc. in their own arrays.\\n\\nUse two hash maps. \\n- One keeps track of the number of occurrences of each item in nums.\\n- the other keeps track of a list of numbers who have been seen at least as many times as the key.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findMatrix(self, nums: List[int]) -> List[List[int]]:\\n        count = {}\\n        freq = {}\\n        for n in nums:\\n            count[n] = count.get(n, 0) + 1\\n            if count[n] in freq:\\n                freq[count[n]].append(n)\\n            else:\\n                freq[count[n]] = [n]\\n        \\n        return freq.values()   \\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def findMatrix(self, nums: List[int]) -> List[List[int]]:\\n        count = {}\\n        freq = {}\\n        for n in nums:\\n            count[n] = count.get(n, 0) + 1\\n            if count[n] in freq:\\n                freq[count[n]].append(n)\\n            else:\\n                freq[count[n]] = [n]\\n        \\n        return freq.values()   \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3900534,
                "title": "c-linq",
                "content": "```\\npublic class Solution {\\n  public IList<IList<int>> FindMatrix(int[] nums) {\\n    var group = nums\\n            .GroupBy(x => x)\\n            .Select(x => new{num = x.Key, count = x.Count()});\\n    return (new List<int>[group.Max(x => x.count)])\\n            .Select((_, i) => new List<int>(group.Where(p => p.count > i).Select(p => p.num)))\\n            .ToArray();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n  public IList<IList<int>> FindMatrix(int[] nums) {\\n    var group = nums\\n            .GroupBy(x => x)\\n            .Select(x => new{num = x.Key, count = x.Count()});\\n    return (new List<int>[group.Max(x => x.count)])\\n            .Select((_, i) => new List<int>(group.Where(p => p.count > i).Select(p => p.num)))\\n            .ToArray();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3898320,
                "title": "beats-92-48-in-python-simple-solution-in-python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findMatrix(self, nums: List[int]) -> List[List[int]]:\\n        O=[]\\n        while len(nums)>0:\\n            li=[]\\n            li=list(set(nums))\\n            for i in li:\\n                nums.remove(i)\\n            O.append(li)\\n        return O\\n```",
                "solutionTags": [
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def findMatrix(self, nums: List[int]) -> List[List[int]]:\\n        O=[]\\n        while len(nums)>0:\\n            li=[]\\n            li=list(set(nums))\\n            for i in li:\\n                nums.remove(i)\\n            O.append(li)\\n        return O\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3894456,
                "title": "c-solution-using-hash-table",
                "content": "```\\npublic class Solution {\\n    public IList<IList<int>> FindMatrix(int[] nums) {\\n        int mostFreq = 0;\\n        Dictionary<int,int> map = new Dictionary<int,int>();\\n        foreach(var num in nums){\\n            if(!map.ContainsKey(num)) map.Add(num,0);\\n            map[num]++;\\n            mostFreq = Math.Max(mostFreq,map[num]);\\n        }\\n        List<IList<int>> res = new List<IList<int>>();\\n        for(int i = 0;i < mostFreq;i++) res.Add(new List<int>());\\n        foreach(var kv in map){\\n            for(int i = 0;i < kv.Value;i++)\\n                res[i].Add(kv.Key);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Hash Table"
                ],
                "code": "```\\npublic class Solution {\\n    public IList<IList<int>> FindMatrix(int[] nums) {\\n        int mostFreq = 0;\\n        Dictionary<int,int> map = new Dictionary<int,int>();\\n        foreach(var num in nums){\\n            if(!map.ContainsKey(num)) map.Add(num,0);\\n            map[num]++;\\n            mostFreq = Math.Max(mostFreq,map[num]);\\n        }\\n        List<IList<int>> res = new List<IList<int>>();\\n        for(int i = 0;i < mostFreq;i++) res.Add(new List<int>());\\n        foreach(var kv in map){\\n            for(int i = 0;i < kv.Value;i++)\\n                res[i].Add(kv.Key);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3890157,
                "title": "easy-to-understand-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findMatrix(vector<int>& nums) {\\n        map<int, int> m;\\n        for(auto i: nums)m[i]++;\\n        int maxi =0;\\n        for(auto i: m){\\n            maxi = max(maxi, i.second);\\n        }\\n        vector<vector<int>> v;\\n        for(int j=0; j<maxi; j++){\\n            vector<int> temp;\\n            for(auto i: m){\\n                if(i.second>0){\\n                    temp.push_back(i.first);\\n                    m[i.first]--;\\n                }\\n            }\\n            v.push_back(temp);\\n        }\\n        return v;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findMatrix(vector<int>& nums) {\\n        map<int, int> m;\\n        for(auto i: nums)m[i]++;\\n        int maxi =0;\\n        for(auto i: m){\\n            maxi = max(maxi, i.second);\\n        }\\n        vector<vector<int>> v;\\n        for(int j=0; j<maxi; j++){\\n            vector<int> temp;\\n            for(auto i: m){\\n                if(i.second>0){\\n                    temp.push_back(i.first);\\n                    m[i.first]--;\\n                }\\n            }\\n            v.push_back(temp);\\n        }\\n        return v;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3888716,
                "title": "elixir-simple-solution-using-map",
                "content": "```\\ndefmodule Solution do\\n  @spec find_matrix(nums :: [integer]) :: [[integer]]\\n  def find_matrix(nums) do\\n    nums\\n    |> Enum.reduce(%{}, fn n, acc ->\\n      Map.update(acc, n, 1, &(&1 + 1))\\n    end)\\n    |> Enum.reduce(%{}, fn {n, ct}, acc ->\\n      1..ct\\n      |> Enum.reduce(acc, fn index, acc ->\\n        Map.update(acc, index, [n], &[n | &1])\\n      end)\\n    end)\\n    |> Map.values()\\n  end\\nend\\n\\n```",
                "solutionTags": [
                    "Elixir"
                ],
                "code": "```\\ndefmodule Solution do\\n  @spec find_matrix(nums :: [integer]) :: [[integer]]\\n  def find_matrix(nums) do\\n    nums\\n    |> Enum.reduce(%{}, fn n, acc ->\\n      Map.update(acc, n, 1, &(&1 + 1))\\n    end)\\n    |> Enum.reduce(%{}, fn {n, ct}, acc ->\\n      1..ct\\n      |> Enum.reduce(acc, fn index, acc ->\\n        Map.update(acc, index, [n], &[n | &1])\\n      end)\\n    end)\\n    |> Map.values()\\n  end\\nend\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3886195,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> findMatrix(int[] nums) {\\n        ArrayList<Integer> a=new ArrayList<>();\\n        List<List<Integer>> k=new ArrayList<>();\\n        for(int i:nums){\\n            a.add(i);\\n        }\\n        while(a.size()!=0){\\n            Set<Integer> s=new LinkedHashSet<>();\\n            for(int t:a){\\n                s.add(t);\\n            }\\n            ArrayList<Integer> p=new ArrayList<>();\\n            for(int r:s){\\n                p.add(r);\\n                a.remove(a.indexOf(r));\\n            }\\n            k.add(p);\\n            System.out.print(p);\\n            \\n        }\\n        return k;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> findMatrix(int[] nums) {\\n        ArrayList<Integer> a=new ArrayList<>();\\n        List<List<Integer>> k=new ArrayList<>();\\n        for(int i:nums){\\n            a.add(i);\\n        }\\n        while(a.size()!=0){\\n            Set<Integer> s=new LinkedHashSet<>();\\n            for(int t:a){\\n                s.add(t);\\n            }\\n            ArrayList<Integer> p=new ArrayList<>();\\n            for(int r:s){\\n                p.add(r);\\n                a.remove(a.indexOf(r));\\n            }\\n            k.add(p);\\n            System.out.print(p);\\n            \\n        }\\n        return k;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3885427,
                "title": "javascript-time-o-n-space-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Use counting sort\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\nvar findMatrix = function(nums) {\\n    let count = nums.length;\\n    const arr = (new Array(201)).fill(0);\\n    const ret = [];\\n\\n    for(let num of nums) {\\n        arr[num]++;\\n    }\\n\\n    while (count) {\\n        const tempArr = [];\\n        ret.push(tempArr);\\n\\n        for(let i = 1; i < arr.length; i++) {\\n            if (arr[i]) {\\n                tempArr.push(i);\\n                arr[i]--;\\n                count--;\\n            }\\n        }\\n    }\\n\\n    return ret;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\nvar findMatrix = function(nums) {\\n    let count = nums.length;\\n    const arr = (new Array(201)).fill(0);\\n    const ret = [];\\n\\n    for(let num of nums) {\\n        arr[num]++;\\n    }\\n\\n    while (count) {\\n        const tempArr = [];\\n        ret.push(tempArr);\\n\\n        for(let i = 1; i < arr.length; i++) {\\n            if (arr[i]) {\\n                tempArr.push(i);\\n                arr[i]--;\\n                count--;\\n            }\\n        }\\n    }\\n\\n    return ret;\\n};\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1857570,
                "content": [
                    {
                        "username": "dmitryartux",
                        "content": "Can be an **Easy** one"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Why constraints are so low when linear time solution is easy?"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n  static boolean check(List<Integer> list , int n){\\n     for(int i=0;i<list.size();i++){\\n         if(list.get(i)==n){\\n             return false;\\n         }\\n     }\\n     return true;\\n }\\n static int size(List<List<Integer>> list){\\n     int ans=0;\\n     for(int i=0;i<list.size();i++){\\n         ans+=list.get(i).size();\\n     }\\n     return ans;\\n }\\n    public static int[] mergesort(int[] arr){\\n        if(arr.length<=1){\\n            return arr;\\n        }\\n        int mid = (arr.length)/2;\\n        int[] arr1 = Arrays.copyOfRange(arr,0,mid);\\n        arr1 = mergesort(arr1);\\n        int[] arr2 = Arrays.copyOfRange(arr,mid,arr.length);\\n        arr2 = mergesort(arr2);\\n\\n        int[] ans = new int[arr.length];\\n        int i=0,j=0;\\n        while( i<arr1.length && j<arr2.length){\\n            if(arr1[i] > arr2[j]){\\n                ans[i+j]=arr2[j];\\n                j++;\\n            }else {\\n                ans[i+j]=arr1[i];\\n                i++;\\n            }\\n        }\\n        if(i==arr1.length){\\n            for(;j<arr2.length;j++){\\n                ans[arr1.length+j]=arr2[j];\\n            }\\n\\n        }else if (j==arr2.length){\\n            for(;i<arr1.length;i++){\\n                ans[arr2.length+i]=arr1[i];\\n            }\\n        }\\n        return ans;\\n    }\\n    public List<List<Integer>> findMatrix(int[] arr) {\\n     int[] nums=mergesort(arr);\\n       List<List<Integer>>  ans = new ArrayList<>();\\n       List<Integer> arr2=new ArrayList<>();\\n       int s=0;\\n       while(s<nums.length){\\n           List<Integer> list = new ArrayList<>();\\n           for(int i=0;i<nums.length;i++){\\n               if(check(arr2,i) && check(list,nums[i])){\\n                   list.add(nums[i]);\\n                   arr2.add(i);\\n               }\\n           }\\n           ans.add(list);\\n           s+=list.size();\\n       }\\n       return ans;\\n    }\\n}"
                    },
                    {
                        "username": "chiruu453",
                        "content": "https://leetcode.com/problems/convert-an-array-into-a-2d-array-with-conditions/solutions/3780195/c-different-approach/\\nsolution with little different approach from rest all."
                    },
                    {
                        "username": "Msey",
                        "content": "I\\'d say it\\'s an easy question even for my log-head "
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Easy question"
                    },
                    {
                        "username": "almostmonday",
                        "content": "You could form the matrix while you\\'re passing through the input array and solve this problem in one pass. The easiest solution with short code is [here](https://leetcode.com/problems/convert-an-array-into-a-2d-array-with-conditions/solutions/3387836/python-creating-matrix-while-passing-through-array/)."
                    },
                    {
                        "username": "Prometheus_1211",
                        "content": "```\nmap<int,int> m;\n        for(int i=0;i<nums.size();i++)\n        m[nums[i]]++;\n        vector<vector<int>> vec;\n        while(m.size())\n        {\n            vector<int> v;\n            for(auto x:m)\n            {\n                if(x.second==0)\n                m.erase(x.first);\n                else\n                {\n                    v.push_back(x.first);\n                    x.second--;\n                }\n            }\n            vec.push_back(v);\n        }\n        return vec;\n```\nWhat is wrong with this code? It is similar to others but still giving TLE. "
                    },
                    {
                        "username": "hero080",
                        "content": "Modifying the container while loop through it is easy to make mistakes.\\nStandard C++ way to modify while looping:\\n```\\n// for some container `c`\\nfor (auto it = c.begin(); it != c.end(); ) {\\n  if (...) {\\n    it = c.erase(it);  // This usually points `it` to the next iterator.\\n  } else {\\n    ++it;\\n  }\\n}\\n```"
                    },
                    {
                        "username": "Msey",
                        "content": "while(m.size()) try to use number and decrease it each step"
                    },
                    {
                        "username": "thesatiricwriter",
                        "content": "[@syedmarwan](/syedmarwan)  Did not get what you\\'re saying. Can you please modify those lines and comment here. It\\'ll BE OF GREAT HELP !!!!"
                    },
                    {
                        "username": "syedmarwan",
                        "content": "when passing the iterator in the map , you should pass a reference to the iterator , to change the values of the map and before adding the vector to the vector of vector , check the size of the vector , as this code will lead to an extra vector of size zero in the main vector(vector of vector). I hope this should fix your problem."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I just feel bad that I was not able to compete in this contest, these two mediums were the fastest that I ever solved :("
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Such low constraints! It could be easily done in linear time using hashmaps."
                    }
                ]
            },
            {
                "id": 1851500,
                "content": [
                    {
                        "username": "dmitryartux",
                        "content": "Can be an **Easy** one"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Why constraints are so low when linear time solution is easy?"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n  static boolean check(List<Integer> list , int n){\\n     for(int i=0;i<list.size();i++){\\n         if(list.get(i)==n){\\n             return false;\\n         }\\n     }\\n     return true;\\n }\\n static int size(List<List<Integer>> list){\\n     int ans=0;\\n     for(int i=0;i<list.size();i++){\\n         ans+=list.get(i).size();\\n     }\\n     return ans;\\n }\\n    public static int[] mergesort(int[] arr){\\n        if(arr.length<=1){\\n            return arr;\\n        }\\n        int mid = (arr.length)/2;\\n        int[] arr1 = Arrays.copyOfRange(arr,0,mid);\\n        arr1 = mergesort(arr1);\\n        int[] arr2 = Arrays.copyOfRange(arr,mid,arr.length);\\n        arr2 = mergesort(arr2);\\n\\n        int[] ans = new int[arr.length];\\n        int i=0,j=0;\\n        while( i<arr1.length && j<arr2.length){\\n            if(arr1[i] > arr2[j]){\\n                ans[i+j]=arr2[j];\\n                j++;\\n            }else {\\n                ans[i+j]=arr1[i];\\n                i++;\\n            }\\n        }\\n        if(i==arr1.length){\\n            for(;j<arr2.length;j++){\\n                ans[arr1.length+j]=arr2[j];\\n            }\\n\\n        }else if (j==arr2.length){\\n            for(;i<arr1.length;i++){\\n                ans[arr2.length+i]=arr1[i];\\n            }\\n        }\\n        return ans;\\n    }\\n    public List<List<Integer>> findMatrix(int[] arr) {\\n     int[] nums=mergesort(arr);\\n       List<List<Integer>>  ans = new ArrayList<>();\\n       List<Integer> arr2=new ArrayList<>();\\n       int s=0;\\n       while(s<nums.length){\\n           List<Integer> list = new ArrayList<>();\\n           for(int i=0;i<nums.length;i++){\\n               if(check(arr2,i) && check(list,nums[i])){\\n                   list.add(nums[i]);\\n                   arr2.add(i);\\n               }\\n           }\\n           ans.add(list);\\n           s+=list.size();\\n       }\\n       return ans;\\n    }\\n}"
                    },
                    {
                        "username": "chiruu453",
                        "content": "https://leetcode.com/problems/convert-an-array-into-a-2d-array-with-conditions/solutions/3780195/c-different-approach/\\nsolution with little different approach from rest all."
                    },
                    {
                        "username": "Msey",
                        "content": "I\\'d say it\\'s an easy question even for my log-head "
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Easy question"
                    },
                    {
                        "username": "almostmonday",
                        "content": "You could form the matrix while you\\'re passing through the input array and solve this problem in one pass. The easiest solution with short code is [here](https://leetcode.com/problems/convert-an-array-into-a-2d-array-with-conditions/solutions/3387836/python-creating-matrix-while-passing-through-array/)."
                    },
                    {
                        "username": "Prometheus_1211",
                        "content": "```\nmap<int,int> m;\n        for(int i=0;i<nums.size();i++)\n        m[nums[i]]++;\n        vector<vector<int>> vec;\n        while(m.size())\n        {\n            vector<int> v;\n            for(auto x:m)\n            {\n                if(x.second==0)\n                m.erase(x.first);\n                else\n                {\n                    v.push_back(x.first);\n                    x.second--;\n                }\n            }\n            vec.push_back(v);\n        }\n        return vec;\n```\nWhat is wrong with this code? It is similar to others but still giving TLE. "
                    },
                    {
                        "username": "hero080",
                        "content": "Modifying the container while loop through it is easy to make mistakes.\\nStandard C++ way to modify while looping:\\n```\\n// for some container `c`\\nfor (auto it = c.begin(); it != c.end(); ) {\\n  if (...) {\\n    it = c.erase(it);  // This usually points `it` to the next iterator.\\n  } else {\\n    ++it;\\n  }\\n}\\n```"
                    },
                    {
                        "username": "Msey",
                        "content": "while(m.size()) try to use number and decrease it each step"
                    },
                    {
                        "username": "thesatiricwriter",
                        "content": "[@syedmarwan](/syedmarwan)  Did not get what you\\'re saying. Can you please modify those lines and comment here. It\\'ll BE OF GREAT HELP !!!!"
                    },
                    {
                        "username": "syedmarwan",
                        "content": "when passing the iterator in the map , you should pass a reference to the iterator , to change the values of the map and before adding the vector to the vector of vector , check the size of the vector , as this code will lead to an extra vector of size zero in the main vector(vector of vector). I hope this should fix your problem."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I just feel bad that I was not able to compete in this contest, these two mediums were the fastest that I ever solved :("
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Such low constraints! It could be easily done in linear time using hashmaps."
                    }
                ]
            },
            {
                "id": 2059809,
                "content": [
                    {
                        "username": "dmitryartux",
                        "content": "Can be an **Easy** one"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Why constraints are so low when linear time solution is easy?"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n  static boolean check(List<Integer> list , int n){\\n     for(int i=0;i<list.size();i++){\\n         if(list.get(i)==n){\\n             return false;\\n         }\\n     }\\n     return true;\\n }\\n static int size(List<List<Integer>> list){\\n     int ans=0;\\n     for(int i=0;i<list.size();i++){\\n         ans+=list.get(i).size();\\n     }\\n     return ans;\\n }\\n    public static int[] mergesort(int[] arr){\\n        if(arr.length<=1){\\n            return arr;\\n        }\\n        int mid = (arr.length)/2;\\n        int[] arr1 = Arrays.copyOfRange(arr,0,mid);\\n        arr1 = mergesort(arr1);\\n        int[] arr2 = Arrays.copyOfRange(arr,mid,arr.length);\\n        arr2 = mergesort(arr2);\\n\\n        int[] ans = new int[arr.length];\\n        int i=0,j=0;\\n        while( i<arr1.length && j<arr2.length){\\n            if(arr1[i] > arr2[j]){\\n                ans[i+j]=arr2[j];\\n                j++;\\n            }else {\\n                ans[i+j]=arr1[i];\\n                i++;\\n            }\\n        }\\n        if(i==arr1.length){\\n            for(;j<arr2.length;j++){\\n                ans[arr1.length+j]=arr2[j];\\n            }\\n\\n        }else if (j==arr2.length){\\n            for(;i<arr1.length;i++){\\n                ans[arr2.length+i]=arr1[i];\\n            }\\n        }\\n        return ans;\\n    }\\n    public List<List<Integer>> findMatrix(int[] arr) {\\n     int[] nums=mergesort(arr);\\n       List<List<Integer>>  ans = new ArrayList<>();\\n       List<Integer> arr2=new ArrayList<>();\\n       int s=0;\\n       while(s<nums.length){\\n           List<Integer> list = new ArrayList<>();\\n           for(int i=0;i<nums.length;i++){\\n               if(check(arr2,i) && check(list,nums[i])){\\n                   list.add(nums[i]);\\n                   arr2.add(i);\\n               }\\n           }\\n           ans.add(list);\\n           s+=list.size();\\n       }\\n       return ans;\\n    }\\n}"
                    },
                    {
                        "username": "chiruu453",
                        "content": "https://leetcode.com/problems/convert-an-array-into-a-2d-array-with-conditions/solutions/3780195/c-different-approach/\\nsolution with little different approach from rest all."
                    },
                    {
                        "username": "Msey",
                        "content": "I\\'d say it\\'s an easy question even for my log-head "
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Easy question"
                    },
                    {
                        "username": "almostmonday",
                        "content": "You could form the matrix while you\\'re passing through the input array and solve this problem in one pass. The easiest solution with short code is [here](https://leetcode.com/problems/convert-an-array-into-a-2d-array-with-conditions/solutions/3387836/python-creating-matrix-while-passing-through-array/)."
                    },
                    {
                        "username": "Prometheus_1211",
                        "content": "```\nmap<int,int> m;\n        for(int i=0;i<nums.size();i++)\n        m[nums[i]]++;\n        vector<vector<int>> vec;\n        while(m.size())\n        {\n            vector<int> v;\n            for(auto x:m)\n            {\n                if(x.second==0)\n                m.erase(x.first);\n                else\n                {\n                    v.push_back(x.first);\n                    x.second--;\n                }\n            }\n            vec.push_back(v);\n        }\n        return vec;\n```\nWhat is wrong with this code? It is similar to others but still giving TLE. "
                    },
                    {
                        "username": "hero080",
                        "content": "Modifying the container while loop through it is easy to make mistakes.\\nStandard C++ way to modify while looping:\\n```\\n// for some container `c`\\nfor (auto it = c.begin(); it != c.end(); ) {\\n  if (...) {\\n    it = c.erase(it);  // This usually points `it` to the next iterator.\\n  } else {\\n    ++it;\\n  }\\n}\\n```"
                    },
                    {
                        "username": "Msey",
                        "content": "while(m.size()) try to use number and decrease it each step"
                    },
                    {
                        "username": "thesatiricwriter",
                        "content": "[@syedmarwan](/syedmarwan)  Did not get what you\\'re saying. Can you please modify those lines and comment here. It\\'ll BE OF GREAT HELP !!!!"
                    },
                    {
                        "username": "syedmarwan",
                        "content": "when passing the iterator in the map , you should pass a reference to the iterator , to change the values of the map and before adding the vector to the vector of vector , check the size of the vector , as this code will lead to an extra vector of size zero in the main vector(vector of vector). I hope this should fix your problem."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I just feel bad that I was not able to compete in this contest, these two mediums were the fastest that I ever solved :("
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Such low constraints! It could be easily done in linear time using hashmaps."
                    }
                ]
            },
            {
                "id": 1974813,
                "content": [
                    {
                        "username": "dmitryartux",
                        "content": "Can be an **Easy** one"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Why constraints are so low when linear time solution is easy?"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n  static boolean check(List<Integer> list , int n){\\n     for(int i=0;i<list.size();i++){\\n         if(list.get(i)==n){\\n             return false;\\n         }\\n     }\\n     return true;\\n }\\n static int size(List<List<Integer>> list){\\n     int ans=0;\\n     for(int i=0;i<list.size();i++){\\n         ans+=list.get(i).size();\\n     }\\n     return ans;\\n }\\n    public static int[] mergesort(int[] arr){\\n        if(arr.length<=1){\\n            return arr;\\n        }\\n        int mid = (arr.length)/2;\\n        int[] arr1 = Arrays.copyOfRange(arr,0,mid);\\n        arr1 = mergesort(arr1);\\n        int[] arr2 = Arrays.copyOfRange(arr,mid,arr.length);\\n        arr2 = mergesort(arr2);\\n\\n        int[] ans = new int[arr.length];\\n        int i=0,j=0;\\n        while( i<arr1.length && j<arr2.length){\\n            if(arr1[i] > arr2[j]){\\n                ans[i+j]=arr2[j];\\n                j++;\\n            }else {\\n                ans[i+j]=arr1[i];\\n                i++;\\n            }\\n        }\\n        if(i==arr1.length){\\n            for(;j<arr2.length;j++){\\n                ans[arr1.length+j]=arr2[j];\\n            }\\n\\n        }else if (j==arr2.length){\\n            for(;i<arr1.length;i++){\\n                ans[arr2.length+i]=arr1[i];\\n            }\\n        }\\n        return ans;\\n    }\\n    public List<List<Integer>> findMatrix(int[] arr) {\\n     int[] nums=mergesort(arr);\\n       List<List<Integer>>  ans = new ArrayList<>();\\n       List<Integer> arr2=new ArrayList<>();\\n       int s=0;\\n       while(s<nums.length){\\n           List<Integer> list = new ArrayList<>();\\n           for(int i=0;i<nums.length;i++){\\n               if(check(arr2,i) && check(list,nums[i])){\\n                   list.add(nums[i]);\\n                   arr2.add(i);\\n               }\\n           }\\n           ans.add(list);\\n           s+=list.size();\\n       }\\n       return ans;\\n    }\\n}"
                    },
                    {
                        "username": "chiruu453",
                        "content": "https://leetcode.com/problems/convert-an-array-into-a-2d-array-with-conditions/solutions/3780195/c-different-approach/\\nsolution with little different approach from rest all."
                    },
                    {
                        "username": "Msey",
                        "content": "I\\'d say it\\'s an easy question even for my log-head "
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Easy question"
                    },
                    {
                        "username": "almostmonday",
                        "content": "You could form the matrix while you\\'re passing through the input array and solve this problem in one pass. The easiest solution with short code is [here](https://leetcode.com/problems/convert-an-array-into-a-2d-array-with-conditions/solutions/3387836/python-creating-matrix-while-passing-through-array/)."
                    },
                    {
                        "username": "Prometheus_1211",
                        "content": "```\nmap<int,int> m;\n        for(int i=0;i<nums.size();i++)\n        m[nums[i]]++;\n        vector<vector<int>> vec;\n        while(m.size())\n        {\n            vector<int> v;\n            for(auto x:m)\n            {\n                if(x.second==0)\n                m.erase(x.first);\n                else\n                {\n                    v.push_back(x.first);\n                    x.second--;\n                }\n            }\n            vec.push_back(v);\n        }\n        return vec;\n```\nWhat is wrong with this code? It is similar to others but still giving TLE. "
                    },
                    {
                        "username": "hero080",
                        "content": "Modifying the container while loop through it is easy to make mistakes.\\nStandard C++ way to modify while looping:\\n```\\n// for some container `c`\\nfor (auto it = c.begin(); it != c.end(); ) {\\n  if (...) {\\n    it = c.erase(it);  // This usually points `it` to the next iterator.\\n  } else {\\n    ++it;\\n  }\\n}\\n```"
                    },
                    {
                        "username": "Msey",
                        "content": "while(m.size()) try to use number and decrease it each step"
                    },
                    {
                        "username": "thesatiricwriter",
                        "content": "[@syedmarwan](/syedmarwan)  Did not get what you\\'re saying. Can you please modify those lines and comment here. It\\'ll BE OF GREAT HELP !!!!"
                    },
                    {
                        "username": "syedmarwan",
                        "content": "when passing the iterator in the map , you should pass a reference to the iterator , to change the values of the map and before adding the vector to the vector of vector , check the size of the vector , as this code will lead to an extra vector of size zero in the main vector(vector of vector). I hope this should fix your problem."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I just feel bad that I was not able to compete in this contest, these two mediums were the fastest that I ever solved :("
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Such low constraints! It could be easily done in linear time using hashmaps."
                    }
                ]
            },
            {
                "id": 1898449,
                "content": [
                    {
                        "username": "dmitryartux",
                        "content": "Can be an **Easy** one"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Why constraints are so low when linear time solution is easy?"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n  static boolean check(List<Integer> list , int n){\\n     for(int i=0;i<list.size();i++){\\n         if(list.get(i)==n){\\n             return false;\\n         }\\n     }\\n     return true;\\n }\\n static int size(List<List<Integer>> list){\\n     int ans=0;\\n     for(int i=0;i<list.size();i++){\\n         ans+=list.get(i).size();\\n     }\\n     return ans;\\n }\\n    public static int[] mergesort(int[] arr){\\n        if(arr.length<=1){\\n            return arr;\\n        }\\n        int mid = (arr.length)/2;\\n        int[] arr1 = Arrays.copyOfRange(arr,0,mid);\\n        arr1 = mergesort(arr1);\\n        int[] arr2 = Arrays.copyOfRange(arr,mid,arr.length);\\n        arr2 = mergesort(arr2);\\n\\n        int[] ans = new int[arr.length];\\n        int i=0,j=0;\\n        while( i<arr1.length && j<arr2.length){\\n            if(arr1[i] > arr2[j]){\\n                ans[i+j]=arr2[j];\\n                j++;\\n            }else {\\n                ans[i+j]=arr1[i];\\n                i++;\\n            }\\n        }\\n        if(i==arr1.length){\\n            for(;j<arr2.length;j++){\\n                ans[arr1.length+j]=arr2[j];\\n            }\\n\\n        }else if (j==arr2.length){\\n            for(;i<arr1.length;i++){\\n                ans[arr2.length+i]=arr1[i];\\n            }\\n        }\\n        return ans;\\n    }\\n    public List<List<Integer>> findMatrix(int[] arr) {\\n     int[] nums=mergesort(arr);\\n       List<List<Integer>>  ans = new ArrayList<>();\\n       List<Integer> arr2=new ArrayList<>();\\n       int s=0;\\n       while(s<nums.length){\\n           List<Integer> list = new ArrayList<>();\\n           for(int i=0;i<nums.length;i++){\\n               if(check(arr2,i) && check(list,nums[i])){\\n                   list.add(nums[i]);\\n                   arr2.add(i);\\n               }\\n           }\\n           ans.add(list);\\n           s+=list.size();\\n       }\\n       return ans;\\n    }\\n}"
                    },
                    {
                        "username": "chiruu453",
                        "content": "https://leetcode.com/problems/convert-an-array-into-a-2d-array-with-conditions/solutions/3780195/c-different-approach/\\nsolution with little different approach from rest all."
                    },
                    {
                        "username": "Msey",
                        "content": "I\\'d say it\\'s an easy question even for my log-head "
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Easy question"
                    },
                    {
                        "username": "almostmonday",
                        "content": "You could form the matrix while you\\'re passing through the input array and solve this problem in one pass. The easiest solution with short code is [here](https://leetcode.com/problems/convert-an-array-into-a-2d-array-with-conditions/solutions/3387836/python-creating-matrix-while-passing-through-array/)."
                    },
                    {
                        "username": "Prometheus_1211",
                        "content": "```\nmap<int,int> m;\n        for(int i=0;i<nums.size();i++)\n        m[nums[i]]++;\n        vector<vector<int>> vec;\n        while(m.size())\n        {\n            vector<int> v;\n            for(auto x:m)\n            {\n                if(x.second==0)\n                m.erase(x.first);\n                else\n                {\n                    v.push_back(x.first);\n                    x.second--;\n                }\n            }\n            vec.push_back(v);\n        }\n        return vec;\n```\nWhat is wrong with this code? It is similar to others but still giving TLE. "
                    },
                    {
                        "username": "hero080",
                        "content": "Modifying the container while loop through it is easy to make mistakes.\\nStandard C++ way to modify while looping:\\n```\\n// for some container `c`\\nfor (auto it = c.begin(); it != c.end(); ) {\\n  if (...) {\\n    it = c.erase(it);  // This usually points `it` to the next iterator.\\n  } else {\\n    ++it;\\n  }\\n}\\n```"
                    },
                    {
                        "username": "Msey",
                        "content": "while(m.size()) try to use number and decrease it each step"
                    },
                    {
                        "username": "thesatiricwriter",
                        "content": "[@syedmarwan](/syedmarwan)  Did not get what you\\'re saying. Can you please modify those lines and comment here. It\\'ll BE OF GREAT HELP !!!!"
                    },
                    {
                        "username": "syedmarwan",
                        "content": "when passing the iterator in the map , you should pass a reference to the iterator , to change the values of the map and before adding the vector to the vector of vector , check the size of the vector , as this code will lead to an extra vector of size zero in the main vector(vector of vector). I hope this should fix your problem."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I just feel bad that I was not able to compete in this contest, these two mediums were the fastest that I ever solved :("
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Such low constraints! It could be easily done in linear time using hashmaps."
                    }
                ]
            },
            {
                "id": 1894851,
                "content": [
                    {
                        "username": "dmitryartux",
                        "content": "Can be an **Easy** one"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Why constraints are so low when linear time solution is easy?"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n  static boolean check(List<Integer> list , int n){\\n     for(int i=0;i<list.size();i++){\\n         if(list.get(i)==n){\\n             return false;\\n         }\\n     }\\n     return true;\\n }\\n static int size(List<List<Integer>> list){\\n     int ans=0;\\n     for(int i=0;i<list.size();i++){\\n         ans+=list.get(i).size();\\n     }\\n     return ans;\\n }\\n    public static int[] mergesort(int[] arr){\\n        if(arr.length<=1){\\n            return arr;\\n        }\\n        int mid = (arr.length)/2;\\n        int[] arr1 = Arrays.copyOfRange(arr,0,mid);\\n        arr1 = mergesort(arr1);\\n        int[] arr2 = Arrays.copyOfRange(arr,mid,arr.length);\\n        arr2 = mergesort(arr2);\\n\\n        int[] ans = new int[arr.length];\\n        int i=0,j=0;\\n        while( i<arr1.length && j<arr2.length){\\n            if(arr1[i] > arr2[j]){\\n                ans[i+j]=arr2[j];\\n                j++;\\n            }else {\\n                ans[i+j]=arr1[i];\\n                i++;\\n            }\\n        }\\n        if(i==arr1.length){\\n            for(;j<arr2.length;j++){\\n                ans[arr1.length+j]=arr2[j];\\n            }\\n\\n        }else if (j==arr2.length){\\n            for(;i<arr1.length;i++){\\n                ans[arr2.length+i]=arr1[i];\\n            }\\n        }\\n        return ans;\\n    }\\n    public List<List<Integer>> findMatrix(int[] arr) {\\n     int[] nums=mergesort(arr);\\n       List<List<Integer>>  ans = new ArrayList<>();\\n       List<Integer> arr2=new ArrayList<>();\\n       int s=0;\\n       while(s<nums.length){\\n           List<Integer> list = new ArrayList<>();\\n           for(int i=0;i<nums.length;i++){\\n               if(check(arr2,i) && check(list,nums[i])){\\n                   list.add(nums[i]);\\n                   arr2.add(i);\\n               }\\n           }\\n           ans.add(list);\\n           s+=list.size();\\n       }\\n       return ans;\\n    }\\n}"
                    },
                    {
                        "username": "chiruu453",
                        "content": "https://leetcode.com/problems/convert-an-array-into-a-2d-array-with-conditions/solutions/3780195/c-different-approach/\\nsolution with little different approach from rest all."
                    },
                    {
                        "username": "Msey",
                        "content": "I\\'d say it\\'s an easy question even for my log-head "
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Easy question"
                    },
                    {
                        "username": "almostmonday",
                        "content": "You could form the matrix while you\\'re passing through the input array and solve this problem in one pass. The easiest solution with short code is [here](https://leetcode.com/problems/convert-an-array-into-a-2d-array-with-conditions/solutions/3387836/python-creating-matrix-while-passing-through-array/)."
                    },
                    {
                        "username": "Prometheus_1211",
                        "content": "```\nmap<int,int> m;\n        for(int i=0;i<nums.size();i++)\n        m[nums[i]]++;\n        vector<vector<int>> vec;\n        while(m.size())\n        {\n            vector<int> v;\n            for(auto x:m)\n            {\n                if(x.second==0)\n                m.erase(x.first);\n                else\n                {\n                    v.push_back(x.first);\n                    x.second--;\n                }\n            }\n            vec.push_back(v);\n        }\n        return vec;\n```\nWhat is wrong with this code? It is similar to others but still giving TLE. "
                    },
                    {
                        "username": "hero080",
                        "content": "Modifying the container while loop through it is easy to make mistakes.\\nStandard C++ way to modify while looping:\\n```\\n// for some container `c`\\nfor (auto it = c.begin(); it != c.end(); ) {\\n  if (...) {\\n    it = c.erase(it);  // This usually points `it` to the next iterator.\\n  } else {\\n    ++it;\\n  }\\n}\\n```"
                    },
                    {
                        "username": "Msey",
                        "content": "while(m.size()) try to use number and decrease it each step"
                    },
                    {
                        "username": "thesatiricwriter",
                        "content": "[@syedmarwan](/syedmarwan)  Did not get what you\\'re saying. Can you please modify those lines and comment here. It\\'ll BE OF GREAT HELP !!!!"
                    },
                    {
                        "username": "syedmarwan",
                        "content": "when passing the iterator in the map , you should pass a reference to the iterator , to change the values of the map and before adding the vector to the vector of vector , check the size of the vector , as this code will lead to an extra vector of size zero in the main vector(vector of vector). I hope this should fix your problem."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I just feel bad that I was not able to compete in this contest, these two mediums were the fastest that I ever solved :("
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Such low constraints! It could be easily done in linear time using hashmaps."
                    }
                ]
            },
            {
                "id": 1855925,
                "content": [
                    {
                        "username": "dmitryartux",
                        "content": "Can be an **Easy** one"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Why constraints are so low when linear time solution is easy?"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n  static boolean check(List<Integer> list , int n){\\n     for(int i=0;i<list.size();i++){\\n         if(list.get(i)==n){\\n             return false;\\n         }\\n     }\\n     return true;\\n }\\n static int size(List<List<Integer>> list){\\n     int ans=0;\\n     for(int i=0;i<list.size();i++){\\n         ans+=list.get(i).size();\\n     }\\n     return ans;\\n }\\n    public static int[] mergesort(int[] arr){\\n        if(arr.length<=1){\\n            return arr;\\n        }\\n        int mid = (arr.length)/2;\\n        int[] arr1 = Arrays.copyOfRange(arr,0,mid);\\n        arr1 = mergesort(arr1);\\n        int[] arr2 = Arrays.copyOfRange(arr,mid,arr.length);\\n        arr2 = mergesort(arr2);\\n\\n        int[] ans = new int[arr.length];\\n        int i=0,j=0;\\n        while( i<arr1.length && j<arr2.length){\\n            if(arr1[i] > arr2[j]){\\n                ans[i+j]=arr2[j];\\n                j++;\\n            }else {\\n                ans[i+j]=arr1[i];\\n                i++;\\n            }\\n        }\\n        if(i==arr1.length){\\n            for(;j<arr2.length;j++){\\n                ans[arr1.length+j]=arr2[j];\\n            }\\n\\n        }else if (j==arr2.length){\\n            for(;i<arr1.length;i++){\\n                ans[arr2.length+i]=arr1[i];\\n            }\\n        }\\n        return ans;\\n    }\\n    public List<List<Integer>> findMatrix(int[] arr) {\\n     int[] nums=mergesort(arr);\\n       List<List<Integer>>  ans = new ArrayList<>();\\n       List<Integer> arr2=new ArrayList<>();\\n       int s=0;\\n       while(s<nums.length){\\n           List<Integer> list = new ArrayList<>();\\n           for(int i=0;i<nums.length;i++){\\n               if(check(arr2,i) && check(list,nums[i])){\\n                   list.add(nums[i]);\\n                   arr2.add(i);\\n               }\\n           }\\n           ans.add(list);\\n           s+=list.size();\\n       }\\n       return ans;\\n    }\\n}"
                    },
                    {
                        "username": "chiruu453",
                        "content": "https://leetcode.com/problems/convert-an-array-into-a-2d-array-with-conditions/solutions/3780195/c-different-approach/\\nsolution with little different approach from rest all."
                    },
                    {
                        "username": "Msey",
                        "content": "I\\'d say it\\'s an easy question even for my log-head "
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Easy question"
                    },
                    {
                        "username": "almostmonday",
                        "content": "You could form the matrix while you\\'re passing through the input array and solve this problem in one pass. The easiest solution with short code is [here](https://leetcode.com/problems/convert-an-array-into-a-2d-array-with-conditions/solutions/3387836/python-creating-matrix-while-passing-through-array/)."
                    },
                    {
                        "username": "Prometheus_1211",
                        "content": "```\nmap<int,int> m;\n        for(int i=0;i<nums.size();i++)\n        m[nums[i]]++;\n        vector<vector<int>> vec;\n        while(m.size())\n        {\n            vector<int> v;\n            for(auto x:m)\n            {\n                if(x.second==0)\n                m.erase(x.first);\n                else\n                {\n                    v.push_back(x.first);\n                    x.second--;\n                }\n            }\n            vec.push_back(v);\n        }\n        return vec;\n```\nWhat is wrong with this code? It is similar to others but still giving TLE. "
                    },
                    {
                        "username": "hero080",
                        "content": "Modifying the container while loop through it is easy to make mistakes.\\nStandard C++ way to modify while looping:\\n```\\n// for some container `c`\\nfor (auto it = c.begin(); it != c.end(); ) {\\n  if (...) {\\n    it = c.erase(it);  // This usually points `it` to the next iterator.\\n  } else {\\n    ++it;\\n  }\\n}\\n```"
                    },
                    {
                        "username": "Msey",
                        "content": "while(m.size()) try to use number and decrease it each step"
                    },
                    {
                        "username": "thesatiricwriter",
                        "content": "[@syedmarwan](/syedmarwan)  Did not get what you\\'re saying. Can you please modify those lines and comment here. It\\'ll BE OF GREAT HELP !!!!"
                    },
                    {
                        "username": "syedmarwan",
                        "content": "when passing the iterator in the map , you should pass a reference to the iterator , to change the values of the map and before adding the vector to the vector of vector , check the size of the vector , as this code will lead to an extra vector of size zero in the main vector(vector of vector). I hope this should fix your problem."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I just feel bad that I was not able to compete in this contest, these two mediums were the fastest that I ever solved :("
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Such low constraints! It could be easily done in linear time using hashmaps."
                    }
                ]
            },
            {
                "id": 1855583,
                "content": [
                    {
                        "username": "dmitryartux",
                        "content": "Can be an **Easy** one"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Why constraints are so low when linear time solution is easy?"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n  static boolean check(List<Integer> list , int n){\\n     for(int i=0;i<list.size();i++){\\n         if(list.get(i)==n){\\n             return false;\\n         }\\n     }\\n     return true;\\n }\\n static int size(List<List<Integer>> list){\\n     int ans=0;\\n     for(int i=0;i<list.size();i++){\\n         ans+=list.get(i).size();\\n     }\\n     return ans;\\n }\\n    public static int[] mergesort(int[] arr){\\n        if(arr.length<=1){\\n            return arr;\\n        }\\n        int mid = (arr.length)/2;\\n        int[] arr1 = Arrays.copyOfRange(arr,0,mid);\\n        arr1 = mergesort(arr1);\\n        int[] arr2 = Arrays.copyOfRange(arr,mid,arr.length);\\n        arr2 = mergesort(arr2);\\n\\n        int[] ans = new int[arr.length];\\n        int i=0,j=0;\\n        while( i<arr1.length && j<arr2.length){\\n            if(arr1[i] > arr2[j]){\\n                ans[i+j]=arr2[j];\\n                j++;\\n            }else {\\n                ans[i+j]=arr1[i];\\n                i++;\\n            }\\n        }\\n        if(i==arr1.length){\\n            for(;j<arr2.length;j++){\\n                ans[arr1.length+j]=arr2[j];\\n            }\\n\\n        }else if (j==arr2.length){\\n            for(;i<arr1.length;i++){\\n                ans[arr2.length+i]=arr1[i];\\n            }\\n        }\\n        return ans;\\n    }\\n    public List<List<Integer>> findMatrix(int[] arr) {\\n     int[] nums=mergesort(arr);\\n       List<List<Integer>>  ans = new ArrayList<>();\\n       List<Integer> arr2=new ArrayList<>();\\n       int s=0;\\n       while(s<nums.length){\\n           List<Integer> list = new ArrayList<>();\\n           for(int i=0;i<nums.length;i++){\\n               if(check(arr2,i) && check(list,nums[i])){\\n                   list.add(nums[i]);\\n                   arr2.add(i);\\n               }\\n           }\\n           ans.add(list);\\n           s+=list.size();\\n       }\\n       return ans;\\n    }\\n}"
                    },
                    {
                        "username": "chiruu453",
                        "content": "https://leetcode.com/problems/convert-an-array-into-a-2d-array-with-conditions/solutions/3780195/c-different-approach/\\nsolution with little different approach from rest all."
                    },
                    {
                        "username": "Msey",
                        "content": "I\\'d say it\\'s an easy question even for my log-head "
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Easy question"
                    },
                    {
                        "username": "almostmonday",
                        "content": "You could form the matrix while you\\'re passing through the input array and solve this problem in one pass. The easiest solution with short code is [here](https://leetcode.com/problems/convert-an-array-into-a-2d-array-with-conditions/solutions/3387836/python-creating-matrix-while-passing-through-array/)."
                    },
                    {
                        "username": "Prometheus_1211",
                        "content": "```\nmap<int,int> m;\n        for(int i=0;i<nums.size();i++)\n        m[nums[i]]++;\n        vector<vector<int>> vec;\n        while(m.size())\n        {\n            vector<int> v;\n            for(auto x:m)\n            {\n                if(x.second==0)\n                m.erase(x.first);\n                else\n                {\n                    v.push_back(x.first);\n                    x.second--;\n                }\n            }\n            vec.push_back(v);\n        }\n        return vec;\n```\nWhat is wrong with this code? It is similar to others but still giving TLE. "
                    },
                    {
                        "username": "hero080",
                        "content": "Modifying the container while loop through it is easy to make mistakes.\\nStandard C++ way to modify while looping:\\n```\\n// for some container `c`\\nfor (auto it = c.begin(); it != c.end(); ) {\\n  if (...) {\\n    it = c.erase(it);  // This usually points `it` to the next iterator.\\n  } else {\\n    ++it;\\n  }\\n}\\n```"
                    },
                    {
                        "username": "Msey",
                        "content": "while(m.size()) try to use number and decrease it each step"
                    },
                    {
                        "username": "thesatiricwriter",
                        "content": "[@syedmarwan](/syedmarwan)  Did not get what you\\'re saying. Can you please modify those lines and comment here. It\\'ll BE OF GREAT HELP !!!!"
                    },
                    {
                        "username": "syedmarwan",
                        "content": "when passing the iterator in the map , you should pass a reference to the iterator , to change the values of the map and before adding the vector to the vector of vector , check the size of the vector , as this code will lead to an extra vector of size zero in the main vector(vector of vector). I hope this should fix your problem."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I just feel bad that I was not able to compete in this contest, these two mediums were the fastest that I ever solved :("
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Such low constraints! It could be easily done in linear time using hashmaps."
                    }
                ]
            },
            {
                "id": 1851932,
                "content": [
                    {
                        "username": "dmitryartux",
                        "content": "Can be an **Easy** one"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Why constraints are so low when linear time solution is easy?"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n  static boolean check(List<Integer> list , int n){\\n     for(int i=0;i<list.size();i++){\\n         if(list.get(i)==n){\\n             return false;\\n         }\\n     }\\n     return true;\\n }\\n static int size(List<List<Integer>> list){\\n     int ans=0;\\n     for(int i=0;i<list.size();i++){\\n         ans+=list.get(i).size();\\n     }\\n     return ans;\\n }\\n    public static int[] mergesort(int[] arr){\\n        if(arr.length<=1){\\n            return arr;\\n        }\\n        int mid = (arr.length)/2;\\n        int[] arr1 = Arrays.copyOfRange(arr,0,mid);\\n        arr1 = mergesort(arr1);\\n        int[] arr2 = Arrays.copyOfRange(arr,mid,arr.length);\\n        arr2 = mergesort(arr2);\\n\\n        int[] ans = new int[arr.length];\\n        int i=0,j=0;\\n        while( i<arr1.length && j<arr2.length){\\n            if(arr1[i] > arr2[j]){\\n                ans[i+j]=arr2[j];\\n                j++;\\n            }else {\\n                ans[i+j]=arr1[i];\\n                i++;\\n            }\\n        }\\n        if(i==arr1.length){\\n            for(;j<arr2.length;j++){\\n                ans[arr1.length+j]=arr2[j];\\n            }\\n\\n        }else if (j==arr2.length){\\n            for(;i<arr1.length;i++){\\n                ans[arr2.length+i]=arr1[i];\\n            }\\n        }\\n        return ans;\\n    }\\n    public List<List<Integer>> findMatrix(int[] arr) {\\n     int[] nums=mergesort(arr);\\n       List<List<Integer>>  ans = new ArrayList<>();\\n       List<Integer> arr2=new ArrayList<>();\\n       int s=0;\\n       while(s<nums.length){\\n           List<Integer> list = new ArrayList<>();\\n           for(int i=0;i<nums.length;i++){\\n               if(check(arr2,i) && check(list,nums[i])){\\n                   list.add(nums[i]);\\n                   arr2.add(i);\\n               }\\n           }\\n           ans.add(list);\\n           s+=list.size();\\n       }\\n       return ans;\\n    }\\n}"
                    },
                    {
                        "username": "chiruu453",
                        "content": "https://leetcode.com/problems/convert-an-array-into-a-2d-array-with-conditions/solutions/3780195/c-different-approach/\\nsolution with little different approach from rest all."
                    },
                    {
                        "username": "Msey",
                        "content": "I\\'d say it\\'s an easy question even for my log-head "
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Easy question"
                    },
                    {
                        "username": "almostmonday",
                        "content": "You could form the matrix while you\\'re passing through the input array and solve this problem in one pass. The easiest solution with short code is [here](https://leetcode.com/problems/convert-an-array-into-a-2d-array-with-conditions/solutions/3387836/python-creating-matrix-while-passing-through-array/)."
                    },
                    {
                        "username": "Prometheus_1211",
                        "content": "```\nmap<int,int> m;\n        for(int i=0;i<nums.size();i++)\n        m[nums[i]]++;\n        vector<vector<int>> vec;\n        while(m.size())\n        {\n            vector<int> v;\n            for(auto x:m)\n            {\n                if(x.second==0)\n                m.erase(x.first);\n                else\n                {\n                    v.push_back(x.first);\n                    x.second--;\n                }\n            }\n            vec.push_back(v);\n        }\n        return vec;\n```\nWhat is wrong with this code? It is similar to others but still giving TLE. "
                    },
                    {
                        "username": "hero080",
                        "content": "Modifying the container while loop through it is easy to make mistakes.\\nStandard C++ way to modify while looping:\\n```\\n// for some container `c`\\nfor (auto it = c.begin(); it != c.end(); ) {\\n  if (...) {\\n    it = c.erase(it);  // This usually points `it` to the next iterator.\\n  } else {\\n    ++it;\\n  }\\n}\\n```"
                    },
                    {
                        "username": "Msey",
                        "content": "while(m.size()) try to use number and decrease it each step"
                    },
                    {
                        "username": "thesatiricwriter",
                        "content": "[@syedmarwan](/syedmarwan)  Did not get what you\\'re saying. Can you please modify those lines and comment here. It\\'ll BE OF GREAT HELP !!!!"
                    },
                    {
                        "username": "syedmarwan",
                        "content": "when passing the iterator in the map , you should pass a reference to the iterator , to change the values of the map and before adding the vector to the vector of vector , check the size of the vector , as this code will lead to an extra vector of size zero in the main vector(vector of vector). I hope this should fix your problem."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I just feel bad that I was not able to compete in this contest, these two mediums were the fastest that I ever solved :("
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Such low constraints! It could be easily done in linear time using hashmaps."
                    }
                ]
            },
            {
                "id": 1851701,
                "content": [
                    {
                        "username": "dmitryartux",
                        "content": "Can be an **Easy** one"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Why constraints are so low when linear time solution is easy?"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n  static boolean check(List<Integer> list , int n){\\n     for(int i=0;i<list.size();i++){\\n         if(list.get(i)==n){\\n             return false;\\n         }\\n     }\\n     return true;\\n }\\n static int size(List<List<Integer>> list){\\n     int ans=0;\\n     for(int i=0;i<list.size();i++){\\n         ans+=list.get(i).size();\\n     }\\n     return ans;\\n }\\n    public static int[] mergesort(int[] arr){\\n        if(arr.length<=1){\\n            return arr;\\n        }\\n        int mid = (arr.length)/2;\\n        int[] arr1 = Arrays.copyOfRange(arr,0,mid);\\n        arr1 = mergesort(arr1);\\n        int[] arr2 = Arrays.copyOfRange(arr,mid,arr.length);\\n        arr2 = mergesort(arr2);\\n\\n        int[] ans = new int[arr.length];\\n        int i=0,j=0;\\n        while( i<arr1.length && j<arr2.length){\\n            if(arr1[i] > arr2[j]){\\n                ans[i+j]=arr2[j];\\n                j++;\\n            }else {\\n                ans[i+j]=arr1[i];\\n                i++;\\n            }\\n        }\\n        if(i==arr1.length){\\n            for(;j<arr2.length;j++){\\n                ans[arr1.length+j]=arr2[j];\\n            }\\n\\n        }else if (j==arr2.length){\\n            for(;i<arr1.length;i++){\\n                ans[arr2.length+i]=arr1[i];\\n            }\\n        }\\n        return ans;\\n    }\\n    public List<List<Integer>> findMatrix(int[] arr) {\\n     int[] nums=mergesort(arr);\\n       List<List<Integer>>  ans = new ArrayList<>();\\n       List<Integer> arr2=new ArrayList<>();\\n       int s=0;\\n       while(s<nums.length){\\n           List<Integer> list = new ArrayList<>();\\n           for(int i=0;i<nums.length;i++){\\n               if(check(arr2,i) && check(list,nums[i])){\\n                   list.add(nums[i]);\\n                   arr2.add(i);\\n               }\\n           }\\n           ans.add(list);\\n           s+=list.size();\\n       }\\n       return ans;\\n    }\\n}"
                    },
                    {
                        "username": "chiruu453",
                        "content": "https://leetcode.com/problems/convert-an-array-into-a-2d-array-with-conditions/solutions/3780195/c-different-approach/\\nsolution with little different approach from rest all."
                    },
                    {
                        "username": "Msey",
                        "content": "I\\'d say it\\'s an easy question even for my log-head "
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Easy question"
                    },
                    {
                        "username": "almostmonday",
                        "content": "You could form the matrix while you\\'re passing through the input array and solve this problem in one pass. The easiest solution with short code is [here](https://leetcode.com/problems/convert-an-array-into-a-2d-array-with-conditions/solutions/3387836/python-creating-matrix-while-passing-through-array/)."
                    },
                    {
                        "username": "Prometheus_1211",
                        "content": "```\nmap<int,int> m;\n        for(int i=0;i<nums.size();i++)\n        m[nums[i]]++;\n        vector<vector<int>> vec;\n        while(m.size())\n        {\n            vector<int> v;\n            for(auto x:m)\n            {\n                if(x.second==0)\n                m.erase(x.first);\n                else\n                {\n                    v.push_back(x.first);\n                    x.second--;\n                }\n            }\n            vec.push_back(v);\n        }\n        return vec;\n```\nWhat is wrong with this code? It is similar to others but still giving TLE. "
                    },
                    {
                        "username": "hero080",
                        "content": "Modifying the container while loop through it is easy to make mistakes.\\nStandard C++ way to modify while looping:\\n```\\n// for some container `c`\\nfor (auto it = c.begin(); it != c.end(); ) {\\n  if (...) {\\n    it = c.erase(it);  // This usually points `it` to the next iterator.\\n  } else {\\n    ++it;\\n  }\\n}\\n```"
                    },
                    {
                        "username": "Msey",
                        "content": "while(m.size()) try to use number and decrease it each step"
                    },
                    {
                        "username": "thesatiricwriter",
                        "content": "[@syedmarwan](/syedmarwan)  Did not get what you\\'re saying. Can you please modify those lines and comment here. It\\'ll BE OF GREAT HELP !!!!"
                    },
                    {
                        "username": "syedmarwan",
                        "content": "when passing the iterator in the map , you should pass a reference to the iterator , to change the values of the map and before adding the vector to the vector of vector , check the size of the vector , as this code will lead to an extra vector of size zero in the main vector(vector of vector). I hope this should fix your problem."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I just feel bad that I was not able to compete in this contest, these two mediums were the fastest that I ever solved :("
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Such low constraints! It could be easily done in linear time using hashmaps."
                    }
                ]
            },
            {
                "id": 1857570,
                "content": [
                    {
                        "username": "dmitryartux",
                        "content": "Can be an **Easy** one"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Why constraints are so low when linear time solution is easy?"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n  static boolean check(List<Integer> list , int n){\\n     for(int i=0;i<list.size();i++){\\n         if(list.get(i)==n){\\n             return false;\\n         }\\n     }\\n     return true;\\n }\\n static int size(List<List<Integer>> list){\\n     int ans=0;\\n     for(int i=0;i<list.size();i++){\\n         ans+=list.get(i).size();\\n     }\\n     return ans;\\n }\\n    public static int[] mergesort(int[] arr){\\n        if(arr.length<=1){\\n            return arr;\\n        }\\n        int mid = (arr.length)/2;\\n        int[] arr1 = Arrays.copyOfRange(arr,0,mid);\\n        arr1 = mergesort(arr1);\\n        int[] arr2 = Arrays.copyOfRange(arr,mid,arr.length);\\n        arr2 = mergesort(arr2);\\n\\n        int[] ans = new int[arr.length];\\n        int i=0,j=0;\\n        while( i<arr1.length && j<arr2.length){\\n            if(arr1[i] > arr2[j]){\\n                ans[i+j]=arr2[j];\\n                j++;\\n            }else {\\n                ans[i+j]=arr1[i];\\n                i++;\\n            }\\n        }\\n        if(i==arr1.length){\\n            for(;j<arr2.length;j++){\\n                ans[arr1.length+j]=arr2[j];\\n            }\\n\\n        }else if (j==arr2.length){\\n            for(;i<arr1.length;i++){\\n                ans[arr2.length+i]=arr1[i];\\n            }\\n        }\\n        return ans;\\n    }\\n    public List<List<Integer>> findMatrix(int[] arr) {\\n     int[] nums=mergesort(arr);\\n       List<List<Integer>>  ans = new ArrayList<>();\\n       List<Integer> arr2=new ArrayList<>();\\n       int s=0;\\n       while(s<nums.length){\\n           List<Integer> list = new ArrayList<>();\\n           for(int i=0;i<nums.length;i++){\\n               if(check(arr2,i) && check(list,nums[i])){\\n                   list.add(nums[i]);\\n                   arr2.add(i);\\n               }\\n           }\\n           ans.add(list);\\n           s+=list.size();\\n       }\\n       return ans;\\n    }\\n}"
                    },
                    {
                        "username": "chiruu453",
                        "content": "https://leetcode.com/problems/convert-an-array-into-a-2d-array-with-conditions/solutions/3780195/c-different-approach/\\nsolution with little different approach from rest all."
                    },
                    {
                        "username": "Msey",
                        "content": "I\\'d say it\\'s an easy question even for my log-head "
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Easy question"
                    },
                    {
                        "username": "almostmonday",
                        "content": "You could form the matrix while you\\'re passing through the input array and solve this problem in one pass. The easiest solution with short code is [here](https://leetcode.com/problems/convert-an-array-into-a-2d-array-with-conditions/solutions/3387836/python-creating-matrix-while-passing-through-array/)."
                    },
                    {
                        "username": "Prometheus_1211",
                        "content": "```\nmap<int,int> m;\n        for(int i=0;i<nums.size();i++)\n        m[nums[i]]++;\n        vector<vector<int>> vec;\n        while(m.size())\n        {\n            vector<int> v;\n            for(auto x:m)\n            {\n                if(x.second==0)\n                m.erase(x.first);\n                else\n                {\n                    v.push_back(x.first);\n                    x.second--;\n                }\n            }\n            vec.push_back(v);\n        }\n        return vec;\n```\nWhat is wrong with this code? It is similar to others but still giving TLE. "
                    },
                    {
                        "username": "hero080",
                        "content": "Modifying the container while loop through it is easy to make mistakes.\\nStandard C++ way to modify while looping:\\n```\\n// for some container `c`\\nfor (auto it = c.begin(); it != c.end(); ) {\\n  if (...) {\\n    it = c.erase(it);  // This usually points `it` to the next iterator.\\n  } else {\\n    ++it;\\n  }\\n}\\n```"
                    },
                    {
                        "username": "Msey",
                        "content": "while(m.size()) try to use number and decrease it each step"
                    },
                    {
                        "username": "thesatiricwriter",
                        "content": "[@syedmarwan](/syedmarwan)  Did not get what you\\'re saying. Can you please modify those lines and comment here. It\\'ll BE OF GREAT HELP !!!!"
                    },
                    {
                        "username": "syedmarwan",
                        "content": "when passing the iterator in the map , you should pass a reference to the iterator , to change the values of the map and before adding the vector to the vector of vector , check the size of the vector , as this code will lead to an extra vector of size zero in the main vector(vector of vector). I hope this should fix your problem."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I just feel bad that I was not able to compete in this contest, these two mediums were the fastest that I ever solved :("
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Such low constraints! It could be easily done in linear time using hashmaps."
                    }
                ]
            },
            {
                "id": 1851500,
                "content": [
                    {
                        "username": "dmitryartux",
                        "content": "Can be an **Easy** one"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Why constraints are so low when linear time solution is easy?"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n  static boolean check(List<Integer> list , int n){\\n     for(int i=0;i<list.size();i++){\\n         if(list.get(i)==n){\\n             return false;\\n         }\\n     }\\n     return true;\\n }\\n static int size(List<List<Integer>> list){\\n     int ans=0;\\n     for(int i=0;i<list.size();i++){\\n         ans+=list.get(i).size();\\n     }\\n     return ans;\\n }\\n    public static int[] mergesort(int[] arr){\\n        if(arr.length<=1){\\n            return arr;\\n        }\\n        int mid = (arr.length)/2;\\n        int[] arr1 = Arrays.copyOfRange(arr,0,mid);\\n        arr1 = mergesort(arr1);\\n        int[] arr2 = Arrays.copyOfRange(arr,mid,arr.length);\\n        arr2 = mergesort(arr2);\\n\\n        int[] ans = new int[arr.length];\\n        int i=0,j=0;\\n        while( i<arr1.length && j<arr2.length){\\n            if(arr1[i] > arr2[j]){\\n                ans[i+j]=arr2[j];\\n                j++;\\n            }else {\\n                ans[i+j]=arr1[i];\\n                i++;\\n            }\\n        }\\n        if(i==arr1.length){\\n            for(;j<arr2.length;j++){\\n                ans[arr1.length+j]=arr2[j];\\n            }\\n\\n        }else if (j==arr2.length){\\n            for(;i<arr1.length;i++){\\n                ans[arr2.length+i]=arr1[i];\\n            }\\n        }\\n        return ans;\\n    }\\n    public List<List<Integer>> findMatrix(int[] arr) {\\n     int[] nums=mergesort(arr);\\n       List<List<Integer>>  ans = new ArrayList<>();\\n       List<Integer> arr2=new ArrayList<>();\\n       int s=0;\\n       while(s<nums.length){\\n           List<Integer> list = new ArrayList<>();\\n           for(int i=0;i<nums.length;i++){\\n               if(check(arr2,i) && check(list,nums[i])){\\n                   list.add(nums[i]);\\n                   arr2.add(i);\\n               }\\n           }\\n           ans.add(list);\\n           s+=list.size();\\n       }\\n       return ans;\\n    }\\n}"
                    },
                    {
                        "username": "chiruu453",
                        "content": "https://leetcode.com/problems/convert-an-array-into-a-2d-array-with-conditions/solutions/3780195/c-different-approach/\\nsolution with little different approach from rest all."
                    },
                    {
                        "username": "Msey",
                        "content": "I\\'d say it\\'s an easy question even for my log-head "
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Easy question"
                    },
                    {
                        "username": "almostmonday",
                        "content": "You could form the matrix while you\\'re passing through the input array and solve this problem in one pass. The easiest solution with short code is [here](https://leetcode.com/problems/convert-an-array-into-a-2d-array-with-conditions/solutions/3387836/python-creating-matrix-while-passing-through-array/)."
                    },
                    {
                        "username": "Prometheus_1211",
                        "content": "```\nmap<int,int> m;\n        for(int i=0;i<nums.size();i++)\n        m[nums[i]]++;\n        vector<vector<int>> vec;\n        while(m.size())\n        {\n            vector<int> v;\n            for(auto x:m)\n            {\n                if(x.second==0)\n                m.erase(x.first);\n                else\n                {\n                    v.push_back(x.first);\n                    x.second--;\n                }\n            }\n            vec.push_back(v);\n        }\n        return vec;\n```\nWhat is wrong with this code? It is similar to others but still giving TLE. "
                    },
                    {
                        "username": "hero080",
                        "content": "Modifying the container while loop through it is easy to make mistakes.\\nStandard C++ way to modify while looping:\\n```\\n// for some container `c`\\nfor (auto it = c.begin(); it != c.end(); ) {\\n  if (...) {\\n    it = c.erase(it);  // This usually points `it` to the next iterator.\\n  } else {\\n    ++it;\\n  }\\n}\\n```"
                    },
                    {
                        "username": "Msey",
                        "content": "while(m.size()) try to use number and decrease it each step"
                    },
                    {
                        "username": "thesatiricwriter",
                        "content": "[@syedmarwan](/syedmarwan)  Did not get what you\\'re saying. Can you please modify those lines and comment here. It\\'ll BE OF GREAT HELP !!!!"
                    },
                    {
                        "username": "syedmarwan",
                        "content": "when passing the iterator in the map , you should pass a reference to the iterator , to change the values of the map and before adding the vector to the vector of vector , check the size of the vector , as this code will lead to an extra vector of size zero in the main vector(vector of vector). I hope this should fix your problem."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I just feel bad that I was not able to compete in this contest, these two mediums were the fastest that I ever solved :("
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Such low constraints! It could be easily done in linear time using hashmaps."
                    }
                ]
            },
            {
                "id": 2059809,
                "content": [
                    {
                        "username": "dmitryartux",
                        "content": "Can be an **Easy** one"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Why constraints are so low when linear time solution is easy?"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n  static boolean check(List<Integer> list , int n){\\n     for(int i=0;i<list.size();i++){\\n         if(list.get(i)==n){\\n             return false;\\n         }\\n     }\\n     return true;\\n }\\n static int size(List<List<Integer>> list){\\n     int ans=0;\\n     for(int i=0;i<list.size();i++){\\n         ans+=list.get(i).size();\\n     }\\n     return ans;\\n }\\n    public static int[] mergesort(int[] arr){\\n        if(arr.length<=1){\\n            return arr;\\n        }\\n        int mid = (arr.length)/2;\\n        int[] arr1 = Arrays.copyOfRange(arr,0,mid);\\n        arr1 = mergesort(arr1);\\n        int[] arr2 = Arrays.copyOfRange(arr,mid,arr.length);\\n        arr2 = mergesort(arr2);\\n\\n        int[] ans = new int[arr.length];\\n        int i=0,j=0;\\n        while( i<arr1.length && j<arr2.length){\\n            if(arr1[i] > arr2[j]){\\n                ans[i+j]=arr2[j];\\n                j++;\\n            }else {\\n                ans[i+j]=arr1[i];\\n                i++;\\n            }\\n        }\\n        if(i==arr1.length){\\n            for(;j<arr2.length;j++){\\n                ans[arr1.length+j]=arr2[j];\\n            }\\n\\n        }else if (j==arr2.length){\\n            for(;i<arr1.length;i++){\\n                ans[arr2.length+i]=arr1[i];\\n            }\\n        }\\n        return ans;\\n    }\\n    public List<List<Integer>> findMatrix(int[] arr) {\\n     int[] nums=mergesort(arr);\\n       List<List<Integer>>  ans = new ArrayList<>();\\n       List<Integer> arr2=new ArrayList<>();\\n       int s=0;\\n       while(s<nums.length){\\n           List<Integer> list = new ArrayList<>();\\n           for(int i=0;i<nums.length;i++){\\n               if(check(arr2,i) && check(list,nums[i])){\\n                   list.add(nums[i]);\\n                   arr2.add(i);\\n               }\\n           }\\n           ans.add(list);\\n           s+=list.size();\\n       }\\n       return ans;\\n    }\\n}"
                    },
                    {
                        "username": "chiruu453",
                        "content": "https://leetcode.com/problems/convert-an-array-into-a-2d-array-with-conditions/solutions/3780195/c-different-approach/\\nsolution with little different approach from rest all."
                    },
                    {
                        "username": "Msey",
                        "content": "I\\'d say it\\'s an easy question even for my log-head "
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Easy question"
                    },
                    {
                        "username": "almostmonday",
                        "content": "You could form the matrix while you\\'re passing through the input array and solve this problem in one pass. The easiest solution with short code is [here](https://leetcode.com/problems/convert-an-array-into-a-2d-array-with-conditions/solutions/3387836/python-creating-matrix-while-passing-through-array/)."
                    },
                    {
                        "username": "Prometheus_1211",
                        "content": "```\nmap<int,int> m;\n        for(int i=0;i<nums.size();i++)\n        m[nums[i]]++;\n        vector<vector<int>> vec;\n        while(m.size())\n        {\n            vector<int> v;\n            for(auto x:m)\n            {\n                if(x.second==0)\n                m.erase(x.first);\n                else\n                {\n                    v.push_back(x.first);\n                    x.second--;\n                }\n            }\n            vec.push_back(v);\n        }\n        return vec;\n```\nWhat is wrong with this code? It is similar to others but still giving TLE. "
                    },
                    {
                        "username": "hero080",
                        "content": "Modifying the container while loop through it is easy to make mistakes.\\nStandard C++ way to modify while looping:\\n```\\n// for some container `c`\\nfor (auto it = c.begin(); it != c.end(); ) {\\n  if (...) {\\n    it = c.erase(it);  // This usually points `it` to the next iterator.\\n  } else {\\n    ++it;\\n  }\\n}\\n```"
                    },
                    {
                        "username": "Msey",
                        "content": "while(m.size()) try to use number and decrease it each step"
                    },
                    {
                        "username": "thesatiricwriter",
                        "content": "[@syedmarwan](/syedmarwan)  Did not get what you\\'re saying. Can you please modify those lines and comment here. It\\'ll BE OF GREAT HELP !!!!"
                    },
                    {
                        "username": "syedmarwan",
                        "content": "when passing the iterator in the map , you should pass a reference to the iterator , to change the values of the map and before adding the vector to the vector of vector , check the size of the vector , as this code will lead to an extra vector of size zero in the main vector(vector of vector). I hope this should fix your problem."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I just feel bad that I was not able to compete in this contest, these two mediums were the fastest that I ever solved :("
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Such low constraints! It could be easily done in linear time using hashmaps."
                    }
                ]
            },
            {
                "id": 1974813,
                "content": [
                    {
                        "username": "dmitryartux",
                        "content": "Can be an **Easy** one"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Why constraints are so low when linear time solution is easy?"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n  static boolean check(List<Integer> list , int n){\\n     for(int i=0;i<list.size();i++){\\n         if(list.get(i)==n){\\n             return false;\\n         }\\n     }\\n     return true;\\n }\\n static int size(List<List<Integer>> list){\\n     int ans=0;\\n     for(int i=0;i<list.size();i++){\\n         ans+=list.get(i).size();\\n     }\\n     return ans;\\n }\\n    public static int[] mergesort(int[] arr){\\n        if(arr.length<=1){\\n            return arr;\\n        }\\n        int mid = (arr.length)/2;\\n        int[] arr1 = Arrays.copyOfRange(arr,0,mid);\\n        arr1 = mergesort(arr1);\\n        int[] arr2 = Arrays.copyOfRange(arr,mid,arr.length);\\n        arr2 = mergesort(arr2);\\n\\n        int[] ans = new int[arr.length];\\n        int i=0,j=0;\\n        while( i<arr1.length && j<arr2.length){\\n            if(arr1[i] > arr2[j]){\\n                ans[i+j]=arr2[j];\\n                j++;\\n            }else {\\n                ans[i+j]=arr1[i];\\n                i++;\\n            }\\n        }\\n        if(i==arr1.length){\\n            for(;j<arr2.length;j++){\\n                ans[arr1.length+j]=arr2[j];\\n            }\\n\\n        }else if (j==arr2.length){\\n            for(;i<arr1.length;i++){\\n                ans[arr2.length+i]=arr1[i];\\n            }\\n        }\\n        return ans;\\n    }\\n    public List<List<Integer>> findMatrix(int[] arr) {\\n     int[] nums=mergesort(arr);\\n       List<List<Integer>>  ans = new ArrayList<>();\\n       List<Integer> arr2=new ArrayList<>();\\n       int s=0;\\n       while(s<nums.length){\\n           List<Integer> list = new ArrayList<>();\\n           for(int i=0;i<nums.length;i++){\\n               if(check(arr2,i) && check(list,nums[i])){\\n                   list.add(nums[i]);\\n                   arr2.add(i);\\n               }\\n           }\\n           ans.add(list);\\n           s+=list.size();\\n       }\\n       return ans;\\n    }\\n}"
                    },
                    {
                        "username": "chiruu453",
                        "content": "https://leetcode.com/problems/convert-an-array-into-a-2d-array-with-conditions/solutions/3780195/c-different-approach/\\nsolution with little different approach from rest all."
                    },
                    {
                        "username": "Msey",
                        "content": "I\\'d say it\\'s an easy question even for my log-head "
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Easy question"
                    },
                    {
                        "username": "almostmonday",
                        "content": "You could form the matrix while you\\'re passing through the input array and solve this problem in one pass. The easiest solution with short code is [here](https://leetcode.com/problems/convert-an-array-into-a-2d-array-with-conditions/solutions/3387836/python-creating-matrix-while-passing-through-array/)."
                    },
                    {
                        "username": "Prometheus_1211",
                        "content": "```\nmap<int,int> m;\n        for(int i=0;i<nums.size();i++)\n        m[nums[i]]++;\n        vector<vector<int>> vec;\n        while(m.size())\n        {\n            vector<int> v;\n            for(auto x:m)\n            {\n                if(x.second==0)\n                m.erase(x.first);\n                else\n                {\n                    v.push_back(x.first);\n                    x.second--;\n                }\n            }\n            vec.push_back(v);\n        }\n        return vec;\n```\nWhat is wrong with this code? It is similar to others but still giving TLE. "
                    },
                    {
                        "username": "hero080",
                        "content": "Modifying the container while loop through it is easy to make mistakes.\\nStandard C++ way to modify while looping:\\n```\\n// for some container `c`\\nfor (auto it = c.begin(); it != c.end(); ) {\\n  if (...) {\\n    it = c.erase(it);  // This usually points `it` to the next iterator.\\n  } else {\\n    ++it;\\n  }\\n}\\n```"
                    },
                    {
                        "username": "Msey",
                        "content": "while(m.size()) try to use number and decrease it each step"
                    },
                    {
                        "username": "thesatiricwriter",
                        "content": "[@syedmarwan](/syedmarwan)  Did not get what you\\'re saying. Can you please modify those lines and comment here. It\\'ll BE OF GREAT HELP !!!!"
                    },
                    {
                        "username": "syedmarwan",
                        "content": "when passing the iterator in the map , you should pass a reference to the iterator , to change the values of the map and before adding the vector to the vector of vector , check the size of the vector , as this code will lead to an extra vector of size zero in the main vector(vector of vector). I hope this should fix your problem."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I just feel bad that I was not able to compete in this contest, these two mediums were the fastest that I ever solved :("
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Such low constraints! It could be easily done in linear time using hashmaps."
                    }
                ]
            },
            {
                "id": 1898449,
                "content": [
                    {
                        "username": "dmitryartux",
                        "content": "Can be an **Easy** one"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Why constraints are so low when linear time solution is easy?"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n  static boolean check(List<Integer> list , int n){\\n     for(int i=0;i<list.size();i++){\\n         if(list.get(i)==n){\\n             return false;\\n         }\\n     }\\n     return true;\\n }\\n static int size(List<List<Integer>> list){\\n     int ans=0;\\n     for(int i=0;i<list.size();i++){\\n         ans+=list.get(i).size();\\n     }\\n     return ans;\\n }\\n    public static int[] mergesort(int[] arr){\\n        if(arr.length<=1){\\n            return arr;\\n        }\\n        int mid = (arr.length)/2;\\n        int[] arr1 = Arrays.copyOfRange(arr,0,mid);\\n        arr1 = mergesort(arr1);\\n        int[] arr2 = Arrays.copyOfRange(arr,mid,arr.length);\\n        arr2 = mergesort(arr2);\\n\\n        int[] ans = new int[arr.length];\\n        int i=0,j=0;\\n        while( i<arr1.length && j<arr2.length){\\n            if(arr1[i] > arr2[j]){\\n                ans[i+j]=arr2[j];\\n                j++;\\n            }else {\\n                ans[i+j]=arr1[i];\\n                i++;\\n            }\\n        }\\n        if(i==arr1.length){\\n            for(;j<arr2.length;j++){\\n                ans[arr1.length+j]=arr2[j];\\n            }\\n\\n        }else if (j==arr2.length){\\n            for(;i<arr1.length;i++){\\n                ans[arr2.length+i]=arr1[i];\\n            }\\n        }\\n        return ans;\\n    }\\n    public List<List<Integer>> findMatrix(int[] arr) {\\n     int[] nums=mergesort(arr);\\n       List<List<Integer>>  ans = new ArrayList<>();\\n       List<Integer> arr2=new ArrayList<>();\\n       int s=0;\\n       while(s<nums.length){\\n           List<Integer> list = new ArrayList<>();\\n           for(int i=0;i<nums.length;i++){\\n               if(check(arr2,i) && check(list,nums[i])){\\n                   list.add(nums[i]);\\n                   arr2.add(i);\\n               }\\n           }\\n           ans.add(list);\\n           s+=list.size();\\n       }\\n       return ans;\\n    }\\n}"
                    },
                    {
                        "username": "chiruu453",
                        "content": "https://leetcode.com/problems/convert-an-array-into-a-2d-array-with-conditions/solutions/3780195/c-different-approach/\\nsolution with little different approach from rest all."
                    },
                    {
                        "username": "Msey",
                        "content": "I\\'d say it\\'s an easy question even for my log-head "
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Easy question"
                    },
                    {
                        "username": "almostmonday",
                        "content": "You could form the matrix while you\\'re passing through the input array and solve this problem in one pass. The easiest solution with short code is [here](https://leetcode.com/problems/convert-an-array-into-a-2d-array-with-conditions/solutions/3387836/python-creating-matrix-while-passing-through-array/)."
                    },
                    {
                        "username": "Prometheus_1211",
                        "content": "```\nmap<int,int> m;\n        for(int i=0;i<nums.size();i++)\n        m[nums[i]]++;\n        vector<vector<int>> vec;\n        while(m.size())\n        {\n            vector<int> v;\n            for(auto x:m)\n            {\n                if(x.second==0)\n                m.erase(x.first);\n                else\n                {\n                    v.push_back(x.first);\n                    x.second--;\n                }\n            }\n            vec.push_back(v);\n        }\n        return vec;\n```\nWhat is wrong with this code? It is similar to others but still giving TLE. "
                    },
                    {
                        "username": "hero080",
                        "content": "Modifying the container while loop through it is easy to make mistakes.\\nStandard C++ way to modify while looping:\\n```\\n// for some container `c`\\nfor (auto it = c.begin(); it != c.end(); ) {\\n  if (...) {\\n    it = c.erase(it);  // This usually points `it` to the next iterator.\\n  } else {\\n    ++it;\\n  }\\n}\\n```"
                    },
                    {
                        "username": "Msey",
                        "content": "while(m.size()) try to use number and decrease it each step"
                    },
                    {
                        "username": "thesatiricwriter",
                        "content": "[@syedmarwan](/syedmarwan)  Did not get what you\\'re saying. Can you please modify those lines and comment here. It\\'ll BE OF GREAT HELP !!!!"
                    },
                    {
                        "username": "syedmarwan",
                        "content": "when passing the iterator in the map , you should pass a reference to the iterator , to change the values of the map and before adding the vector to the vector of vector , check the size of the vector , as this code will lead to an extra vector of size zero in the main vector(vector of vector). I hope this should fix your problem."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I just feel bad that I was not able to compete in this contest, these two mediums were the fastest that I ever solved :("
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Such low constraints! It could be easily done in linear time using hashmaps."
                    }
                ]
            },
            {
                "id": 1894851,
                "content": [
                    {
                        "username": "dmitryartux",
                        "content": "Can be an **Easy** one"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Why constraints are so low when linear time solution is easy?"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n  static boolean check(List<Integer> list , int n){\\n     for(int i=0;i<list.size();i++){\\n         if(list.get(i)==n){\\n             return false;\\n         }\\n     }\\n     return true;\\n }\\n static int size(List<List<Integer>> list){\\n     int ans=0;\\n     for(int i=0;i<list.size();i++){\\n         ans+=list.get(i).size();\\n     }\\n     return ans;\\n }\\n    public static int[] mergesort(int[] arr){\\n        if(arr.length<=1){\\n            return arr;\\n        }\\n        int mid = (arr.length)/2;\\n        int[] arr1 = Arrays.copyOfRange(arr,0,mid);\\n        arr1 = mergesort(arr1);\\n        int[] arr2 = Arrays.copyOfRange(arr,mid,arr.length);\\n        arr2 = mergesort(arr2);\\n\\n        int[] ans = new int[arr.length];\\n        int i=0,j=0;\\n        while( i<arr1.length && j<arr2.length){\\n            if(arr1[i] > arr2[j]){\\n                ans[i+j]=arr2[j];\\n                j++;\\n            }else {\\n                ans[i+j]=arr1[i];\\n                i++;\\n            }\\n        }\\n        if(i==arr1.length){\\n            for(;j<arr2.length;j++){\\n                ans[arr1.length+j]=arr2[j];\\n            }\\n\\n        }else if (j==arr2.length){\\n            for(;i<arr1.length;i++){\\n                ans[arr2.length+i]=arr1[i];\\n            }\\n        }\\n        return ans;\\n    }\\n    public List<List<Integer>> findMatrix(int[] arr) {\\n     int[] nums=mergesort(arr);\\n       List<List<Integer>>  ans = new ArrayList<>();\\n       List<Integer> arr2=new ArrayList<>();\\n       int s=0;\\n       while(s<nums.length){\\n           List<Integer> list = new ArrayList<>();\\n           for(int i=0;i<nums.length;i++){\\n               if(check(arr2,i) && check(list,nums[i])){\\n                   list.add(nums[i]);\\n                   arr2.add(i);\\n               }\\n           }\\n           ans.add(list);\\n           s+=list.size();\\n       }\\n       return ans;\\n    }\\n}"
                    },
                    {
                        "username": "chiruu453",
                        "content": "https://leetcode.com/problems/convert-an-array-into-a-2d-array-with-conditions/solutions/3780195/c-different-approach/\\nsolution with little different approach from rest all."
                    },
                    {
                        "username": "Msey",
                        "content": "I\\'d say it\\'s an easy question even for my log-head "
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Easy question"
                    },
                    {
                        "username": "almostmonday",
                        "content": "You could form the matrix while you\\'re passing through the input array and solve this problem in one pass. The easiest solution with short code is [here](https://leetcode.com/problems/convert-an-array-into-a-2d-array-with-conditions/solutions/3387836/python-creating-matrix-while-passing-through-array/)."
                    },
                    {
                        "username": "Prometheus_1211",
                        "content": "```\nmap<int,int> m;\n        for(int i=0;i<nums.size();i++)\n        m[nums[i]]++;\n        vector<vector<int>> vec;\n        while(m.size())\n        {\n            vector<int> v;\n            for(auto x:m)\n            {\n                if(x.second==0)\n                m.erase(x.first);\n                else\n                {\n                    v.push_back(x.first);\n                    x.second--;\n                }\n            }\n            vec.push_back(v);\n        }\n        return vec;\n```\nWhat is wrong with this code? It is similar to others but still giving TLE. "
                    },
                    {
                        "username": "hero080",
                        "content": "Modifying the container while loop through it is easy to make mistakes.\\nStandard C++ way to modify while looping:\\n```\\n// for some container `c`\\nfor (auto it = c.begin(); it != c.end(); ) {\\n  if (...) {\\n    it = c.erase(it);  // This usually points `it` to the next iterator.\\n  } else {\\n    ++it;\\n  }\\n}\\n```"
                    },
                    {
                        "username": "Msey",
                        "content": "while(m.size()) try to use number and decrease it each step"
                    },
                    {
                        "username": "thesatiricwriter",
                        "content": "[@syedmarwan](/syedmarwan)  Did not get what you\\'re saying. Can you please modify those lines and comment here. It\\'ll BE OF GREAT HELP !!!!"
                    },
                    {
                        "username": "syedmarwan",
                        "content": "when passing the iterator in the map , you should pass a reference to the iterator , to change the values of the map and before adding the vector to the vector of vector , check the size of the vector , as this code will lead to an extra vector of size zero in the main vector(vector of vector). I hope this should fix your problem."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I just feel bad that I was not able to compete in this contest, these two mediums were the fastest that I ever solved :("
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Such low constraints! It could be easily done in linear time using hashmaps."
                    }
                ]
            },
            {
                "id": 1855925,
                "content": [
                    {
                        "username": "dmitryartux",
                        "content": "Can be an **Easy** one"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Why constraints are so low when linear time solution is easy?"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n  static boolean check(List<Integer> list , int n){\\n     for(int i=0;i<list.size();i++){\\n         if(list.get(i)==n){\\n             return false;\\n         }\\n     }\\n     return true;\\n }\\n static int size(List<List<Integer>> list){\\n     int ans=0;\\n     for(int i=0;i<list.size();i++){\\n         ans+=list.get(i).size();\\n     }\\n     return ans;\\n }\\n    public static int[] mergesort(int[] arr){\\n        if(arr.length<=1){\\n            return arr;\\n        }\\n        int mid = (arr.length)/2;\\n        int[] arr1 = Arrays.copyOfRange(arr,0,mid);\\n        arr1 = mergesort(arr1);\\n        int[] arr2 = Arrays.copyOfRange(arr,mid,arr.length);\\n        arr2 = mergesort(arr2);\\n\\n        int[] ans = new int[arr.length];\\n        int i=0,j=0;\\n        while( i<arr1.length && j<arr2.length){\\n            if(arr1[i] > arr2[j]){\\n                ans[i+j]=arr2[j];\\n                j++;\\n            }else {\\n                ans[i+j]=arr1[i];\\n                i++;\\n            }\\n        }\\n        if(i==arr1.length){\\n            for(;j<arr2.length;j++){\\n                ans[arr1.length+j]=arr2[j];\\n            }\\n\\n        }else if (j==arr2.length){\\n            for(;i<arr1.length;i++){\\n                ans[arr2.length+i]=arr1[i];\\n            }\\n        }\\n        return ans;\\n    }\\n    public List<List<Integer>> findMatrix(int[] arr) {\\n     int[] nums=mergesort(arr);\\n       List<List<Integer>>  ans = new ArrayList<>();\\n       List<Integer> arr2=new ArrayList<>();\\n       int s=0;\\n       while(s<nums.length){\\n           List<Integer> list = new ArrayList<>();\\n           for(int i=0;i<nums.length;i++){\\n               if(check(arr2,i) && check(list,nums[i])){\\n                   list.add(nums[i]);\\n                   arr2.add(i);\\n               }\\n           }\\n           ans.add(list);\\n           s+=list.size();\\n       }\\n       return ans;\\n    }\\n}"
                    },
                    {
                        "username": "chiruu453",
                        "content": "https://leetcode.com/problems/convert-an-array-into-a-2d-array-with-conditions/solutions/3780195/c-different-approach/\\nsolution with little different approach from rest all."
                    },
                    {
                        "username": "Msey",
                        "content": "I\\'d say it\\'s an easy question even for my log-head "
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Easy question"
                    },
                    {
                        "username": "almostmonday",
                        "content": "You could form the matrix while you\\'re passing through the input array and solve this problem in one pass. The easiest solution with short code is [here](https://leetcode.com/problems/convert-an-array-into-a-2d-array-with-conditions/solutions/3387836/python-creating-matrix-while-passing-through-array/)."
                    },
                    {
                        "username": "Prometheus_1211",
                        "content": "```\nmap<int,int> m;\n        for(int i=0;i<nums.size();i++)\n        m[nums[i]]++;\n        vector<vector<int>> vec;\n        while(m.size())\n        {\n            vector<int> v;\n            for(auto x:m)\n            {\n                if(x.second==0)\n                m.erase(x.first);\n                else\n                {\n                    v.push_back(x.first);\n                    x.second--;\n                }\n            }\n            vec.push_back(v);\n        }\n        return vec;\n```\nWhat is wrong with this code? It is similar to others but still giving TLE. "
                    },
                    {
                        "username": "hero080",
                        "content": "Modifying the container while loop through it is easy to make mistakes.\\nStandard C++ way to modify while looping:\\n```\\n// for some container `c`\\nfor (auto it = c.begin(); it != c.end(); ) {\\n  if (...) {\\n    it = c.erase(it);  // This usually points `it` to the next iterator.\\n  } else {\\n    ++it;\\n  }\\n}\\n```"
                    },
                    {
                        "username": "Msey",
                        "content": "while(m.size()) try to use number and decrease it each step"
                    },
                    {
                        "username": "thesatiricwriter",
                        "content": "[@syedmarwan](/syedmarwan)  Did not get what you\\'re saying. Can you please modify those lines and comment here. It\\'ll BE OF GREAT HELP !!!!"
                    },
                    {
                        "username": "syedmarwan",
                        "content": "when passing the iterator in the map , you should pass a reference to the iterator , to change the values of the map and before adding the vector to the vector of vector , check the size of the vector , as this code will lead to an extra vector of size zero in the main vector(vector of vector). I hope this should fix your problem."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I just feel bad that I was not able to compete in this contest, these two mediums were the fastest that I ever solved :("
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Such low constraints! It could be easily done in linear time using hashmaps."
                    }
                ]
            },
            {
                "id": 1855583,
                "content": [
                    {
                        "username": "dmitryartux",
                        "content": "Can be an **Easy** one"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Why constraints are so low when linear time solution is easy?"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n  static boolean check(List<Integer> list , int n){\\n     for(int i=0;i<list.size();i++){\\n         if(list.get(i)==n){\\n             return false;\\n         }\\n     }\\n     return true;\\n }\\n static int size(List<List<Integer>> list){\\n     int ans=0;\\n     for(int i=0;i<list.size();i++){\\n         ans+=list.get(i).size();\\n     }\\n     return ans;\\n }\\n    public static int[] mergesort(int[] arr){\\n        if(arr.length<=1){\\n            return arr;\\n        }\\n        int mid = (arr.length)/2;\\n        int[] arr1 = Arrays.copyOfRange(arr,0,mid);\\n        arr1 = mergesort(arr1);\\n        int[] arr2 = Arrays.copyOfRange(arr,mid,arr.length);\\n        arr2 = mergesort(arr2);\\n\\n        int[] ans = new int[arr.length];\\n        int i=0,j=0;\\n        while( i<arr1.length && j<arr2.length){\\n            if(arr1[i] > arr2[j]){\\n                ans[i+j]=arr2[j];\\n                j++;\\n            }else {\\n                ans[i+j]=arr1[i];\\n                i++;\\n            }\\n        }\\n        if(i==arr1.length){\\n            for(;j<arr2.length;j++){\\n                ans[arr1.length+j]=arr2[j];\\n            }\\n\\n        }else if (j==arr2.length){\\n            for(;i<arr1.length;i++){\\n                ans[arr2.length+i]=arr1[i];\\n            }\\n        }\\n        return ans;\\n    }\\n    public List<List<Integer>> findMatrix(int[] arr) {\\n     int[] nums=mergesort(arr);\\n       List<List<Integer>>  ans = new ArrayList<>();\\n       List<Integer> arr2=new ArrayList<>();\\n       int s=0;\\n       while(s<nums.length){\\n           List<Integer> list = new ArrayList<>();\\n           for(int i=0;i<nums.length;i++){\\n               if(check(arr2,i) && check(list,nums[i])){\\n                   list.add(nums[i]);\\n                   arr2.add(i);\\n               }\\n           }\\n           ans.add(list);\\n           s+=list.size();\\n       }\\n       return ans;\\n    }\\n}"
                    },
                    {
                        "username": "chiruu453",
                        "content": "https://leetcode.com/problems/convert-an-array-into-a-2d-array-with-conditions/solutions/3780195/c-different-approach/\\nsolution with little different approach from rest all."
                    },
                    {
                        "username": "Msey",
                        "content": "I\\'d say it\\'s an easy question even for my log-head "
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Easy question"
                    },
                    {
                        "username": "almostmonday",
                        "content": "You could form the matrix while you\\'re passing through the input array and solve this problem in one pass. The easiest solution with short code is [here](https://leetcode.com/problems/convert-an-array-into-a-2d-array-with-conditions/solutions/3387836/python-creating-matrix-while-passing-through-array/)."
                    },
                    {
                        "username": "Prometheus_1211",
                        "content": "```\nmap<int,int> m;\n        for(int i=0;i<nums.size();i++)\n        m[nums[i]]++;\n        vector<vector<int>> vec;\n        while(m.size())\n        {\n            vector<int> v;\n            for(auto x:m)\n            {\n                if(x.second==0)\n                m.erase(x.first);\n                else\n                {\n                    v.push_back(x.first);\n                    x.second--;\n                }\n            }\n            vec.push_back(v);\n        }\n        return vec;\n```\nWhat is wrong with this code? It is similar to others but still giving TLE. "
                    },
                    {
                        "username": "hero080",
                        "content": "Modifying the container while loop through it is easy to make mistakes.\\nStandard C++ way to modify while looping:\\n```\\n// for some container `c`\\nfor (auto it = c.begin(); it != c.end(); ) {\\n  if (...) {\\n    it = c.erase(it);  // This usually points `it` to the next iterator.\\n  } else {\\n    ++it;\\n  }\\n}\\n```"
                    },
                    {
                        "username": "Msey",
                        "content": "while(m.size()) try to use number and decrease it each step"
                    },
                    {
                        "username": "thesatiricwriter",
                        "content": "[@syedmarwan](/syedmarwan)  Did not get what you\\'re saying. Can you please modify those lines and comment here. It\\'ll BE OF GREAT HELP !!!!"
                    },
                    {
                        "username": "syedmarwan",
                        "content": "when passing the iterator in the map , you should pass a reference to the iterator , to change the values of the map and before adding the vector to the vector of vector , check the size of the vector , as this code will lead to an extra vector of size zero in the main vector(vector of vector). I hope this should fix your problem."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I just feel bad that I was not able to compete in this contest, these two mediums were the fastest that I ever solved :("
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Such low constraints! It could be easily done in linear time using hashmaps."
                    }
                ]
            },
            {
                "id": 1851932,
                "content": [
                    {
                        "username": "dmitryartux",
                        "content": "Can be an **Easy** one"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Why constraints are so low when linear time solution is easy?"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n  static boolean check(List<Integer> list , int n){\\n     for(int i=0;i<list.size();i++){\\n         if(list.get(i)==n){\\n             return false;\\n         }\\n     }\\n     return true;\\n }\\n static int size(List<List<Integer>> list){\\n     int ans=0;\\n     for(int i=0;i<list.size();i++){\\n         ans+=list.get(i).size();\\n     }\\n     return ans;\\n }\\n    public static int[] mergesort(int[] arr){\\n        if(arr.length<=1){\\n            return arr;\\n        }\\n        int mid = (arr.length)/2;\\n        int[] arr1 = Arrays.copyOfRange(arr,0,mid);\\n        arr1 = mergesort(arr1);\\n        int[] arr2 = Arrays.copyOfRange(arr,mid,arr.length);\\n        arr2 = mergesort(arr2);\\n\\n        int[] ans = new int[arr.length];\\n        int i=0,j=0;\\n        while( i<arr1.length && j<arr2.length){\\n            if(arr1[i] > arr2[j]){\\n                ans[i+j]=arr2[j];\\n                j++;\\n            }else {\\n                ans[i+j]=arr1[i];\\n                i++;\\n            }\\n        }\\n        if(i==arr1.length){\\n            for(;j<arr2.length;j++){\\n                ans[arr1.length+j]=arr2[j];\\n            }\\n\\n        }else if (j==arr2.length){\\n            for(;i<arr1.length;i++){\\n                ans[arr2.length+i]=arr1[i];\\n            }\\n        }\\n        return ans;\\n    }\\n    public List<List<Integer>> findMatrix(int[] arr) {\\n     int[] nums=mergesort(arr);\\n       List<List<Integer>>  ans = new ArrayList<>();\\n       List<Integer> arr2=new ArrayList<>();\\n       int s=0;\\n       while(s<nums.length){\\n           List<Integer> list = new ArrayList<>();\\n           for(int i=0;i<nums.length;i++){\\n               if(check(arr2,i) && check(list,nums[i])){\\n                   list.add(nums[i]);\\n                   arr2.add(i);\\n               }\\n           }\\n           ans.add(list);\\n           s+=list.size();\\n       }\\n       return ans;\\n    }\\n}"
                    },
                    {
                        "username": "chiruu453",
                        "content": "https://leetcode.com/problems/convert-an-array-into-a-2d-array-with-conditions/solutions/3780195/c-different-approach/\\nsolution with little different approach from rest all."
                    },
                    {
                        "username": "Msey",
                        "content": "I\\'d say it\\'s an easy question even for my log-head "
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Easy question"
                    },
                    {
                        "username": "almostmonday",
                        "content": "You could form the matrix while you\\'re passing through the input array and solve this problem in one pass. The easiest solution with short code is [here](https://leetcode.com/problems/convert-an-array-into-a-2d-array-with-conditions/solutions/3387836/python-creating-matrix-while-passing-through-array/)."
                    },
                    {
                        "username": "Prometheus_1211",
                        "content": "```\nmap<int,int> m;\n        for(int i=0;i<nums.size();i++)\n        m[nums[i]]++;\n        vector<vector<int>> vec;\n        while(m.size())\n        {\n            vector<int> v;\n            for(auto x:m)\n            {\n                if(x.second==0)\n                m.erase(x.first);\n                else\n                {\n                    v.push_back(x.first);\n                    x.second--;\n                }\n            }\n            vec.push_back(v);\n        }\n        return vec;\n```\nWhat is wrong with this code? It is similar to others but still giving TLE. "
                    },
                    {
                        "username": "hero080",
                        "content": "Modifying the container while loop through it is easy to make mistakes.\\nStandard C++ way to modify while looping:\\n```\\n// for some container `c`\\nfor (auto it = c.begin(); it != c.end(); ) {\\n  if (...) {\\n    it = c.erase(it);  // This usually points `it` to the next iterator.\\n  } else {\\n    ++it;\\n  }\\n}\\n```"
                    },
                    {
                        "username": "Msey",
                        "content": "while(m.size()) try to use number and decrease it each step"
                    },
                    {
                        "username": "thesatiricwriter",
                        "content": "[@syedmarwan](/syedmarwan)  Did not get what you\\'re saying. Can you please modify those lines and comment here. It\\'ll BE OF GREAT HELP !!!!"
                    },
                    {
                        "username": "syedmarwan",
                        "content": "when passing the iterator in the map , you should pass a reference to the iterator , to change the values of the map and before adding the vector to the vector of vector , check the size of the vector , as this code will lead to an extra vector of size zero in the main vector(vector of vector). I hope this should fix your problem."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I just feel bad that I was not able to compete in this contest, these two mediums were the fastest that I ever solved :("
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Such low constraints! It could be easily done in linear time using hashmaps."
                    }
                ]
            },
            {
                "id": 1851701,
                "content": [
                    {
                        "username": "dmitryartux",
                        "content": "Can be an **Easy** one"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Why constraints are so low when linear time solution is easy?"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n  static boolean check(List<Integer> list , int n){\\n     for(int i=0;i<list.size();i++){\\n         if(list.get(i)==n){\\n             return false;\\n         }\\n     }\\n     return true;\\n }\\n static int size(List<List<Integer>> list){\\n     int ans=0;\\n     for(int i=0;i<list.size();i++){\\n         ans+=list.get(i).size();\\n     }\\n     return ans;\\n }\\n    public static int[] mergesort(int[] arr){\\n        if(arr.length<=1){\\n            return arr;\\n        }\\n        int mid = (arr.length)/2;\\n        int[] arr1 = Arrays.copyOfRange(arr,0,mid);\\n        arr1 = mergesort(arr1);\\n        int[] arr2 = Arrays.copyOfRange(arr,mid,arr.length);\\n        arr2 = mergesort(arr2);\\n\\n        int[] ans = new int[arr.length];\\n        int i=0,j=0;\\n        while( i<arr1.length && j<arr2.length){\\n            if(arr1[i] > arr2[j]){\\n                ans[i+j]=arr2[j];\\n                j++;\\n            }else {\\n                ans[i+j]=arr1[i];\\n                i++;\\n            }\\n        }\\n        if(i==arr1.length){\\n            for(;j<arr2.length;j++){\\n                ans[arr1.length+j]=arr2[j];\\n            }\\n\\n        }else if (j==arr2.length){\\n            for(;i<arr1.length;i++){\\n                ans[arr2.length+i]=arr1[i];\\n            }\\n        }\\n        return ans;\\n    }\\n    public List<List<Integer>> findMatrix(int[] arr) {\\n     int[] nums=mergesort(arr);\\n       List<List<Integer>>  ans = new ArrayList<>();\\n       List<Integer> arr2=new ArrayList<>();\\n       int s=0;\\n       while(s<nums.length){\\n           List<Integer> list = new ArrayList<>();\\n           for(int i=0;i<nums.length;i++){\\n               if(check(arr2,i) && check(list,nums[i])){\\n                   list.add(nums[i]);\\n                   arr2.add(i);\\n               }\\n           }\\n           ans.add(list);\\n           s+=list.size();\\n       }\\n       return ans;\\n    }\\n}"
                    },
                    {
                        "username": "chiruu453",
                        "content": "https://leetcode.com/problems/convert-an-array-into-a-2d-array-with-conditions/solutions/3780195/c-different-approach/\\nsolution with little different approach from rest all."
                    },
                    {
                        "username": "Msey",
                        "content": "I\\'d say it\\'s an easy question even for my log-head "
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Easy question"
                    },
                    {
                        "username": "almostmonday",
                        "content": "You could form the matrix while you\\'re passing through the input array and solve this problem in one pass. The easiest solution with short code is [here](https://leetcode.com/problems/convert-an-array-into-a-2d-array-with-conditions/solutions/3387836/python-creating-matrix-while-passing-through-array/)."
                    },
                    {
                        "username": "Prometheus_1211",
                        "content": "```\nmap<int,int> m;\n        for(int i=0;i<nums.size();i++)\n        m[nums[i]]++;\n        vector<vector<int>> vec;\n        while(m.size())\n        {\n            vector<int> v;\n            for(auto x:m)\n            {\n                if(x.second==0)\n                m.erase(x.first);\n                else\n                {\n                    v.push_back(x.first);\n                    x.second--;\n                }\n            }\n            vec.push_back(v);\n        }\n        return vec;\n```\nWhat is wrong with this code? It is similar to others but still giving TLE. "
                    },
                    {
                        "username": "hero080",
                        "content": "Modifying the container while loop through it is easy to make mistakes.\\nStandard C++ way to modify while looping:\\n```\\n// for some container `c`\\nfor (auto it = c.begin(); it != c.end(); ) {\\n  if (...) {\\n    it = c.erase(it);  // This usually points `it` to the next iterator.\\n  } else {\\n    ++it;\\n  }\\n}\\n```"
                    },
                    {
                        "username": "Msey",
                        "content": "while(m.size()) try to use number and decrease it each step"
                    },
                    {
                        "username": "thesatiricwriter",
                        "content": "[@syedmarwan](/syedmarwan)  Did not get what you\\'re saying. Can you please modify those lines and comment here. It\\'ll BE OF GREAT HELP !!!!"
                    },
                    {
                        "username": "syedmarwan",
                        "content": "when passing the iterator in the map , you should pass a reference to the iterator , to change the values of the map and before adding the vector to the vector of vector , check the size of the vector , as this code will lead to an extra vector of size zero in the main vector(vector of vector). I hope this should fix your problem."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I just feel bad that I was not able to compete in this contest, these two mediums were the fastest that I ever solved :("
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Such low constraints! It could be easily done in linear time using hashmaps."
                    }
                ]
            }
        ]
    }
]